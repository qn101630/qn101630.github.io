<!DOCTYPE html>
<html lang="zh-CN">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="南有乔木" />


    
    


<meta name="description" content="hexo博客">
<meta property="og:type" content="website">
<meta property="og:title" content="南有乔木的技术博客专栏">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="南有乔木的技术博客专栏">
<meta property="og:description" content="hexo博客">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="南有乔木的技术博客专栏" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>南有乔木的技术博客专栏</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/sex.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">南有乔木</a></h1>
        </hgroup>

        
        <p class="header-subtitle">学习笔记</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">大狗哥</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="/1150887961@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%92%8C/" rel="tag">$和#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/condig%E5%AE%9E%E6%88%98-%E6%9C%8D%E5%8A%A1%E5%8C%96%E4%B8%8E%E9%AB%98%E5%8F%AF%E7%94%A8/" rel="tag">condig实战 服务化与高可用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/config-%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/" rel="tag">config 配置中心</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/config%E5%AE%9E%E6%88%98-%E5%88%9D%E4%BD%93%E9%AA%8C/" rel="tag">config实战 初体验</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/config%E5%AE%9E%E6%88%98-%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0/" rel="tag">config实战 动态刷新</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/config%E5%AE%9E%E6%88%98-%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0%EF%BC%88Bus%EF%BC%89/" rel="tag">config实战 动态刷新（Bus）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpu/" rel="tag">cpu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker-kafka%E5%AE%89%E8%A3%85/" rel="tag">docker kafka安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker%E6%95%99%E7%A8%8B/" rel="tag">docker教程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eureka-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/" rel="tag">eureka 服务发现</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eureka%E5%AE%9E%E6%88%98/" rel="tag">eureka实战</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/feign-%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E5%8C%96/" rel="tag">feign 服务接口化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/feign%E5%AE%9E%E6%88%98/" rel="tag">feign实战</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hystrix-%E7%86%94%E6%96%AD%E5%99%A8/" rel="tag">hystrix 熔断器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hystrix%E5%AE%9E%E6%88%98-%E5%8D%95%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7/" rel="tag">hystrix实战 单应用监控</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E5%AE%B9%E5%99%A8-ArrayList/" rel="tag">java容器 ArrayList</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E5%AE%B9%E5%99%A8-ConcurrentHashMap/" rel="tag">java容器 ConcurrentHashMap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E5%AE%B9%E5%99%A8-HashMap/" rel="tag">java容器 HashMap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E5%AE%B9%E5%99%A8-LinkedList/" rel="tag">java容器 LinkedList</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E5%AE%B9%E5%99%A8-%E6%A6%82%E8%BF%B0/" rel="tag">java容器 概述</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka%E5%8E%9F%E7%90%86/" rel="tag">kafka原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka%E5%AE%9E%E6%88%98/" rel="tag">kafka实战</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ribbon-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" rel="tag">ribbon 负载均衡</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ribbon%E5%AE%9E%E6%88%98/" rel="tag">ribbon实战</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ribbon%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/" rel="tag">ribbon服务网关</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/" rel="tag">shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zuul%E5%AE%9E%E6%88%98/" rel="tag">zuul实战</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%8B%E7%BB%8D-%E5%AE%89%E8%A3%85/" rel="tag">介绍 安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7-turbine/" rel="tag">多应用监控 turbine</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" rel="tag">定时任务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BB%8B%E7%BB%8D/" rel="tag">微服务介绍</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E3%80%81%E5%9B%BE/" rel="tag">数据结构 堆、哈希表、图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84/" rel="tag">数据结构 数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/" rel="tag">数据结构 栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/" rel="tag">数据结构 树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/" rel="tag">数据结构 链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/" rel="tag">数据结构 队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%80%E4%BB%8B/" rel="tag">数据结构与算法 简介</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0-zookeeper-eureka/" rel="tag">服务发现 zookeeper eureka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/" rel="tag">算法 排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95-%E6%90%9C%E7%B4%A0/" rel="tag">算法 搜素</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io" target="_blank" rel="noopener">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/" target="_blank" rel="noopener">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/" target="_blank" rel="noopener">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">南有乔木</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/sex.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">南有乔木</a></h1>
            </hgroup>
            
            <p class="header-subtitle">学习笔记</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">大狗哥</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="/1150887961@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article
  id="post-JAVA容器——ConcurrentHashMap"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
>
  
  <div class="article-meta">
    <a href="/2020/03/04/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ConcurrentHashMap/" class="article-date">
      <time datetime="2020-03-04T08:28:27.000Z" itemprop="datePublished">2020-03-04</time>
</a>

 
    <a href="/2020/03/04/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ConcurrentHashMap/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
        
            <span class="disqus-comment-count" data-disqus-identifier="2020/03/04/JAVA容器——ConcurrentHashMap/"></span>
        
    </a>

  </div>
  
  <div class="article-inner">
    
    <input type="hidden" class="isFancy" />
     
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/04/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ConcurrentHashMap/">JAVA容器——ConcurrentHashMap</a>
    </h1>
  
 
    </header>
     
    <div class="article-entry" itemprop="articleBody">
        <h1 id="我们已经知道了-HashMap-是不安全的，对于高并发我们常会选择用-ConcuerrentHashMap-为什么？"><a href="#我们已经知道了-HashMap-是不安全的，对于高并发我们常会选择用-ConcuerrentHashMap-为什么？" class="headerlink" title="我们已经知道了 HashMap 是不安全的，对于高并发我们常会选择用 ConcuerrentHashMap,为什么？"></a>我们已经知道了 HashMap 是不安全的，对于高并发我们常会选择用 ConcuerrentHashMap,为什么？</h1><p><code>HashMap</code> 在多线程环境下存在线程安全问题，一般在多线程的场景，我都会使用好几种不同的方式去代替：</p>
<ul>
<li>使用 <code>Collections.synchronizedMap(Map)</code> 创建线程安全的 <code>map</code> 集合；</li>
<li><code>Hashtable</code></li>
<li><code>ConcurrentHashMap</code></li>
</ul>
<p>但是仔细研究过源码的同学都知道，前两者保证线程安全的操作 <code>synchronized</code> 修饰方法，锁住整个 <code>hash</code> 表，效率低下。</p>
<p><code>ConcurrentHashMap</code> 对锁的粒度和锁的方式进行了优化，<code>jdk1.7</code> 采用了分段锁，而 <code>jdk1.8</code> 采用了 <code>CAS + synchronized</code> 的方式。保证了并发效率及安全性，具体见下文。</p>
<h1 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h1><p>ConcurrentHashMap 使用的是分段锁技术,将 ConcurrentHashMap 容器的数据分段存储,每一段数据分配一个 Segment,当线程占用一个 Segment 时,其他线程可以访问其他段的数据。</p>
<h3 id="请讲一下-JDK1-7-ConcurrentHashMap-数据结构"><a href="#请讲一下-JDK1-7-ConcurrentHashMap-数据结构" class="headerlink" title="请讲一下 JDK1.7 ConcurrentHashMap 数据结构"></a>请讲一下 JDK1.7 ConcurrentHashMap 数据结构</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>是由 Segment 数组、HashEntry 组成，和 HashMap 一样，仍然是 <strong>数组加链表</strong>。</p>
<ul>
<li>Segment : 可重入锁,继承 <code>ReentrantLock</code>S 也称之为桶</li>
<li>HashEntry : 主要存储键值对 可以叫节点</li>
</ul>
<p>CurrentHashMap 包含一个 <code>Segment</code>数组，每个 <code>Segment</code> 包含一个<code>HashEntry</code> 数组并且守护它，当修改 <code>HashEntry</code> 数组数据时，需要先获取它对应的 <code>Segment</code> 锁；而 <code>HashEntry</code> 数组采用开链法处理冲突，所以它的每个 <code>HashEntry</code> 元素又是链表结构的元素。</p>
<h4 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h4><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ConcurrentHashMap_2020-03-04-17-11-30.png" alt="JAVA容器——ConcurrentHashMap_2020-03-04-17-11-30.png"></p>
<p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ConcurrentHashMap_2020-03-04-17-23-51.png" alt="JAVA容器——ConcurrentHashMap_2020-03-04-17-23-51.png"></p>
<h3 id="请讲一下-JDK1-7-ConcurrentHashMap-操作方法和原理"><a href="#请讲一下-JDK1-7-ConcurrentHashMap-操作方法和原理" class="headerlink" title="请讲一下 JDK1.7 ConcurrentHashMap 操作方法和原理"></a>请讲一下 JDK1.7 ConcurrentHashMap 操作方法和原理</h3><h4 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<p>ConcurrentHashMap 继承自 AbstractMap 类，实现了 ConcurrentMap 和 Serializable 接口。</p>
<h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><ul>
<li>默认初始化大小值 16</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>默认负载因子大小 0.75</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>默认分段数量（最大并发线程数）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>最大容量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>每个 segment 分段中表的最小容量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SEGMENT_TABLE_CAPACITY = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>最大分段数量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SEGMENTS = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>containsValue 方法不锁表的情况下尝试的次数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h4 id="segment"><a href="#segment" class="headerlink" title="segment"></a>segment</h4><h5 id="成员变量及构造函数"><a href="#成员变量及构造函数" class="headerlink" title="成员变量及构造函数"></a>成员变量及构造函数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自旋等待尝试加锁次数，单核为1，多核为64，Runtime.getRuntime().availableProcessors()方法获取CPU核心数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SCAN_RETRIES =</span><br><span class="line">            Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span> ? <span class="number">64</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表，即HashEntry数组（每个segment中都有一个table）</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//segment中元素个数</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改次数</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扩容阀值</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//负载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 构造函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Segment(<span class="keyword">float</span> lf, <span class="keyword">int</span> threshold, HashEntry&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">            <span class="keyword">this</span>.loadFactor = lf;</span><br><span class="line">            <span class="keyword">this</span>.threshold = threshold;</span><br><span class="line">            <span class="keyword">this</span>.table = tab;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h5><p>先尝试获取锁，如果加锁失败，则 scanAndLock 自旋等待（和上面的 put 方法相似）。</p>
<p>获取锁之后，(tab.length - 1) &amp; hash 计算删除节点在 table 中的下标。如果 table 中该位置的链表 <code>HashEntry</code> 不为空,循环判断链表中节点是否存在：</p>
<ul>
<li>存在，则替换 value 值，返回 OldValue。</li>
<li>如果不存在，新建节点，放在 frist 节点前。节点超出最大负载则 rehash。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 尝试进行加锁，如果加锁失败，则执行scanAndLockForPut方法，尝试加锁一定次数之后调用线程自中断方法（自旋等待）。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">                scanAndLockForPut(key, hash, value);</span><br><span class="line">            V oldValue;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">                <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">                HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;  <span class="comment">//for循环查找key是否存在，如果找到了，替换value值，返回oldValue</span></span><br><span class="line">                    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        K k;</span><br><span class="line">                        <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                            (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                            oldValue = e.value;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                                e.value = value;</span><br><span class="line">                                ++modCount;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        e = e.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;  <span class="comment">//如果没找到，新建HashEntry节点，放到first节点前面</span></span><br><span class="line">                        <span class="keyword">if</span> (node != <span class="keyword">null</span>)   <span class="comment">//scanAndLockForPut自旋等待时如果已经新建了节点，设置next值即可，setNext方法实现了延迟写。</span></span><br><span class="line">                            node.setNext(first);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                        <span class="keyword">int</span> c = count + <span class="number">1</span>;  <span class="comment">//元素个数加1，如果超过了阀值，则进行rehash，进行扩容</span></span><br><span class="line">                        <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                            rehash(node);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            setEntryAt(tab, index, node);   <span class="comment">//把新建节点放在链表的头位置</span></span><br><span class="line">                        ++modCount;</span><br><span class="line">                        count = c;</span><br><span class="line">                        oldValue = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();   <span class="comment">//最后释放锁</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h5 id="scanAndLockForPut-方法"><a href="#scanAndLockForPut-方法" class="headerlink" title="scanAndLockForPut 方法"></a>scanAndLockForPut 方法</h5><p>自旋锁，尝试加锁一定次数仍然失败进行线程自中断。</p>
<p>该方法先计算 hash 值在 table 中的位置，循环该位置上的链表查找 key 值。</p>
<p>如果不存在则新建节点，之后尝试加锁 MAX_SCAN_RETRIES 次，如果一直失败则挂起当前线程。</p>
<p>期间如果链表头被修改，则重新开始该过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">            HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">            HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> retries = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (!tryLock()) &#123;    <span class="comment">//获取锁失败时进入循环</span></span><br><span class="line">                HashEntry&lt;K,V&gt; f;</span><br><span class="line">                <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;  <span class="comment">//循环链表，找到key值或者不存在新建节点</span></span><br><span class="line">                    <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                            node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        retries = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))     <span class="comment">//如果找到了key值，</span></span><br><span class="line">                        retries = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        e = e.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                * 找到key值或者key值不存在新建节点之后，尝试加锁一定次数进入等待状态</span></span><br><span class="line"><span class="comment">                * 尝试次数，单核为1，多核为64</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">                    lock();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123; <span class="comment">//如果尝试加锁过程中发现链表头变化了，重置retries为-1，重新开始</span></span><br><span class="line">                    e = first = f;</span><br><span class="line">                    retries = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h5 id="rehash-方法"><a href="#rehash-方法" class="headerlink" title="rehash 方法"></a>rehash 方法</h5><p>对当前 <code>table</code> 进行扩容操作，大小变为原来的 2 倍，其中的元素会被重新分配位置，<code>oldTable[idx]</code> 上的链表上的元素可能会重新 <code>hash</code> 到 <code>newTable[idx]</code> 和 <code>newTbale[idx+n]</code> 的链表上,<code>n</code> 为 <code>oldTable</code> 的大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>; <span class="comment">//newTable的大小为oldTable的2被</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">        (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">    <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">int</span> idx = e.hash &amp; sizeMask;    <span class="comment">//计算节点在newTable中的位置idx</span></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">//如果链表只有一个节点，直接放到newTable的idx上</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                * 与重新计算每个节点在newTable中的位置并依次进行头插法插入链表头相比，这里进行了优化</span></span><br><span class="line"><span class="comment">                * 1.计算链表中每个节点在newTable中的位置，但是并不立即插入链表头</span></span><br><span class="line"><span class="comment">                * 2.记住最后一个与它的上一个节点在新表中位置不同的节点lastRun，即链表中此节点之后的节点在newTable中的位置都相同</span></span><br><span class="line"><span class="comment">                * 3.把lastRun放到newTable中，它之后的节点会带过来</span></span><br><span class="line"><span class="comment">                * 4.计算lastRun之前的节点在newTable中的位置并依次进行头插法插入newTable中。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                     last != <span class="keyword">null</span>;</span><br><span class="line">                     last = last.next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// Clone remaining nodes</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                    <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// 把新节点放入newTable中</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove 方法"></a>remove 方法</h5><p>先尝试获取锁，如果加锁失败，则 scanAndLock 自旋等待（和上面的 put 方法相似）。</p>
<p>获取锁之后，(tab.length - 1) &amp; hash 计算删除节点在 table 中的下标，如果 table 中该位置的链表不为空，循环判断链表中节点是否和删除节点相等（value 为 null 时，key 相等即可，否则 key 和 value 均需相等）。</p>
<p>如果删除节点存在，设置 pre 节点的 next 指针指向 next 节点即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">remove</span><span class="params">(Object key, <span class="keyword">int</span> hash, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryLock())     <span class="comment">//尝试加锁</span></span><br><span class="line">        scanAndLock(key, hash);     <span class="comment">//加锁失败，则自旋等待</span></span><br><span class="line">    V oldValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;    <span class="comment">//计算hash值在table中的下标</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = entryAt(tab, index);</span><br><span class="line">        HashEntry&lt;K,V&gt; pred = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                V v = e.value;</span><br><span class="line">                <span class="keyword">if</span> (value == <span class="keyword">null</span> || value == v || value.equals(v)) &#123;   <span class="comment">//key相等时，value为null或者value也相等即为删除节点</span></span><br><span class="line">                    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                        setEntryAt(tab, index, next);   <span class="comment">//如果删除节点是头节点，设置头节点为next节点</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        pred.setNext(next);     <span class="comment">//否则设置上一个节点的next指针指向next节点</span></span><br><span class="line">                    ++modCount;     <span class="comment">//修改次数加1</span></span><br><span class="line">                    --count;        <span class="comment">//节点数量减1</span></span><br><span class="line">                    oldValue = v;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pred = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();   <span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="hash-方法"><a href="#hash-方法" class="headerlink" title="hash 方法"></a>hash 方法</h4><p>用 key.hashCode()与 key.hashCode()向右位移 16 位值异或。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hashSeed;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="number">0</span> != h) &amp;&amp; (k <span class="keyword">instanceof</span> String)) &#123;</span><br><span class="line">            <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">        h += (h &lt;&lt;  <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line">        h += (h &lt;&lt;   <span class="number">3</span>);</span><br><span class="line">        h ^= (h &gt;&gt;&gt;  <span class="number">6</span>);</span><br><span class="line">        h += (h &lt;&lt;   <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</span><br><span class="line">        <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="定位-segment"><a href="#定位-segment" class="headerlink" title="定位 segment"></a>定位 segment</h4><p>ConcurrentHashMap 使用分段锁 Segment 来保护不同段的数据，那么在插入和获取元素的时候，必须先通过散列算法定位到 Segment。</p>
<p>首先对 key 的 hashCode 进行 hash 操作</p>
<p>运用散列算法定位 segment 的位置</p>
<ul>
<li><code>segmentMask</code>：段掩码，假如 segments 数组长度为 16，则段掩码为 16-1=15；segments 长度为 32，段掩码为 32-1=31。这样得到的所有 bit 位都为 1，可以更好地保证散列的均匀性</li>
<li><code>segmentShift</code>：2 的 sshift 次方等于 ssize，segmentShift=32-sshift。若 segments 长度为 16，segmentShift=32-4=28;若 segments 长度为 32，segmentShift=32-5=27。而计算得出的 hash 值最大为 32 位，无符号右移 segmentShift，则意味着只保留高几位（其余位是没用的），然后与段掩码 segmentMask 位运算来定位 Segment。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Segment&lt;K,V&gt; <span class="title">segmentFor</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="put-方法（ConcurrentHashMap）"><a href="#put-方法（ConcurrentHashMap）" class="headerlink" title="put 方法（ConcurrentHashMap）"></a>put 方法（ConcurrentHashMap）</h4><p>先计算 key 值在哪个 segment 中，然后调用 segment 的 put 方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        Segment&lt;K,V&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;      <span class="comment">//计算key落在哪个segment中</span></span><br><span class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject</span><br><span class="line">             (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>)</span><br><span class="line">            s = ensureSegment(j);                           <span class="comment">//如果segment不存在则初始化</span></span><br><span class="line">        <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);              <span class="comment">//调用segment的put方法</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="get-方法（ConcurrentHashMap）"><a href="#get-方法（ConcurrentHashMap）" class="headerlink" title="get 方法（ConcurrentHashMap）"></a>get 方法（ConcurrentHashMap）</h4><p>先计算 key 落在哪个 segment 中</p>
<p>如果 segment 不为 null 并且 table 不为 null，tab.length - 1) &amp; h 计算在 table 中的下标</p>
<p>循环链表的节点进行比较，如果 key 相等或者 hash 和 equals 方法相等，则返回 value 值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                     (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">                 e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))   <span class="comment">//如果key相等，或者重载的hash方法和equals方法相等</span></span><br><span class="line">                    <span class="keyword">return</span> e.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="remove-方法（ConcurrentHashMap）"><a href="#remove-方法（ConcurrentHashMap）" class="headerlink" title="remove 方法（ConcurrentHashMap）"></a>remove 方法（ConcurrentHashMap）</h4><p>remove 方法有两个，一个参数只有 key，一个参数是 key 和 value，所以 segment 的 remove 方法中 value 为 null 时，key 相等即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);                       <span class="comment">//计算hash值</span></span><br><span class="line">        Segment&lt;K,V&gt; s = segmentForHash(hash);      <span class="comment">//计算hash值落在哪个segment中</span></span><br><span class="line">        <span class="keyword">return</span> s == <span class="keyword">null</span> ? <span class="keyword">null</span> : s.remove(key, hash, <span class="keyword">null</span>);    <span class="comment">//调用segment的remove方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified key is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        Segment&lt;K,V&gt; s;</span><br><span class="line">        <span class="keyword">return</span> value != <span class="keyword">null</span> &amp;&amp; (s = segmentForHash(hash)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            s.remove(key, hash, value) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="你有没有发现-1-7-虽然可以支持每个-Segment-并发访问，但是还是存在一些问题？"><a href="#你有没有发现-1-7-虽然可以支持每个-Segment-并发访问，但是还是存在一些问题？" class="headerlink" title="你有没有发现 1.7 虽然可以支持每个 Segment 并发访问，但是还是存在一些问题？"></a>你有没有发现 1.7 虽然可以支持每个 Segment 并发访问，但是还是存在一些问题？</h3><p>是的，因为基本上还是数组加链表的方式，我们去查询的时候，还得遍历链表，会导致效率很低，这个跟 jdk1.7 的 HashMap 是存在的一样问题，所以他在 jdk1.8 完全优化了。</p>
<h1 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h1><p>jdk1.8 中 ConcurrentHashMap 有了很大的变化，不再是 segment 结构，而是使用类似乐观锁的方式（<code>CAS + synchronized</code>）来达到多线程安全的目的。</p>
<h3 id="请讲一下-JDK1-8-ConcurrentHashMap-数据结构"><a href="#请讲一下-JDK1-8-ConcurrentHashMap-数据结构" class="headerlink" title="请讲一下 JDK1.8 ConcurrentHashMap 数据结构"></a>请讲一下 JDK1.8 ConcurrentHashMap 数据结构</h3><p>把之前的 HashEntry 改成了 Node，但是作用不变，把值和 next 采用了 volatile 去修饰，保证了可见性，并且也引入了红黑树，在链表大于一定值的时候会转换（默认是 8）</p>
<p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ConcurrentHashMap_2020-03-06-19-21-16.png" alt="JAVA容器——ConcurrentHashMap_2020-03-06-19-21-16.png"></p>
<h3 id="请讲一下-JDK1-8-ConcurrentHashMap-的属性、内部类"><a href="#请讲一下-JDK1-8-ConcurrentHashMap-的属性、内部类" class="headerlink" title="请讲一下 JDK1.8 ConcurrentHashMap 的属性、内部类"></a>请讲一下 JDK1.8 ConcurrentHashMap 的属性、内部类</h3><h4 id="类定义-1"><a href="#类定义-1" class="headerlink" title="类定义"></a>类定义</h4><p>ConcurrentHashMap 继承了 AbstractMap，实现了 ConcurrentMap 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<h4 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h4><ul>
<li>最大容量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>默认初始化的容量 16，容量必须是 2 的倍数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>数组的最大容量，toArray 和相关方法会用到</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>默认分段数量（不再使用，兼容老版本）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>默认负载因子</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>链表转换为树的阈值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>树转化为链表的阈值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>树结构的最小容量（当 table 中的其中一个链表长度达到 8 并且 table 中的节点总数达到 64 时，会把该链表转化为树结构，而如果 table 中的节点数量小于 64，不会进行树结构的转化，而是对 table 进行扩容以降低该链表的长度。）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>扩容时每个核心转移的间隔数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br></pre></td></tr></table></figure>

<ul>
<li>节点的 hash 值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// 表示该节点正在处理中</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// 表示该节点是树的根节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// 暂时保留</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// 正常节点的hash值可用的位数</span></span><br></pre></td></tr></table></figure>

<ul>
<li>CPU 的核心数量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br></pre></td></tr></table></figure>

<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul>
<li>table 表，volatile 修饰（一个线程修改该属性时，会立即写入到主存中，即对其他线程立即可见），transient 修饰符（序列化时忽略该属性，即该属性只存在内存中，而不会持久化到磁盘里）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>

<ul>
<li>newTable，进行扩容时会新建该表，其他线程发现该表不为空，说明已经有线程在进行扩容操作，就会帮助把 oldTable 中的数据扩容操作到此新表中，一起完成扩容操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br></pre></td></tr></table></figure>

<ul>
<li>baseCount 用于计算 size 的其中一个属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>控制 table 初始化和扩容的属性</p>
<ul>
<li>0 ，初始化值</li>
<li>-1，表示正在初始化</li>
<li>-N，表示 N-1 个线程正在一起进行扩容操作</li>
<li>N ，table 为 null 时，该值表示初始化的大小，table 不为 null，该值表示下一次扩容的大小</li>
</ul>
</li>
<li><p>扩容时下一个 table 下标</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br></pre></td></tr></table></figure>

<ul>
<li>扩容和 CounterCells 时的锁标识</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> KeySetView&lt;K,V&gt; keySet;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> ValuesView&lt;K,V&gt; values;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> EntrySetView&lt;K,V&gt; entrySet;</span><br></pre></td></tr></table></figure>

<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><h5 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h5><p>Node 类实现了 Map.Entry 接口，主要存放 key-value 对，并且具有 next 域</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V val;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">		......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a>TreeNode</h5><p>树节点，继承于承载数据的 Node 类。而红黑树的操作是针对 TreeBin 类的，从该类的注释也可以看出，也就是 TreeBin 会将 TreeNode 进行再一次封装</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * Nodes <span class="keyword">for</span> use in TreeBins</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;</span><br><span class="line">		......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="TreeBin"><a href="#TreeBin" class="headerlink" title="TreeBin"></a>TreeBin</h5><p>这个类并不负责包装用户的 key、value 信息，而是包装的很多 TreeNode 节点。实际的 ConcurrentHashMap“数组”中，存放的是 TreeBin 对象，而不是 TreeNode 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; root;</span><br><span class="line">        <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">        <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line">        <span class="comment">// values for lockState</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br><span class="line">		......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ForwardingNode"><a href="#ForwardingNode" class="headerlink" title="ForwardingNode"></a>ForwardingNode</h5><p>在扩容时才会出现的特殊节点，其 key,value,hash 全部为 null。并拥有 nextTable 指针引用新的 table 数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line">   .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="你在上面提到-CAS-CAS-是什么"><a href="#你在上面提到-CAS-CAS-是什么" class="headerlink" title="你在上面提到 CAS,CAS 是什么?"></a>你在上面提到 CAS,CAS 是什么?</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>CAS 是乐观锁的一种实现方式，是一种轻量级锁，JUC 中很多工具类的实现就是基于 CAS 的。</p>
<h4 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h4><p>CAS 操作的流程如下图所示，线程在读取数据时不进行加锁，在准备写回数据时，比较原值是否修改，若未被其他线程修改则写回，若已被修改，则重新执行读取流程。</p>
<p>这是一种乐观策略，认为并发操作并不总会发生。</p>
<p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ConcurrentHashMap_2020-03-06-18-50-14.png" alt="JAVA容器——ConcurrentHashMap_2020-03-06-18-50-14.png"></p>
<h4 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h4><p>一个线程把值改回了 B，又来了一个线程把值又改回了 A，对于这个时候判断的线程，就发现他的值还是 A，所以他就不知道这个值到底有没有被人改过，其实很多场景如果只追求最后结果正确，这是没关系的。</p>
<p>但是实际过程中还是需要记录修改过程的，比如资金修改什么的，你每次修改的都应该有记录，方便回溯。</p>
<p>CAS 无法判断 ABA 问题，这个时候我们可以用版本号、时间戳等来保证记录更新。</p>
<h4 id="关键操作"><a href="#关键操作" class="headerlink" title="关键操作"></a>关键操作</h4><h5 id="tabAt"><a href="#tabAt" class="headerlink" title="tabAt"></a>tabAt</h5><p>该方法用来获取 table 数组中索引为 i 的 Node 元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="casTabAt"><a href="#casTabAt" class="headerlink" title="casTabAt"></a>casTabAt</h5><p>利用 CAS 操作设置 table 数组中索引为 i 的元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="setTabAt"><a href="#setTabAt" class="headerlink" title="setTabAt"></a>setTabAt</h5><p>该方法用来设置 table 数组中索引为 i 的元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CAS-性能很高，但是我知道-synchronized-性能可不咋地，为啥-jdk1-8-升级之后反而多了-synchronized？"><a href="#CAS-性能很高，但是我知道-synchronized-性能可不咋地，为啥-jdk1-8-升级之后反而多了-synchronized？" class="headerlink" title="CAS 性能很高，但是我知道 synchronized 性能可不咋地，为啥 jdk1.8 升级之后反而多了 synchronized？"></a>CAS 性能很高，但是我知道 synchronized 性能可不咋地，为啥 jdk1.8 升级之后反而多了 synchronized？</h3><p>synchronized 之前一直都是重量级的锁，但是后来 java 官方是对他进行过升级的，他现在采用的是锁升级的方式去做的。</p>
<p>针对 synchronized 获取锁的方式，JVM 使用了锁升级的优化方式，就是先使用偏向锁优先同一线程然后再次获取锁，如果失败，就升级为 CAS 轻量级锁，如果失败就会短暂自旋，防止线程被系统挂起。最后如果以上都失败就升级为重量级锁。</p>
<h3 id="请你讲一下-JDK1-8-ConcurrentHashMap-的操作方法"><a href="#请你讲一下-JDK1-8-ConcurrentHashMap-的操作方法" class="headerlink" title="请你讲一下 JDK1.8 ConcurrentHashMap 的操作方法"></a>请你讲一下 JDK1.8 ConcurrentHashMap 的操作方法</h3><h4 id="构造器方法"><a href="#构造器方法" class="headerlink" title="构造器方法"></a>构造器方法</h4><p>ConcurrentHashMap 一共给我们提供了 5 中构造器方法，具体使用请看注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 构造一个空的map，即table数组还未初始化，初始化放在第一次插入数据时，默认大小为16</span></span><br><span class="line">ConcurrentHashMap()</span><br><span class="line"><span class="comment">// 2. 给定map的大小</span></span><br><span class="line">ConcurrentHashMap(<span class="keyword">int</span> initialCapacity)</span><br><span class="line"><span class="comment">// 3. 给定一个map</span></span><br><span class="line">ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)</span><br><span class="line"><span class="comment">// 4. 给定map的大小以及加载因子</span></span><br><span class="line">ConcurrentHashMap(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span><br><span class="line"><span class="comment">// 5. 给定map大小，加载因子以及并发度（预计同时操作数据的线程）</span></span><br><span class="line">ConcurrentHashMap(<span class="keyword">int</span> initialCapacity,<span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span><br></pre></td></tr></table></figure>

<p>我们来看看第 2 种构造器，传入指定大小时的情况，该构造器源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1. 小于0直接抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">	<span class="comment">//2. 判断是否超过了允许的最大值，超过了话则取最大值，否则再对该值进一步处理</span></span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">	<span class="comment">//3. 赋值给sizeCtl</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的逻辑请看注释，很容易理解，如果 <code>initialCapacity</code> 小于 0 就直接抛出异常，如果指定值大于了所允许的最大值的话就取最大值，否则，在对指定值做进一步处理。最后将 <code>cap</code> 赋值给 <code>sizeCtl</code></p>
<p>关于 <code>sizeCtl</code> 的说明请看上面的说明，当调用构造器方法之后，<strong><code>sizeCtl</code> 的大小应该就代表了 ConcurrentHashMap 的大小，即 table 数组长度。</strong></p>
<p>调用构造器方法的时候并未构造出 table 数组（可以理解为 ConcurrentHashMap 的数据容器），只是算出 table 数组的长度，当第一次向 ConcurrentHashMap 插入数据的时候才真正的完成初始化创建 table 数组的工作</p>
<h4 id="tableSizeFor"><a href="#tableSizeFor" class="headerlink" title="tableSizeFor"></a>tableSizeFor</h4><p>通过注释就很清楚了，该方法会将调用构造器方法时指定的大小转换成一个 2 的幂次方数，也就是说 ConcurrentHashMap 的大小一定是 2 的幂次方，比如，当指定大小为 18 时，为了满足 2 的幂次方特性，实际上 concurrentHashMapd 的大小为 2 的 5 次方（32）。</p>
<h4 id="initTable"><a href="#initTable" class="headerlink" title="initTable"></a>initTable</h4><p>ConcurrentHashMap 的初始化操作，保证只有一个线程正在进行初始化操作。</p>
<p>正在进行初始化的线程会调用 U.compareAndSwapInt 方法将 sizeCtl 改为-1 即正在初始化的状态。</p>
<p>有可能存在一个情况是多个线程同时走到这个方法中，为了保证能够正确初始化，在第 1 步中会先通过 if 进行判断，若当前已经有一个线程正在初始化即 sizeCtl 值变为-1，这个时候其他线程在 If 判断为 true 从而调用 Thread.yield()让出 CPU 时间片。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="comment">// 1. 保证只有一个线程正在进行初始化操作</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="comment">// 2. 得出数组的大小</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">					<span class="comment">// 3. 这里才真正的初始化数组</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">					<span class="comment">// 4. 计算数组中可用的大小：实际大小n*0.75（加载因子）</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><ol>
<li><p><code>spread()</code> 重哈希</p>
<p>我们知道对于一个 <code>hash</code> 表来说，<code>hash</code> 值分散的不够均匀的话会大大增加哈希冲突的概率，从而影响到 <code>hash</code> 表的性能。因此通过 <code>spread</code> 方法进行了一次重 <code>hash</code> 从而大大减小哈希冲突的可能性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化 <code>table</code></p>
<p>紧接着到第 2 步，会判断当前 <code>table</code> 数组是否初始化了，没有的话就调用 <code>initTable</code> 进行初始化，该方法在上面已经讲过了。</p>
</li>
<li><p>能否直接将新值插入到 table 数组中</p>
<p>通过 <code>(n - 1) &amp; hash</code> 确定数组中索引 <code>i</code> 的位置，</p>
<p>通过 <code>tabAt()</code> 方法（该方法在上面已经说明了，有疑问可以回过头去看看）获取该位置上的元素</p>
<p>如果当前 <code>Node f</code> 为 <code>null</code> 的话，就可以直接用 casTabAt 方法将新值插入即可。</p>
</li>
<li><p>当前是否正在扩容</p>
<p>如果当前节点不为 <code>null</code>，且该节点为特殊节点（<code>forwardingNode</code>）的话，就说明当前 <code>concurrentHashMap</code> 正在进行扩容操作，关于扩容操作，下面会作为一个具体的方法进行讲解。</p>
<p>那么怎样确定当前的这个 <code>Node</code> 是不是特殊的节点了？是通过判断该节点的 <code>hash</code> 值是不是等于<code>-1（MOVED</code>,代码为<code>(fh = f.hash) == MOVED</code>，对 <code>MOVED</code> 的解释在源码上也写的很清楚了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// hash for forwarding nodes</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当 <code>table[i]</code> 为链表的头结点，在链表中插入新值</p>
<p>在 <code>table[i]</code> 不为 <code>null</code> 并且不为 <code>forwardingNode</code> 时，并且当前 <code>Node f</code> 的 <code>hash</code> 值大于 <code>0（fh &gt;= 0）</code>的话说明当前节点 <code>f</code> 为当前桶的所有的节点组成的链表的头结点。</p>
<p>那么接下来，要想向 <code>ConcurrentHashMap</code> 插入新值的话就是向这个链表插入新值。通过 <code>synchronized (f)</code> 的方式进行加锁以实现线程安全性。</p>
<p>如果直到找到了链表的末尾都没有找到的话，就直接将待插入的键值对追加到链表的末尾即可。</p>
</li>
<li><p>当 table[i]为红黑树的根节点，在红黑树中插入新值</p>
<p>一旦出现拉链过长，甚至在极端情况下，查找一个节点会出现时间复杂度为 <code>O(n)</code> 的情况，则会严重影响 <code>ConcurrentHashMap</code> 的性能，于是，在 <code>JDK1.8</code> 版本中，对数据结构做了进一步的优化，引入了红黑树。</p>
<p>而当链表长度太长（默认超过 8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高 <code>ConcurrentHashMap</code> 的性能，其中会用到红黑树的插入、删除、查找等算法。</p>
<p>首先在 <code>if</code> 中通过 <code>f instanceof TreeBin</code> 判断当前 <code>table[i]</code> 是否是树节点，这下也正好验证了我们在最上面介绍时说的 <code>TreeBin</code> 会对 <code>TreeNode</code> 做进一步封装，对红黑树进行操作的时候针对的是 <code>TreeBin</code> 而不是 <code>TreeNode</code>。</p>
</li>
<li><p>根据当前节点个数进行调整</p>
<p>如果当前链表节点个数大于等于 <code>8（TREEIFY_THRESHOLD）</code>的时候，就会调用 <code>treeifyBin</code> 方法将 <code>tabel[i]</code>（第 i 个散列桶）拉链转换成红黑树。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">	<span class="comment">//1. 计算key的hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">		<span class="comment">//2. 如果当前table还没有初始化先调用initTable方法将tab进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">		<span class="comment">//3. tab中索引为i的位置的元素为null，则直接使用CAS将值插入即可</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//4. 当前正在扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">					<span class="comment">//5. 当前为链表，在链表中插入新的键值对</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">					<span class="comment">// 6.当前为红黑树，将新的键值对插入到红黑树中</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 7.插入完键值对后再根据实际大小看是否需要转换成红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//8.对当前容量大小进行检查，如果超过了临界值（实际大小*加载因子）就需要扩容</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>看完了 put 方法再来看 get 方法就很容易了，用逆向思维去看就好，这样存的话我反过来这么取就好了</p>
<ol>
<li>首先先看当前的 hash 桶数组节点即 table[i]是否为查找的节点</li>
<li>若是则直接返回。若不是，则继续再看当前是不是树节点？</li>
<li>通过看节点的 hash 值是否为小于 0，如果小于 0 则为树节点。</li>
<li>如果是树节点在红黑树中查找节点；</li>
<li>如果不是树节点，那就只剩下为链表的形式的一种可能性了，就向后遍历查找节点，若查找到则返回节点的 value 即可，若没有找到就返回 null。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">	<span class="comment">// 1. 重hash</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2. table[i]桶节点的key与查找的key相同，则直接返回</span></span><br><span class="line">		<span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 3. 当前节点hash小于0说明为树节点，在红黑树中查找即可</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//4. 从链表中查找，查找到则返回该节点的value，否则就返回null即可</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h4><p>当 <code>ConcurrentHashMap</code> 容量不足的时候，需要对 <code>table</code> 进行扩容。这个方法的基本思想跟 <code>HashMap</code> 是很像的，但是由于它是支持并发扩容的，所以要复杂的多。原因是它支持多线程进行扩容操作，而并没有加锁。我想这样做的目的不仅仅是为了满足 <code>concurrent</code> 的要求，而是希望利用并发处理去减少扩容带来的时间影响。</p>
<p><strong>第一部分</strong>是构建一个 <code>nextTable</code>,它的容量是原来的两倍，这个操作是单线程完成的。新建 <code>table</code> 数组的代码为: <code>Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1]</code> , 在原容量大小的基础上右移一位。</p>
<p><strong>第二部分</strong>就是将原来 <code>table</code> 中的元素复制到 <code>nextTable</code> 中，主要是遍历复制的过程。 根据运算得到当前遍历的数组的位置 <code>i</code>，然后利用 <code>tabAt</code> 方法获得 <code>i</code> 位置的元素再进行判断：</p>
<ol>
<li>如果这个位置为空，就在原 <code>table</code> 中的 <code>i</code> 位置放入 <code>forwardNode</code> 节点，这个也是触发并发扩容的关键点；</li>
<li>如果这个位置是 <code>Node</code> 节点<code>（fh&gt;=0）</code>，如果它是一个链表的头节点，就构造一个反序链表，把他们分别放在 <code>nextTable</code> 的 <code>i</code> 和 <code>i+n</code> 的位置上</li>
<li>如果这个位置是 <code>TreeBin</code> 节点<code>（fh&lt;0）</code>，也做一个反序处理，并且判断是否需要 <code>untreefi</code>，把处理的结果分别放在 <code>nextTable</code> 的 <code>i</code> 和 <code>i+n</code> 的位置上</li>
<li>遍历过所有的节点以后就完成了复制工作，这时让 <code>nextTable</code> 作为新的 <code>table</code>，并且更新 <code>sizeCtl</code> 为新容量的 <code>0.75</code> 倍 ，完成扩容。设置为新容量的 <code>0.75</code> 倍代码为 <code>sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1)</code>，仔细体会下是不是很巧妙，<code>n&lt;&lt;1</code> 相当于 <code>n</code> 左移一位表示 n 的两倍即 <code>2n</code>,<code>n&gt;&gt;&gt;1</code>，<code>n</code> 右移相当于 <code>n</code> 除以 <code>2</code> 即 <code>0.5n</code>,然后两者相减为 <code>2n-0.5n=1.5n</code>,是不是刚好等于新容量的 <code>0.75</code> 倍即 <code>2n*0.75=1.5n</code>。最后用一个示意图来进行总结（图片摘自网络）：</li>
</ol>
<p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ConcurrentHashMap_2020-03-06-19-58-06.png" alt="JAVA容器——ConcurrentHashMap_2020-03-06-19-58-06.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>JDK6,7 中的 ConcurrentHashmap 主要使用 Segment 来实现减小锁粒度，分割成若干个 Segment，在 put 的时候需要锁住 Segment，get 时候不加锁，使用 volatile 来保证可见性，当要统计全局时（比如 size），首先会尝试多次计算 modcount 来确定，这几次尝试中，是否有其他线程进行了修改操作，如果没有，则直接返回 size。如果有，则需要依次锁住所有的 Segment 来计算。</p>
<p>1.8 之前 put 定位节点时要先定位到具体的 segment，然后再在 segment 中定位到具体的桶。而在 1.8 的时候摒弃了 segment 臃肿的设计，直接针对的是 Node[] tale 数组中的每一个桶，进一步减小了锁粒度。并且防止拉链过长导致性能下降，当链表长度大于 8 的时候采用红黑树的设计。</p>
<p>主要设计上的变化有以下几点:</p>
<ol>
<li>不采用 segment 而采用 node，锁住 node 来实现减小锁粒度。</li>
<li>设计了 MOVED 状态 当 resize 的中过程中 线程 2 还在 put 数据，线程 2 会帮助 resize。</li>
<li>使用 3 个 CAS 操作来确保 node 的一些操作的原子性，这种方式代替了锁。</li>
<li>sizeCtl 的不同值来代表不同含义，起到了控制的作用。</li>
<li>采用 synchronized 而不是 ReentrantLock</li>
</ol>
 
    </div>
    
    <div class="article-info article-info-index">
       
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JAVA%E5%AE%B9%E5%99%A8/">JAVA容器</a>
    </div>

 
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java%E5%AE%B9%E5%99%A8-ConcurrentHashMap/" rel="tag">java容器 ConcurrentHashMap</a></li></ul>
    </div>
 
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>
    

  
    <article
  id="post-JAVA容器——HashMap"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
>
  
  <div class="article-meta">
    <a href="/2020/02/25/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94HashMap/" class="article-date">
      <time datetime="2020-02-25T10:07:33.000Z" itemprop="datePublished">2020-02-25</time>
</a>

 
    <a href="/2020/02/25/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94HashMap/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
        
            <span class="disqus-comment-count" data-disqus-identifier="2020/02/25/JAVA容器——HashMap/"></span>
        
    </a>

  </div>
  
  <div class="article-inner">
    
    <input type="hidden" class="isFancy" />
     
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/25/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94HashMap/">JAVA容器——HashMap</a>
    </h1>
  
 
    </header>
     
    <div class="article-entry" itemprop="articleBody">
        <h1 id="您能给我说说-HashMap-吗？"><a href="#您能给我说说-HashMap-吗？" class="headerlink" title="您能给我说说 HashMap 吗？"></a>您能给我说说 HashMap 吗？</h1><ol>
<li>HashMap 是基于 Map 接口实现的一种键-值对&lt;key,value&gt;的存储结构，允许 null 值，同时非有序，非同步(即线程不安全)。</li>
<li>HashMap 的底层实现是数组 + 链表 + 红黑树（JDK1.8 增加了红黑树部分。</li>
<li>它存储和查找数据时，是根据键 key 的 hashCode 的值计算出具体的存储位置。</li>
<li>HashMap 增删改查等常规操作都有不错的执行效率，是 ArrayList 和 LinkedList 等数据结构的一种折中实现。</li>
</ol>
<h1 id="HashMap-的一些组成部分"><a href="#HashMap-的一些组成部分" class="headerlink" title="HashMap 的一些组成部分"></a>HashMap 的一些组成部分</h1><p>HashMap 的底层实现是数组 + 链表 + 红黑树（JDK1.8 增加了红黑树部分。</p>
<h2 id="核心组成部分"><a href="#核心组成部分" class="headerlink" title="核心组成部分"></a>核心组成部分</h2><ol>
<li><p><code>int size;</code> 用于记录 HashMap 实际存储元素的个数；</p>
</li>
<li><p><code>float loadFactor;</code> 负载因子（默认是 0.75，此属性后面详细解释）。</p>
</li>
<li><p><code>int threshold;</code> 下一次扩容时的阈值，达到阈值便会触发扩容机制 resize（阈值 threshold = 容器容量 capacity * 负载因子 load factor）。也就是说，在容器定义好容量之后，负载因子越大，所能容纳的键值对元素个数就越多。</p>
</li>
<li><p><code>Node&lt;K,V&gt;[] table;</code> 底层数组，充当哈希表的作用，用于存储对应 hash 位置的元素 Node&lt;K,V&gt;，此数组长度总是 2 的 N 次幂。（具体原因后面详细解释）</p>
</li>
</ol>
<h2 id="哈希表存储的核心元素"><a href="#哈希表存储的核心元素" class="headerlink" title="哈希表存储的核心元素"></a>哈希表存储的核心元素</h2><ol>
<li><p><code>final int hash;</code> 元素的哈希值，决定元素存储在 Node&lt;K,V&gt;[] table;哈希表中的位置。由 final 修饰可知，当 hash 的值确定后，就不能再修改。</p>
</li>
<li><p><code>final K key;</code> 键，由 final 修饰可知，当 key 的值确定后，就不能再修改。</p>
</li>
<li><p><code>V value;</code> 值</p>
</li>
<li><p><code>Node&lt;K,V&gt; next;</code> 记录下一个元素结点(单链表结构，用于解决 hash 冲突)</p>
</li>
</ol>
<p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94HashMap_2020-02-28-18-54-23.png" alt="JAVA容器——HashMap_2020-02-28-18-54-23.png"></p>
<h1 id="您能说说-HashMap-常用操作的底层实现原理吗？如存储-put-K-key-V-value-，查找-get-Object-key-，删除-remove-Object-key-，修改-replace-K-key-V-value-等操作。"><a href="#您能说说-HashMap-常用操作的底层实现原理吗？如存储-put-K-key-V-value-，查找-get-Object-key-，删除-remove-Object-key-，修改-replace-K-key-V-value-等操作。" class="headerlink" title="您能说说 HashMap 常用操作的底层实现原理吗？如存储 put(K key, V value)，查找 get(Object key)，删除 remove(Object key)，修改 replace(K key, V value)等操作。"></a>您能说说 HashMap 常用操作的底层实现原理吗？如存储 put(K key, V value)，查找 get(Object key)，删除 remove(Object key)，修改 replace(K key, V value)等操作。</h1><h2 id="put-添加"><a href="#put-添加" class="headerlink" title="put 添加"></a>put 添加</h2><ol>
<li><p>判断哈希表 <code>Node&lt;K,V&gt;[] table</code> 是否为空或者 <code>null</code>，是则执行 <code>resize()</code>方法进行扩容（初始化）。</p>
</li>
<li><p>根据插入的键值 <code>key</code> 的 <code>hash</code> 值（key 的 hashCode 值与 16 的位运算），通过<code>(n - 1) &amp; hash</code> 当前元素的 <code>hash</code> 值 <code>&amp; hash</code> 表长度 - 1（实际就是 <code>hash</code> 值 <code>% hash</code> 表长度） 计算出存储位置 <code>table[i]</code>。如果存储位置没有元素存放，则将新增结点存储在此位置 <code>table[i]</code>。</p>
</li>
<li><p>如果存储位置已经有键值对元素存在，则判断该位置元素的 <code>hash</code> 值和 <code>key</code> 值是否和当前操作元素一致，一致则证明是修改 <code>value</code> 操作，覆盖 <code>value</code> 即可。</p>
</li>
<li><p>当前存储位置即有元素，又不和当前操作元素一致，则证明此位置 <code>table[i]</code>已经发生了 <code>hash</code> 冲突，则通过判断头结点是否是 <code>treeNode</code>，如果是 <code>treeNode</code> 则证明此位置的结构是红黑树，已红黑树的方式新增结点。</p>
<ul>
<li>如果不是红黑树，则证明是单链表，将新增结点插入至链表的最后位置，随后判断当前链表长度是否 大于等于 8，是则将当前存储位置的链表转化为红黑树。遍历过程中如果发现 <code>key</code> 已经存在，则直接覆盖 <code>value</code>。</li>
<li>插入成功后，判断当前存储键值对的数量 大于 阈值 <code>threshold</code> 是则扩容。</li>
</ul>
</li>
</ol>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加key-value键值对</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果原本存在此key，则返回旧的value值，如果是新增的key-</span></span><br><span class="line"><span class="comment"> *         value，则返回nulll</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实际调用putVal方法进行添加 key-value 键值对操作</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key 键 的 hashCode 通过 “扰动函数” 生成对应的 hash值</span></span><br><span class="line"><span class="comment"> * 经过此操作后，使每一个key对应的hash值生成的更均匀，</span></span><br><span class="line"><span class="comment"> * 减少元素之间的碰撞几率（后面详细说明）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加key-value键值对的实际调用方法（重点）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash key 键的hash值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent 此值如果是true, 则如果此key已存在value，则不执</span></span><br><span class="line"><span class="comment"> * 行修改操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict 此值如果是false，哈希表是在初始化模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回原本的旧值, 如果是新增，则返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于记录当前的hash表</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="comment">// 用于记录当前的链表结点</span></span><br><span class="line">    Node&lt;K,V&gt; p;</span><br><span class="line">    <span class="comment">// n用于记录hash表的长度，i用于记录当前操作索引index</span></span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 当前hash表为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 初始化hash表，并把初始化后的hash表长度值赋值给n</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 1）通过 (n - 1) &amp; hash 当前元素的hash值 &amp; hash表长度 - 1</span></span><br><span class="line">    <span class="comment">// 2）确定当前元素的存储位置，此运算等价于 当前元素的hash值 % hash表的长度</span></span><br><span class="line">    <span class="comment">// 3）计算出的存储位置没有元素存在</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 4) 则新建一个Node结点，在该位置存储此元素</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 当前存储位置已经有元素存在了(不考虑是修改的情况的话，就代表发生hash冲突了)</span></span><br><span class="line">        <span class="comment">// 用于存放新增结点</span></span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="comment">// 用于临时存在某个key值</span></span><br><span class="line">        K k;</span><br><span class="line">        <span class="comment">// 1)如果当前位置已存在元素的hash值和新增元素的hash值相等</span></span><br><span class="line">        <span class="comment">// 2)并且key也相等，则证明是同一个key元素，想执行修改value操作</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;<span class="comment">// 将当前结点引用赋值给e</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 如果当前结点是树结点</span></span><br><span class="line">            <span class="comment">// 则证明当前位置的链表已变成红黑树结构，则已红黑树结点结构新增元素</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">// 排除上述情况，则证明已发生hash冲突，并hash冲突位置现时的结构是单链表结构</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//遍历单链表，将新元素结点放置此链表的最后一位</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 将新元素结点放在此链表的最后一位</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 新增结点后，当前结点数量是否大于等于 阈值 8</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">// 大于等于8则将链表转换成红黑树</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果链表中已经存在对应的key，则覆盖value</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// 已存在对应key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>) <span class="comment">//如果允许修改，则修改value为新值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 当前存储键值对的数量 大于 阈值 是则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">       <span class="comment">// 重置hash大小，将旧hash表的数据逐一复制到新的hash表中（后面详细讲解）</span></span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="comment">// 返回null，则证明是新增操作，而不是修改操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="取值-get"><a href="#取值-get" class="headerlink" title="取值 get"></a>取值 get</h2><ol>
<li><p>先调用 <code>hash(key)</code>方法计算出 <code>key</code> 的 <code>hash</code>值。</p>
</li>
<li><p>根据查找的键值<code>key</code>的<code>hash</code>值，通过<code>(n - 1) &amp; hash</code>当前元素的<code>hash</code>值 <code>&amp; hash</code>表长度 <code>- 1</code>（实际就是 <code>hash</code>值 <code>% hash</code>表长度） 计算出存储位置<code>table[i]</code>，判断存储位置是否有元素存在 。</p>
<ul>
<li>如果存储位置有元素存放，则首先比较头结点元素，如果头结点的<code>key</code>的<code>hash</code>值 和 要获取的<code>key</code>的<code>hash</code>值相等，并且 头结点的<code>key</code>本身 和要获取的 <code>key</code> 相等，则返回该位置的头结点。</li>
<li>如果存储位置没有元素存放，则返回<code>null</code>。</li>
</ul>
</li>
<li><p>如果存储位置有元素存放，但是头结点元素不是要查找的元素，则需要遍历该位置进行查找。</p>
</li>
<li><p>先判断头结点是否是<code>treeNode</code>，如果是<code>treeNode</code>则证明此位置的结构是红黑树，以红色树的方式遍历查找该结点，没有则返回<code>null</code>。</p>
</li>
<li><p>如果不是红黑树，则证明是单链表。遍历单链表，逐一比较链表结点，链表结点的<code>key</code>的<code>hash</code>值 和 要获取的<code>key</code>的<code>hash</code>值相等，并且 链表结点的<code>key</code>本身 和要获取的 <code>key</code> 相等，则返回该结点，遍历结束仍未找到对应<code>key</code>的结点，则返回<code>null</code>。</p>
</li>
</ol>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定 key 所映射的 value 值</span></span><br><span class="line"><span class="comment"> * 或者 返回 null 如果容器里不存在对应的key</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 更确切地讲，如果此映射包含一个满足 (key==null ? k==null :key.equals(k))</span></span><br><span class="line"><span class="comment"> * 的从 k 键到 v 值的映射关系，</span></span><br><span class="line"><span class="comment"> * 则此方法返回 v；否则返回 null。（最多只能有一个这样的映射关系。）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回 null 值并不一定 表明该映射不包含该键的映射关系；</span></span><br><span class="line"><span class="comment"> * 也可能该映射将该键显示地映射为 null。可使用containsKey操作来区分这两种情况。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 1.先调用 hash(key)方法计算出 key 的 hash值</span></span><br><span class="line">    <span class="comment">// 2.随后调用getNode方法获取对应key所映射的value值</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取哈希表结点的方法实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash key 键的hash值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回对应的结点，如果结点不存在，则返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于记录当前的hash表</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="comment">// first用于记录对应hash位置的第一个结点，e充当工作结点的作用</span></span><br><span class="line">    Node&lt;K,V&gt; first, e;</span><br><span class="line">    <span class="comment">// n用于记录hash表的长度</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">// 用于临时存放Key</span></span><br><span class="line">    K k;</span><br><span class="line">    <span class="comment">// 通过 (n - 1) &amp; hash 当前元素的hash值 &amp; hash表长度 - 1</span></span><br><span class="line">    <span class="comment">// 判断当前元素的存储位置是否有元素存在</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;<span class="comment">//元素存在的情况</span></span><br><span class="line">       <span class="comment">// 如果头结点的key的hash值 和 要获取的key的hash值相等</span></span><br><span class="line">       <span class="comment">// 并且 头结点的key本身 和要获取的 key 相等</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node 总是检查头结点</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 返回该位置的头结点</span></span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;<span class="comment">// 头结点不相等</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 如果当前结点是树结点</span></span><br><span class="line">                <span class="comment">// 则证明当前位置的链表已变成红黑树结构</span></span><br><span class="line">                <span class="comment">// 通过红黑树结点的方式获取对应key结点</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;<span class="comment">// 当前位置不是红黑树，则证明是单链表</span></span><br><span class="line">                <span class="comment">// 遍历单链表，逐一比较链表结点</span></span><br><span class="line">                <span class="comment">// 链表结点的key的hash值 和 要获取的key的hash值相等</span></span><br><span class="line">                <span class="comment">// 并且 链表结点的key本身 和要获取的 key 相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 找到对应的结点则返回</span></span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过上述查找均无找到，则返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除-remove"><a href="#删除-remove" class="headerlink" title="删除 remove"></a>删除 remove</h2><ol>
<li><p>先调用 <code>hash(key)</code>方法计算出 <code>key</code> 的 <code>hash</code>值。</p>
</li>
<li><p>根据查找的键值<code>key</code>的<code>hash</code>值，通过<code>(n - 1) &amp; hash</code>当前元素的<code>hash</code>值 <code>&amp; hash</code>表长度 - 1（实际就是 <code>hash</code>值 <code>% hash</code>表长度） 计算出存储位置<code>table[i]</code>，判断存储位置是否有元素存在 。</p>
<ul>
<li>如果存储位置有元素存放，则首先比较头结点元素，如果头结点的 key 的 hash 值 和 要获取的 key 的 hash 值相等，并且 头结点的 key 本身 和要获取的 key 相等，则该位置的头结点即为要删除的结点，记录此结点至变量 node 中。</li>
<li>如果存储位置没有元素存放，则没有找到对应要删除的结点，则返回 null。</li>
</ul>
</li>
<li><p>如果存储位置有元素存放，但是头结点元素不是要删除的元素，则需要遍历该位置进行查找。<br>4, 先判断头结点是否是<code>treeNode</code>，如果是<code>treeNode</code>则证明此位置的结构是红黑树，以红色树的方式遍历查找并删除该结点，没有则返回<code>null</code>。</p>
</li>
<li><p>如果不是红黑树，则证明是单链表。遍历单链表，逐一比较链表结点，链表结点的<code>key</code>的<code>hash</code>值 和 要获取的<code>key</code>的<code>hash</code>值相等，并且 链表结点的<code>key</code>本身 和要获取的<code>key</code>相等，则此为要删除的结点，记录此结点至变量 <code>node</code> 中，遍历结束仍未找到对应<code>key</code>的结点，则返回<code>null</code>。</p>
</li>
<li><p>如果找到要删除的结点 <code>node</code>，则判断是否需要比较 <code>value</code> 也是否一致，如果 <code>value</code> 值一致或者不需要比较 <code>value</code> 值，则执行删除结点操作，删除操作根据不同的情况与结构进行不同的处理。</p>
<ul>
<li>如果当前结点是树结点，则证明当前位置的链表已变成红黑树结构，通过红黑树结点的方式删除对应结点。</li>
<li>如果不是红黑树，则证明是单链表。如果要删除的是头结点，则当前存储位置 <code>table[i]</code> 的头结点指向删除结点的下一个结点。</li>
<li>如果要删除的结点不是头结点，则将要删除的结点的后继结点 <code>node.next</code> 赋值给要删除结点的前驱结点的 <code>next</code> 域，即 <code>p.next = node.next;</code>。</li>
</ul>
</li>
<li><p><code>HashMap</code> 当前存储键值对的数量 <code>- 1</code>，并返回删除结点。</p>
</li>
</ol>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从此映射中移除指定键的映射关系（如果存在）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  key 其映射关系要从映射中移除的键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 与 key 关联的旧值；如果 key 没有任何映射关系，则返回 null。</span></span><br><span class="line"><span class="comment"> *        （返回 null 还可能表示该映射之前将 null 与 key 关联。）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 1.先调用 hash(key)方法计算出 key 的 hash值</span></span><br><span class="line">    <span class="comment">// 2.随后调用removeNode方法删除对应key所映射的结点</span></span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除哈希表结点的方法实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 键的hash值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 用于比较的value值，当matchValue 是 true时才有效, 否则忽略</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> matchValue 如果是 true 只有当value相等时才会移除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> movable 如果是 false当执行移除操作时，不删除其他结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回删除结点node，不存在则返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于记录当前的hash表</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="comment">// 用于记录当前的链表结点</span></span><br><span class="line">    Node&lt;K,V&gt; p;</span><br><span class="line">    <span class="comment">// n用于记录hash表的长度，index用于记录当前操作索引index</span></span><br><span class="line">    <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">// 通过 (n - 1) &amp; hash 当前元素的hash值 &amp; hash表长度 - 1</span></span><br><span class="line">    <span class="comment">// 判断当前元素的存储位置是否有元素存在</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;<span class="comment">// 元素存在的情况</span></span><br><span class="line">        <span class="comment">// node 用于记录找到的结点，e为工作结点</span></span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e;</span><br><span class="line">        K k; V v;</span><br><span class="line">       <span class="comment">// 如果头结点的key的hash值 和 要获取的key的hash值相等</span></span><br><span class="line">       <span class="comment">// 并且 头结点的key本身 和要获取的 key 相等</span></span><br><span class="line">       <span class="comment">// 则证明此头结点就是要删除的结点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 记录要删除的结点的引用地址至node中</span></span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;<span class="comment">// 头结点不相等</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)<span class="comment">// 如果当前结点是树结点</span></span><br><span class="line">                <span class="comment">// 则证明当前位置的链表已变成红黑树结构</span></span><br><span class="line">                <span class="comment">// 通过红黑树结点的方式获取对应key结点</span></span><br><span class="line">                <span class="comment">// 记录要删除的结点的引用地址至node中</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">// 当前位置不是红黑树，则证明是单链表</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">// 遍历单链表，逐一比较链表结点</span></span><br><span class="line">                    <span class="comment">// 链表结点的key的hash值 和 要获取的key的hash值相等</span></span><br><span class="line">                    <span class="comment">// 并且 链表结点的key本身 和要获取的 key 相等</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        <span class="comment">// 找到则记录要删除的结点的引用地址至node中，中断遍历</span></span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果找到要删除的结点，则判断是否需要比较value也是否一致</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">// value值一致或者不需要比较value值，则执行删除结点操作</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 如果当前结点是树结点</span></span><br><span class="line">                <span class="comment">// 则证明当前位置的链表已变成红黑树结构</span></span><br><span class="line">                <span class="comment">// 通过红黑树结点的方式删除对应结点</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p) <span class="comment">// node 和 p相等，则证明删除的是头结点</span></span><br><span class="line">                <span class="comment">// 当前存储位置的头结点指向删除结点的下一个结点</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 删除的不是头结点</span></span><br><span class="line">                <span class="comment">// p是删除结点node的前驱结点，p的next改为记录要删除结点node的后继结点</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">           <span class="comment">// 当前存储键值对的数量 - 1</span></span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="comment">// 返回删除结点</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不存在要删除的结点，则返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="替换-replace"><a href="#替换-replace" class="headerlink" title="替换 replace"></a>替换 replace</h2><ol>
<li><p>先调用 <code>hash(key)</code>方法计算出 <code>key</code> 的 <code>hash</code>值</p>
</li>
<li><p>随后调用<code>getNode</code>方法获取对应<code>key</code>所映射的<code>value</code>值 。</p>
</li>
<li><p>记录元素旧值，将新值赋值给元素，返回元素旧值，如果没有找到元素，则返回<code>null</code>。</p>
</li>
</ol>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 替换指定 key 所映射的 value 值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 对应要替换value值元素的key键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要替换对应元素的新value值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回原本的旧值，如果没有找到key对应的元素，则返回null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8 JDK1.8新增方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 1.先调用 hash(key)方法计算出 key 的 hash值</span></span><br><span class="line">    <span class="comment">// 2.随后调用getNode方法获取对应key所映射的value值</span></span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span>) &#123;<span class="comment">// 如果找到对应的元素</span></span><br><span class="line">        <span class="comment">// 元素旧值</span></span><br><span class="line">        V oldValue = e.value;</span><br><span class="line">        <span class="comment">// 将新值赋值给元素</span></span><br><span class="line">        e.value = value;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="comment">// 返回元素旧值</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有找到元素，则返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="hash-冲突（或者叫-hash-碰撞）是什么？为什么会出现这种现象，如何解决-hash-冲突？"><a href="#hash-冲突（或者叫-hash-碰撞）是什么？为什么会出现这种现象，如何解决-hash-冲突？" class="headerlink" title="hash 冲突（或者叫 hash 碰撞）是什么？为什么会出现这种现象，如何解决 hash 冲突？"></a>hash 冲突（或者叫 hash 碰撞）是什么？为什么会出现这种现象，如何解决 hash 冲突？</h1><h2 id="hash-冲突"><a href="#hash-冲突" class="headerlink" title="hash 冲突"></a>hash 冲突</h2><p>当我们调用<code>put(K key, V value)</code>操作添加<code>key-value</code>键值对，这个<code>key-value</code>键值对存放在的位置是通过扰动函数<code>(key == null)? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>计算键 <code>key</code> 的 <code>hash</code> 值。随后将 这个 <code>hash</code> 值 <code>%</code>模上 哈希表 <code>Node&lt;K,V&gt;[] table</code> 的长度 得到具体的存放位置。所以 <code>put(K key, V value)</code>多个元素，是有可能计算出相同的存放位置。此现象就是 <code>hash</code> 冲突或者叫 <code>hash</code> 碰撞。</p>
<h2 id="hash-冲突的避免"><a href="#hash-冲突的避免" class="headerlink" title="hash 冲突的避免"></a>hash 冲突的避免</h2><p>既然会发生<code>hash</code>冲突，我们就应该想办法避免此现象的发生，解决这个问题最关键就是如果生成元素的<code>hash</code>值。<code>Java</code>是使用“扰动函数”生成元素的<code>hash</code>值。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDK 7 的 hash方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">     h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">     <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDK 8 的 hash方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>Java7 做了 4 次 16 位右位移异或混合，Java 8 中这步已经简化了，只做一次 16 位右位移异或混合，而不是四次，但原理是不变的。例子如下：</p>
<p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94HashMap_2020-02-28-19-50-28.png" alt="JAVA容器——HashMap_2020-02-28-19-50-28.png"></p>
<p>右位移 16 位，正好是 32bit 的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来</p>
<h2 id="hash-冲突解决："><a href="#hash-冲突解决：" class="headerlink" title="hash 冲突解决："></a>hash 冲突解决：</h2><p>解决<code>hash</code>冲突的方法有很多，常见的有：开发定址法，再散列法，链地址法，公共溢出区法。<code>HashMap</code>是使用链地址法解决<code>hash</code>冲突的，当有冲突元素放进来时，会将此元素插入至此位置链表的最后一位，形成单链表。但是由于是单链表的缘故，每当通过<code>hash % length</code>找到该位置的元素时，均需要从头遍历链表，通过逐一比较<code>hash</code>值，找到对应元素。如果此位置元素过多，造成链表过长，遍历时间会大大增加，最坏情况下的时间复杂度为<code>O(N)</code>，造成查找效率过低。所以当存在位置的链表长度 大于等于 <code>8</code> 时，<code>HashMap</code>会将链表 转变为 红黑树，红黑树最坏情况下的时间复杂度为<code>O(logn)</code>。以此提高查找效率。</p>
<h1 id="HashMap-的容量为什么一定要是-2-的-n-次方？"><a href="#HashMap-的容量为什么一定要是-2-的-n-次方？" class="headerlink" title="HashMap 的容量为什么一定要是 2 的 n 次方？"></a>HashMap 的容量为什么一定要是 2 的 n 次方？</h1><h2 id="运算效率高"><a href="#运算效率高" class="headerlink" title="运算效率高"></a>运算效率高</h2><p>因为调用 <code>put(K key, V value)</code> 操作添加<code>key-value</code>键值对时，具体确定此元素的位置是通过 <code>hash</code>值 <code>%</code> 模上 哈希表<code>Node&lt;K,V&gt;[] table</code>的长度 <code>hash % length</code> 计算的。但是”模”运算的消耗相对较大，通过位运算<code>h &amp; (length-1)</code>也可以得到取模后的存放位置，而位运算的运行效率高，但只有 length 的长度是 2 的 n 次方时，<code>h &amp; (length-1)</code> 才等价于 <code>h % length</code>。</p>
<h2 id="分布均匀"><a href="#分布均匀" class="headerlink" title="分布均匀"></a>分布均匀</h2><p>而且当数组长度为 2 的 n 次幂的时候，不同的<code>key</code>算出的<code>index</code>相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。</p>
<h1 id="HashMap-的负载因子是什么，有什么作用？"><a href="#HashMap-的负载因子是什么，有什么作用？" class="headerlink" title="HashMap 的负载因子是什么，有什么作用？"></a>HashMap 的负载因子是什么，有什么作用？</h1><p>负载因子表示哈希表空间的使用程度</p>
<ul>
<li>当负载因子越大，则<code>HashMap</code>的装载程度就越高。也就是能容纳更多的元素，元素多了，发生<code>hash</code>碰撞的几率就会加大，从而链表就会拉长，此时的查询效率就会降低。</li>
<li>当负载因子越小，则链表中的数据量就越稀疏，此时会对空间造成浪费，但是此时查询效率高。</li>
</ul>
<h1 id="扩容？它是怎么扩容的呢？"><a href="#扩容？它是怎么扩容的呢？" class="headerlink" title="扩容？它是怎么扩容的呢？"></a>扩容？它是怎么扩容的呢？</h1><p>当 <code>put</code> 时，如果发现目前的 <code>bucket</code> 占用程度已经超过了 <code>Load Factor</code> 所希望的比例，那么就会发生 <code>resize</code>。在 <code>resize</code> 的过程，简单的说就是把 <code>bucket</code> 扩充为 2 倍，之后重新计算 <code>index</code>，把节点再放到新的 <code>bucket</code> 中。</p>
<p>当超过限制的时候会<code>resize</code>，然而又因为我们使用的是 2 次幂的扩展(指长度扩为原来 2 倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动 2 次幂的位置。</p>
<p>怎么理解呢？例如我们从 16 扩展为 32 时，具体的变化如下所示：</p>
<p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94HashMap_2020-02-28-20-03-28.png" alt="JAVA容器——HashMap_2020-02-28-20-03-28.png"></p>
<p>因此元素在重新计算 <code>hash</code> 之后，因为 n 变为 2 倍，那么 <code>n-1</code> 的 mask 范围在高位多 1bit(红色)，因此新的 index 就会发生这样的变化：</p>
<p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94HashMap_2020-02-28-20-04-09.png" alt="JAVA容器——HashMap_2020-02-28-20-04-09.png"></p>
<p>因此，我们在扩充 <code>HashMap</code> 的时候，不需要重新计算 <code>hash</code>，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就好了，是 0 的话索引没变，是 1 的话索引变成“原索引+oldCap”。</p>
<p>这个设计确实非常的巧妙，既省去了重新计算 <code>hash</code> 值的时间，而且同时，由于新增的 1bit 是 0 还是 1 可以认为是随机的，因此 <code>resize</code> 的过程，均匀的把之前的冲突的节点分散到新的 <code>bucket</code> 了。</p>
<h1 id="拉链法插入链表-为啥-java7-之前用头插法，java8-之后改成尾插了呢？"><a href="#拉链法插入链表-为啥-java7-之前用头插法，java8-之后改成尾插了呢？" class="headerlink" title="拉链法插入链表 为啥 java7 之前用头插法，java8 之后改成尾插了呢？"></a>拉链法插入链表 为啥 java7 之前用头插法，java8 之后改成尾插了呢？</h1><p>使用头插会改变链表的上的顺序，但是如果使用尾插，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了。</p>
<ul>
<li>Java7 在多线程操作 HashMap 时可能引起死循环，原因是扩容转移后前后链表顺序倒置，在转移过程中修改了原来链表中节点的引用关系。</li>
<li>Java8 在同样的前提下并不会引起死循环，原因是扩容转移后前后链表顺序不变，保持之前节点的引用关系。</li>
</ul>
<h1 id="您能说说-HashMap-和-HashTable-的区别吗？"><a href="#您能说说-HashMap-和-HashTable-的区别吗？" class="headerlink" title="您能说说 HashMap 和 HashTable 的区别吗？"></a>您能说说 HashMap 和 HashTable 的区别吗？</h1><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>Hashtable 继承了 Dictionary 类，而 HashMap 继承的是 AbstractMap 类。</p>
<h2 id="容器整体结构"><a href="#容器整体结构" class="headerlink" title="容器整体结构"></a>容器整体结构</h2><ul>
<li><code>HashMap</code>的<code>key</code>和<code>value</code>都允许为<code>null</code>，<code>HashMap</code>遇到<code>key</code>为<code>null</code>的时候，调用<code>putForNullKey</code>方法进行处理，而对<code>value</code>没有处理。</li>
<li><code>Hashtable</code> 的 <code>key</code> 和 <code>value</code> 都不允许为 <code>null</code>。<code>Hashtable</code> 遇到 <code>null</code>，直接返回 <code>NullPointerException</code>。</li>
</ul>
<h2 id="初始化容量和扩容机制"><a href="#初始化容量和扩容机制" class="headerlink" title="初始化容量和扩容机制"></a>初始化容量和扩容机制</h2><ul>
<li><code>HashMap</code>默认初始化容量为 16，并且容器容量一定是 2 的 n 次方，扩容时，是以原容量 2 倍 的方式 进行扩容。</li>
<li><code>Hashtable</code>默认初始化容量为 11，扩容时，是以原容量 2 倍 再加 1 的方式进行扩容。即<code>int newCapacity = (oldCapacity &lt;&lt; 1) + 1</code>;。</li>
</ul>
<h2 id="迭代方式不同"><a href="#迭代方式不同" class="headerlink" title="迭代方式不同"></a>迭代方式不同</h2><p>HashMap 中的 Iterator 迭代器是 fail-fast 的，而 Hashtable 的 Enumerator 不是 fail-fast 的。</p>
<h2 id="线程安全（最重要）"><a href="#线程安全（最重要）" class="headerlink" title="线程安全（最重要）"></a>线程安全（最重要）</h2><ul>
<li><code>HashMap</code> 不是线程安全，如果想线程安全，可以通过调用<code>synchronizedMap(Map&lt;K,V&gt; m)</code>使其线程安全。但是使用时的运行效率会下降，所以建议使用<code>ConcurrentHashMap</code>容器以此达到线程安全。</li>
<li><code>Hashtable</code>则是线程安全的，每个操作方法前都有<code>synchronized</code>修饰使其同步，但运行效率也不高，所以还是建议使用<code>ConcurrentHashMap</code>容器以此达到线程安全。</li>
</ul>
<p>因此，<code>Hashtable</code>是一个遗留容器，如果我们不需要线程同步，则建议使用<code>HashMap</code>，如果需要线程同步，则建议使用<code>ConcurrentHashMap</code>。</p>
<h1 id="谈谈-HashMap-线程不安全的体现"><a href="#谈谈-HashMap-线程不安全的体现" class="headerlink" title="谈谈 HashMap 线程不安全的体现"></a>谈谈 HashMap 线程不安全的体现</h1><p>那么，为什么说 HashMap 是线程不安全的呢？它在多线程环境下，会发生什么情况呢？</p>
<h2 id="resize-死循环-JDK7"><a href="#resize-死循环-JDK7" class="headerlink" title="resize 死循环(JDK7)"></a>resize 死循环(JDK7)</h2><p>我们都知道 HashMap 初始容量大小为 16,一般来说，当有数据要插入时，都会检查容量有没有超过设定的 thredhold，如果超过，需要增大 Hash 表的尺寸，但是这样一来，整个 Hash 表里的元素都需要被重算一遍。这叫 rehash，这个成本相当的大。<br>对索引数组中的元素遍历</p>
<p>对链表上的每一个节点遍历：用 next 取得要转移那个元素的下一个，将 e 转移到新 Hash 表的头部，使用头插法插入节点。</p>
<p>循环 2，直到链表节点全部转移</p>
<p>循环 1，直到所有索引数组全部转移</p>
<p>经过这几步，我们会发现转移的时候是逆序的。假如转移前链表顺序是 1-&gt;2-&gt;3，那么转移后就会变成 3-&gt;2-&gt;1。这时候就有点头绪了，死锁问题不就是因为 1-&gt;2 的同时 2-&gt;1 造成的吗？所以，HashMap 的死锁问题就出在这个 transfer()函数上。</p>
<h2 id="fail-fast"><a href="#fail-fast" class="headerlink" title="fail-fast"></a>fail-fast</h2><p>如果在使用迭代器的过程中有其他线程修改了 map，那么将抛出 ConcurrentModificationException，这就是所谓 fail-fast 策略。</p>
 
    </div>
    
    <div class="article-info article-info-index">
       
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JAVA%E5%AE%B9%E5%99%A8/">JAVA容器</a>
    </div>

 
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java%E5%AE%B9%E5%99%A8-HashMap/" rel="tag">java容器 HashMap</a></li></ul>
    </div>
 
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>
    

  
    <article
  id="post-JAVA容器——LinkedList"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
>
  
  <div class="article-meta">
    <a href="/2020/02/25/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94LinkedList/" class="article-date">
      <time datetime="2020-02-25T07:58:23.000Z" itemprop="datePublished">2020-02-25</time>
</a>

 
    <a href="/2020/02/25/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94LinkedList/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
        
            <span class="disqus-comment-count" data-disqus-identifier="2020/02/25/JAVA容器——LinkedList/"></span>
        
    </a>

  </div>
  
  <div class="article-inner">
    
    <input type="hidden" class="isFancy" />
     
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/25/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94LinkedList/">JAVA容器——LinkedList</a>
    </h1>
  
 
    </header>
     
    <div class="article-entry" itemprop="articleBody">
        <h1 id="请简单介绍一下您所了解的-LinkedList，它可以用来做什么，怎么使用？"><a href="#请简单介绍一下您所了解的-LinkedList，它可以用来做什么，怎么使用？" class="headerlink" title="请简单介绍一下您所了解的 LinkedList，它可以用来做什么，怎么使用？"></a>请简单介绍一下您所了解的 LinkedList，它可以用来做什么，怎么使用？</h1><ol>
<li>LinkedList 底层是双向链表，同时实现了<code>List</code>接口和<code>Deque</code>接口，所以它既可以看作是一个顺序容器，也可以看作是一个队列(Queue)，同时也可以看作是一个栈(Stack)，但如果想使用栈或队列等数据结构的话，推荐使用 ArrayDeque，它作为栈或队列会比 LinkedList 有更好的使用性能。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个LinkedList，链表的每个节点的内存空间都是实时分配的，所以无须事先指定容器大小</span></span><br><span class="line">LinkedList&lt;String&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line"><span class="comment">// 往容器里面添加元素</span></span><br><span class="line">linkedList.add(<span class="string">"张三"</span>);</span><br><span class="line">linkedList.add(<span class="string">"李四"</span>);</span><br><span class="line"><span class="comment">// 在张三与李四之间插入一个王五</span></span><br><span class="line">linkedList.add(<span class="number">1</span>, <span class="string">"王五"</span>);</span><br><span class="line"><span class="comment">// 在头部插入一个小三</span></span><br><span class="line">linkedList.addFirst(<span class="string">"小三"</span>);</span><br><span class="line"><span class="comment">// 获取index下标为2的元素 王五</span></span><br><span class="line">String element = linkedList.get(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 修改index下标为2的元素 王五 为小四</span></span><br><span class="line">linkedList.set(<span class="number">2</span>, <span class="string">"小四"</span>);</span><br><span class="line"><span class="comment">// 删除index下标为1的元素 张三</span></span><br><span class="line">String removeElement = linkedList.remove(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 删除第一个元素</span></span><br><span class="line">String removeFirstElement = linkedList.removeFirst();</span><br><span class="line"><span class="comment">// 删除最后一个元素</span></span><br><span class="line">String removeLastElement = linkedList.removeLast();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>LinkedList 底层实现是双向链表，核心组成元素有：<code>int size = 0</code>用于记录链表长度；<code>Node&lt;E&gt; first</code>;用于记录头（第一个）结点（储存的是头结点的引用）；<code>Node&lt;E&gt; last</code>;用于记录尾（最后一个）结点（储存的是尾结点的引用）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 记录链表长度</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to first node. 指向第一个结点</span></span><br><span class="line"><span class="comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">     *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to last node. 指向最后一个结点</span></span><br><span class="line"><span class="comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">     *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>双向链表的核心组成元素还有一个最重要的<code>Node&lt;E&gt;</code>，<code>Node&lt;E&gt;</code>包含：<code>E item</code>; 用于存储元素数据，<code>Node&lt;E&gt; next</code>; 指向当前元素的后继结点，<code>Node&lt;E&gt; prev</code>; 指向当前元素的前驱结点。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义LinkedList底层的结点实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item; <span class="comment">// 存储元素数据</span></span><br><span class="line">    Node&lt;E&gt; next;<span class="comment">// 指向当前元素的后继结点</span></span><br><span class="line">    Node&lt;E&gt; prev;<span class="comment">// 指向当前元素的前驱结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Node结点构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;<span class="comment">// 存储的元素</span></span><br><span class="line">        <span class="keyword">this</span>.next = next;<span class="comment">// 后继结点</span></span><br><span class="line">        <span class="keyword">this</span>.prev = prev;<span class="comment">// 前驱结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>双向链表底层视图：</li>
</ul>
<p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94LinkedList_2020-02-25-16-22-31.png" alt="JAVA容器——LinkedList_2020-02-25-16-22-31.png"></p>
<h1 id="请分别分析一下它是如何获取元素，修改元素，新增元素与删除元素，并分析这些操作对应的时间复杂度。"><a href="#请分别分析一下它是如何获取元素，修改元素，新增元素与删除元素，并分析这些操作对应的时间复杂度。" class="headerlink" title="请分别分析一下它是如何获取元素，修改元素，新增元素与删除元素，并分析这些操作对应的时间复杂度。"></a>请分别分析一下它是如何获取元素，修改元素，新增元素与删除元素，并分析这些操作对应的时间复杂度。</h1><h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><p>LinkedList 提供了三种获取元素的方法，分别是：</p>
<ol>
<li><p>获取第一个元素 getFirst()，获取第一个元素，直接返回 Node<E> first 指向的结点即可，所以时间复杂度为 O(1)。</p>
</li>
<li><p>获取最后一个元素 getLast()，获取最后一个元素，直接返回 Node<E> last 指向的结点即可，所以时间复杂度也为 O(1)。</p>
</li>
<li><p>获取指定索引 index 位置的元素 <code>get(int index)</code>，由于 <code>Node&lt;E&gt;</code>结点在内存中存储的空间不是连续存储的，所以查找某一位置的结点，只能通过遍历链表的方式查找结点，因此 LinkedList 会先通过判断 <code>index &lt; (size &gt;&gt; 1)</code>，<code>size&gt;&gt;1</code> 即为 <code>size/2</code> 当前链表长度的一半，判断 index 的位置是在链表的前半部分还是后半部分。决定是从头部遍历查找数据还是从尾部遍历查找数据。最坏情况下，获取中间元素，则需要遍历 n/2 次才能获取到对应元素，所以此方法的时间复杂度为 O(n)。</p>
</li>
</ol>
<p>综上所述，LinkedList 获取元素的时间复杂度为 O(n)。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回列表中指定位置的元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定index位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回指定位置的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查index下标是否合法[0,size)</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// 遍历列表获取对应index位置的元素</span></span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查下标是否合法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isElementIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定位置的结点元素（重点）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="comment">// 判断index位置是在链表的前半部分还是后半部分</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// 从头结点开始，从前往后遍历找到对应位置的结点元素</span></span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从尾结点开始，从后往前遍历找到对应位置的结点元素</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h2><p>LinkedList 提供了一种修改元素数据的方法 set(int index, E element)，修改元素数据的步骤是：1.检查 index 索引是否合法[0,size)。2.折半查询获取对应索引元素。3.将新元素赋值，返回旧元素。由获取元素的分析可知，折半查询的时间复杂度为 O(n)，故修改元素数据的时间复杂度为 O(n)。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改指定位置结点的存储数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 修改的存储数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回未修改前的存储数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查index下标是否合法[0,size)</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// 折半查询获取对应索引元素</span></span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    <span class="comment">// 将新元素赋值，返回旧元素</span></span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="新增元素"><a href="#新增元素" class="headerlink" title="新增元素"></a>新增元素</h2><p>LinkedList 提供了四种新增元素的方法，分别是：</p>
<ol>
<li><p>将指定元素插入到链表的第一个位置中 addFirst(E e)，只需将头结点 first 指向新元素结点，将原第一结点的前驱指针指向新元素结点即可。不需要移动原数据存储位置，只需交换一下相关结点的指针域信息即可。所以时间复杂度为 O(1)。</p>
</li>
<li><p>将指定元素插入到链表的最后一个位置中 addLast(E e)，只需将尾结点 last 指向新元素结点，将原最后一个结点的后继指针指向新元素结点即可。不需要移动原数据存储位置，只需交换一下相关结点的指针域信息即可。所以时间复杂度也为 O(1)。</p>
</li>
<li><p>添加元素方法 add(E e) 等价于 addLast(E e)。</p>
</li>
<li><p>将指定元素插入到链表的指定位置 index 中 add(int index, E element)，需要先根据位置 index 调用 node(index)遍历链表获取该位置的原结点，然后将新结点插入至原该位置结点的前面，不需要移动原数据存储位置，只需交换一下相关结点的指针域信息即可。所以时间复杂度也为 O(1)。</p>
</li>
</ol>
<p>综上所述，LinkedList 新增元素的时间复杂度为 O(1)，单纯论插入新元素，操作是非常高效的，特别是插入至头部或插入到尾部。但如果是通过索引 index 的方式插入，插入的位置越靠近链表中间所费时间越长，因为需要对链表进行遍历查找。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定元素插入到链表的第一个位置中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要插入的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将元素e作为第一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取原头结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">// 初始化新元素结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    <span class="comment">// 头指针指向新元素结点</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="comment">// 如果是第一个元素（链表为空）</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 将尾指针也指向新元素结点</span></span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 链表不会空</span></span><br><span class="line">        <span class="comment">// 原头结点的前驱指针指向新结点</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    <span class="comment">// 记录链表长度的size + 1</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定元素插入到链表的最后一个位置中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;此方法等同与add(E e)方法 &#123;<span class="doctag">@link</span> #add&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要插入的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定元素插入到链表的最后一个位置中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;此方法等同与addLast(E e)方法  &#123;<span class="doctag">@link</span> #addLast&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要插入的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将元素e作为最后一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取原尾结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 初始化新元素结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 位指针指向新元素结点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">// 如果是第一个元素（链表为空）</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 将头指针也指向新元素结点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 链表不会空</span></span><br><span class="line">        <span class="comment">// 原尾结点的后继指针指向新结点</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    <span class="comment">// 记录链表长度的size + 1</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定元素插入到链表的指定位置index中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 元素要插入的位置index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 要插入的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查插入位置是否合法[0,size]</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="comment">// 如果插入的位置和当前链表长度相等，则直接将元素插入至链表的尾部</span></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        <span class="comment">// 将元素插入至链表的尾部</span></span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//将元素插入至指定位置,node(index)先获取占有该index位置的原结点</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查位置是否合法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查位置是否合法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//合法位置为[0,size]</span></span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将新元素e插入至旧元素succ前面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="comment">// 记录旧元素结点succ的前驱指针</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="comment">// 初始化新元素结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    <span class="comment">// 旧元素结点的前驱指针指向新元素结点(即新元素结点放至在旧元素结点的前面，取代了原本旧元素的位置)</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="comment">// 如果旧元素结点的前驱指针为空，则证明旧元素结点是头结点，</span></span><br><span class="line">    <span class="comment">// 将新元素结点插入至旧元素结点前面，所以现时新的头结点是新元素结点</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//不是插入至头部</span></span><br><span class="line">        <span class="comment">// 旧元素的前驱结点的后继指针指向新元素结点</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    <span class="comment">// 记录链表长度的size + 1</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>LinkedList 提供了四种删除元素的方法，分别是：</p>
<ol>
<li><p>删除链表中的第一个元素<code>removeFirst()</code>，只需将头结点<code>first</code>指向删除元素结点的后继结点并将其前驱结点指针信息<code>prev</code>清空即可。不需要移动原数据存储位置，只需操作相关结点的指针域信息即可。所以时间复杂度为 O(1)。</p>
</li>
<li><p>删除链表中的最后一个元素<code>removeLast()</code>，只需将尾结点<code>last</code>指向删除元素结点的前驱结点并将其后继结点指针信息<code>next</code>清空即可。不需要移动原数据存储位置，只需操作相关结点的指针域信息即可，所以时间复杂度也为 O(1)。</p>
</li>
<li><p>将指定位置 index 的元素删除<code>remove(int index)</code>，需要先根据位置 index 调用<code>node(index)</code>遍历链表获取该位置的原结点，然后将删除元素结点的前驱结点的 next 后继结点指针域指向删除元素结点的后继结点<code>node.prev.next = node.next</code>，删除元素结点的后继结点的 prev 前驱结点指针域指向删除元素结点的前驱结点即可<code>node.next.prev = node.prev</code>（此处可能有些绕，不太理解的同学自行学习一下双向链表的数据结构吧），不需要移动原数据存储位置，只需交换一下相关结点的指针域信息即可。所以时间复杂度也为 O(1)。</p>
</li>
<li><p>删除传入的 Object o 指定对象，比较对象是否一致通过<code>o.equals</code>方法比较<code>remove(Object o)</code>，和 3.的思路基本差不多，关键是比较对象是通过<code>o.equals</code>方法，记住这点即可。</p>
</li>
</ol>
<p>综上所述，LinkedList 删除元素的时间复杂度为 O(1)，单纯论删除元素，操作是非常高效的，特别是删除第一个结点或删除最后一个结点。但如果是通过索引 index 的方式或者 object 对象的方式删除，则需要对链表进行遍历查找对应 index 索引的对象或者利用 equals 方法判断对象。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除链表中的第一个元素并返回</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 链表中的第一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据头结点获取第一个元素结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>) <span class="comment">// 没有元素结点则抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除第一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="comment">// 记录要移除元素结点的数据域</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="comment">// 记录要移除元素结点的后继结点指针</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    <span class="comment">// 清空要删除结点的数据域和next指针域信息，以帮助垃圾回收</span></span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    <span class="comment">// 头结点指向要移除元素结点的后继结点</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="comment">// 如果要移除元素结点的后继结点为空，则证明链表只有一个元素</span></span><br><span class="line">    <span class="comment">// 所以需要将尾结点的指针信息也要清空</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 将新的第一个结点的前驱结点指针信息清空</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 记录链表长度的size - 1</span></span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 返回移除元素结点的数据域</span></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除链表中的最后一个元素并返回</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 链表中的最后一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据尾结点获取最后一个元素结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)<span class="comment">// 没有元素结点则抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除最后一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">    <span class="comment">// 记录要移除元素结点的数据域</span></span><br><span class="line">    <span class="keyword">final</span> E element = l.item;</span><br><span class="line">    <span class="comment">// 记录要移除元素结点的前驱结点指针</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    <span class="comment">// 清空要删除结点的数据域和prev指针域信息，以帮助垃圾回收</span></span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    <span class="comment">// 头结点指向要移除元素结点的前驱结点</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="comment">// 如果要移除元素结点的前驱结点为空，则证明链表只有一个元素</span></span><br><span class="line">    <span class="comment">// 所以需要将头结点的指针信息也要清空</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 将新的最后一个结点的后继结点指针信息清空</span></span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 记录链表长度的size - 1</span></span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 返回移除元素结点的数据域</span></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定位置index的元素删除</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 要删除的位置index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 要删除位置的原元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查index下标是否合法[0,size)</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// 根据index进行遍历链表获取要删除的结点，再调用unlink方法进行删除</span></span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除传入的Object o指定对象，比较对象是否一致通过o.equals方法比较</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 要删除的Object o指定对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 是否存在要删除对象o</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果删除对象为null，则遍历链表查找node.item数据域为null的结点并移除</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从头开始遍历链表，并通过equals方法逐一比较node.item是否相等</span></span><br><span class="line">        <span class="comment">// 相等则对象一致，删除此对象。</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除指定结点x</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="comment">// 记录要移除元素结点的数据域</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="comment">// 记录要移除元素结点的后继结点指针</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="comment">// 记录要移除元素结点的前驱结点指针</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果要移除元素结点的前驱结点为空，则证明要删除结点为第一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 头结点指向要删除元素结点的后继结点</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 要删除元素结点的前驱结点的后继指针指向要删除元素结点的后继结点</span></span><br><span class="line">        prev.next = next;</span><br><span class="line">        <span class="comment">// 清空要删除结点的前驱结点指针信息，以帮助GC</span></span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果要移除元素结点的后继结点为空，则证明要删除结点为最后一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 尾结点指向要删除元素结点的前驱结点</span></span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 要删除元素结点的后继结点的前驱指针指向要删除元素结点的前驱结点</span></span><br><span class="line">        next.prev = prev;</span><br><span class="line">        <span class="comment">// 清空要删除结点的后继结点指针信息，以帮助GC</span></span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空要删除元素的数据域，以帮助GC</span></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 记录链表长度的size - 1</span></span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 返回移除元素结点的数据域</span></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="那您可以比较一下-ArrayList-和-LinkedList-吗"><a href="#那您可以比较一下-ArrayList-和-LinkedList-吗" class="headerlink" title="那您可以比较一下 ArrayList 和 LinkedList 吗?"></a>那您可以比较一下 ArrayList 和 LinkedList 吗?</h1><h2 id="更占内存"><a href="#更占内存" class="headerlink" title="更占内存"></a>更占内存</h2><p>LinkedList 内部存储的是 Node<E>，不仅要维护数据域，还要维护 prev 和 next，如果 LinkedList 中的结点特别多，则 LinkedList 比 ArrayList 更占内存。</p>
<h2 id="插入删除效率高"><a href="#插入删除效率高" class="headerlink" title="插入删除效率高"></a>插入删除效率高</h2><p>LinkedList 在做插入和删除操作时，插入或删除头部或尾部时是高效的，操作越靠近中间位置的元素时，需要遍历查找，速度相对慢一些，如果在数据量较大时，每次插入或删除时遍历查找比较费时。所以 LinkedList 插入与删除，慢在遍历查找，快在只需要更改相关结点的引用地址。ArrayList 在做插入和删除操作时，插入或删除尾部时也一样是高效的，操作其他位置，则需要批量移动元素，所以 ArrayList 插入与删除，快在遍历查找，慢在需要批量移动元素。</p>
<h2 id="循环遍历效率低"><a href="#循环遍历效率低" class="headerlink" title="循环遍历效率低"></a>循环遍历效率低</h2><ul>
<li>由于 ArrayList 实现了 RandomAccess 随机访问接口，所以使用 for(int i = 0; i &lt; size; i++)遍历会比使用 Iterator 迭代器来遍历快：</li>
<li>而由于 LinkedList 未实现 RandomAccess 接口，所以推荐使用 Iterator 迭代器来遍历数据。</li>
<li>因此，如果我们需要频繁在列表的中部改变插入或删除元素时，建议使用 LinkedList，否则，建议使用 ArrayList，因为 ArrayList 遍历查找元素较快，并且只需存储元素的数据域，不需要额外记录其他数据的位置信息，可以节省内存空间。</li>
</ul>
<h1 id="LinkedList-是线程安全的吗？"><a href="#LinkedList-是线程安全的吗？" class="headerlink" title="LinkedList 是线程安全的吗？"></a>LinkedList 是线程安全的吗？</h1><p>LinkedList 不是线程安全的，如果多个线程同时对同一个 LinkedList 更改数据的话，会导致数据不一致或者数据污染。如果出现线程不安全的操作时，LinkedList 会尽可能的抛出<code>ConcurrentModificationException</code>防止数据异常，当我们在对一个 LinkedList 进行遍历时，在遍历期间，我们是不能对 LinkedList 进行添加，删除等更改数据结构的操作的，否则也会抛出<code>ConcurrentModificationException</code>异常，此为 fail-fast（快速失败）机制。从源码上分析，我们在 add,remove 等更改 LinkedList 数据时，都会导致 modCount 的改变，当<code>expectedModCount != modCount</code>时，则抛出<code>ConcurrentModificationException</code>。如果想要线程安全，可以考虑调用<code>Collections.synchronizedCollection(Collection&lt;T&gt; c)</code>方法。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>参考资料</p>
 
    </div>
    
    <div class="article-info article-info-index">
       
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JAVA%E5%AE%B9%E5%99%A8/">JAVA容器</a>
    </div>

 
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java%E5%AE%B9%E5%99%A8-LinkedList/" rel="tag">java容器 LinkedList</a></li></ul>
    </div>
 
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>
    

  
    <article
  id="post-JAVA容器——ArrayList"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
>
  
  <div class="article-meta">
    <a href="/2020/02/24/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ArrayList/" class="article-date">
      <time datetime="2020-02-24T07:44:53.000Z" itemprop="datePublished">2020-02-24</time>
</a>

 
    <a href="/2020/02/24/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ArrayList/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
        
            <span class="disqus-comment-count" data-disqus-identifier="2020/02/24/JAVA容器——ArrayList/"></span>
        
    </a>

  </div>
  
  <div class="article-inner">
    
    <input type="hidden" class="isFancy" />
     
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/24/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ArrayList/">JAVA容器——ArrayList</a>
    </h1>
  
 
    </header>
     
    <div class="article-entry" itemprop="articleBody">
        <h1 id="ArrayList-有用过吗？它是一个什么东西？可以用来干嘛？"><a href="#ArrayList-有用过吗？它是一个什么东西？可以用来干嘛？" class="headerlink" title="ArrayList 有用过吗？它是一个什么东西？可以用来干嘛？"></a>ArrayList 有用过吗？它是一个什么东西？可以用来干嘛？</h1><h2 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h2><p>ArrayList 就是数组列表，主要用来装载数据，当我们装载的是基本类型的数据 int，long，boolean，short，byte…的时候我们只能存储他们对应的包装类，它的主要底层实现是数组 Object[] elementData。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>ArrayList 底层是用数组实现的存储。</li>
<li>初始化容量为 10，扩容为 1.5 倍。</li>
<li>查询效率高，增删效率低，线程不安全。使用频率很高。</li>
</ul>
<h1 id="为啥线程不安全还使用他呢？"><a href="#为啥线程不安全还使用他呢？" class="headerlink" title="为啥线程不安全还使用他呢？"></a>为啥线程不安全还使用他呢？</h1><h2 id="用于查询较多"><a href="#用于查询较多" class="headerlink" title="用于查询较多"></a>用于查询较多</h2><p>因为我们正常使用的场景中，都是用来查询，不会涉及太频繁的增删，如果涉及频繁的增删，可以使用 LinkedList，如果你需要线程安全就使用 Vector，这就是三者的区别了，实际开发过程中还是 ArrayList 使用最多的。</p>
<h2 id="综合考虑安全和性能"><a href="#综合考虑安全和性能" class="headerlink" title="综合考虑安全和性能"></a>综合考虑安全和性能</h2><p>不存在一个集合工具是查询效率又高，增删效率也高的，还线程安全的，至于为啥大家看代码就知道了，因为数据结构的特性就是优劣共存的，想找个平衡点很难，牺牲了性能，那就安全，牺牲了安全那就快速。</p>
<h1 id="您说它的底层实现是数组，但是数组的大小是定长的，如果我们不断的往里面添加数据的话，不会有问题吗？"><a href="#您说它的底层实现是数组，但是数组的大小是定长的，如果我们不断的往里面添加数据的话，不会有问题吗？" class="headerlink" title="您说它的底层实现是数组，但是数组的大小是定长的，如果我们不断的往里面添加数据的话，不会有问题吗？"></a>您说它的底层实现是数组，但是数组的大小是定长的，如果我们不断的往里面添加数据的话，不会有问题吗？</h1><p>ArrayList 可以通过构造方法在初始化的时候指定底层数组的大小；</p>
<p>通过无参构造方法的方式 <code>ArrayList()</code> 初始化，则赋值底层数 <code>Object[] elementData</code> 为一个默认空数组 <code>Object[]DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}</code> 所以数组容量为 <code>0</code>，只有真正对数据进行添加 <code>add</code> 时，才分配默认 <code>DEFAULT_CAPACITY = 10</code> 的初始容量。</p>
<p>容量超过 <code>10</code> 时，会创建一个容量 <code>1.5</code> 倍的空数组，将原有数据拷贝过去。</p>
<h1 id="能具体说下-1-7-和-1-8-版本初始化的时候的区别么？"><a href="#能具体说下-1-7-和-1-8-版本初始化的时候的区别么？" class="headerlink" title="能具体说下 1.7 和 1.8 版本初始化的时候的区别么？"></a>能具体说下 1.7 和 1.8 版本初始化的时候的区别么？</h1><p>1.7 开始变化有点大，一个是初始化的时候，1.7 以前会调用 <code>this(10)</code> 才是真正的容量为 10，1.7 即本身以后是默认走了空数组，只有第一次 <code>add</code> 的时候容量会变成 10。</p>
<h1 id="我记得你说到了，他增删很慢，你能说一下-ArrayList-在增删的时候是怎么做的么？主要说一下他为啥慢。"><a href="#我记得你说到了，他增删很慢，你能说一下-ArrayList-在增删的时候是怎么做的么？主要说一下他为啥慢。" class="headerlink" title="我记得你说到了，他增删很慢，你能说一下 ArrayList 在增删的时候是怎么做的么？主要说一下他为啥慢。"></a>我记得你说到了，他增删很慢，你能说一下 ArrayList 在增删的时候是怎么做的么？主要说一下他为啥慢。</h1><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>他有指定 index 新增，也有直接新增的，在这之前他会有一步校验长度的判断 ensureCapacityInternal，就是说如果长度不够，是需要扩容的。</p>
<p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ArrayList_2020-02-24-15-55-53.png" alt="JAVA容器——ArrayList_2020-02-24-15-55-53.png"></p>
<p>在扩容的时候，老版本的 jdk 和 8 以后的版本是有区别的，8 之后的效率更高了，采用了位运算，右移一位，其实就是除以 2 这个操作。</p>
<p>1.7 的时候 3/2+1 ，1.8 直接就是 3/2。</p>
<p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ArrayList_2020-02-24-15-56-30.png" alt="JAVA容器——ArrayList_2020-02-24-15-56-30.png"></p>
<h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><p>指定位置新增的时候，在校验之后的操作很简单，就是数组的 copy，大家可以看下代码。</p>
<p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ArrayList_2020-02-24-16-04-27.png" alt="JAVA容器——ArrayList_2020-02-24-16-04-27.png"></p>
<p>不知道大家看懂 arraycopy 的代码没有，我画个图解释下，你可能就明白一点：</p>
<p>比如有下面这样一个数组我需要在 index 5 的位置去新增一个元素 A</p>
<p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ArrayList_2020-02-24-16-04-56.png" alt="JAVA容器——ArrayList_2020-02-24-16-04-56.png"></p>
<p>那从代码里面我们可以看到，他复制了一个数组，是从 index 5 的位置开始的，然后把它放在了 index 5+1 的位置</p>
<p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ArrayList_2020-02-24-16-05-25.png" alt="JAVA容器——ArrayList_2020-02-24-16-05-25.png"></p>
<p>给我们要新增的元素腾出了位置，然后在 index 的位置放入元素 A 就完成了新增的操作了</p>
<p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ArrayList_2020-02-24-16-05-52.png" alt="JAVA容器——ArrayList_2020-02-24-16-05-52.png"></p>
<p>至于为啥说他效率低，我想我不说你也应该知道了，我这只是在一个这么小的 List 里面操作，要是我去一个几百几千几万大小的 List 新增一个元素，那就需要后面所有的元素都复制，然后如果再涉及到扩容啥的就更慢了不是嘛。</p>
<h1 id="ArrayList-插入删除一定慢么？"><a href="#ArrayList-插入删除一定慢么？" class="headerlink" title="ArrayList 插入删除一定慢么？"></a>ArrayList 插入删除一定慢么？</h1><p>取决于你删除的元素离数组末端有多远，ArrayList 拿来作为堆栈来用还是挺合适的，push 和 pop 操作完全不涉及数据移动操作。</p>
<h1 id="那他的删除是怎么实现的那？"><a href="#那他的删除是怎么实现的那？" class="headerlink" title="那他的删除是怎么实现的那？"></a>那他的删除是怎么实现的那？</h1><p>删除其实跟新增是一样的，不过叫是叫删除，但是在代码里面我们发现，他还是在 copy 一个数组。</p>
<h1 id="ArrayList-的遍历和-LinkedList-遍历性能比较如何？"><a href="#ArrayList-的遍历和-LinkedList-遍历性能比较如何？" class="headerlink" title="ArrayList 的遍历和 LinkedList 遍历性能比较如何？"></a>ArrayList 的遍历和 LinkedList 遍历性能比较如何？</h1><p>论遍历 ArrayList 要比 LinkedList 快得多，ArrayList 遍历最大的优势在于内存的连续性，CPU 的内部缓存结构会缓存连续的内存片段，可以大幅降低读取内存的性能开销。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ArrayList 就是动态数组，用 MSDN 中的说法，就是 Array 的复杂版本，它提供了动态的增加和减少元素，实现了 ICollection 和 IList 接口，灵活的设置数组的大小等好处。</p>
 
    </div>
    
    <div class="article-info article-info-index">
       
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JAVA%E5%AE%B9%E5%99%A8/">JAVA容器</a>
    </div>

 
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java%E5%AE%B9%E5%99%A8-ArrayList/" rel="tag">java容器 ArrayList</a></li></ul>
    </div>
 
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>
    

  
    <article
  id="post-JAVA容器——概述"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
>
  
  <div class="article-meta">
    <a href="/2020/02/24/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/" class="article-date">
      <time datetime="2020-02-24T06:41:35.000Z" itemprop="datePublished">2020-02-24</time>
</a>

 
    <a href="/2020/02/24/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
        
            <span class="disqus-comment-count" data-disqus-identifier="2020/02/24/JAVA容器——概述/"></span>
        
    </a>

  </div>
  
  <div class="article-inner">
    
    <input type="hidden" class="isFancy" />
     
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/24/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/">JAVA容器——概述</a>
    </h1>
  
 
    </header>
     
    <div class="article-entry" itemprop="articleBody">
        <p>&lt;java 容器概述-容器的分类及简介 | 首页摘要&gt;</p>  
    </div>
    
    <div class="article-info article-info-index">
       
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/JAVA%E5%AE%B9%E5%99%A8/">JAVA容器</a>
    </div>

 
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java%E5%AE%B9%E5%99%A8-%E6%A6%82%E8%BF%B0/" rel="tag">java容器 概述</a></li></ul>
    </div>
 
      <p class="article-more-link">
        <a href="/2020/02/24/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/#more">more >></a>
      </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>
    

  
    <article
  id="post-数据结构与算法（九）——搜素"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
>
  
  <div class="article-meta">
    <a href="/2020/02/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A0/" class="article-date">
      <time datetime="2020-02-24T06:16:21.000Z" itemprop="datePublished">2020-02-24</time>
</a>

 
    <a href="/2020/02/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A0/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
        
            <span class="disqus-comment-count" data-disqus-identifier="2020/02/24/数据结构与算法（九）——搜素/"></span>
        
    </a>

  </div>
  
  <div class="article-inner">
    
    <input type="hidden" class="isFancy" />
     
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A0/">数据结构与算法（九）——搜素</a>
    </h1>
  
 
    </header>
     
    <div class="article-entry" itemprop="articleBody">
        <h1 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h1><p>顺序查找对序列本身没有要求（比如不需要是已经排序好的），也不仅限于数字、字符，也可以用于前缀，对象信息的关键信息的匹配（比如查找指定 id 的相应信息）。</p>
<p>衡量查找性能的一个指标是————ASL(Average Search Length)，ASL=Pi 乘 Ci，Pi 是查找第 i 个元素的概率，Ci 是找到第 i 个已经比较过次数。</p>
<p>哨兵方式的顺序查找相比较基础的顺序查找在循环的比较部分减少了一般。</p>
<h3 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 顺序查找</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequentialSearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SequentialSearch</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 哨兵方式顺序查找</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Search2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Search2</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(key == array[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = array[<span class="number">0</span>];</span><br><span class="line">        array[<span class="number">0</span>] = key;</span><br><span class="line">        <span class="keyword">int</span> index = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(array[index] != key) &#123;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        array[<span class="number">0</span>] = temp;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>如果是顺序查找，7 个数最多可能会比较 7 次，但用二分查找，最多只要 3 次就能 OK。</p>
<p>时间复杂度是 O（logn）(底数为 2)。</p>
<p>二分查找的优化————插值查找</p>
<p>如果数据范围是 1<del>100000,让你找 10,那么就不一定要从中间找起了。可以三分之一，四分之一处查找，比如 1</del>10，待查为 3，那可以从前面三分之一为划分点。对于要查找的位置有个精确的计算公式 P=low+（key-a[low])/(a[high]-a[low])*(high-low)</p>
<h1 id="java-实现-1"><a href="#java-实现-1" class="headerlink" title="java 实现"></a>java 实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 二分查找递归与非递归的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchRecursion</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  searchRecursion(target, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; array[mid]) &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">searchRecursion</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(array[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &lt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> searchRecursion(target, mid + <span class="number">1</span>, end);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> searchRecursion(target, start, mid -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 二分插入排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryInsertSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryInsertSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = array.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = array[i];</span><br><span class="line">            <span class="keyword">int</span> insertIndex = binarySearch(i - <span class="number">1</span>, temp);</span><br><span class="line">            <span class="keyword">if</span>(insertIndex != i) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; insertIndex; j--) &#123;</span><br><span class="line">                    array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                array[insertIndex] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.println(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> end, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">            mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid] &gt; target) &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果相等，也插入到后面</span></span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="杨氏矩阵的的查找"><a href="#杨氏矩阵的的查找" class="headerlink" title="杨氏矩阵的的查找"></a>杨氏矩阵的的查找</h1><p>杨氏矩阵就是行列递增的矩阵。</p>
<p>杨氏矩阵的操作</p>
<p>插入。插入一个数，需要移动其他元素<br>删除。给定 x,y 坐标，删除那个数，伴随其他元素移动，怎样移动操作最少？<br>查找 t 是否存在于矩阵中。这也是这篇博客里所要关注的。<br>返回第 k 大的数。涉及到堆查找，后续博客再细说。<br>关于查找 t 是否存在于矩阵，书中给了几种实现的方法：</p>
<p>递归实现和非递归实现</p>
<p>优化：<br>每次不都从每行的第一个数开始查找，左右上下进行比较然后查找。<br>分治法。杨氏矩阵行列是递增的，那么对角线也是递增的，可以利用对角线划分的区域来缩小要查找数的范围。（实现略）<br>定位查找法。先定位到第一行最右的数，然后只需要往下走，往左走两种操作即可，相比方法 2 省掉了往右走。</p>
<h3 id="java-实现-2"><a href="#java-实现-2" class="headerlink" title="java 实现"></a>java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YoungSearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">YoungSearch</span><span class="params">(<span class="keyword">int</span>[][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recursionSearch</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == array.length || y == array[<span class="number">0</span>].length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; array[x][y]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target == array[x][y]) &#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"x: %d, y: %d"</span>, x, y));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> recursionSearch(x + <span class="number">1</span>, y, target) || recursionSearch(x, y + <span class="number">1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array[<span class="number">0</span>].length &amp;&amp; target &gt;= array[i][j]; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(target == array[i][j]) &#123;</span><br><span class="line">                    System.out.println(String.format(<span class="string">"x: %d y: %d"</span>, i, j));</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.简单优化（向左/右/下走）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search2</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> width = array[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> height = array.length;</span><br><span class="line">        <span class="keyword">if</span>(target &gt;= array[<span class="number">0</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; width &amp;&amp; target &gt;= array[<span class="number">0</span>][i]; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(target == array[<span class="number">0</span>][i]) &#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">"x: %d, y: %d"</span>, <span class="number">0</span>, i));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; width - <span class="number">1</span>) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环向下查找</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; height; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(target == array[j][i]) &#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">"x: %d, y: %d"</span>, j, i));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; array[j][i]) &#123;</span><br><span class="line">                <span class="keyword">for</span>(; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(target == array[j][i]) &#123;</span><br><span class="line">                        System.out.println(String.format(<span class="string">"x: %d, y: %d"</span>, j, i));</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &gt; array[j][i]) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &gt; array[j][i]) &#123;</span><br><span class="line">                <span class="keyword">for</span>(; i &lt; width; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(target == array[j][i])&#123;</span><br><span class="line">                        System.out.println(String.format(<span class="string">"x: %d, y: %d"</span>, j, i));</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; array[j][i]) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; width - <span class="number">1</span>) &#123;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.进一步优化（从第一行最右边的数开始，只需要向下和向左两个操作）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search3</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = array[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = array[i][j];</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(target == temp) &#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">"x: %d, y: %d"</span>, i, j));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">0</span> &amp;&amp; target &lt; temp)&#123;</span><br><span class="line">                temp = array[i][--j];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i &lt; array.length - <span class="number">1</span> &amp;&amp; target &gt; temp) &#123;</span><br><span class="line">                temp = array[++i][j];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h1><p>对于待查找的数据列表来说，如果元素变动很少，那么可以先进行排序再查找。但如果这个数据经常需要添加元素，那么每次查找前都需要排序，这并不是一个好的选择。</p>
<p>就有了分块查找，这个概念再学数据库的时候听过。分块查找里有索引表和分块这两个概念。索引表就是帮助分块查找的一个分块依据，就是一个数组，用来存储每块最大的存储值（范围上限）；分块就是通过索引表把数据分为几块。</p>
<p>原理</p>
<p>当需要增加一个元素的时候，先根据索引表，获取这个元素应该在那一块，然后直接把元素加入到相应的块里，而块内的元素直接不需要有序。</p>
<p>从上面可知，分块查找只需要索引表有序，每一个块里的元素可以是无序的，但第 i 块的每个元素一定比第 i-1 块的每一个元素大（小）。当索引表很大的时候，可以对索引表进行二分查找，锁定块的位置，然后对块内的元素进行顺序查找。总性能不如二分查找，但强过顺序查找，更好的是不需要数列完全有序。<br>举个例子，比如索引表为【10，20，30】,分块一【2，1，4，2】分块二【19，15，18，】分块三【22，27，23】，现在要增加 22 这个数，直接根据索引表把 22 放到分块三最后就行了【22,27,23,22】。</p>
<p>可以看出，分块查找同时有顺序查找和二分查找的有点————不需要有序、速度快。</p>
<p>应用场景<br>视频网站对用户观看行为记录，每个用户分别观看了一个视频多久，如果对每条这样的记录都放到一个表里，那太多了，可以根据具体业务做分表，一天一个表，表名如 t_user_watch_xxx_20180806，存储查询的时候就可以根据时间去做一个表的分块，在查询详细的记录。</p>
<h3 id="java-实现-3"><a href="#java-实现-3" class="headerlink" title="java 实现"></a>java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分块查找</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockSearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] index;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlockSearch</span><span class="params">(<span class="keyword">int</span>[] index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index.length; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = binarySearch(value);</span><br><span class="line">        list.get(i).add(value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = binarySearch(data);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; list.get(i).size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(data == list.get(i).get(j)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; l = list.get(i);</span><br><span class="line">            System.out.println(<span class="string">"ArrayList: "</span> + i +  <span class="string">":"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; l.size(); j++) &#123;</span><br><span class="line">                System.out.println(l.get(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = index.length - <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">int</span> mid = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">            mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target == index[mid]) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; index[mid]) &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 
    </div>
    
    <div class="article-info article-info-index">
       
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
    </div>

 
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95-%E6%90%9C%E7%B4%A0/" rel="tag">算法 搜素</a></li></ul>
    </div>
 
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>
    

  
    <article
  id="post-数据结构与算法（八）——排序算法"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
>
  
  <div class="article-meta">
    <a href="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="article-date">
      <time datetime="2020-02-20T08:41:54.000Z" itemprop="datePublished">2020-02-20</time>
</a>

 
    <a href="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
        
            <span class="disqus-comment-count" data-disqus-identifier="2020/02/20/数据结构与算法（八）——排序算法/"></span>
        
    </a>

  </div>
  
  <div class="article-inner">
    
    <input type="hidden" class="isFancy" />
     
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">数据结构与算法（八）——排序算法</a>
    </h1>
  
 
    </header>
     
    <div class="article-entry" itemprop="articleBody">
        <h1 id="常见的排序算法总结"><a href="#常见的排序算法总结" class="headerlink" title="常见的排序算法总结"></a>常见的排序算法总结</h1><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95_2020-02-20-16-44-05.png" alt="数据结构与算法（八）——排序算法_2020-02-20-16-44-05.png"></p>
<h1 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h1><p>因为待排序的记录序列中可能存在两个或两个以上的关键字相等的记录， 排序结果可能会存在不唯一的情况。所以就有稳定与不稳定的定义。</p>
<p>假设 ki=kj( 1 =&lt; i &lt;= n,1 =&lt; j &lt;= n, i != j)，且在排序前的序列中 ri 领先于 rj。如果排序后 ri 仍领先于 rj，则称所用的排序方法是稳定的；反之，若可能使得排序后的序列中 rj 领先于 ri，则称所用的排序方法是不稳定的。只要有一组关键字发生类似情况，就可认为此排序方法是不稳定的。</p>
<h1 id="内排序和外排序"><a href="#内排序和外排序" class="headerlink" title="内排序和外排序"></a>内排序和外排序</h1><p>根据在排序过程中待排序记录是否全部放在内存中，排序分为内排序和外排序。</p>
<ul>
<li>内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。</li>
<li>外排序是由于排序的记录个数太多，不能同时放置在内存中，整个排序过程需要在内外存之间多次交换数据才能进行。</li>
</ul>
<p>内排序，排序算法的性能主要有 3 个影响因素：</p>
<ul>
<li>时间性能<br>排序算法的时间开销是衡量其好坏的最重要的标志。<br>在内排序中，主要进行两种操作：比较和移动。<br>高效率的内排序算法应该具有尽可能少的关键字比较次数和尽可能少的记录移动次数。</li>
<li>辅助空间<br>评估算法的另一个主要标准是执行算法所需要的辅助存储空间。<br>辅助存储空间是除了存放待排序所占用的存储空间外，执行算法所需要的其他存储空间。</li>
<li>算法的复杂性<br>指算法本身的复杂性，过于复杂的算法也会影响排序的性能。</li>
</ul>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p><strong>两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。</strong></p>
<h3 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h3><ul>
<li>最好：仅需要 n - 1 次比较，时间复杂度为 O(n)；</li>
<li>最坏：需要 n(n - 1)/2 次比较和交换；</li>
<li>平均：复杂度为 O(n2)。</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 最简单交换排序，非冒泡排序,比较的不是相邻关键字，但便于理解</span></span><br><span class="line">   <span class="comment">// 比较次数n(n + 1)/2，交换次数会很多，仔细分析下，会把小的数字放到最后去，而冒泡则不会，原因就是比较的是相邻关键字</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">simpleSwapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array.length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = array.length; i &lt; size; ++i) &#123;</span><br><span class="line">           <span class="comment">//for (int j = 0; j &lt; size; j++) &#123; //这种效率更低 n^2</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; size; ++j) &#123;</span><br><span class="line">               <span class="keyword">if</span> (array[j] &lt; array[i]) &#123;</span><br><span class="line">                   CommonUtil.swap(array, i, j);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 正宗的冒泡排序，从最底下开始冒泡，两两比较,每次都将小的往上冒一点</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array.length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, size = array.length; i &lt; size; ++i) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = size - <span class="number">1</span>; j &gt;= i; --j) &#123;</span><br><span class="line">               <span class="keyword">if</span> (array[j] &lt; array[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                   CommonUtil.swap(array, j, j - <span class="number">1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//CommonUtil.printArray(array);</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 冒泡排序优化，如果经过一轮发现已经是有序的，就不再进行排序</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSortBetter</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array.length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, size = array.length; i &lt; size &amp;&amp; flag; ++i) &#123;</span><br><span class="line">           flag = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = size - <span class="number">1</span>; j &gt;= i; --j) &#123;<span class="comment">//经过一轮循环，发现两两已经是有序的了，就置为false</span></span><br><span class="line">               <span class="keyword">if</span> (array[j] &lt; array[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                   CommonUtil.swap(array, j, j - <span class="number">1</span>);</span><br><span class="line">                   flag = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//CommonUtil.printArray(array);</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h1><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>每一次遍历时选取关键字最小的记录作为有序序列的第 i 个记录。</p>
<h3 id="算法复杂度分析-1"><a href="#算法复杂度分析-1" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h3><ul>
<li>最好最差的情况，都要进行 n(n-1)/2 次比较；在最好的情况下，不需要进行交换，在最坏的情况下，进行 n-1 次交换。</li>
<li>平均：复杂度为 O(n2)。</li>
</ul>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleSelectionSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">simpleSelectionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array.length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = array.length; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; size; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &lt; array[minIndex]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">                CommonUtil.swap(array, i, minIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><h3 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h3><p>将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录递增 1 的有序表。插入排序是进行值移动，而非值交换。所以在量较小的情况下插入排序性能要优于冒泡和简单选择排序。</p>
<h3 id="算法复杂度分析-2"><a href="#算法复杂度分析-2" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h3><ul>
<li>最好，只需进行比较 n - 1 次，无需进行移动；</li>
<li>最坏的情况下，比较(n + 2)(n - 1)/2 次，交换(n + 4)(n - 1)/2 次。</li>
<li>平均：复杂度 O(n2)</li>
</ul>
<h3 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StraightInsertionSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//for循环</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">straightInsertionSort2</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array.length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j, temp, size = array.length; i &lt; size; ++i) &#123;</span><br><span class="line">            temp = array[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; temp; --j) &#123;</span><br><span class="line">                array[j + <span class="number">1</span>] = array[j];<span class="comment">//移动而非交换</span></span><br><span class="line">            &#125;</span><br><span class="line">            array[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a>二分插入排序</h1><h3 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h3><p>二分（折半）插入排序是一种在直接插入排序算法上进行小改动的排序算法。其与直接排序算法最大的区别在于查找插入位置时使用的是二分查找的方式，在速度上有一定提升。</p>
<h3 id="算法复杂度分析-3"><a href="#算法复杂度分析-3" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h3><p>插入每个记录需要 O(log i)比较，最多移动 i+1 次，最少 2 次。</p>
<ul>
<li>最佳： O(n log n)，</li>
<li>最差：O(n^2)</li>
<li>平均: O(n^2)。</li>
<li></li>
</ul>
<p>总排序码比较次数比直接插入排序的最差情况好得多，但比最好情况要差，所元素初始序列已经按排序码接近有序时，直接插入排序比二分插入排序比较次数少</p>
<h3 id="java-实现-1"><a href="#java-实现-1" class="headerlink" title="java 实现"></a>java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryInsertionSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binaryInsertionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array.length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp, left, right, middle;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, size = array.length; i &lt; size; i++) &#123;</span><br><span class="line">            temp = array[i];</span><br><span class="line">            left = <span class="number">0</span>;</span><br><span class="line">            right = i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//寻找合适的位置</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">                middle = (left + right) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (array[middle] &gt; temp) &#123;</span><br><span class="line">                    right = middle - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = middle + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= left; j--) &#123;</span><br><span class="line">                array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            array[left] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h3 id="基本思想-4"><a href="#基本思想-4" class="headerlink" title="基本思想"></a>基本思想</h3><ol>
<li><p>对一个未排序序列，假设从该序列中的元素中取一个基准值 pivotkey，将小于 pivotkey 放左边，大于 pivotkey 放右边；</p>
</li>
<li><p>接着以该 k 为中间，左右两边的分割作为新的序列，重新进行 1 操作。 快排因为用到了递归操作，所以在简单排序中性能不如直接插入排序， 而在大量数据排序时，递归产生的性能影响对于算法的整体性能优势可以忽略。</p>
</li>
</ol>
<h3 id="算法复杂度分析-4"><a href="#算法复杂度分析-4" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h3><ul>
<li>最坏：待排序为正序或逆序，这样每次分割后的子序列一个之比上一次序列少一个元素，一个为空。如 1 2 3 4 5 pivotkey=1;分割后一个序列为 2 3 4 5 一个为空，最终 O(n^2)</li>
<li>最好：每一次分割都能平分，很均匀 O(nlogn)</li>
<li>平均：O(n*logn) 数学归纳法</li>
</ul>
<h3 id="java-实现-2"><a href="#java-实现-2" class="headerlink" title="java 实现"></a>java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuickSortWhile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_LIMIT = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array.length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        quick_sort_recursive(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick_sort_recursive</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= MAX_LIMIT) &#123;</span><br><span class="line">            <span class="comment">// 到达一定程度的小数组时使用插入排序</span></span><br><span class="line">            insertSort(arr, start, end);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123; <span class="comment">//尾递归优化</span></span><br><span class="line">            <span class="keyword">int</span> pivot = partition(arr, start, end);</span><br><span class="line"></span><br><span class="line">            quick_sort_recursive(arr, start, pivot - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            start = pivot + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       分区操作：将arr[end]作为中轴，比它小的放在前面，比它大的放在后面</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivotKey = arr[end];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = start, right = end - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (arr[left] &lt;= pivotKey &amp;&amp; left &lt; right) left++;</span><br><span class="line">            <span class="keyword">while</span> (arr[right] &gt;= pivotKey &amp;&amp; left &lt; right) right--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                CommonUtil.swap(arr, left, right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr[left] &gt;= pivotKey) &#123;</span><br><span class="line">            CommonUtil.swap(arr, left, end);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入排序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>, j, temp; i &lt;= end; ++i) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            j = i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= start &amp;&amp; arr[j] &gt; temp) &#123;</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li>
</ul>
<h3 id="基本思想-5"><a href="#基本思想-5" class="headerlink" title="基本思想"></a>基本思想</h3><p>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。</p>
<p>假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为 O(n2)的排序（冒泡排序或插入排序），可能会进行 n 次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。</p>
<p>一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用 i += step_size 而不是 i++ ）。</p>
<p>例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为 5 开始进行排序，我们可以通过将这列表放在有 5 列的表中来更好地描述算法，这样他们就应该看起来是这样：</p>
<p>13 14 94 33 82<br>25 59 94 65 23<br>45 27 73 25 39<br>10</p>
<p>然后我们对每列进行排序：</p>
<pre><code>10 14 73 25 23
13 27 94 33 39
25 59 94 65 82
45</code></pre><p>将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时 10 已经移至正确位置了，然后再以 3 为步长进行排序：</p>
<pre><code>10 14 73
25 23 13
27 94 33
39 25 59
94 65 82
45</code></pre><p>排序之后变为：</p>
<pre><code>10 14 13
25 23 33
27 25 59
39 65 73
45 94 82
94</code></pre><p>最后以 1 步长进行排序（此时就是简单的插入排序了）。</p>
<h3 id="步长选择及复杂度"><a href="#步长选择及复杂度" class="headerlink" title="步长选择及复杂度"></a>步长选择及复杂度</h3><p>步长的选择是希尔排序的重要部分。只要最终步长为 1 任何步长序列都可以工作。<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95_2020-02-23-23-05-25.png" alt="数据结构与算法（八）——排序算法_2020-02-23-23-05-25.png"></p>
<ul>
<li><p>最优时间复杂度<br>O(n)</p>
</li>
<li><p>不稳定</p>
</li>
</ul>
<h3 id="java-实现-3"><a href="#java-实现-3" class="headerlink" title="java 实现"></a>java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellsort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = a.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> d=n/<span class="number">2</span>;d&gt;<span class="number">0</span>;d/=<span class="number">2</span>) &#123;<span class="comment">/* 希尔增量序列 */</span></span><br><span class="line">            <span class="comment">/* 插入排序 */</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> p=d;p&lt;n;p++) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[p];</span><br><span class="line">                <span class="keyword">for</span>(j=p;j&gt;=d &amp;&amp; a[j-<span class="number">1</span>] &gt; temp;j=j-d)</span><br><span class="line">                    a[j] = a[j-d];</span><br><span class="line">                a[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><pre><code>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</code></pre><h3 id="基本思想-6"><a href="#基本思想-6" class="headerlink" title="基本思想"></a>基本思想</h3><p>归并过程</p>
<pre><code>比较a[i]和b[j]的大小，若a[i]≤b[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素b[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。</code></pre><p>原理</p>
<p>第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</p>
<pre><code>第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置

第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置

重复步骤3直到某一指针超出序列尾

将另一序列剩下的所有元素直接复制到合并序列尾</code></pre><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>上述我们讲了归并排序的原理，将两个有序数组进行归并排序，但现实中可能不会给我们从上面的演算我们就直到，归并排序的前提是需要两个已经排好顺序的数组，那往往不会有两个已经排好顺序的数组给我们的呀<strong>(一般是杂乱无章的一个数组)</strong>，那这个算法是不是很鸡肋的呢？？</p>
<p>其实并不是的，首先假设题目给出的数组是这样子的：int[] arr = {2, 7, 8, 1, 4, 9};<br>当我们要做归并的时候就以 arr[3]也就元素为 1 的那个地方分开。是然后用一个指针 L 指向 arr[0]，一个指针 M 指向 arr[3]，用一个指针 R 指向 arr<a href="数组最后一位">5</a>。有了指针的帮助，我们就可以将这个数组切割成是两个有序的数组了（操作的方式就可以和上面一样了）<br>可是上面说了，一般给出的是杂乱无章的一个数组，现在还是达不到要求。比如给出的是这样一个数组：int[] arrays = {9, 2, 5, 1, 3, 2, 9, 5, 2, 1, 8};<br>此时，我们就得用到分治的思想了：</p>
<p>那么我们也可以这样想将 int[] arr = {2, 7, 8, 1, 4, 9};数组分隔成一份一份的，arr[0]它是一个有序的”数组”,arr[1]它也是一个有序的”数组”,利用指针(L,M,R)又可以像操作两个数组一样进行排序。最终合成{2,7}…….再不断拆分合并，最后又回到了我们的 arr = {1,2,4,7,8,9}，因此归并排序是可以排序杂乱无章的数组的</p>
<p>这就是我们的分治法—&gt;将一个大问题分成很多个小问题进行解决，最后重新组合起来</p>
<h3 id="算法复杂度分析-5"><a href="#算法复杂度分析-5" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h3><p>归并排序的时间复杂度为 O(nlogn)</p>
<h3 id="java-实现-4"><a href="#java-实现-4" class="headerlink" title="java 实现"></a>java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arrays = &#123;<span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    mergeSort(arrays, <span class="number">0</span>, arrays.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"公众号：Java3y"</span> + arrays);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arrays</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> L      指向数组第一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> R      指向数组最后一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arrays, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果只有一个元素，那就不用排序了</span></span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取中间的数，进行拆分</span></span><br><span class="line">        <span class="keyword">int</span> M = (L + R) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左边的数不断进行拆分</span></span><br><span class="line">        mergeSort(arrays, L, M);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右边的数不断进行拆分</span></span><br><span class="line">        mergeSort(arrays, M + <span class="number">1</span>, R);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//合并</span></span><br><span class="line">        merge(arrays, L, M + <span class="number">1</span>, R);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arrays</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> L      指向数组第一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> M      指向数组分隔的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> R      指向数组最后的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arrays, <span class="keyword">int</span> L, <span class="keyword">int</span> M, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左边的数组的大小</span></span><br><span class="line">    <span class="keyword">int</span>[] leftArray = <span class="keyword">new</span> <span class="keyword">int</span>[M - L];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//右边的数组大小</span></span><br><span class="line">    <span class="keyword">int</span>[] rightArray = <span class="keyword">new</span> <span class="keyword">int</span>[R - M + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//往这两个数组填充数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt; M; i++) &#123;</span><br><span class="line">        leftArray[i - L] = arrays[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = M; i &lt;= R; i++) &#123;</span><br><span class="line">        rightArray[i - M] = arrays[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// arrays数组的第一个元素</span></span><br><span class="line">    <span class="keyword">int</span>  k = L;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//比较这两个数组的值，哪个小，就往数组上放</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; leftArray.length &amp;&amp; j &lt; rightArray.length) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//谁比较小，谁将元素放入大数组中,移动指针，继续比较下一个</span></span><br><span class="line">        <span class="keyword">if</span> (leftArray[i] &lt; rightArray[j]) &#123;</span><br><span class="line">            arrays[k] = leftArray[i];</span><br><span class="line"></span><br><span class="line">            i++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arrays[k] = rightArray[j];</span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果左边的数组还没比较完，右边的数都已经完了，那么将左边的数抄到大数组中(剩下的都是大数字)</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; leftArray.length) &#123;</span><br><span class="line">        arrays[k] = leftArray[i];</span><br><span class="line"></span><br><span class="line">        i++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果右边的数组还没比较完，左边的数都已经完了，那么将右边的数抄到大数组中(剩下的都是大数字)</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; rightArray.length) &#123;</span><br><span class="line">        arrays[k] = rightArray[j];</span><br><span class="line"></span><br><span class="line">        k++;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结及参考资料"><a href="#总结及参考资料" class="headerlink" title="总结及参考资料"></a>总结及参考资料</h3><p>除了以上常见的排序算法，还有堆排序、桶排序、基数排序、计数排序等。<br>常见的排序算法</p>
 
    </div>
    
    <div class="article-info article-info-index">
       
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
    </div>

 
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/" rel="tag">算法 排序</a></li></ul>
    </div>
 
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>
    

  
    <article
  id="post-数据结构与算法（七）——堆、哈希表、图"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
>
  
  <div class="article-meta">
    <a href="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E5%A0%86%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E3%80%81%E5%9B%BE/" class="article-date">
      <time datetime="2020-02-20T08:30:50.000Z" itemprop="datePublished">2020-02-20</time>
</a>

 
    <a href="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E5%A0%86%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E3%80%81%E5%9B%BE/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
        
            <span class="disqus-comment-count" data-disqus-identifier="2020/02/20/数据结构与算法（七）——堆、哈希表、图/"></span>
        
    </a>

  </div>
  
  <div class="article-inner">
    
    <input type="hidden" class="isFancy" />
     
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E5%A0%86%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E3%80%81%E5%9B%BE/">数据结构与算法（七）——堆、哈希表、图</a>
    </h1>
  
 
    </header>
     
    <div class="article-entry" itemprop="articleBody">
        <h1 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h1><ul>
<li>堆(也被称为优先队列(队列+排序规则)，图一最大堆，图二最小堆)</li>
<li>堆是一种特殊的基于树的满足某些特性的数据结构，整个堆中的所有父子节点的键值都会满足相同的排序条件。堆更准确地可以分为最大堆与最小堆，在最大堆中，父节点的键值永远大于或者等于子节点的值，并且整个堆中的最大值存储于根节点；而最小堆中，父节点的键值永远小于或者等于其子节点的键值，并且整个堆中的最小值存储于根节点。</li>
</ul>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度:"></a>时间复杂度:</h3><ul>
<li>访问最大值 / 最小值: O(1)</li>
<li>插入: O(log(n))</li>
<li>移除最大值 / 最小值: O(log(n))</li>
</ul>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E5%A0%86%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E3%80%81%E5%9B%BE_2020-02-20-16-33-06.png" alt="数据结构与算法（七）——堆、哈希表、图_2020-02-20-16-33-06.png"></p>
<h1 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h1><ul>
<li>哈希能够将任意长度的数据映射到固定长度的数据。哈希函数返回的即是哈希值，如果两个不同的键得到相同的哈希值，即将这种现象称为碰撞。</li>
<li>Hash Map: Hash Map 是一种能够建立起键与值之间关系的数据结构，Hash Map 能够使用哈希函数将键转化为桶或者槽中的下标，从而优化对于目标值的搜索速度。</li>
</ul>
<h3 id="碰撞解决"><a href="#碰撞解决" class="headerlink" title="碰撞解决"></a>碰撞解决</h3><ul>
<li>链地址法（Separate Chaining）: 链地址法中，每个桶是相互独立的，包含了一系列索引的列表。搜索操作的时间复杂度即是搜索桶的时间（固定时间）与遍历列表的时间之和。</li>
<li>开地址法（Open Addressing）: 在开地址法中，当插入新值时，会判断该值对应的哈希桶是否存在，如果存在则根据某种算法依次选择下一个可能的位置，直到找到一个尚未被占用的地址。所谓开地址法也是指某个元素的位置并不永远由其哈希值决定。</li>
</ul>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E5%A0%86%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E3%80%81%E5%9B%BE_2020-02-20-16-35-27.png" alt="数据结构与算法（七）——堆、哈希表、图_2020-02-20-16-35-27.png"></p>
<h1 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h1><ul>
<li>图是一种数据元素间为多对多关系的数据结构，加上一组基本操作构成的抽象数据类型。<ul>
<li>无向图（Undirected Graph）: 无向图具有对称的邻接矩阵，因此如果存在某条从节点 u 到节点 v 的边，反之从 v 到 u 的边也存在。</li>
<li>有向图（Directed Graph）: 有向图的邻接矩阵是非对称的，即如果存在从 u 到 v 的边并不意味着一定存在从 v 到 u 的边。</li>
</ul>
</li>
</ul>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E5%A0%86%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E3%80%81%E5%9B%BE_2020-02-20-16-37-36.png" alt="数据结构与算法（七）——堆、哈希表、图_2020-02-20-16-37-36.png"></p>
 
    </div>
    
    <div class="article-info article-info-index">
       
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
    </div>

 
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E3%80%81%E5%9B%BE/" rel="tag">数据结构 堆、哈希表、图</a></li></ul>
    </div>
 
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>
    

  
    <article
  id="post-数据结构与算法（六）——树"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
>
  
  <div class="article-meta">
    <a href="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91/" class="article-date">
      <time datetime="2020-02-20T06:13:18.000Z" itemprop="datePublished">2020-02-20</time>
</a>

 
    <a href="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
        
            <span class="disqus-comment-count" data-disqus-identifier="2020/02/20/数据结构与算法（六）——树/"></span>
        
    </a>

  </div>
  
  <div class="article-inner">
    
    <input type="hidden" class="isFancy" />
     
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91/">数据结构与算法（六）——树</a>
    </h1>
  
 
    </header>
     
    <div class="article-entry" itemprop="articleBody">
        <h1 id="树的介绍"><a href="#树的介绍" class="headerlink" title="树的介绍"></a>树的介绍</h1><p>首先它是一种非线性的数据结构，将它命名为“树”是因为它看起来像一颗倒挂的树，根朝上，页朝下。</p>
<p>当然计算机的树模型，是由现实中的树抽象来的，它指的是 N 个有父子关系的节点的有限集合。对于这个有限的节点集合而言，它满足如下条件：</p>
<ul>
<li>当 N=0 时，改节点集合为空，这课树也被称为空树</li>
<li>在任意的非空树中，有且仅有一个根(root)节点</li>
<li>当 N&gt;1 时，除根节点以外的其余节点可分为 M 个互为相交的有限集合 T1,T2,…,Tm，其中的每个集合本身又是一棵树，并称其为根的子树（subtree）。</li>
</ul>
<h1 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h1><ul>
<li>节点：树的最基本组成单元，通常包括一个数据元素及若干指针用于指向其他节点。</li>
<li>节点的度：节点拥有的子树的个数被称为节点的度（degree）</li>
<li>树的度：树中所有节点的度的最大值就是该树的度</li>
<li>叶子节点：度为 0 的节点被称为叶子节点或终端节点</li>
<li>分支节点：度不为 0 的节点被称为分支节点或非终端节点</li>
<li>子节点,父节点，兄弟节点：节点的子树的根被称为该节点的子节点，而该节点称为子节点的父节点(parent).具有相同父节点的子节点之间互称为兄弟节点。</li>
<li>节点的层次(level):节点的层次从根开始算起，根的层次值为 1，其余节点的层次值为父节点层次值加 l。</li>
<li>树的深度(depth):树中节点的最大层次值称为树的深度或高度。</li>
<li>有序树与无序树:如果将树中节点的各棵子树看成从左到右是有序的(即不能互换),则称该树为有序树,否则称为无序树。</li>
<li>祖先节点(ancestor)：从根到该节点所经分支上的所有节点</li>
<li>后代节点(descendant):以某节点为根的子树中任一节点都称为该节点的后代节点。</li>
<li>森林(forest):森林是两颗或两颗以上互不相交的树的集合，删去一棵树的根，就得到一个森林。</li>
</ul>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉树指的是每个节点最多只能有两个子树的有序树。通常左边的子树被称作“左子树”(left subtree)，右边的子树被称为“右子树”(right subtree).由此可见，二叉树依然是树，它是一种特殊的树。</p>
<h3 id="树与二叉树的区别"><a href="#树与二叉树的区别" class="headerlink" title="树与二叉树的区别"></a>树与二叉树的区别</h3><ul>
<li>树中节点的最大度数没有限制，而二叉树节点的最大度数为 2，也就是说，二叉树是节点的最大度数为 2 的树。</li>
<li>无序树的节点无左右之分，而二叉树的节点有左，右之分，也就是说，二叉树是有序树。</li>
</ul>
<h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>一棵深度为 k 的二叉树，如果它包含了 2^k-1 个节点，就把这棵二叉树称为满二叉树。满二叉树的特点是。每一层上的节点数都是最大节点数，即各层节点数分别为 1,2,4,8, 16,…,满二叉树下图所示：<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91_2020-02-20-14-59-36.png" alt="数据结构与算法（六）——树_2020-02-20-14-59-36.png"></p>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>如果一颗二叉树除最后一层外，其余层的所有节点都是满的，并且最后一层或者是满的，或者仅在右边缺少若干连续的节点，则此二叉树就是完全二叉树。</p>
<h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p>哈夫曼树又被称为最优二叉树，是一种带权路径最短的二叉树。哈夫曼树是二叉树的一种应用，在信息检索中很常用.</p>
<p>对于哈夫曼树，有一个很重要的定理:对于具有对 n 个叶子节点的哈夫曼树，一共需要 2 乘以 n-1 个节点。因为对于二叉树来说，有三种类型节点，即度数为 2 的节点、度数为 1 的节点和度数为 0 的叶子节点，而哈夫曼树的非叶子节点都是由两个节点合并产生的，所以不会出现度 数为 1 的节点。而生成的非叶子节点的个数为叶子节点个数-1 因此 n 个叶子节点的哈夫曼树，一共需要 Z 乘以 n-1 个节点。</p>
<h3 id="二叉树的特点"><a href="#二叉树的特点" class="headerlink" title="二叉树的特点"></a>二叉树的特点</h3><ul>
<li>二叉树第 i 层上的节点数据至多为 2 的 i-1 次方</li>
<li>深度为 k 的二叉树至多有 2 的 k 次方-1 个节点.满二叉树的每层节点的数量依次为 1, 2, 4,8,…,因此深度为 k 的满二叉树包含的节点数为公比为 2 的等比数列的前 k 项总和，即 2 的 k 次方一 1。</li>
<li>在任何一棵二叉树中，如果其叶子节点的数量为 n0,度为 2 的子节点数量为 n2，则 n0=n2 + 1。这是因为:如果为任意叶子节点增加一个子节点，则原有叶子节点变成非叶子节点，新增节点变成叶子节点，上述等式不变;如果为任意叶子节点增加两个子节点，则原有叶子节点变成度为 2 的非叶子 lto 点，新增的两个节点变成叶子节点，上述等式依然不变。</li>
<li>具有 n 个节点的完全二叉树的深度为 log2(n+1)</li>
</ul>
<h3 id="二叉树的储存"><a href="#二叉树的储存" class="headerlink" title="二叉树的储存"></a>二叉树的储存</h3><ul>
<li>顺序存储:采用数组来记录二叉树的所有节点。（可能会造成空间浪费）</li>
<li>二叉链表存储:每个节点保留一个 left,right 域，分别指向其左、右子节点。</li>
<li>三叉链表存储:每个节点保留一个 left, right,parent 域，分别指向其左、右子节点和父节点。</li>
</ul>
<h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><p>遍历二叉树指的是按某种规律依次访问二叉树的每个节点，对二叉树的遍历过程就是将非线性结构的二叉树的节点排列成线性序列的过程。<br>如果采用顺序结构来保存二叉树，程序遍历二叉树非常容易，无须进行任何思考，直接遍历底层数组即可。如果采用链表来保存二叉树的节点，则有以下两种遍历方式。</p>
<ul>
<li>深度优先遍历：这种遍历算法将先访问到树中最深层次的节点<ul>
<li>先序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
</ul>
</li>
<li>广度优先遍历：这种遍历算法将逐层访问每层的节点，先访问根（第一层）节点，然后访问第二层的节点…..一次类推。因此，广度优先遍历方法又被称为按层遍历。</li>
</ul>
<h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>先序遍历指先处理根节点，其处理顺序如下：</p>
<ol>
<li>访问根节点</li>
<li>递归遍历左子树</li>
<li>递归遍历右子树</li>
</ol>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>中序遍历指其次处理根节点.其处理顺序如下。</p>
<ol>
<li>递归遍历左子树</li>
<li>访问根节点</li>
<li>递归遍历右子树</li>
</ol>
<h4 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h4><p>后序遍历指最后处理根节点，其处理顺序如下。</p>
<ol>
<li>递归遍历左子树</li>
<li>递归遍历右子树</li>
<li>访问根节点</li>
</ol>
<h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><p>广度优先遍历又称为按层遍历，整个遍历算法是先遍历几叉树的第一层(根节点)，再遍历根节点的两个子’节点(第二层)……依此类推，逐层遍历二叉树的所有节点。</p>
<p>为了实现广度优先遍历，可以借助于具有 FIFO 特征的队列来实现。如下所示。</p>
<ul>
<li>建一个队列(先进先出)，把树的根节点压入队列。</li>
<li>从队列中弹出一个节点(第一个弹出的就是根节点)，然后把改节点的左，右节点压入队列，如果没有子节点，则说明已经达到叶子节点了。</li>
<li>用循环重复执行 2 步，知道队列为空。当队列为空时，说明所有的叶子节点(深度最深的层)都已经经过了队列，也就完成了遍历。</li>
</ul>
<h4 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h4><p>用栈储存二叉树，栈代替我们完成了递归。</p>
<h4 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h4><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91_2020-02-20-15-45-37.png" alt="数据结构与算法（六）——树_2020-02-20-15-45-37.png"></p>
<p>前序遍历：1 2 4 5 7 8 3 6</p>
<p>中序遍历：4 2 7 5 8 1 3 6</p>
<p>后序遍历：4 7 8 5 2 6 3 1</p>
<p>层次遍历：1 2 3 4 5 6 7 8</p>
<h3 id="二叉树的初始化"><a href="#二叉树的初始化" class="headerlink" title="二叉树的初始化"></a>二叉树的初始化</h3><h4 id="链式储存"><a href="#链式储存" class="headerlink" title="链式储存"></a>链式储存</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by engineer on 2017/10/23.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 二叉树结点定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据域</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="comment">// 左子树</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode&lt;T&gt; leftChild;</span><br><span class="line">    <span class="comment">// 右子树</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode&lt;T&gt; rightChild;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, data, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(TreeNode&lt;T&gt; leftChild, T data, TreeNode&lt;T&gt; rightChild)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.leftChild = leftChild;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.rightChild = rightChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode&lt;T&gt; <span class="title">getLeftChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> leftChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode&lt;T&gt; <span class="title">getRightChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rightChild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建二叉树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 树根</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">TreeNode <span class="title">CreateTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeNode&lt;String&gt; nodeH = <span class="keyword">new</span> TreeNode&lt;&gt;(<span class="string">"H"</span>);</span><br><span class="line">        TreeNode&lt;String&gt; nodeG = <span class="keyword">new</span> TreeNode&lt;&gt;(<span class="string">"G"</span>);</span><br><span class="line"></span><br><span class="line">        TreeNode&lt;String&gt; nodeF = <span class="keyword">new</span> TreeNode&lt;&gt;(nodeH, <span class="string">"F"</span>, <span class="keyword">null</span>);</span><br><span class="line">        TreeNode&lt;String&gt; nodeE = <span class="keyword">new</span> TreeNode&lt;&gt;(nodeG, <span class="string">"E"</span>, <span class="keyword">null</span>);</span><br><span class="line">        TreeNode&lt;String&gt; nodeD = <span class="keyword">new</span> TreeNode&lt;&gt;(<span class="string">"D"</span>);</span><br><span class="line"></span><br><span class="line">        TreeNode&lt;String&gt; nodeC = <span class="keyword">new</span> TreeNode&lt;&gt;(<span class="keyword">null</span>, <span class="string">"C"</span>, nodeF);</span><br><span class="line">        TreeNode&lt;String&gt; nodeB = <span class="keyword">new</span> TreeNode&lt;&gt;(nodeD, <span class="string">"B"</span>, nodeE);</span><br><span class="line">        TreeNode&lt;String&gt; nodeA = <span class="keyword">new</span> TreeNode&lt;&gt;(nodeB, <span class="string">"A"</span>, nodeC);</span><br><span class="line">        <span class="keyword">return</span> nodeA;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问每个结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">visitNode</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        System.out.print(node.getData().toString());</span><br><span class="line">        System.out.print(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序遍历-递归实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preTraversal</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            visitNode(node);</span><br><span class="line">            preTraversal(node.getLeftChild());</span><br><span class="line">            preTraversal(node.getRightChild());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序遍历-递归实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            traversal(node.getLeftChild());</span><br><span class="line">            visitNode(node);</span><br><span class="line">            traversal(node.getRightChild());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后序遍历-递归实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postTraversal</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            postTraversal(node.getLeftChild());</span><br><span class="line">            postTraversal(node.getRightChild());</span><br><span class="line">            visitNode(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="排序二叉树"><a href="#排序二叉树" class="headerlink" title="排序二叉树"></a>排序二叉树</h3><p>排序二叉树是一种特殊结构的二叉树，通过它可以非常方便地对树中的所有节点进行排序和检索</p>
<p>排序二叉树要么是一颗空二叉树，要么是具有下列性质的二叉树</p>
<ul>
<li>若它的左子树不空，则左子树上所有的节点的值均小于它的根节点的值</li>
<li>若它的右子树不空，则右子树上所有的节点均大于它的根节点的值</li>
<li>它的左右子树分别为排序二叉树。</li>
</ul>
<p>下图显示了一棵排序二叉树. 对于排序二叉树，若按中序遍历就可以得到由小到大的有序序列。中序遍历得:<br>{2,3,4,8,9,9,10,13,15,18)<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91_2020-02-20-15-57-44.png" alt="数据结构与算法（六）——树_2020-02-20-15-57-44.png"></p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>排序二叉树虽然可以快速检索，但在最坏的情况下，如果插入的节点集本身就是有序的，要么是由小到大排列，要么是由大到小排列，那么最后得到的排序二义树将变成链表:在这种情况下，排序二叉树就变成了普通链表，其检索效率就会很低。<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91_2020-02-20-16-07-33.png" alt="数据结构与算法（六）——树_2020-02-20-16-07-33.png"></p>
<p>为了改变排序二叉树存在的不足，对二叉树进行改进————红黑树，他将这种排序二叉树称为“对称二叉 B 树”。</p>
<p>红黑树的应用非常广泛，常见的函数库，如 C++中的 map，multimap,以及 Java 中的 TreeMap，TreeSet， Java8 中的 HashMap 的实现也采用了红黑树。</p>
<p>红黑树从本质上来说就是一颗二叉查找树，但是在二叉树的基础上增加了着色相关的性质，使得红黑树可以保证相对平衡，从而保证红黑树的增删改查的时间复杂度最坏也能达到 O(log N)。</p>
<p>红黑树是一个更高效的检索二叉树，因此常常用来实现关联数组。典型的，JDK 提供的集合类 TreeMap 本身就是一颗红黑树的实现。 红黑树在原有的排序二叉树上增加如下几个要求：</p>
<ul>
<li>性质 l:每个节点要么是红色，要么是黑色。</li>
<li>性质 2:根节点永远是黑色的。</li>
<li>除质 3:所有的叶子节点都是空节点(即 null)，并且是黑色的。</li>
<li>性质 4:每个红色节点的两个子节点都是黑色的。(从每个叶子到根的路径上不会有两个连续的红色节点。)</li>
<li>性质 5:从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。</li>
</ul>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91_2020-02-20-16-09-08.png" alt="数据结构与算法（六）——树_2020-02-20-16-09-08.png"></p>
<p>上图是一棵典型的红黑树，红黑树的 5 条特性确保了从根到叶子的最长的可能路径不多于最短的可能路径的两倍长，使得整棵树大致上是平衡的。树上的增删改查操作的最坏情况时间都与树的高度成正比，所以红黑树在最坏情况下也是高效的。</p>
<p>在红黑树中一般用黑的 NIL 节点表示叶节点，不包含值，只是标志该分支结束，有时候绘图中会直接省略。</p>
<h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p>当在含 n 个关键字的红黑树上进行 insert 和 delete 操作时，修改后的树可能不满足上面给出的 5 个红黑树的基本特性，所以需要改变树中的某些节点的颜色以及指针结构。 这些指针结构的修改是通过旋转完成的，旋转分为左旋和右旋:</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91_2020-02-20-16-16-55.png" alt="数据结构与算法（六）——树_2020-02-20-16-16-55.png"></p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p>疯狂 java 笔记之树和二叉树</p>
<p>图解红黑树</p>
 
    </div>
    
    <div class="article-info article-info-index">
       
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
    </div>

 
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/" rel="tag">数据结构 树</a></li></ul>
    </div>
 
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>
    

  
    <article
  id="post-数据结构与算法（五）——队列"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
>
  
  <div class="article-meta">
    <a href="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/" class="article-date">
      <time datetime="2020-02-20T05:36:36.000Z" itemprop="datePublished">2020-02-20</time>
</a>

 
    <a href="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/#comments" title="查看评论">
        <i class="fa fa-comments-o" aria-hidden="true"></i>
        <span class="count-comment"></span>
        
        
            <span class="disqus-comment-count" data-disqus-identifier="2020/02/20/数据结构与算法（五）——队列/"></span>
        
    </a>

  </div>
  
  <div class="article-inner">
    
    <input type="hidden" class="isFancy" />
     
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/">数据结构与算法（五）——队列</a>
    </h1>
  
 
    </header>
     
    <div class="article-entry" itemprop="articleBody">
        <h1 id="队列介绍"><a href="#队列介绍" class="headerlink" title="队列介绍"></a>队列介绍</h1><p>队列是数据结构中比较重要的一种类型，它支持 FIFO，尾部添加、头部删除（先进队列的元素先出队列），跟我们生活中的排队类似。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><ul>
<li>索引: O(n)</li>
<li>搜索: O(n)</li>
<li>插入: O(1)</li>
<li>移除: O(1)</li>
</ul>
<h1 id="队列类型"><a href="#队列类型" class="headerlink" title="队列类型"></a>队列类型</h1><h3 id="单队列"><a href="#单队列" class="headerlink" title="单队列"></a>单队列</h3><p>单队列就是常见的队列, 每次添加元素时，都是添加到队尾：<br>以数组实现的队列为例，初始时队列长度固定为 4，font 和 rear 均为 0：<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%98%9F%E5%88%97_2020-02-20-13-45-34.png" alt="数据结构与算法（五）——队列_2020-02-20-13-45-34.png"><br>每添加一个元素，rear 后移一位。当添加四个元素后， rear 到了索引为 4 的位置：<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%98%9F%E5%88%97_2020-02-20-13-46-12.png" alt="数据结构与算法（五）——队列_2020-02-20-13-46-12.png"><br>这时 a1,a2 出队，front 后移动到 2：<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%98%9F%E5%88%97_2020-02-20-13-46-40.png" alt="数据结构与算法（五）——队列_2020-02-20-13-46-40.png"><br>这时想要再添加两个元素，但 rear 后移两位后就会越界：<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%98%9F%E5%88%97_2020-02-20-13-47-26.png" alt="数据结构与算法（五）——队列_2020-02-20-13-47-26.png"><br>明明有三个空位，却只能再放入一个！这就是单队列的“假溢出”情况。<br>针对这种情况，解决办法就是后面满了，就再从头开始，也就是头尾相接的循环。这就是 “循环队列” 的概念。</p>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>循环队列中，<br>rear = (rear - size) % size</p>
<p>接着上面的例子，当 rear 大于 队列长度时，rear = ( 5 - 5) % 5 = 0 :<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%98%9F%E5%88%97_2020-02-20-13-52-12.png" alt="数据结构与算法（五）——队列_2020-02-20-13-52-12.png"><br>这样继续添加时，还可以添加几个元素：<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%98%9F%E5%88%97_2020-02-20-13-52-37.png" alt="数据结构与算法（五）——队列_2020-02-20-13-52-37.png"><br>那如何判断队列是否装满元素了呢，单使用 front == rear 无法判断究竟是空的还是满了。</p>
<p>两种方法：</p>
<ul>
<li>加个标志 flag ,初始为 false，添加满了置为 true；</li>
<li>不以 front = rear 为放满标志，改为 (rear - front) % size = 1。</li>
</ul>
<p>法 2 的公式放满元素时空余了一个位置，这个公式是什么意思呢？<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%98%9F%E5%88%97_2020-02-20-13-53-37.png" alt="数据结构与算法（五）——队列_2020-02-20-13-53-37.png"><br>接着上面的情况，当 rear 从后面添加元素跑到前面 0 时，再添加一个元素 a6，rear 后移一位到 1，这时 front = 2, (1 - 2) % 5 = 1, 满足放满条件。</p>
<p>因此，当 rear &gt; font 时，队列中元素个数 = rear - font;</p>
<p>当 rear &lt; font 时，队列中元素分为两部分： size - font 和 rear ,也就是 rear + size - font。以上述图片为例，队列中元素个数 = 1 + 5 - 2 = 4.</p>
<h1 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 1.单向队列（Queue）：只能在一端插入数据，另一端删除数据。</span></span><br><span class="line"><span class="comment">     * 2.双向队列（Deque）：每一端都可以进行插入数据和删除数据操作。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  与栈不同的是，队列中的数据不总是从数组的0下标开始的</span></span><br><span class="line"><span class="comment">     *  选择的做法是移动队头和队尾的指针。</span></span><br><span class="line"><span class="comment">     *  为了避免队列不满却不能插入新的数据，我们可以让队尾指针绕回到数组开始的位置，这也称为“循环队列”。</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="comment">// 单向循环队列，顺序存储结构实现</span></span><br><span class="line">    <span class="keyword">private</span> Object[] objQueue;</span><br><span class="line">    <span class="comment">//队列大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="comment">//顶部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top;</span><br><span class="line">    <span class="comment">//底部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bottom;</span><br><span class="line">    <span class="comment">//实际元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> item;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        maxSize = size;</span><br><span class="line">        objQueue = <span class="keyword">new</span> Object[maxSize];</span><br><span class="line">        top = <span class="number">0</span>;</span><br><span class="line">        bottom = -<span class="number">1</span>;</span><br><span class="line">        item = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入队</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(item == maxSize)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(obj+<span class="string">" add error, queue is full"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环队列，首尾结合，下标控制队首和队尾位置</span></span><br><span class="line">        <span class="keyword">if</span>(bottom == maxSize-<span class="number">1</span>)&#123;</span><br><span class="line">            bottom = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        objQueue[++bottom] = obj;</span><br><span class="line">        item++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出对</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(item == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"queue is null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Object obj = objQueue[top];</span><br><span class="line">        <span class="comment">//声明原顶栈可以回收空间(GC)</span></span><br><span class="line">        objQueue[top] = <span class="keyword">null</span>;</span><br><span class="line">        top++;</span><br><span class="line">        <span class="comment">//重置下标</span></span><br><span class="line">        <span class="keyword">if</span>(top == maxSize)&#123;</span><br><span class="line">            top = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        item--;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//链式存储结构实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeQueue</span>&lt;<span class="title">Object</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> NodeQueue next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NodeQueue</span><span class="params">(Object data, NodeQueue next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队列头 出</span></span><br><span class="line">    <span class="keyword">private</span> NodeQueue queueTop;</span><br><span class="line">    <span class="comment">//队列尾 进</span></span><br><span class="line">    <span class="keyword">private</span> NodeQueue queueBottom;</span><br><span class="line">    <span class="comment">//队列大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queueTop = <span class="keyword">null</span>;</span><br><span class="line">        queueBottom = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入队</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNodeQueue</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            queueTop = <span class="keyword">new</span> NodeQueue(obj,<span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//指向同一存储地址</span></span><br><span class="line">            queueBottom = queueTop;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            NodeQueue&lt;Object&gt; nodeQueue = <span class="keyword">new</span> NodeQueue(obj,<span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//让尾节点的next指向新增的节点</span></span><br><span class="line">            queueBottom.next = nodeQueue;</span><br><span class="line">            <span class="comment">//以新节点作为尾节点</span></span><br><span class="line">            queueBottom = nodeQueue;</span><br><span class="line">        &#125;</span><br><span class="line">        size ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出队</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">removeNodeQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"queue is null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        NodeQueue nodeQueue = queueTop;</span><br><span class="line">        queueTop = queueTop.next;</span><br><span class="line">        <span class="comment">//声明原队列头next可以回收空间(GC)</span></span><br><span class="line">        nodeQueue.next = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> nodeQueue.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"&#123; "</span>);</span><br><span class="line">        <span class="keyword">for</span>(NodeQueue nodeQueue = queueTop ; nodeQueue != <span class="keyword">null</span> ; nodeQueue = nodeQueue.next)&#123;</span><br><span class="line">            sb.append(nodeQueue.data.toString()+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString()+<span class="string">"&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue queue = <span class="keyword">new</span> Queue();</span><br><span class="line">        queue.addNodeQueue(<span class="string">"123"</span>);</span><br><span class="line">        queue.addNodeQueue(<span class="string">"abc"</span>);</span><br><span class="line">        queue.addNodeQueue(<span class="string">"ddd"</span>);</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">        queue.removeNodeQueue();</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">        queue.removeNodeQueue();</span><br><span class="line">        queue.removeNodeQueue();</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="队列应用"><a href="#队列应用" class="headerlink" title="队列应用"></a>队列应用</h1><ol>
<li>模拟现实世界中的队列，如售票柜台的队列以及其他先到先服务的场景。</li>
<li>计算客户在呼叫中心等待的时间。</li>
<li>异步数据的传输（文件输入输出、管道、嵌套字）。</li>
<li>操作系统中的优先级任务执行。</li>
<li>短信群体发送 应用的发布订阅模式</li>
</ol>
 
    </div>
    
    <div class="article-info article-info-index">
       
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
    </div>

 
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/" rel="tag">数据结构 队列</a></li></ul>
    </div>
 
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>
    

  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2019-2020 南有乔木
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 2;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>


    

    
        <script id="dsq-count-scr" src="//qnsite.disqus.com/count.js" async></script>
        <script>
            if ($(".left-col").is(":visible")) {
                var $disqusCount = $(".disqus-comment-count");
                $disqusCount.bind("DOMNodeInserted", function(e) {
                    var num = $(this).text().replace(/[^0-9]/ig,"");
                    if (num > 0) {
                        $(this).siblings(".count-comment").text(num);
                    }
                    $(this).remove();
                })
            } else {
                $(".disqus-comment-count").remove();
            }
        </script>
     




<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
            
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>