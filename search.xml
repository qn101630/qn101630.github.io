<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>测试</title>
      <link href="/2020/03/09/%E6%B5%8B%E8%AF%95/"/>
      <url>/2020/03/09/%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="只是为了测试"><a href="#只是为了测试" class="headerlink" title="只是为了测试"></a>只是为了测试</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA容器——ConcurrentHashMap</title>
      <link href="/2020/03/04/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ConcurrentHashMap/"/>
      <url>/2020/03/04/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ConcurrentHashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="我们已经知道了-HashMap-是不安全的，对于高并发我们常会选择用-ConcuerrentHashMap-为什么？"><a href="#我们已经知道了-HashMap-是不安全的，对于高并发我们常会选择用-ConcuerrentHashMap-为什么？" class="headerlink" title="我们已经知道了 HashMap 是不安全的，对于高并发我们常会选择用 ConcuerrentHashMap,为什么？"></a>我们已经知道了 HashMap 是不安全的，对于高并发我们常会选择用 ConcuerrentHashMap,为什么？</h1><p><code>HashMap</code> 在多线程环境下存在线程安全问题，一般在多线程的场景，我都会使用好几种不同的方式去代替：</p><ul><li>使用 <code>Collections.synchronizedMap(Map)</code> 创建线程安全的 <code>map</code> 集合；</li><li><code>Hashtable</code></li><li><code>ConcurrentHashMap</code></li></ul><p>但是仔细研究过源码的同学都知道，前两者保证线程安全的操作 <code>synchronized</code> 修饰方法，锁住整个 <code>hash</code> 表，效率低下。</p><p><code>ConcurrentHashMap</code> 对锁的粒度和锁的方式进行了优化，<code>jdk1.7</code> 采用了分段锁，而 <code>jdk1.8</code> 采用了 <code>CAS + synchronized</code> 的方式。保证了并发效率及安全性，具体见下文。</p><h1 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h1><p>ConcurrentHashMap 使用的是分段锁技术,将 ConcurrentHashMap 容器的数据分段存储,每一段数据分配一个 Segment,当线程占用一个 Segment 时,其他线程可以访问其他段的数据。</p><h3 id="请讲一下-JDK1-7-ConcurrentHashMap-数据结构"><a href="#请讲一下-JDK1-7-ConcurrentHashMap-数据结构" class="headerlink" title="请讲一下 JDK1.7 ConcurrentHashMap 数据结构"></a>请讲一下 JDK1.7 ConcurrentHashMap 数据结构</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>是由 Segment 数组、HashEntry 组成，和 HashMap 一样，仍然是 <strong>数组加链表</strong>。</p><ul><li>Segment : 可重入锁,继承 <code>ReentrantLock</code>S 也称之为桶</li><li>HashEntry : 主要存储键值对 可以叫节点</li></ul><p>CurrentHashMap 包含一个 <code>Segment</code>数组，每个 <code>Segment</code> 包含一个<code>HashEntry</code> 数组并且守护它，当修改 <code>HashEntry</code> 数组数据时，需要先获取它对应的 <code>Segment</code> 锁；而 <code>HashEntry</code> 数组采用开链法处理冲突，所以它的每个 <code>HashEntry</code> 元素又是链表结构的元素。</p><h4 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h4><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ConcurrentHashMap_2020-03-04-17-11-30.png" alt="JAVA容器——ConcurrentHashMap_2020-03-04-17-11-30.png"></p><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ConcurrentHashMap_2020-03-04-17-23-51.png" alt="JAVA容器——ConcurrentHashMap_2020-03-04-17-23-51.png"></p><h3 id="请讲一下-JDK1-7-ConcurrentHashMap-操作方法和原理"><a href="#请讲一下-JDK1-7-ConcurrentHashMap-操作方法和原理" class="headerlink" title="请讲一下 JDK1.7 ConcurrentHashMap 操作方法和原理"></a>请讲一下 JDK1.7 ConcurrentHashMap 操作方法和原理</h3><h4 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>ConcurrentHashMap 继承自 AbstractMap 类，实现了 ConcurrentMap 和 Serializable 接口。</p><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><ul><li>默认初始化大小值 16</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br></pre></td></tr></table></figure><ul><li>默认负载因子大小 0.75</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure><ul><li>默认分段数量（最大并发线程数）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br></pre></td></tr></table></figure><ul><li>最大容量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure><ul><li>每个 segment 分段中表的最小容量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SEGMENT_TABLE_CAPACITY = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><ul><li>最大分段数量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SEGMENTS = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;</span><br></pre></td></tr></table></figure><ul><li>containsValue 方法不锁表的情况下尝试的次数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h4 id="segment"><a href="#segment" class="headerlink" title="segment"></a>segment</h4><h5 id="成员变量及构造函数"><a href="#成员变量及构造函数" class="headerlink" title="成员变量及构造函数"></a>成员变量及构造函数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自旋等待尝试加锁次数，单核为1，多核为64，Runtime.getRuntime().availableProcessors()方法获取CPU核心数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SCAN_RETRIES =</span><br><span class="line">            Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span> ? <span class="number">64</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表，即HashEntry数组（每个segment中都有一个table）</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//segment中元素个数</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改次数</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扩容阀值</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//负载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 构造函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Segment(<span class="keyword">float</span> lf, <span class="keyword">int</span> threshold, HashEntry&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">            <span class="keyword">this</span>.loadFactor = lf;</span><br><span class="line">            <span class="keyword">this</span>.threshold = threshold;</span><br><span class="line">            <span class="keyword">this</span>.table = tab;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h5><p>先尝试获取锁，如果加锁失败，则 scanAndLock 自旋等待（和上面的 put 方法相似）。</p><p>获取锁之后，(tab.length - 1) &amp; hash 计算删除节点在 table 中的下标。如果 table 中该位置的链表 <code>HashEntry</code> 不为空,循环判断链表中节点是否存在：</p><ul><li>存在，则替换 value 值，返回 OldValue。</li><li>如果不存在，新建节点，放在 frist 节点前。节点超出最大负载则 rehash。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 尝试进行加锁，如果加锁失败，则执行scanAndLockForPut方法，尝试加锁一定次数之后调用线程自中断方法（自旋等待）。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">                scanAndLockForPut(key, hash, value);</span><br><span class="line">            V oldValue;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">                <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">                HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;  <span class="comment">//for循环查找key是否存在，如果找到了，替换value值，返回oldValue</span></span><br><span class="line">                    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        K k;</span><br><span class="line">                        <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                            (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                            oldValue = e.value;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                                e.value = value;</span><br><span class="line">                                ++modCount;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        e = e.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;  <span class="comment">//如果没找到，新建HashEntry节点，放到first节点前面</span></span><br><span class="line">                        <span class="keyword">if</span> (node != <span class="keyword">null</span>)   <span class="comment">//scanAndLockForPut自旋等待时如果已经新建了节点，设置next值即可，setNext方法实现了延迟写。</span></span><br><span class="line">                            node.setNext(first);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                        <span class="keyword">int</span> c = count + <span class="number">1</span>;  <span class="comment">//元素个数加1，如果超过了阀值，则进行rehash，进行扩容</span></span><br><span class="line">                        <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                            rehash(node);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            setEntryAt(tab, index, node);   <span class="comment">//把新建节点放在链表的头位置</span></span><br><span class="line">                        ++modCount;</span><br><span class="line">                        count = c;</span><br><span class="line">                        oldValue = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();   <span class="comment">//最后释放锁</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h5 id="scanAndLockForPut-方法"><a href="#scanAndLockForPut-方法" class="headerlink" title="scanAndLockForPut 方法"></a>scanAndLockForPut 方法</h5><p>自旋锁，尝试加锁一定次数仍然失败进行线程自中断。</p><p>该方法先计算 hash 值在 table 中的位置，循环该位置上的链表查找 key 值。</p><p>如果不存在则新建节点，之后尝试加锁 MAX_SCAN_RETRIES 次，如果一直失败则挂起当前线程。</p><p>期间如果链表头被修改，则重新开始该过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">            HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">            HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> retries = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (!tryLock()) &#123;    <span class="comment">//获取锁失败时进入循环</span></span><br><span class="line">                HashEntry&lt;K,V&gt; f;</span><br><span class="line">                <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;  <span class="comment">//循环链表，找到key值或者不存在新建节点</span></span><br><span class="line">                    <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                            node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        retries = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))     <span class="comment">//如果找到了key值，</span></span><br><span class="line">                        retries = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        e = e.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                * 找到key值或者key值不存在新建节点之后，尝试加锁一定次数进入等待状态</span></span><br><span class="line"><span class="comment">                * 尝试次数，单核为1，多核为64</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">                    lock();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123; <span class="comment">//如果尝试加锁过程中发现链表头变化了，重置retries为-1，重新开始</span></span><br><span class="line">                    e = first = f;</span><br><span class="line">                    retries = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h5 id="rehash-方法"><a href="#rehash-方法" class="headerlink" title="rehash 方法"></a>rehash 方法</h5><p>对当前 <code>table</code> 进行扩容操作，大小变为原来的 2 倍，其中的元素会被重新分配位置，<code>oldTable[idx]</code> 上的链表上的元素可能会重新 <code>hash</code> 到 <code>newTable[idx]</code> 和 <code>newTbale[idx+n]</code> 的链表上,<code>n</code> 为 <code>oldTable</code> 的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>; <span class="comment">//newTable的大小为oldTable的2被</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">        (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">    <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">int</span> idx = e.hash &amp; sizeMask;    <span class="comment">//计算节点在newTable中的位置idx</span></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">//如果链表只有一个节点，直接放到newTable的idx上</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                * 与重新计算每个节点在newTable中的位置并依次进行头插法插入链表头相比，这里进行了优化</span></span><br><span class="line"><span class="comment">                * 1.计算链表中每个节点在newTable中的位置，但是并不立即插入链表头</span></span><br><span class="line"><span class="comment">                * 2.记住最后一个与它的上一个节点在新表中位置不同的节点lastRun，即链表中此节点之后的节点在newTable中的位置都相同</span></span><br><span class="line"><span class="comment">                * 3.把lastRun放到newTable中，它之后的节点会带过来</span></span><br><span class="line"><span class="comment">                * 4.计算lastRun之前的节点在newTable中的位置并依次进行头插法插入newTable中。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                     last != <span class="keyword">null</span>;</span><br><span class="line">                     last = last.next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// Clone remaining nodes</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                    <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// 把新节点放入newTable中</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove 方法"></a>remove 方法</h5><p>先尝试获取锁，如果加锁失败，则 scanAndLock 自旋等待（和上面的 put 方法相似）。</p><p>获取锁之后，(tab.length - 1) &amp; hash 计算删除节点在 table 中的下标，如果 table 中该位置的链表不为空，循环判断链表中节点是否和删除节点相等（value 为 null 时，key 相等即可，否则 key 和 value 均需相等）。</p><p>如果删除节点存在，设置 pre 节点的 next 指针指向 next 节点即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">remove</span><span class="params">(Object key, <span class="keyword">int</span> hash, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryLock())     <span class="comment">//尝试加锁</span></span><br><span class="line">        scanAndLock(key, hash);     <span class="comment">//加锁失败，则自旋等待</span></span><br><span class="line">    V oldValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;    <span class="comment">//计算hash值在table中的下标</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = entryAt(tab, index);</span><br><span class="line">        HashEntry&lt;K,V&gt; pred = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                V v = e.value;</span><br><span class="line">                <span class="keyword">if</span> (value == <span class="keyword">null</span> || value == v || value.equals(v)) &#123;   <span class="comment">//key相等时，value为null或者value也相等即为删除节点</span></span><br><span class="line">                    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                        setEntryAt(tab, index, next);   <span class="comment">//如果删除节点是头节点，设置头节点为next节点</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        pred.setNext(next);     <span class="comment">//否则设置上一个节点的next指针指向next节点</span></span><br><span class="line">                    ++modCount;     <span class="comment">//修改次数加1</span></span><br><span class="line">                    --count;        <span class="comment">//节点数量减1</span></span><br><span class="line">                    oldValue = v;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pred = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();   <span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hash-方法"><a href="#hash-方法" class="headerlink" title="hash 方法"></a>hash 方法</h4><p>用 key.hashCode()与 key.hashCode()向右位移 16 位值异或。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hashSeed;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="number">0</span> != h) &amp;&amp; (k <span class="keyword">instanceof</span> String)) &#123;</span><br><span class="line">            <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">        h += (h &lt;&lt;  <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line">        h += (h &lt;&lt;   <span class="number">3</span>);</span><br><span class="line">        h ^= (h &gt;&gt;&gt;  <span class="number">6</span>);</span><br><span class="line">        h += (h &lt;&lt;   <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</span><br><span class="line">        <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="定位-segment"><a href="#定位-segment" class="headerlink" title="定位 segment"></a>定位 segment</h4><p>ConcurrentHashMap 使用分段锁 Segment 来保护不同段的数据，那么在插入和获取元素的时候，必须先通过散列算法定位到 Segment。</p><p>首先对 key 的 hashCode 进行 hash 操作</p><p>运用散列算法定位 segment 的位置</p><ul><li><code>segmentMask</code>：段掩码，假如 segments 数组长度为 16，则段掩码为 16-1=15；segments 长度为 32，段掩码为 32-1=31。这样得到的所有 bit 位都为 1，可以更好地保证散列的均匀性</li><li><code>segmentShift</code>：2 的 sshift 次方等于 ssize，segmentShift=32-sshift。若 segments 长度为 16，segmentShift=32-4=28;若 segments 长度为 32，segmentShift=32-5=27。而计算得出的 hash 值最大为 32 位，无符号右移 segmentShift，则意味着只保留高几位（其余位是没用的），然后与段掩码 segmentMask 位运算来定位 Segment。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Segment&lt;K,V&gt; <span class="title">segmentFor</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="put-方法（ConcurrentHashMap）"><a href="#put-方法（ConcurrentHashMap）" class="headerlink" title="put 方法（ConcurrentHashMap）"></a>put 方法（ConcurrentHashMap）</h4><p>先计算 key 值在哪个 segment 中，然后调用 segment 的 put 方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        Segment&lt;K,V&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;      <span class="comment">//计算key落在哪个segment中</span></span><br><span class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject</span><br><span class="line">             (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>)</span><br><span class="line">            s = ensureSegment(j);                           <span class="comment">//如果segment不存在则初始化</span></span><br><span class="line">        <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);              <span class="comment">//调用segment的put方法</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="get-方法（ConcurrentHashMap）"><a href="#get-方法（ConcurrentHashMap）" class="headerlink" title="get 方法（ConcurrentHashMap）"></a>get 方法（ConcurrentHashMap）</h4><p>先计算 key 落在哪个 segment 中</p><p>如果 segment 不为 null 并且 table 不为 null，tab.length - 1) &amp; h 计算在 table 中的下标</p><p>循环链表的节点进行比较，如果 key 相等或者 hash 和 equals 方法相等，则返回 value 值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                     (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">                 e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))   <span class="comment">//如果key相等，或者重载的hash方法和equals方法相等</span></span><br><span class="line">                    <span class="keyword">return</span> e.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="remove-方法（ConcurrentHashMap）"><a href="#remove-方法（ConcurrentHashMap）" class="headerlink" title="remove 方法（ConcurrentHashMap）"></a>remove 方法（ConcurrentHashMap）</h4><p>remove 方法有两个，一个参数只有 key，一个参数是 key 和 value，所以 segment 的 remove 方法中 value 为 null 时，key 相等即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);                       <span class="comment">//计算hash值</span></span><br><span class="line">        Segment&lt;K,V&gt; s = segmentForHash(hash);      <span class="comment">//计算hash值落在哪个segment中</span></span><br><span class="line">        <span class="keyword">return</span> s == <span class="keyword">null</span> ? <span class="keyword">null</span> : s.remove(key, hash, <span class="keyword">null</span>);    <span class="comment">//调用segment的remove方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified key is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        Segment&lt;K,V&gt; s;</span><br><span class="line">        <span class="keyword">return</span> value != <span class="keyword">null</span> &amp;&amp; (s = segmentForHash(hash)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            s.remove(key, hash, value) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="你有没有发现-1-7-虽然可以支持每个-Segment-并发访问，但是还是存在一些问题？"><a href="#你有没有发现-1-7-虽然可以支持每个-Segment-并发访问，但是还是存在一些问题？" class="headerlink" title="你有没有发现 1.7 虽然可以支持每个 Segment 并发访问，但是还是存在一些问题？"></a>你有没有发现 1.7 虽然可以支持每个 Segment 并发访问，但是还是存在一些问题？</h3><p>是的，因为基本上还是数组加链表的方式，我们去查询的时候，还得遍历链表，会导致效率很低，这个跟 jdk1.7 的 HashMap 是存在的一样问题，所以他在 jdk1.8 完全优化了。</p><h1 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h1><p>jdk1.8 中 ConcurrentHashMap 有了很大的变化，不再是 segment 结构，而是使用类似乐观锁的方式（<code>CAS + synchronized</code>）来达到多线程安全的目的。</p><h3 id="请讲一下-JDK1-8-ConcurrentHashMap-数据结构"><a href="#请讲一下-JDK1-8-ConcurrentHashMap-数据结构" class="headerlink" title="请讲一下 JDK1.8 ConcurrentHashMap 数据结构"></a>请讲一下 JDK1.8 ConcurrentHashMap 数据结构</h3><p>把之前的 HashEntry 改成了 Node，但是作用不变，把值和 next 采用了 volatile 去修饰，保证了可见性，并且也引入了红黑树，在链表大于一定值的时候会转换（默认是 8）</p><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ConcurrentHashMap_2020-03-06-19-21-16.png" alt="JAVA容器——ConcurrentHashMap_2020-03-06-19-21-16.png"></p><h3 id="请讲一下-JDK1-8-ConcurrentHashMap-的属性、内部类"><a href="#请讲一下-JDK1-8-ConcurrentHashMap-的属性、内部类" class="headerlink" title="请讲一下 JDK1.8 ConcurrentHashMap 的属性、内部类"></a>请讲一下 JDK1.8 ConcurrentHashMap 的属性、内部类</h3><h4 id="类定义-1"><a href="#类定义-1" class="headerlink" title="类定义"></a>类定义</h4><p>ConcurrentHashMap 继承了 AbstractMap，实现了 ConcurrentMap 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><h4 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h4><ul><li>最大容量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure><ul><li>默认初始化的容量 16，容量必须是 2 的倍数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br></pre></td></tr></table></figure><ul><li>数组的最大容量，toArray 和相关方法会用到</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure><ul><li>默认分段数量（不再使用，兼容老版本）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br></pre></td></tr></table></figure><ul><li>默认负载因子</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure><ul><li>链表转换为树的阈值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br></pre></td></tr></table></figure><ul><li>树转化为链表的阈值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><ul><li>树结构的最小容量（当 table 中的其中一个链表长度达到 8 并且 table 中的节点总数达到 64 时，会把该链表转化为树结构，而如果 table 中的节点数量小于 64，不会进行树结构的转化，而是对 table 进行扩容以降低该链表的长度。）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure><ul><li>扩容时每个核心转移的间隔数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br></pre></td></tr></table></figure><ul><li>节点的 hash 值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// 表示该节点正在处理中</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// 表示该节点是树的根节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// 暂时保留</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// 正常节点的hash值可用的位数</span></span><br></pre></td></tr></table></figure><ul><li>CPU 的核心数量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br></pre></td></tr></table></figure><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul><li>table 表，volatile 修饰（一个线程修改该属性时，会立即写入到主存中，即对其他线程立即可见），transient 修饰符（序列化时忽略该属性，即该属性只存在内存中，而不会持久化到磁盘里）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><ul><li>newTable，进行扩容时会新建该表，其他线程发现该表不为空，说明已经有线程在进行扩容操作，就会帮助把 oldTable 中的数据扩容操作到此新表中，一起完成扩容操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br></pre></td></tr></table></figure><ul><li>baseCount 用于计算 size 的其中一个属性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br></pre></td></tr></table></figure><ul><li><p>控制 table 初始化和扩容的属性</p><ul><li>0 ，初始化值</li><li>-1，表示正在初始化</li><li>-N，表示 N-1 个线程正在一起进行扩容操作</li><li>N ，table 为 null 时，该值表示初始化的大小，table 不为 null，该值表示下一次扩容的大小</li></ul></li><li><p>扩容时下一个 table 下标</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br></pre></td></tr></table></figure><ul><li>扩容和 CounterCells 时的锁标识</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> KeySetView&lt;K,V&gt; keySet;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> ValuesView&lt;K,V&gt; values;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> EntrySetView&lt;K,V&gt; entrySet;</span><br></pre></td></tr></table></figure><h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><h5 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h5><p>Node 类实现了 Map.Entry 接口，主要存放 key-value 对，并且具有 next 域</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V val;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a>TreeNode</h5><p>树节点，继承于承载数据的 Node 类。而红黑树的操作是针对 TreeBin 类的，从该类的注释也可以看出，也就是 TreeBin 会将 TreeNode 进行再一次封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * Nodes <span class="keyword">for</span> use in TreeBins</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="TreeBin"><a href="#TreeBin" class="headerlink" title="TreeBin"></a>TreeBin</h5><p>这个类并不负责包装用户的 key、value 信息，而是包装的很多 TreeNode 节点。实际的 ConcurrentHashMap“数组”中，存放的是 TreeBin 对象，而不是 TreeNode 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; root;</span><br><span class="line">        <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">        <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line">        <span class="comment">// values for lockState</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ForwardingNode"><a href="#ForwardingNode" class="headerlink" title="ForwardingNode"></a>ForwardingNode</h5><p>在扩容时才会出现的特殊节点，其 key,value,hash 全部为 null。并拥有 nextTable 指针引用新的 table 数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line">   .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="你在上面提到-CAS-CAS-是什么"><a href="#你在上面提到-CAS-CAS-是什么" class="headerlink" title="你在上面提到 CAS,CAS 是什么?"></a>你在上面提到 CAS,CAS 是什么?</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>CAS 是乐观锁的一种实现方式，是一种轻量级锁，JUC 中很多工具类的实现就是基于 CAS 的。</p><h4 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h4><p>CAS 操作的流程如下图所示，线程在读取数据时不进行加锁，在准备写回数据时，比较原值是否修改，若未被其他线程修改则写回，若已被修改，则重新执行读取流程。</p><p>这是一种乐观策略，认为并发操作并不总会发生。</p><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ConcurrentHashMap_2020-03-06-18-50-14.png" alt="JAVA容器——ConcurrentHashMap_2020-03-06-18-50-14.png"></p><h4 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h4><p>一个线程把值改回了 B，又来了一个线程把值又改回了 A，对于这个时候判断的线程，就发现他的值还是 A，所以他就不知道这个值到底有没有被人改过，其实很多场景如果只追求最后结果正确，这是没关系的。</p><p>但是实际过程中还是需要记录修改过程的，比如资金修改什么的，你每次修改的都应该有记录，方便回溯。</p><p>CAS 无法判断 ABA 问题，这个时候我们可以用版本号、时间戳等来保证记录更新。</p><h4 id="关键操作"><a href="#关键操作" class="headerlink" title="关键操作"></a>关键操作</h4><h5 id="tabAt"><a href="#tabAt" class="headerlink" title="tabAt"></a>tabAt</h5><p>该方法用来获取 table 数组中索引为 i 的 Node 元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="casTabAt"><a href="#casTabAt" class="headerlink" title="casTabAt"></a>casTabAt</h5><p>利用 CAS 操作设置 table 数组中索引为 i 的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="setTabAt"><a href="#setTabAt" class="headerlink" title="setTabAt"></a>setTabAt</h5><p>该方法用来设置 table 数组中索引为 i 的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CAS-性能很高，但是我知道-synchronized-性能可不咋地，为啥-jdk1-8-升级之后反而多了-synchronized？"><a href="#CAS-性能很高，但是我知道-synchronized-性能可不咋地，为啥-jdk1-8-升级之后反而多了-synchronized？" class="headerlink" title="CAS 性能很高，但是我知道 synchronized 性能可不咋地，为啥 jdk1.8 升级之后反而多了 synchronized？"></a>CAS 性能很高，但是我知道 synchronized 性能可不咋地，为啥 jdk1.8 升级之后反而多了 synchronized？</h3><p>synchronized 之前一直都是重量级的锁，但是后来 java 官方是对他进行过升级的，他现在采用的是锁升级的方式去做的。</p><p>针对 synchronized 获取锁的方式，JVM 使用了锁升级的优化方式，就是先使用偏向锁优先同一线程然后再次获取锁，如果失败，就升级为 CAS 轻量级锁，如果失败就会短暂自旋，防止线程被系统挂起。最后如果以上都失败就升级为重量级锁。</p><h3 id="请你讲一下-JDK1-8-ConcurrentHashMap-的操作方法"><a href="#请你讲一下-JDK1-8-ConcurrentHashMap-的操作方法" class="headerlink" title="请你讲一下 JDK1.8 ConcurrentHashMap 的操作方法"></a>请你讲一下 JDK1.8 ConcurrentHashMap 的操作方法</h3><h4 id="构造器方法"><a href="#构造器方法" class="headerlink" title="构造器方法"></a>构造器方法</h4><p>ConcurrentHashMap 一共给我们提供了 5 中构造器方法，具体使用请看注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 构造一个空的map，即table数组还未初始化，初始化放在第一次插入数据时，默认大小为16</span></span><br><span class="line">ConcurrentHashMap()</span><br><span class="line"><span class="comment">// 2. 给定map的大小</span></span><br><span class="line">ConcurrentHashMap(<span class="keyword">int</span> initialCapacity)</span><br><span class="line"><span class="comment">// 3. 给定一个map</span></span><br><span class="line">ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)</span><br><span class="line"><span class="comment">// 4. 给定map的大小以及加载因子</span></span><br><span class="line">ConcurrentHashMap(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span><br><span class="line"><span class="comment">// 5. 给定map大小，加载因子以及并发度（预计同时操作数据的线程）</span></span><br><span class="line">ConcurrentHashMap(<span class="keyword">int</span> initialCapacity,<span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span><br></pre></td></tr></table></figure><p>我们来看看第 2 种构造器，传入指定大小时的情况，该构造器源码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line"><span class="comment">//1. 小于0直接抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"><span class="comment">//2. 判断是否超过了允许的最大值，超过了话则取最大值，否则再对该值进一步处理</span></span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line"><span class="comment">//3. 赋值给sizeCtl</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的逻辑请看注释，很容易理解，如果 <code>initialCapacity</code> 小于 0 就直接抛出异常，如果指定值大于了所允许的最大值的话就取最大值，否则，在对指定值做进一步处理。最后将 <code>cap</code> 赋值给 <code>sizeCtl</code></p><p>关于 <code>sizeCtl</code> 的说明请看上面的说明，当调用构造器方法之后，<strong><code>sizeCtl</code> 的大小应该就代表了 ConcurrentHashMap 的大小，即 table 数组长度。</strong></p><p>调用构造器方法的时候并未构造出 table 数组（可以理解为 ConcurrentHashMap 的数据容器），只是算出 table 数组的长度，当第一次向 ConcurrentHashMap 插入数据的时候才真正的完成初始化创建 table 数组的工作</p><h4 id="tableSizeFor"><a href="#tableSizeFor" class="headerlink" title="tableSizeFor"></a>tableSizeFor</h4><p>通过注释就很清楚了，该方法会将调用构造器方法时指定的大小转换成一个 2 的幂次方数，也就是说 ConcurrentHashMap 的大小一定是 2 的幂次方，比如，当指定大小为 18 时，为了满足 2 的幂次方特性，实际上 concurrentHashMapd 的大小为 2 的 5 次方（32）。</p><h4 id="initTable"><a href="#initTable" class="headerlink" title="initTable"></a>initTable</h4><p>ConcurrentHashMap 的初始化操作，保证只有一个线程正在进行初始化操作。</p><p>正在进行初始化的线程会调用 U.compareAndSwapInt 方法将 sizeCtl 改为-1 即正在初始化的状态。</p><p>有可能存在一个情况是多个线程同时走到这个方法中，为了保证能够正确初始化，在第 1 步中会先通过 if 进行判断，若当前已经有一个线程正在初始化即 sizeCtl 值变为-1，这个时候其他线程在 If 判断为 true 从而调用 Thread.yield()让出 CPU 时间片。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 1. 保证只有一个线程正在进行初始化操作</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 2. 得出数组的大小</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="comment">// 3. 这里才真正的初始化数组</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line"><span class="comment">// 4. 计算数组中可用的大小：实际大小n*0.75（加载因子）</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><ol><li><p><code>spread()</code> 重哈希</p><p>我们知道对于一个 <code>hash</code> 表来说，<code>hash</code> 值分散的不够均匀的话会大大增加哈希冲突的概率，从而影响到 <code>hash</code> 表的性能。因此通过 <code>spread</code> 方法进行了一次重 <code>hash</code> 从而大大减小哈希冲突的可能性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>初始化 <code>table</code></p><p>紧接着到第 2 步，会判断当前 <code>table</code> 数组是否初始化了，没有的话就调用 <code>initTable</code> 进行初始化，该方法在上面已经讲过了。</p></li><li><p>能否直接将新值插入到 table 数组中</p><p>通过 <code>(n - 1) &amp; hash</code> 确定数组中索引 <code>i</code> 的位置，</p><p>通过 <code>tabAt()</code> 方法（该方法在上面已经说明了，有疑问可以回过头去看看）获取该位置上的元素</p><p>如果当前 <code>Node f</code> 为 <code>null</code> 的话，就可以直接用 casTabAt 方法将新值插入即可。</p></li><li><p>当前是否正在扩容</p><p>如果当前节点不为 <code>null</code>，且该节点为特殊节点（<code>forwardingNode</code>）的话，就说明当前 <code>concurrentHashMap</code> 正在进行扩容操作，关于扩容操作，下面会作为一个具体的方法进行讲解。</p><p>那么怎样确定当前的这个 <code>Node</code> 是不是特殊的节点了？是通过判断该节点的 <code>hash</code> 值是不是等于<code>-1（MOVED</code>,代码为<code>(fh = f.hash) == MOVED</code>，对 <code>MOVED</code> 的解释在源码上也写的很清楚了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// hash for forwarding nodes</span></span><br></pre></td></tr></table></figure></li><li><p>当 <code>table[i]</code> 为链表的头结点，在链表中插入新值</p><p>在 <code>table[i]</code> 不为 <code>null</code> 并且不为 <code>forwardingNode</code> 时，并且当前 <code>Node f</code> 的 <code>hash</code> 值大于 <code>0（fh &gt;= 0）</code>的话说明当前节点 <code>f</code> 为当前桶的所有的节点组成的链表的头结点。</p><p>那么接下来，要想向 <code>ConcurrentHashMap</code> 插入新值的话就是向这个链表插入新值。通过 <code>synchronized (f)</code> 的方式进行加锁以实现线程安全性。</p><p>如果直到找到了链表的末尾都没有找到的话，就直接将待插入的键值对追加到链表的末尾即可。</p></li><li><p>当 table[i]为红黑树的根节点，在红黑树中插入新值</p><p>一旦出现拉链过长，甚至在极端情况下，查找一个节点会出现时间复杂度为 <code>O(n)</code> 的情况，则会严重影响 <code>ConcurrentHashMap</code> 的性能，于是，在 <code>JDK1.8</code> 版本中，对数据结构做了进一步的优化，引入了红黑树。</p><p>而当链表长度太长（默认超过 8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高 <code>ConcurrentHashMap</code> 的性能，其中会用到红黑树的插入、删除、查找等算法。</p><p>首先在 <code>if</code> 中通过 <code>f instanceof TreeBin</code> 判断当前 <code>table[i]</code> 是否是树节点，这下也正好验证了我们在最上面介绍时说的 <code>TreeBin</code> 会对 <code>TreeNode</code> 做进一步封装，对红黑树进行操作的时候针对的是 <code>TreeBin</code> 而不是 <code>TreeNode</code>。</p></li><li><p>根据当前节点个数进行调整</p><p>如果当前链表节点个数大于等于 <code>8（TREEIFY_THRESHOLD）</code>的时候，就会调用 <code>treeifyBin</code> 方法将 <code>tabel[i]</code>（第 i 个散列桶）拉链转换成红黑树。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"><span class="comment">//1. 计算key的hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line"><span class="comment">//2. 如果当前table还没有初始化先调用initTable方法将tab进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line"><span class="comment">//3. tab中索引为i的位置的元素为null，则直接使用CAS将值插入即可</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//4. 当前正在扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line"><span class="comment">//5. 当前为链表，在链表中插入新的键值对</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">// 6.当前为红黑树，将新的键值对插入到红黑树中</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 7.插入完键值对后再根据实际大小看是否需要转换成红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//8.对当前容量大小进行检查，如果超过了临界值（实际大小*加载因子）就需要扩容</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>看完了 put 方法再来看 get 方法就很容易了，用逆向思维去看就好，这样存的话我反过来这么取就好了</p><ol><li>首先先看当前的 hash 桶数组节点即 table[i]是否为查找的节点</li><li>若是则直接返回。若不是，则继续再看当前是不是树节点？</li><li>通过看节点的 hash 值是否为小于 0，如果小于 0 则为树节点。</li><li>如果是树节点在红黑树中查找节点；</li><li>如果不是树节点，那就只剩下为链表的形式的一种可能性了，就向后遍历查找节点，若查找到则返回节点的 value 即可，若没有找到就返回 null。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line"><span class="comment">// 1. 重hash</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2. table[i]桶节点的key与查找的key相同，则直接返回</span></span><br><span class="line"><span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 3. 当前节点hash小于0说明为树节点，在红黑树中查找即可</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//4. 从链表中查找，查找到则返回该节点的value，否则就返回null即可</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h4><p>当 <code>ConcurrentHashMap</code> 容量不足的时候，需要对 <code>table</code> 进行扩容。这个方法的基本思想跟 <code>HashMap</code> 是很像的，但是由于它是支持并发扩容的，所以要复杂的多。原因是它支持多线程进行扩容操作，而并没有加锁。我想这样做的目的不仅仅是为了满足 <code>concurrent</code> 的要求，而是希望利用并发处理去减少扩容带来的时间影响。</p><p><strong>第一部分</strong>是构建一个 <code>nextTable</code>,它的容量是原来的两倍，这个操作是单线程完成的。新建 <code>table</code> 数组的代码为: <code>Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1]</code> , 在原容量大小的基础上右移一位。</p><p><strong>第二部分</strong>就是将原来 <code>table</code> 中的元素复制到 <code>nextTable</code> 中，主要是遍历复制的过程。 根据运算得到当前遍历的数组的位置 <code>i</code>，然后利用 <code>tabAt</code> 方法获得 <code>i</code> 位置的元素再进行判断：</p><ol><li>如果这个位置为空，就在原 <code>table</code> 中的 <code>i</code> 位置放入 <code>forwardNode</code> 节点，这个也是触发并发扩容的关键点；</li><li>如果这个位置是 <code>Node</code> 节点<code>（fh&gt;=0）</code>，如果它是一个链表的头节点，就构造一个反序链表，把他们分别放在 <code>nextTable</code> 的 <code>i</code> 和 <code>i+n</code> 的位置上</li><li>如果这个位置是 <code>TreeBin</code> 节点<code>（fh&lt;0）</code>，也做一个反序处理，并且判断是否需要 <code>untreefi</code>，把处理的结果分别放在 <code>nextTable</code> 的 <code>i</code> 和 <code>i+n</code> 的位置上</li><li>遍历过所有的节点以后就完成了复制工作，这时让 <code>nextTable</code> 作为新的 <code>table</code>，并且更新 <code>sizeCtl</code> 为新容量的 <code>0.75</code> 倍 ，完成扩容。设置为新容量的 <code>0.75</code> 倍代码为 <code>sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1)</code>，仔细体会下是不是很巧妙，<code>n&lt;&lt;1</code> 相当于 <code>n</code> 左移一位表示 n 的两倍即 <code>2n</code>,<code>n&gt;&gt;&gt;1</code>，<code>n</code> 右移相当于 <code>n</code> 除以 <code>2</code> 即 <code>0.5n</code>,然后两者相减为 <code>2n-0.5n=1.5n</code>,是不是刚好等于新容量的 <code>0.75</code> 倍即 <code>2n*0.75=1.5n</code>。最后用一个示意图来进行总结（图片摘自网络）：</li></ol><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ConcurrentHashMap_2020-03-06-19-58-06.png" alt="JAVA容器——ConcurrentHashMap_2020-03-06-19-58-06.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>JDK6,7 中的 ConcurrentHashmap 主要使用 Segment 来实现减小锁粒度，分割成若干个 Segment，在 put 的时候需要锁住 Segment，get 时候不加锁，使用 volatile 来保证可见性，当要统计全局时（比如 size），首先会尝试多次计算 modcount 来确定，这几次尝试中，是否有其他线程进行了修改操作，如果没有，则直接返回 size。如果有，则需要依次锁住所有的 Segment 来计算。</p><p>1.8 之前 put 定位节点时要先定位到具体的 segment，然后再在 segment 中定位到具体的桶。而在 1.8 的时候摒弃了 segment 臃肿的设计，直接针对的是 Node[] tale 数组中的每一个桶，进一步减小了锁粒度。并且防止拉链过长导致性能下降，当链表长度大于 8 的时候采用红黑树的设计。</p><p>主要设计上的变化有以下几点:</p><ol><li>不采用 segment 而采用 node，锁住 node 来实现减小锁粒度。</li><li>设计了 MOVED 状态 当 resize 的中过程中 线程 2 还在 put 数据，线程 2 会帮助 resize。</li><li>使用 3 个 CAS 操作来确保 node 的一些操作的原子性，这种方式代替了锁。</li><li>sizeCtl 的不同值来代表不同含义，起到了控制的作用。</li><li>采用 synchronized 而不是 ReentrantLock</li></ol>]]></content>
      
      
      <categories>
          
          <category> JAVA容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java容器 ConcurrentHashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA容器——HashMap</title>
      <link href="/2020/02/25/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94HashMap/"/>
      <url>/2020/02/25/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94HashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="您能给我说说-HashMap-吗？"><a href="#您能给我说说-HashMap-吗？" class="headerlink" title="您能给我说说 HashMap 吗？"></a>您能给我说说 HashMap 吗？</h1><ol><li>HashMap 是基于 Map 接口实现的一种键-值对&lt;key,value&gt;的存储结构，允许 null 值，同时非有序，非同步(即线程不安全)。</li><li>HashMap 的底层实现是数组 + 链表 + 红黑树（JDK1.8 增加了红黑树部分。</li><li>它存储和查找数据时，是根据键 key 的 hashCode 的值计算出具体的存储位置。</li><li>HashMap 增删改查等常规操作都有不错的执行效率，是 ArrayList 和 LinkedList 等数据结构的一种折中实现。</li></ol><h1 id="HashMap-的一些组成部分"><a href="#HashMap-的一些组成部分" class="headerlink" title="HashMap 的一些组成部分"></a>HashMap 的一些组成部分</h1><p>HashMap 的底层实现是数组 + 链表 + 红黑树（JDK1.8 增加了红黑树部分。</p><h2 id="核心组成部分"><a href="#核心组成部分" class="headerlink" title="核心组成部分"></a>核心组成部分</h2><ol><li><p><code>int size;</code> 用于记录 HashMap 实际存储元素的个数；</p></li><li><p><code>float loadFactor;</code> 负载因子（默认是 0.75，此属性后面详细解释）。</p></li><li><p><code>int threshold;</code> 下一次扩容时的阈值，达到阈值便会触发扩容机制 resize（阈值 threshold = 容器容量 capacity * 负载因子 load factor）。也就是说，在容器定义好容量之后，负载因子越大，所能容纳的键值对元素个数就越多。</p></li><li><p><code>Node&lt;K,V&gt;[] table;</code> 底层数组，充当哈希表的作用，用于存储对应 hash 位置的元素 Node&lt;K,V&gt;，此数组长度总是 2 的 N 次幂。（具体原因后面详细解释）</p></li></ol><h2 id="哈希表存储的核心元素"><a href="#哈希表存储的核心元素" class="headerlink" title="哈希表存储的核心元素"></a>哈希表存储的核心元素</h2><ol><li><p><code>final int hash;</code> 元素的哈希值，决定元素存储在 Node&lt;K,V&gt;[] table;哈希表中的位置。由 final 修饰可知，当 hash 的值确定后，就不能再修改。</p></li><li><p><code>final K key;</code> 键，由 final 修饰可知，当 key 的值确定后，就不能再修改。</p></li><li><p><code>V value;</code> 值</p></li><li><p><code>Node&lt;K,V&gt; next;</code> 记录下一个元素结点(单链表结构，用于解决 hash 冲突)</p></li></ol><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94HashMap_2020-02-28-18-54-23.png" alt="JAVA容器——HashMap_2020-02-28-18-54-23.png"></p><h1 id="您能说说-HashMap-常用操作的底层实现原理吗？如存储-put-K-key-V-value-，查找-get-Object-key-，删除-remove-Object-key-，修改-replace-K-key-V-value-等操作。"><a href="#您能说说-HashMap-常用操作的底层实现原理吗？如存储-put-K-key-V-value-，查找-get-Object-key-，删除-remove-Object-key-，修改-replace-K-key-V-value-等操作。" class="headerlink" title="您能说说 HashMap 常用操作的底层实现原理吗？如存储 put(K key, V value)，查找 get(Object key)，删除 remove(Object key)，修改 replace(K key, V value)等操作。"></a>您能说说 HashMap 常用操作的底层实现原理吗？如存储 put(K key, V value)，查找 get(Object key)，删除 remove(Object key)，修改 replace(K key, V value)等操作。</h1><h2 id="put-添加"><a href="#put-添加" class="headerlink" title="put 添加"></a>put 添加</h2><ol><li><p>判断哈希表 <code>Node&lt;K,V&gt;[] table</code> 是否为空或者 <code>null</code>，是则执行 <code>resize()</code>方法进行扩容（初始化）。</p></li><li><p>根据插入的键值 <code>key</code> 的 <code>hash</code> 值（key 的 hashCode 值与 16 的位运算），通过<code>(n - 1) &amp; hash</code> 当前元素的 <code>hash</code> 值 <code>&amp; hash</code> 表长度 - 1（实际就是 <code>hash</code> 值 <code>% hash</code> 表长度） 计算出存储位置 <code>table[i]</code>。如果存储位置没有元素存放，则将新增结点存储在此位置 <code>table[i]</code>。</p></li><li><p>如果存储位置已经有键值对元素存在，则判断该位置元素的 <code>hash</code> 值和 <code>key</code> 值是否和当前操作元素一致，一致则证明是修改 <code>value</code> 操作，覆盖 <code>value</code> 即可。</p></li><li><p>当前存储位置即有元素，又不和当前操作元素一致，则证明此位置 <code>table[i]</code>已经发生了 <code>hash</code> 冲突，则通过判断头结点是否是 <code>treeNode</code>，如果是 <code>treeNode</code> 则证明此位置的结构是红黑树，已红黑树的方式新增结点。</p><ul><li>如果不是红黑树，则证明是单链表，将新增结点插入至链表的最后位置，随后判断当前链表长度是否 大于等于 8，是则将当前存储位置的链表转化为红黑树。遍历过程中如果发现 <code>key</code> 已经存在，则直接覆盖 <code>value</code>。</li><li>插入成功后，判断当前存储键值对的数量 大于 阈值 <code>threshold</code> 是则扩容。</li></ul></li></ol><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加key-value键值对</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果原本存在此key，则返回旧的value值，如果是新增的key-</span></span><br><span class="line"><span class="comment"> *         value，则返回nulll</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实际调用putVal方法进行添加 key-value 键值对操作</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key 键 的 hashCode 通过 “扰动函数” 生成对应的 hash值</span></span><br><span class="line"><span class="comment"> * 经过此操作后，使每一个key对应的hash值生成的更均匀，</span></span><br><span class="line"><span class="comment"> * 减少元素之间的碰撞几率（后面详细说明）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加key-value键值对的实际调用方法（重点）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash key 键的hash值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent 此值如果是true, 则如果此key已存在value，则不执</span></span><br><span class="line"><span class="comment"> * 行修改操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict 此值如果是false，哈希表是在初始化模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回原本的旧值, 如果是新增，则返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于记录当前的hash表</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="comment">// 用于记录当前的链表结点</span></span><br><span class="line">    Node&lt;K,V&gt; p;</span><br><span class="line">    <span class="comment">// n用于记录hash表的长度，i用于记录当前操作索引index</span></span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 当前hash表为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 初始化hash表，并把初始化后的hash表长度值赋值给n</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 1）通过 (n - 1) &amp; hash 当前元素的hash值 &amp; hash表长度 - 1</span></span><br><span class="line">    <span class="comment">// 2）确定当前元素的存储位置，此运算等价于 当前元素的hash值 % hash表的长度</span></span><br><span class="line">    <span class="comment">// 3）计算出的存储位置没有元素存在</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 4) 则新建一个Node结点，在该位置存储此元素</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 当前存储位置已经有元素存在了(不考虑是修改的情况的话，就代表发生hash冲突了)</span></span><br><span class="line">        <span class="comment">// 用于存放新增结点</span></span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="comment">// 用于临时存在某个key值</span></span><br><span class="line">        K k;</span><br><span class="line">        <span class="comment">// 1)如果当前位置已存在元素的hash值和新增元素的hash值相等</span></span><br><span class="line">        <span class="comment">// 2)并且key也相等，则证明是同一个key元素，想执行修改value操作</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;<span class="comment">// 将当前结点引用赋值给e</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 如果当前结点是树结点</span></span><br><span class="line">            <span class="comment">// 则证明当前位置的链表已变成红黑树结构，则已红黑树结点结构新增元素</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">// 排除上述情况，则证明已发生hash冲突，并hash冲突位置现时的结构是单链表结构</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//遍历单链表，将新元素结点放置此链表的最后一位</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 将新元素结点放在此链表的最后一位</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 新增结点后，当前结点数量是否大于等于 阈值 8</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">// 大于等于8则将链表转换成红黑树</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果链表中已经存在对应的key，则覆盖value</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// 已存在对应key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>) <span class="comment">//如果允许修改，则修改value为新值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 当前存储键值对的数量 大于 阈值 是则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">       <span class="comment">// 重置hash大小，将旧hash表的数据逐一复制到新的hash表中（后面详细讲解）</span></span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="comment">// 返回null，则证明是新增操作，而不是修改操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取值-get"><a href="#取值-get" class="headerlink" title="取值 get"></a>取值 get</h2><ol><li><p>先调用 <code>hash(key)</code>方法计算出 <code>key</code> 的 <code>hash</code>值。</p></li><li><p>根据查找的键值<code>key</code>的<code>hash</code>值，通过<code>(n - 1) &amp; hash</code>当前元素的<code>hash</code>值 <code>&amp; hash</code>表长度 <code>- 1</code>（实际就是 <code>hash</code>值 <code>% hash</code>表长度） 计算出存储位置<code>table[i]</code>，判断存储位置是否有元素存在 。</p><ul><li>如果存储位置有元素存放，则首先比较头结点元素，如果头结点的<code>key</code>的<code>hash</code>值 和 要获取的<code>key</code>的<code>hash</code>值相等，并且 头结点的<code>key</code>本身 和要获取的 <code>key</code> 相等，则返回该位置的头结点。</li><li>如果存储位置没有元素存放，则返回<code>null</code>。</li></ul></li><li><p>如果存储位置有元素存放，但是头结点元素不是要查找的元素，则需要遍历该位置进行查找。</p></li><li><p>先判断头结点是否是<code>treeNode</code>，如果是<code>treeNode</code>则证明此位置的结构是红黑树，以红色树的方式遍历查找该结点，没有则返回<code>null</code>。</p></li><li><p>如果不是红黑树，则证明是单链表。遍历单链表，逐一比较链表结点，链表结点的<code>key</code>的<code>hash</code>值 和 要获取的<code>key</code>的<code>hash</code>值相等，并且 链表结点的<code>key</code>本身 和要获取的 <code>key</code> 相等，则返回该结点，遍历结束仍未找到对应<code>key</code>的结点，则返回<code>null</code>。</p></li></ol><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定 key 所映射的 value 值</span></span><br><span class="line"><span class="comment"> * 或者 返回 null 如果容器里不存在对应的key</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 更确切地讲，如果此映射包含一个满足 (key==null ? k==null :key.equals(k))</span></span><br><span class="line"><span class="comment"> * 的从 k 键到 v 值的映射关系，</span></span><br><span class="line"><span class="comment"> * 则此方法返回 v；否则返回 null。（最多只能有一个这样的映射关系。）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回 null 值并不一定 表明该映射不包含该键的映射关系；</span></span><br><span class="line"><span class="comment"> * 也可能该映射将该键显示地映射为 null。可使用containsKey操作来区分这两种情况。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 1.先调用 hash(key)方法计算出 key 的 hash值</span></span><br><span class="line">    <span class="comment">// 2.随后调用getNode方法获取对应key所映射的value值</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取哈希表结点的方法实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash key 键的hash值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回对应的结点，如果结点不存在，则返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于记录当前的hash表</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="comment">// first用于记录对应hash位置的第一个结点，e充当工作结点的作用</span></span><br><span class="line">    Node&lt;K,V&gt; first, e;</span><br><span class="line">    <span class="comment">// n用于记录hash表的长度</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">// 用于临时存放Key</span></span><br><span class="line">    K k;</span><br><span class="line">    <span class="comment">// 通过 (n - 1) &amp; hash 当前元素的hash值 &amp; hash表长度 - 1</span></span><br><span class="line">    <span class="comment">// 判断当前元素的存储位置是否有元素存在</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;<span class="comment">//元素存在的情况</span></span><br><span class="line">       <span class="comment">// 如果头结点的key的hash值 和 要获取的key的hash值相等</span></span><br><span class="line">       <span class="comment">// 并且 头结点的key本身 和要获取的 key 相等</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node 总是检查头结点</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 返回该位置的头结点</span></span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;<span class="comment">// 头结点不相等</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 如果当前结点是树结点</span></span><br><span class="line">                <span class="comment">// 则证明当前位置的链表已变成红黑树结构</span></span><br><span class="line">                <span class="comment">// 通过红黑树结点的方式获取对应key结点</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;<span class="comment">// 当前位置不是红黑树，则证明是单链表</span></span><br><span class="line">                <span class="comment">// 遍历单链表，逐一比较链表结点</span></span><br><span class="line">                <span class="comment">// 链表结点的key的hash值 和 要获取的key的hash值相等</span></span><br><span class="line">                <span class="comment">// 并且 链表结点的key本身 和要获取的 key 相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 找到对应的结点则返回</span></span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过上述查找均无找到，则返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除-remove"><a href="#删除-remove" class="headerlink" title="删除 remove"></a>删除 remove</h2><ol><li><p>先调用 <code>hash(key)</code>方法计算出 <code>key</code> 的 <code>hash</code>值。</p></li><li><p>根据查找的键值<code>key</code>的<code>hash</code>值，通过<code>(n - 1) &amp; hash</code>当前元素的<code>hash</code>值 <code>&amp; hash</code>表长度 - 1（实际就是 <code>hash</code>值 <code>% hash</code>表长度） 计算出存储位置<code>table[i]</code>，判断存储位置是否有元素存在 。</p><ul><li>如果存储位置有元素存放，则首先比较头结点元素，如果头结点的 key 的 hash 值 和 要获取的 key 的 hash 值相等，并且 头结点的 key 本身 和要获取的 key 相等，则该位置的头结点即为要删除的结点，记录此结点至变量 node 中。</li><li>如果存储位置没有元素存放，则没有找到对应要删除的结点，则返回 null。</li></ul></li><li><p>如果存储位置有元素存放，但是头结点元素不是要删除的元素，则需要遍历该位置进行查找。<br>4, 先判断头结点是否是<code>treeNode</code>，如果是<code>treeNode</code>则证明此位置的结构是红黑树，以红色树的方式遍历查找并删除该结点，没有则返回<code>null</code>。</p></li><li><p>如果不是红黑树，则证明是单链表。遍历单链表，逐一比较链表结点，链表结点的<code>key</code>的<code>hash</code>值 和 要获取的<code>key</code>的<code>hash</code>值相等，并且 链表结点的<code>key</code>本身 和要获取的<code>key</code>相等，则此为要删除的结点，记录此结点至变量 <code>node</code> 中，遍历结束仍未找到对应<code>key</code>的结点，则返回<code>null</code>。</p></li><li><p>如果找到要删除的结点 <code>node</code>，则判断是否需要比较 <code>value</code> 也是否一致，如果 <code>value</code> 值一致或者不需要比较 <code>value</code> 值，则执行删除结点操作，删除操作根据不同的情况与结构进行不同的处理。</p><ul><li>如果当前结点是树结点，则证明当前位置的链表已变成红黑树结构，通过红黑树结点的方式删除对应结点。</li><li>如果不是红黑树，则证明是单链表。如果要删除的是头结点，则当前存储位置 <code>table[i]</code> 的头结点指向删除结点的下一个结点。</li><li>如果要删除的结点不是头结点，则将要删除的结点的后继结点 <code>node.next</code> 赋值给要删除结点的前驱结点的 <code>next</code> 域，即 <code>p.next = node.next;</code>。</li></ul></li><li><p><code>HashMap</code> 当前存储键值对的数量 <code>- 1</code>，并返回删除结点。</p></li></ol><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从此映射中移除指定键的映射关系（如果存在）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  key 其映射关系要从映射中移除的键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 与 key 关联的旧值；如果 key 没有任何映射关系，则返回 null。</span></span><br><span class="line"><span class="comment"> *        （返回 null 还可能表示该映射之前将 null 与 key 关联。）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 1.先调用 hash(key)方法计算出 key 的 hash值</span></span><br><span class="line">    <span class="comment">// 2.随后调用removeNode方法删除对应key所映射的结点</span></span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除哈希表结点的方法实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 键的hash值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 用于比较的value值，当matchValue 是 true时才有效, 否则忽略</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> matchValue 如果是 true 只有当value相等时才会移除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> movable 如果是 false当执行移除操作时，不删除其他结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回删除结点node，不存在则返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于记录当前的hash表</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="comment">// 用于记录当前的链表结点</span></span><br><span class="line">    Node&lt;K,V&gt; p;</span><br><span class="line">    <span class="comment">// n用于记录hash表的长度，index用于记录当前操作索引index</span></span><br><span class="line">    <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">// 通过 (n - 1) &amp; hash 当前元素的hash值 &amp; hash表长度 - 1</span></span><br><span class="line">    <span class="comment">// 判断当前元素的存储位置是否有元素存在</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;<span class="comment">// 元素存在的情况</span></span><br><span class="line">        <span class="comment">// node 用于记录找到的结点，e为工作结点</span></span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e;</span><br><span class="line">        K k; V v;</span><br><span class="line">       <span class="comment">// 如果头结点的key的hash值 和 要获取的key的hash值相等</span></span><br><span class="line">       <span class="comment">// 并且 头结点的key本身 和要获取的 key 相等</span></span><br><span class="line">       <span class="comment">// 则证明此头结点就是要删除的结点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 记录要删除的结点的引用地址至node中</span></span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;<span class="comment">// 头结点不相等</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)<span class="comment">// 如果当前结点是树结点</span></span><br><span class="line">                <span class="comment">// 则证明当前位置的链表已变成红黑树结构</span></span><br><span class="line">                <span class="comment">// 通过红黑树结点的方式获取对应key结点</span></span><br><span class="line">                <span class="comment">// 记录要删除的结点的引用地址至node中</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">// 当前位置不是红黑树，则证明是单链表</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">// 遍历单链表，逐一比较链表结点</span></span><br><span class="line">                    <span class="comment">// 链表结点的key的hash值 和 要获取的key的hash值相等</span></span><br><span class="line">                    <span class="comment">// 并且 链表结点的key本身 和要获取的 key 相等</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        <span class="comment">// 找到则记录要删除的结点的引用地址至node中，中断遍历</span></span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果找到要删除的结点，则判断是否需要比较value也是否一致</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">// value值一致或者不需要比较value值，则执行删除结点操作</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 如果当前结点是树结点</span></span><br><span class="line">                <span class="comment">// 则证明当前位置的链表已变成红黑树结构</span></span><br><span class="line">                <span class="comment">// 通过红黑树结点的方式删除对应结点</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p) <span class="comment">// node 和 p相等，则证明删除的是头结点</span></span><br><span class="line">                <span class="comment">// 当前存储位置的头结点指向删除结点的下一个结点</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 删除的不是头结点</span></span><br><span class="line">                <span class="comment">// p是删除结点node的前驱结点，p的next改为记录要删除结点node的后继结点</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">           <span class="comment">// 当前存储键值对的数量 - 1</span></span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="comment">// 返回删除结点</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不存在要删除的结点，则返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="替换-replace"><a href="#替换-replace" class="headerlink" title="替换 replace"></a>替换 replace</h2><ol><li><p>先调用 <code>hash(key)</code>方法计算出 <code>key</code> 的 <code>hash</code>值</p></li><li><p>随后调用<code>getNode</code>方法获取对应<code>key</code>所映射的<code>value</code>值 。</p></li><li><p>记录元素旧值，将新值赋值给元素，返回元素旧值，如果没有找到元素，则返回<code>null</code>。</p></li></ol><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 替换指定 key 所映射的 value 值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 对应要替换value值元素的key键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要替换对应元素的新value值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回原本的旧值，如果没有找到key对应的元素，则返回null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8 JDK1.8新增方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 1.先调用 hash(key)方法计算出 key 的 hash值</span></span><br><span class="line">    <span class="comment">// 2.随后调用getNode方法获取对应key所映射的value值</span></span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span>) &#123;<span class="comment">// 如果找到对应的元素</span></span><br><span class="line">        <span class="comment">// 元素旧值</span></span><br><span class="line">        V oldValue = e.value;</span><br><span class="line">        <span class="comment">// 将新值赋值给元素</span></span><br><span class="line">        e.value = value;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="comment">// 返回元素旧值</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有找到元素，则返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="hash-冲突（或者叫-hash-碰撞）是什么？为什么会出现这种现象，如何解决-hash-冲突？"><a href="#hash-冲突（或者叫-hash-碰撞）是什么？为什么会出现这种现象，如何解决-hash-冲突？" class="headerlink" title="hash 冲突（或者叫 hash 碰撞）是什么？为什么会出现这种现象，如何解决 hash 冲突？"></a>hash 冲突（或者叫 hash 碰撞）是什么？为什么会出现这种现象，如何解决 hash 冲突？</h1><h2 id="hash-冲突"><a href="#hash-冲突" class="headerlink" title="hash 冲突"></a>hash 冲突</h2><p>当我们调用<code>put(K key, V value)</code>操作添加<code>key-value</code>键值对，这个<code>key-value</code>键值对存放在的位置是通过扰动函数<code>(key == null)? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>计算键 <code>key</code> 的 <code>hash</code> 值。随后将 这个 <code>hash</code> 值 <code>%</code>模上 哈希表 <code>Node&lt;K,V&gt;[] table</code> 的长度 得到具体的存放位置。所以 <code>put(K key, V value)</code>多个元素，是有可能计算出相同的存放位置。此现象就是 <code>hash</code> 冲突或者叫 <code>hash</code> 碰撞。</p><h2 id="hash-冲突的避免"><a href="#hash-冲突的避免" class="headerlink" title="hash 冲突的避免"></a>hash 冲突的避免</h2><p>既然会发生<code>hash</code>冲突，我们就应该想办法避免此现象的发生，解决这个问题最关键就是如果生成元素的<code>hash</code>值。<code>Java</code>是使用“扰动函数”生成元素的<code>hash</code>值。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDK 7 的 hash方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">     h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">     <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDK 8 的 hash方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>Java7 做了 4 次 16 位右位移异或混合，Java 8 中这步已经简化了，只做一次 16 位右位移异或混合，而不是四次，但原理是不变的。例子如下：</p><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94HashMap_2020-02-28-19-50-28.png" alt="JAVA容器——HashMap_2020-02-28-19-50-28.png"></p><p>右位移 16 位，正好是 32bit 的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来</p><h2 id="hash-冲突解决："><a href="#hash-冲突解决：" class="headerlink" title="hash 冲突解决："></a>hash 冲突解决：</h2><p>解决<code>hash</code>冲突的方法有很多，常见的有：开发定址法，再散列法，链地址法，公共溢出区法。<code>HashMap</code>是使用链地址法解决<code>hash</code>冲突的，当有冲突元素放进来时，会将此元素插入至此位置链表的最后一位，形成单链表。但是由于是单链表的缘故，每当通过<code>hash % length</code>找到该位置的元素时，均需要从头遍历链表，通过逐一比较<code>hash</code>值，找到对应元素。如果此位置元素过多，造成链表过长，遍历时间会大大增加，最坏情况下的时间复杂度为<code>O(N)</code>，造成查找效率过低。所以当存在位置的链表长度 大于等于 <code>8</code> 时，<code>HashMap</code>会将链表 转变为 红黑树，红黑树最坏情况下的时间复杂度为<code>O(logn)</code>。以此提高查找效率。</p><h1 id="HashMap-的容量为什么一定要是-2-的-n-次方？"><a href="#HashMap-的容量为什么一定要是-2-的-n-次方？" class="headerlink" title="HashMap 的容量为什么一定要是 2 的 n 次方？"></a>HashMap 的容量为什么一定要是 2 的 n 次方？</h1><h2 id="运算效率高"><a href="#运算效率高" class="headerlink" title="运算效率高"></a>运算效率高</h2><p>因为调用 <code>put(K key, V value)</code> 操作添加<code>key-value</code>键值对时，具体确定此元素的位置是通过 <code>hash</code>值 <code>%</code> 模上 哈希表<code>Node&lt;K,V&gt;[] table</code>的长度 <code>hash % length</code> 计算的。但是”模”运算的消耗相对较大，通过位运算<code>h &amp; (length-1)</code>也可以得到取模后的存放位置，而位运算的运行效率高，但只有 length 的长度是 2 的 n 次方时，<code>h &amp; (length-1)</code> 才等价于 <code>h % length</code>。</p><h2 id="分布均匀"><a href="#分布均匀" class="headerlink" title="分布均匀"></a>分布均匀</h2><p>而且当数组长度为 2 的 n 次幂的时候，不同的<code>key</code>算出的<code>index</code>相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。</p><h1 id="HashMap-的负载因子是什么，有什么作用？"><a href="#HashMap-的负载因子是什么，有什么作用？" class="headerlink" title="HashMap 的负载因子是什么，有什么作用？"></a>HashMap 的负载因子是什么，有什么作用？</h1><p>负载因子表示哈希表空间的使用程度</p><ul><li>当负载因子越大，则<code>HashMap</code>的装载程度就越高。也就是能容纳更多的元素，元素多了，发生<code>hash</code>碰撞的几率就会加大，从而链表就会拉长，此时的查询效率就会降低。</li><li>当负载因子越小，则链表中的数据量就越稀疏，此时会对空间造成浪费，但是此时查询效率高。</li></ul><h1 id="扩容？它是怎么扩容的呢？"><a href="#扩容？它是怎么扩容的呢？" class="headerlink" title="扩容？它是怎么扩容的呢？"></a>扩容？它是怎么扩容的呢？</h1><p>当 <code>put</code> 时，如果发现目前的 <code>bucket</code> 占用程度已经超过了 <code>Load Factor</code> 所希望的比例，那么就会发生 <code>resize</code>。在 <code>resize</code> 的过程，简单的说就是把 <code>bucket</code> 扩充为 2 倍，之后重新计算 <code>index</code>，把节点再放到新的 <code>bucket</code> 中。</p><p>当超过限制的时候会<code>resize</code>，然而又因为我们使用的是 2 次幂的扩展(指长度扩为原来 2 倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动 2 次幂的位置。</p><p>怎么理解呢？例如我们从 16 扩展为 32 时，具体的变化如下所示：</p><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94HashMap_2020-02-28-20-03-28.png" alt="JAVA容器——HashMap_2020-02-28-20-03-28.png"></p><p>因此元素在重新计算 <code>hash</code> 之后，因为 n 变为 2 倍，那么 <code>n-1</code> 的 mask 范围在高位多 1bit(红色)，因此新的 index 就会发生这样的变化：</p><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94HashMap_2020-02-28-20-04-09.png" alt="JAVA容器——HashMap_2020-02-28-20-04-09.png"></p><p>因此，我们在扩充 <code>HashMap</code> 的时候，不需要重新计算 <code>hash</code>，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就好了，是 0 的话索引没变，是 1 的话索引变成“原索引+oldCap”。</p><p>这个设计确实非常的巧妙，既省去了重新计算 <code>hash</code> 值的时间，而且同时，由于新增的 1bit 是 0 还是 1 可以认为是随机的，因此 <code>resize</code> 的过程，均匀的把之前的冲突的节点分散到新的 <code>bucket</code> 了。</p><h1 id="拉链法插入链表-为啥-java7-之前用头插法，java8-之后改成尾插了呢？"><a href="#拉链法插入链表-为啥-java7-之前用头插法，java8-之后改成尾插了呢？" class="headerlink" title="拉链法插入链表 为啥 java7 之前用头插法，java8 之后改成尾插了呢？"></a>拉链法插入链表 为啥 java7 之前用头插法，java8 之后改成尾插了呢？</h1><p>使用头插会改变链表的上的顺序，但是如果使用尾插，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了。</p><ul><li>Java7 在多线程操作 HashMap 时可能引起死循环，原因是扩容转移后前后链表顺序倒置，在转移过程中修改了原来链表中节点的引用关系。</li><li>Java8 在同样的前提下并不会引起死循环，原因是扩容转移后前后链表顺序不变，保持之前节点的引用关系。</li></ul><h1 id="您能说说-HashMap-和-HashTable-的区别吗？"><a href="#您能说说-HashMap-和-HashTable-的区别吗？" class="headerlink" title="您能说说 HashMap 和 HashTable 的区别吗？"></a>您能说说 HashMap 和 HashTable 的区别吗？</h1><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>Hashtable 继承了 Dictionary 类，而 HashMap 继承的是 AbstractMap 类。</p><h2 id="容器整体结构"><a href="#容器整体结构" class="headerlink" title="容器整体结构"></a>容器整体结构</h2><ul><li><code>HashMap</code>的<code>key</code>和<code>value</code>都允许为<code>null</code>，<code>HashMap</code>遇到<code>key</code>为<code>null</code>的时候，调用<code>putForNullKey</code>方法进行处理，而对<code>value</code>没有处理。</li><li><code>Hashtable</code> 的 <code>key</code> 和 <code>value</code> 都不允许为 <code>null</code>。<code>Hashtable</code> 遇到 <code>null</code>，直接返回 <code>NullPointerException</code>。</li></ul><h2 id="初始化容量和扩容机制"><a href="#初始化容量和扩容机制" class="headerlink" title="初始化容量和扩容机制"></a>初始化容量和扩容机制</h2><ul><li><code>HashMap</code>默认初始化容量为 16，并且容器容量一定是 2 的 n 次方，扩容时，是以原容量 2 倍 的方式 进行扩容。</li><li><code>Hashtable</code>默认初始化容量为 11，扩容时，是以原容量 2 倍 再加 1 的方式进行扩容。即<code>int newCapacity = (oldCapacity &lt;&lt; 1) + 1</code>;。</li></ul><h2 id="迭代方式不同"><a href="#迭代方式不同" class="headerlink" title="迭代方式不同"></a>迭代方式不同</h2><p>HashMap 中的 Iterator 迭代器是 fail-fast 的，而 Hashtable 的 Enumerator 不是 fail-fast 的。</p><h2 id="线程安全（最重要）"><a href="#线程安全（最重要）" class="headerlink" title="线程安全（最重要）"></a>线程安全（最重要）</h2><ul><li><code>HashMap</code> 不是线程安全，如果想线程安全，可以通过调用<code>synchronizedMap(Map&lt;K,V&gt; m)</code>使其线程安全。但是使用时的运行效率会下降，所以建议使用<code>ConcurrentHashMap</code>容器以此达到线程安全。</li><li><code>Hashtable</code>则是线程安全的，每个操作方法前都有<code>synchronized</code>修饰使其同步，但运行效率也不高，所以还是建议使用<code>ConcurrentHashMap</code>容器以此达到线程安全。</li></ul><p>因此，<code>Hashtable</code>是一个遗留容器，如果我们不需要线程同步，则建议使用<code>HashMap</code>，如果需要线程同步，则建议使用<code>ConcurrentHashMap</code>。</p><h1 id="谈谈-HashMap-线程不安全的体现"><a href="#谈谈-HashMap-线程不安全的体现" class="headerlink" title="谈谈 HashMap 线程不安全的体现"></a>谈谈 HashMap 线程不安全的体现</h1><p>那么，为什么说 HashMap 是线程不安全的呢？它在多线程环境下，会发生什么情况呢？</p><h2 id="resize-死循环-JDK7"><a href="#resize-死循环-JDK7" class="headerlink" title="resize 死循环(JDK7)"></a>resize 死循环(JDK7)</h2><p>我们都知道 HashMap 初始容量大小为 16,一般来说，当有数据要插入时，都会检查容量有没有超过设定的 thredhold，如果超过，需要增大 Hash 表的尺寸，但是这样一来，整个 Hash 表里的元素都需要被重算一遍。这叫 rehash，这个成本相当的大。<br>对索引数组中的元素遍历</p><p>对链表上的每一个节点遍历：用 next 取得要转移那个元素的下一个，将 e 转移到新 Hash 表的头部，使用头插法插入节点。</p><p>循环 2，直到链表节点全部转移</p><p>循环 1，直到所有索引数组全部转移</p><p>经过这几步，我们会发现转移的时候是逆序的。假如转移前链表顺序是 1-&gt;2-&gt;3，那么转移后就会变成 3-&gt;2-&gt;1。这时候就有点头绪了，死锁问题不就是因为 1-&gt;2 的同时 2-&gt;1 造成的吗？所以，HashMap 的死锁问题就出在这个 transfer()函数上。</p><h2 id="fail-fast"><a href="#fail-fast" class="headerlink" title="fail-fast"></a>fail-fast</h2><p>如果在使用迭代器的过程中有其他线程修改了 map，那么将抛出 ConcurrentModificationException，这就是所谓 fail-fast 策略。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java容器 HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA容器——LinkedList</title>
      <link href="/2020/02/25/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94LinkedList/"/>
      <url>/2020/02/25/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94LinkedList/</url>
      
        <content type="html"><![CDATA[<h1 id="请简单介绍一下您所了解的-LinkedList，它可以用来做什么，怎么使用？"><a href="#请简单介绍一下您所了解的-LinkedList，它可以用来做什么，怎么使用？" class="headerlink" title="请简单介绍一下您所了解的 LinkedList，它可以用来做什么，怎么使用？"></a>请简单介绍一下您所了解的 LinkedList，它可以用来做什么，怎么使用？</h1><ol><li>LinkedList 底层是双向链表，同时实现了<code>List</code>接口和<code>Deque</code>接口，所以它既可以看作是一个顺序容器，也可以看作是一个队列(Queue)，同时也可以看作是一个栈(Stack)，但如果想使用栈或队列等数据结构的话，推荐使用 ArrayDeque，它作为栈或队列会比 LinkedList 有更好的使用性能。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个LinkedList，链表的每个节点的内存空间都是实时分配的，所以无须事先指定容器大小</span></span><br><span class="line">LinkedList&lt;String&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line"><span class="comment">// 往容器里面添加元素</span></span><br><span class="line">linkedList.add(<span class="string">"张三"</span>);</span><br><span class="line">linkedList.add(<span class="string">"李四"</span>);</span><br><span class="line"><span class="comment">// 在张三与李四之间插入一个王五</span></span><br><span class="line">linkedList.add(<span class="number">1</span>, <span class="string">"王五"</span>);</span><br><span class="line"><span class="comment">// 在头部插入一个小三</span></span><br><span class="line">linkedList.addFirst(<span class="string">"小三"</span>);</span><br><span class="line"><span class="comment">// 获取index下标为2的元素 王五</span></span><br><span class="line">String element = linkedList.get(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 修改index下标为2的元素 王五 为小四</span></span><br><span class="line">linkedList.set(<span class="number">2</span>, <span class="string">"小四"</span>);</span><br><span class="line"><span class="comment">// 删除index下标为1的元素 张三</span></span><br><span class="line">String removeElement = linkedList.remove(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 删除第一个元素</span></span><br><span class="line">String removeFirstElement = linkedList.removeFirst();</span><br><span class="line"><span class="comment">// 删除最后一个元素</span></span><br><span class="line">String removeLastElement = linkedList.removeLast();</span><br></pre></td></tr></table></figure><ol start="2"><li>LinkedList 底层实现是双向链表，核心组成元素有：<code>int size = 0</code>用于记录链表长度；<code>Node&lt;E&gt; first</code>;用于记录头（第一个）结点（储存的是头结点的引用）；<code>Node&lt;E&gt; last</code>;用于记录尾（最后一个）结点（储存的是尾结点的引用）。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 记录链表长度</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to first node. 指向第一个结点</span></span><br><span class="line"><span class="comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">     *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to last node. 指向最后一个结点</span></span><br><span class="line"><span class="comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">     *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>双向链表的核心组成元素还有一个最重要的<code>Node&lt;E&gt;</code>，<code>Node&lt;E&gt;</code>包含：<code>E item</code>; 用于存储元素数据，<code>Node&lt;E&gt; next</code>; 指向当前元素的后继结点，<code>Node&lt;E&gt; prev</code>; 指向当前元素的前驱结点。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义LinkedList底层的结点实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item; <span class="comment">// 存储元素数据</span></span><br><span class="line">    Node&lt;E&gt; next;<span class="comment">// 指向当前元素的后继结点</span></span><br><span class="line">    Node&lt;E&gt; prev;<span class="comment">// 指向当前元素的前驱结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Node结点构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;<span class="comment">// 存储的元素</span></span><br><span class="line">        <span class="keyword">this</span>.next = next;<span class="comment">// 后继结点</span></span><br><span class="line">        <span class="keyword">this</span>.prev = prev;<span class="comment">// 前驱结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>双向链表底层视图：</li></ul><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94LinkedList_2020-02-25-16-22-31.png" alt="JAVA容器——LinkedList_2020-02-25-16-22-31.png"></p><h1 id="请分别分析一下它是如何获取元素，修改元素，新增元素与删除元素，并分析这些操作对应的时间复杂度。"><a href="#请分别分析一下它是如何获取元素，修改元素，新增元素与删除元素，并分析这些操作对应的时间复杂度。" class="headerlink" title="请分别分析一下它是如何获取元素，修改元素，新增元素与删除元素，并分析这些操作对应的时间复杂度。"></a>请分别分析一下它是如何获取元素，修改元素，新增元素与删除元素，并分析这些操作对应的时间复杂度。</h1><h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><p>LinkedList 提供了三种获取元素的方法，分别是：</p><ol><li><p>获取第一个元素 getFirst()，获取第一个元素，直接返回 Node<E> first 指向的结点即可，所以时间复杂度为 O(1)。</p></li><li><p>获取最后一个元素 getLast()，获取最后一个元素，直接返回 Node<E> last 指向的结点即可，所以时间复杂度也为 O(1)。</p></li><li><p>获取指定索引 index 位置的元素 <code>get(int index)</code>，由于 <code>Node&lt;E&gt;</code>结点在内存中存储的空间不是连续存储的，所以查找某一位置的结点，只能通过遍历链表的方式查找结点，因此 LinkedList 会先通过判断 <code>index &lt; (size &gt;&gt; 1)</code>，<code>size&gt;&gt;1</code> 即为 <code>size/2</code> 当前链表长度的一半，判断 index 的位置是在链表的前半部分还是后半部分。决定是从头部遍历查找数据还是从尾部遍历查找数据。最坏情况下，获取中间元素，则需要遍历 n/2 次才能获取到对应元素，所以此方法的时间复杂度为 O(n)。</p></li></ol><p>综上所述，LinkedList 获取元素的时间复杂度为 O(n)。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回列表中指定位置的元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定index位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回指定位置的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查index下标是否合法[0,size)</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// 遍历列表获取对应index位置的元素</span></span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查下标是否合法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isElementIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定位置的结点元素（重点）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="comment">// 判断index位置是在链表的前半部分还是后半部分</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// 从头结点开始，从前往后遍历找到对应位置的结点元素</span></span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从尾结点开始，从后往前遍历找到对应位置的结点元素</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h2><p>LinkedList 提供了一种修改元素数据的方法 set(int index, E element)，修改元素数据的步骤是：1.检查 index 索引是否合法[0,size)。2.折半查询获取对应索引元素。3.将新元素赋值，返回旧元素。由获取元素的分析可知，折半查询的时间复杂度为 O(n)，故修改元素数据的时间复杂度为 O(n)。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改指定位置结点的存储数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 修改的存储数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回未修改前的存储数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查index下标是否合法[0,size)</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// 折半查询获取对应索引元素</span></span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    <span class="comment">// 将新元素赋值，返回旧元素</span></span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="新增元素"><a href="#新增元素" class="headerlink" title="新增元素"></a>新增元素</h2><p>LinkedList 提供了四种新增元素的方法，分别是：</p><ol><li><p>将指定元素插入到链表的第一个位置中 addFirst(E e)，只需将头结点 first 指向新元素结点，将原第一结点的前驱指针指向新元素结点即可。不需要移动原数据存储位置，只需交换一下相关结点的指针域信息即可。所以时间复杂度为 O(1)。</p></li><li><p>将指定元素插入到链表的最后一个位置中 addLast(E e)，只需将尾结点 last 指向新元素结点，将原最后一个结点的后继指针指向新元素结点即可。不需要移动原数据存储位置，只需交换一下相关结点的指针域信息即可。所以时间复杂度也为 O(1)。</p></li><li><p>添加元素方法 add(E e) 等价于 addLast(E e)。</p></li><li><p>将指定元素插入到链表的指定位置 index 中 add(int index, E element)，需要先根据位置 index 调用 node(index)遍历链表获取该位置的原结点，然后将新结点插入至原该位置结点的前面，不需要移动原数据存储位置，只需交换一下相关结点的指针域信息即可。所以时间复杂度也为 O(1)。</p></li></ol><p>综上所述，LinkedList 新增元素的时间复杂度为 O(1)，单纯论插入新元素，操作是非常高效的，特别是插入至头部或插入到尾部。但如果是通过索引 index 的方式插入，插入的位置越靠近链表中间所费时间越长，因为需要对链表进行遍历查找。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定元素插入到链表的第一个位置中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要插入的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将元素e作为第一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取原头结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">// 初始化新元素结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    <span class="comment">// 头指针指向新元素结点</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="comment">// 如果是第一个元素（链表为空）</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 将尾指针也指向新元素结点</span></span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 链表不会空</span></span><br><span class="line">        <span class="comment">// 原头结点的前驱指针指向新结点</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    <span class="comment">// 记录链表长度的size + 1</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定元素插入到链表的最后一个位置中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;此方法等同与add(E e)方法 &#123;<span class="doctag">@link</span> #add&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要插入的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定元素插入到链表的最后一个位置中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;此方法等同与addLast(E e)方法  &#123;<span class="doctag">@link</span> #addLast&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要插入的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将元素e作为最后一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取原尾结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 初始化新元素结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 位指针指向新元素结点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">// 如果是第一个元素（链表为空）</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 将头指针也指向新元素结点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 链表不会空</span></span><br><span class="line">        <span class="comment">// 原尾结点的后继指针指向新结点</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    <span class="comment">// 记录链表长度的size + 1</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定元素插入到链表的指定位置index中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 元素要插入的位置index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 要插入的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查插入位置是否合法[0,size]</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="comment">// 如果插入的位置和当前链表长度相等，则直接将元素插入至链表的尾部</span></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        <span class="comment">// 将元素插入至链表的尾部</span></span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//将元素插入至指定位置,node(index)先获取占有该index位置的原结点</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查位置是否合法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查位置是否合法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//合法位置为[0,size]</span></span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将新元素e插入至旧元素succ前面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="comment">// 记录旧元素结点succ的前驱指针</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="comment">// 初始化新元素结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    <span class="comment">// 旧元素结点的前驱指针指向新元素结点(即新元素结点放至在旧元素结点的前面，取代了原本旧元素的位置)</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="comment">// 如果旧元素结点的前驱指针为空，则证明旧元素结点是头结点，</span></span><br><span class="line">    <span class="comment">// 将新元素结点插入至旧元素结点前面，所以现时新的头结点是新元素结点</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//不是插入至头部</span></span><br><span class="line">        <span class="comment">// 旧元素的前驱结点的后继指针指向新元素结点</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    <span class="comment">// 记录链表长度的size + 1</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>LinkedList 提供了四种删除元素的方法，分别是：</p><ol><li><p>删除链表中的第一个元素<code>removeFirst()</code>，只需将头结点<code>first</code>指向删除元素结点的后继结点并将其前驱结点指针信息<code>prev</code>清空即可。不需要移动原数据存储位置，只需操作相关结点的指针域信息即可。所以时间复杂度为 O(1)。</p></li><li><p>删除链表中的最后一个元素<code>removeLast()</code>，只需将尾结点<code>last</code>指向删除元素结点的前驱结点并将其后继结点指针信息<code>next</code>清空即可。不需要移动原数据存储位置，只需操作相关结点的指针域信息即可，所以时间复杂度也为 O(1)。</p></li><li><p>将指定位置 index 的元素删除<code>remove(int index)</code>，需要先根据位置 index 调用<code>node(index)</code>遍历链表获取该位置的原结点，然后将删除元素结点的前驱结点的 next 后继结点指针域指向删除元素结点的后继结点<code>node.prev.next = node.next</code>，删除元素结点的后继结点的 prev 前驱结点指针域指向删除元素结点的前驱结点即可<code>node.next.prev = node.prev</code>（此处可能有些绕，不太理解的同学自行学习一下双向链表的数据结构吧），不需要移动原数据存储位置，只需交换一下相关结点的指针域信息即可。所以时间复杂度也为 O(1)。</p></li><li><p>删除传入的 Object o 指定对象，比较对象是否一致通过<code>o.equals</code>方法比较<code>remove(Object o)</code>，和 3.的思路基本差不多，关键是比较对象是通过<code>o.equals</code>方法，记住这点即可。</p></li></ol><p>综上所述，LinkedList 删除元素的时间复杂度为 O(1)，单纯论删除元素，操作是非常高效的，特别是删除第一个结点或删除最后一个结点。但如果是通过索引 index 的方式或者 object 对象的方式删除，则需要对链表进行遍历查找对应 index 索引的对象或者利用 equals 方法判断对象。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除链表中的第一个元素并返回</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 链表中的第一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据头结点获取第一个元素结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>) <span class="comment">// 没有元素结点则抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除第一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="comment">// 记录要移除元素结点的数据域</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="comment">// 记录要移除元素结点的后继结点指针</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    <span class="comment">// 清空要删除结点的数据域和next指针域信息，以帮助垃圾回收</span></span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    <span class="comment">// 头结点指向要移除元素结点的后继结点</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="comment">// 如果要移除元素结点的后继结点为空，则证明链表只有一个元素</span></span><br><span class="line">    <span class="comment">// 所以需要将尾结点的指针信息也要清空</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 将新的第一个结点的前驱结点指针信息清空</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 记录链表长度的size - 1</span></span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 返回移除元素结点的数据域</span></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除链表中的最后一个元素并返回</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 链表中的最后一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据尾结点获取最后一个元素结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)<span class="comment">// 没有元素结点则抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除最后一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">    <span class="comment">// 记录要移除元素结点的数据域</span></span><br><span class="line">    <span class="keyword">final</span> E element = l.item;</span><br><span class="line">    <span class="comment">// 记录要移除元素结点的前驱结点指针</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    <span class="comment">// 清空要删除结点的数据域和prev指针域信息，以帮助垃圾回收</span></span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    <span class="comment">// 头结点指向要移除元素结点的前驱结点</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="comment">// 如果要移除元素结点的前驱结点为空，则证明链表只有一个元素</span></span><br><span class="line">    <span class="comment">// 所以需要将头结点的指针信息也要清空</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 将新的最后一个结点的后继结点指针信息清空</span></span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 记录链表长度的size - 1</span></span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 返回移除元素结点的数据域</span></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定位置index的元素删除</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 要删除的位置index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 要删除位置的原元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查index下标是否合法[0,size)</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// 根据index进行遍历链表获取要删除的结点，再调用unlink方法进行删除</span></span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除传入的Object o指定对象，比较对象是否一致通过o.equals方法比较</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 要删除的Object o指定对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 是否存在要删除对象o</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果删除对象为null，则遍历链表查找node.item数据域为null的结点并移除</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从头开始遍历链表，并通过equals方法逐一比较node.item是否相等</span></span><br><span class="line">        <span class="comment">// 相等则对象一致，删除此对象。</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除指定结点x</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="comment">// 记录要移除元素结点的数据域</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="comment">// 记录要移除元素结点的后继结点指针</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="comment">// 记录要移除元素结点的前驱结点指针</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果要移除元素结点的前驱结点为空，则证明要删除结点为第一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 头结点指向要删除元素结点的后继结点</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 要删除元素结点的前驱结点的后继指针指向要删除元素结点的后继结点</span></span><br><span class="line">        prev.next = next;</span><br><span class="line">        <span class="comment">// 清空要删除结点的前驱结点指针信息，以帮助GC</span></span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果要移除元素结点的后继结点为空，则证明要删除结点为最后一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 尾结点指向要删除元素结点的前驱结点</span></span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 要删除元素结点的后继结点的前驱指针指向要删除元素结点的前驱结点</span></span><br><span class="line">        next.prev = prev;</span><br><span class="line">        <span class="comment">// 清空要删除结点的后继结点指针信息，以帮助GC</span></span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空要删除元素的数据域，以帮助GC</span></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 记录链表长度的size - 1</span></span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 返回移除元素结点的数据域</span></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="那您可以比较一下-ArrayList-和-LinkedList-吗"><a href="#那您可以比较一下-ArrayList-和-LinkedList-吗" class="headerlink" title="那您可以比较一下 ArrayList 和 LinkedList 吗?"></a>那您可以比较一下 ArrayList 和 LinkedList 吗?</h1><h2 id="更占内存"><a href="#更占内存" class="headerlink" title="更占内存"></a>更占内存</h2><p>LinkedList 内部存储的是 Node<E>，不仅要维护数据域，还要维护 prev 和 next，如果 LinkedList 中的结点特别多，则 LinkedList 比 ArrayList 更占内存。</p><h2 id="插入删除效率高"><a href="#插入删除效率高" class="headerlink" title="插入删除效率高"></a>插入删除效率高</h2><p>LinkedList 在做插入和删除操作时，插入或删除头部或尾部时是高效的，操作越靠近中间位置的元素时，需要遍历查找，速度相对慢一些，如果在数据量较大时，每次插入或删除时遍历查找比较费时。所以 LinkedList 插入与删除，慢在遍历查找，快在只需要更改相关结点的引用地址。ArrayList 在做插入和删除操作时，插入或删除尾部时也一样是高效的，操作其他位置，则需要批量移动元素，所以 ArrayList 插入与删除，快在遍历查找，慢在需要批量移动元素。</p><h2 id="循环遍历效率低"><a href="#循环遍历效率低" class="headerlink" title="循环遍历效率低"></a>循环遍历效率低</h2><ul><li>由于 ArrayList 实现了 RandomAccess 随机访问接口，所以使用 for(int i = 0; i &lt; size; i++)遍历会比使用 Iterator 迭代器来遍历快：</li><li>而由于 LinkedList 未实现 RandomAccess 接口，所以推荐使用 Iterator 迭代器来遍历数据。</li><li>因此，如果我们需要频繁在列表的中部改变插入或删除元素时，建议使用 LinkedList，否则，建议使用 ArrayList，因为 ArrayList 遍历查找元素较快，并且只需存储元素的数据域，不需要额外记录其他数据的位置信息，可以节省内存空间。</li></ul><h1 id="LinkedList-是线程安全的吗？"><a href="#LinkedList-是线程安全的吗？" class="headerlink" title="LinkedList 是线程安全的吗？"></a>LinkedList 是线程安全的吗？</h1><p>LinkedList 不是线程安全的，如果多个线程同时对同一个 LinkedList 更改数据的话，会导致数据不一致或者数据污染。如果出现线程不安全的操作时，LinkedList 会尽可能的抛出<code>ConcurrentModificationException</code>防止数据异常，当我们在对一个 LinkedList 进行遍历时，在遍历期间，我们是不能对 LinkedList 进行添加，删除等更改数据结构的操作的，否则也会抛出<code>ConcurrentModificationException</code>异常，此为 fail-fast（快速失败）机制。从源码上分析，我们在 add,remove 等更改 LinkedList 数据时，都会导致 modCount 的改变，当<code>expectedModCount != modCount</code>时，则抛出<code>ConcurrentModificationException</code>。如果想要线程安全，可以考虑调用<code>Collections.synchronizedCollection(Collection&lt;T&gt; c)</code>方法。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>参考资料</p>]]></content>
      
      
      <categories>
          
          <category> JAVA容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java容器 LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA容器——ArrayList</title>
      <link href="/2020/02/24/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ArrayList/"/>
      <url>/2020/02/24/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ArrayList/</url>
      
        <content type="html"><![CDATA[<h1 id="ArrayList-有用过吗？它是一个什么东西？可以用来干嘛？"><a href="#ArrayList-有用过吗？它是一个什么东西？可以用来干嘛？" class="headerlink" title="ArrayList 有用过吗？它是一个什么东西？可以用来干嘛？"></a>ArrayList 有用过吗？它是一个什么东西？可以用来干嘛？</h1><h2 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h2><p>ArrayList 就是数组列表，主要用来装载数据，当我们装载的是基本类型的数据 int，long，boolean，short，byte…的时候我们只能存储他们对应的包装类，它的主要底层实现是数组 Object[] elementData。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>ArrayList 底层是用数组实现的存储。</li><li>初始化容量为 10，扩容为 1.5 倍。</li><li>查询效率高，增删效率低，线程不安全。使用频率很高。</li></ul><h1 id="为啥线程不安全还使用他呢？"><a href="#为啥线程不安全还使用他呢？" class="headerlink" title="为啥线程不安全还使用他呢？"></a>为啥线程不安全还使用他呢？</h1><h2 id="用于查询较多"><a href="#用于查询较多" class="headerlink" title="用于查询较多"></a>用于查询较多</h2><p>因为我们正常使用的场景中，都是用来查询，不会涉及太频繁的增删，如果涉及频繁的增删，可以使用 LinkedList，如果你需要线程安全就使用 Vector，这就是三者的区别了，实际开发过程中还是 ArrayList 使用最多的。</p><h2 id="综合考虑安全和性能"><a href="#综合考虑安全和性能" class="headerlink" title="综合考虑安全和性能"></a>综合考虑安全和性能</h2><p>不存在一个集合工具是查询效率又高，增删效率也高的，还线程安全的，至于为啥大家看代码就知道了，因为数据结构的特性就是优劣共存的，想找个平衡点很难，牺牲了性能，那就安全，牺牲了安全那就快速。</p><h1 id="您说它的底层实现是数组，但是数组的大小是定长的，如果我们不断的往里面添加数据的话，不会有问题吗？"><a href="#您说它的底层实现是数组，但是数组的大小是定长的，如果我们不断的往里面添加数据的话，不会有问题吗？" class="headerlink" title="您说它的底层实现是数组，但是数组的大小是定长的，如果我们不断的往里面添加数据的话，不会有问题吗？"></a>您说它的底层实现是数组，但是数组的大小是定长的，如果我们不断的往里面添加数据的话，不会有问题吗？</h1><p>ArrayList 可以通过构造方法在初始化的时候指定底层数组的大小；</p><p>通过无参构造方法的方式 <code>ArrayList()</code> 初始化，则赋值底层数 <code>Object[] elementData</code> 为一个默认空数组 <code>Object[]DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}</code> 所以数组容量为 <code>0</code>，只有真正对数据进行添加 <code>add</code> 时，才分配默认 <code>DEFAULT_CAPACITY = 10</code> 的初始容量。</p><p>容量超过 <code>10</code> 时，会创建一个容量 <code>1.5</code> 倍的空数组，将原有数据拷贝过去。</p><h1 id="能具体说下-1-7-和-1-8-版本初始化的时候的区别么？"><a href="#能具体说下-1-7-和-1-8-版本初始化的时候的区别么？" class="headerlink" title="能具体说下 1.7 和 1.8 版本初始化的时候的区别么？"></a>能具体说下 1.7 和 1.8 版本初始化的时候的区别么？</h1><p>1.7 开始变化有点大，一个是初始化的时候，1.7 以前会调用 <code>this(10)</code> 才是真正的容量为 10，1.7 即本身以后是默认走了空数组，只有第一次 <code>add</code> 的时候容量会变成 10。</p><h1 id="我记得你说到了，他增删很慢，你能说一下-ArrayList-在增删的时候是怎么做的么？主要说一下他为啥慢。"><a href="#我记得你说到了，他增删很慢，你能说一下-ArrayList-在增删的时候是怎么做的么？主要说一下他为啥慢。" class="headerlink" title="我记得你说到了，他增删很慢，你能说一下 ArrayList 在增删的时候是怎么做的么？主要说一下他为啥慢。"></a>我记得你说到了，他增删很慢，你能说一下 ArrayList 在增删的时候是怎么做的么？主要说一下他为啥慢。</h1><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>他有指定 index 新增，也有直接新增的，在这之前他会有一步校验长度的判断 ensureCapacityInternal，就是说如果长度不够，是需要扩容的。</p><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ArrayList_2020-02-24-15-55-53.png" alt="JAVA容器——ArrayList_2020-02-24-15-55-53.png"></p><p>在扩容的时候，老版本的 jdk 和 8 以后的版本是有区别的，8 之后的效率更高了，采用了位运算，右移一位，其实就是除以 2 这个操作。</p><p>1.7 的时候 3/2+1 ，1.8 直接就是 3/2。</p><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ArrayList_2020-02-24-15-56-30.png" alt="JAVA容器——ArrayList_2020-02-24-15-56-30.png"></p><h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><p>指定位置新增的时候，在校验之后的操作很简单，就是数组的 copy，大家可以看下代码。</p><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ArrayList_2020-02-24-16-04-27.png" alt="JAVA容器——ArrayList_2020-02-24-16-04-27.png"></p><p>不知道大家看懂 arraycopy 的代码没有，我画个图解释下，你可能就明白一点：</p><p>比如有下面这样一个数组我需要在 index 5 的位置去新增一个元素 A</p><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ArrayList_2020-02-24-16-04-56.png" alt="JAVA容器——ArrayList_2020-02-24-16-04-56.png"></p><p>那从代码里面我们可以看到，他复制了一个数组，是从 index 5 的位置开始的，然后把它放在了 index 5+1 的位置</p><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ArrayList_2020-02-24-16-05-25.png" alt="JAVA容器——ArrayList_2020-02-24-16-05-25.png"></p><p>给我们要新增的元素腾出了位置，然后在 index 的位置放入元素 A 就完成了新增的操作了</p><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ArrayList_2020-02-24-16-05-52.png" alt="JAVA容器——ArrayList_2020-02-24-16-05-52.png"></p><p>至于为啥说他效率低，我想我不说你也应该知道了，我这只是在一个这么小的 List 里面操作，要是我去一个几百几千几万大小的 List 新增一个元素，那就需要后面所有的元素都复制，然后如果再涉及到扩容啥的就更慢了不是嘛。</p><h1 id="ArrayList-插入删除一定慢么？"><a href="#ArrayList-插入删除一定慢么？" class="headerlink" title="ArrayList 插入删除一定慢么？"></a>ArrayList 插入删除一定慢么？</h1><p>取决于你删除的元素离数组末端有多远，ArrayList 拿来作为堆栈来用还是挺合适的，push 和 pop 操作完全不涉及数据移动操作。</p><h1 id="那他的删除是怎么实现的那？"><a href="#那他的删除是怎么实现的那？" class="headerlink" title="那他的删除是怎么实现的那？"></a>那他的删除是怎么实现的那？</h1><p>删除其实跟新增是一样的，不过叫是叫删除，但是在代码里面我们发现，他还是在 copy 一个数组。</p><h1 id="ArrayList-的遍历和-LinkedList-遍历性能比较如何？"><a href="#ArrayList-的遍历和-LinkedList-遍历性能比较如何？" class="headerlink" title="ArrayList 的遍历和 LinkedList 遍历性能比较如何？"></a>ArrayList 的遍历和 LinkedList 遍历性能比较如何？</h1><p>论遍历 ArrayList 要比 LinkedList 快得多，ArrayList 遍历最大的优势在于内存的连续性，CPU 的内部缓存结构会缓存连续的内存片段，可以大幅降低读取内存的性能开销。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ArrayList 就是动态数组，用 MSDN 中的说法，就是 Array 的复杂版本，它提供了动态的增加和减少元素，实现了 ICollection 和 IList 接口，灵活的设置数组的大小等好处。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java容器 ArrayList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA容器——概述</title>
      <link href="/2020/02/24/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/02/24/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>Java 的容器是前人为我们设计好的一套存储对象和数据的一套轮子，通过使用 Java 中写好的容器 API 我们可以很方便的存储、操作我们的数据。</p><h1 id="容器的分类"><a href="#容器的分类" class="headerlink" title="容器的分类"></a>容器的分类</h1><p>容器主要包括 Collection 和 Map 两种：</p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>主要是单个元素的集合，由 List、Queue、Set 三个接口区分不同的集合特征，然后由下面的具体的类来实现对应的功能。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>有一组键值对的存储形式来保存，可以用键对象来查找值。</p><h2 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h2><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0_2020-02-24-14-44-33.png" alt="JAVA容器——概述_2020-02-24-14-44-33.png"></p><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0_2020-02-24-14-45-06.png" alt="JAVA容器——概述_2020-02-24-14-45-06.png"></p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>List 的特点就是所有的元素是可以重复的。</p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><ul><li>底层由 Object 数组实现。</li><li>默认长度为 10，每次扩容 1.5 倍，也可以自定义初始长度。</li><li>元素存放数据为遍历顺序。</li><li>访问与查找速度快，删除与插入速度慢。</li><li>toArray：把 LinkedList 转化为 Array</li></ul><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>底层由链表（双向链表）实现。</li><li>在列表中插入和删除速度快，但是查找需要遍历整个链表。</li><li>可以通过它实现队列和栈。</li><li>动态改变大小（链表特性）</li></ul><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li>getFirst 和 element 都返回列表的头，但是不删除它，如果列表为空，抛出异常</li><li>peek 实现的功能一样，但是列表为空时返回 null</li><li>removeFirst 和 remove 都是删除并返回列表的头，如果列表为空抛出异常</li><li>pool 实现的功能一样，但是列表为空时返回 null</li></ul><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><ul><li>底层由数组实现</li><li>synchronized 进行同步，线程安全</li><li>插入、删除、访问速度慢</li></ul><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p>队列是一个满足“先进先出”的数据结构。<br>LinkedList 提供了方法支持队列操作，并且实现了 Queue 接口，所以 LinkedList 是队列的一种实现，可以通过 LinkedList 向上转型为 Queue</p><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><ul><li>offer:讲一个元素插入对尾</li><li>peek:不移除的情况下将元素插入队尾，队列为空返回 null</li><li>element:不移除的情况下将元素插入队尾，队列为空报错</li><li>poll:移除并返回队头，队列为空返回 null</li><li>remove:不移除的情况下将元素插入队尾，队列为空报错</li></ul><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ol><li><p>FIFO 队列</p><p>Queue<Integer> q=new LinkedList<Integer>();</p></li><li><p>优先队列</p><p>Queue<Integer> q=new PriorityQueue<Integer>();</p><p>默认升序，底层为堆，初始容量 11</p><p>Queue<Student> q=new PriorityQueue<Student>((e1,e2)-&gt;(e1.id-e2.id));</p><p>传入对象时需要指定比较器；</p></li><li><p>BlockingQueue</p><p>阻塞队列，在 java.util.concurrent 包下，在线程安全中介绍。</p></li></ol><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>不可重复</p><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li>基于哈希表实现，支持快速查找，但不支持有序性操作。</li><li>通过 HashMap 实现。</li></ul><h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><pre><code>public boolean add(E e)public boolean contains(Object o)public boolean remove(Object o)</code></pre><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><ul><li><p>基于红黑树实现，支持有序性操作，查找效率 O(logN)。</p></li><li><p>通过 NavigableMap 实现</p><p>private transient NavigableMap&lt;E,Object&gt; m;</p></li><li><p>数据类型为对象数据时须指定比较方法。</p><p>public TreeSet(Comparator&lt;? super E&gt; comparator)</p></li></ul><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。</p><h1 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h1><h2 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h2><ul><li>Map 是使用键值对存储的一种结构，所以在处理列如单词统计等方面是杀手锏</li><li>Map 的键值对都可以为 null</li><li>Map 可以多维扩展。例如一个人拥有多个宠物，你可以这样定义：Map&lt; Person, List&lt; pet&gt;&gt;</li></ul><h2 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h2><ul><li>Object put(Object key, Object value):放进一个键值对，返回值是被替换的值</li><li>Object remove(Object key)</li><li>void putAll(Map mapping)</li><li>void clear()</li><li>boolean containsKey(Object key)是否包含某个键</li><li>boolean containsValue(Object value)是否包含某个值</li></ul><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><ul><li><p>public Set keySet()：返回这个 Map 的所有键的集合，因为 Map 中键是唯一的，所以返回使用一个 set</p></li><li><p>public Collection values()：返回这个 Map 的所有值的集合，因为值可能重复，所以返回一个 Collection</p></li><li><p>public Set entrySet()：返回一个实现 Map.Entry 接口对象集合，使用这个方法可以遍历每一条记录。</p><p>for(Map.Entry&lt;String, String&gt; file : films.entrySet()){<br>String title = file.getKey();<br>String videoUrl = file.getValue();<br>}</p></li></ul><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>基于红黑树实现。</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ul><li>基于哈希表实现。</li><li>由数组和链表，红黑树共同完成：</li><li>键可以是 null，而且键值不可以重复，如果重复了以后就会对第一个进行键值进行覆盖。</li><li>初始容量为 16，最大容量 1073741824</li><li>默认负载因子 0.75,扩容 2 倍。</li><li>链表转红黑树的阈值 8，红黑树转链表的阈值 6</li></ul><h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><ul><li>和 HashMap 类似，但它是线程安全的</li><li>它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</li><li>HashMap 的默认初始容量为 16，Hashtable 为 11。</li><li>HashMap 的扩容为原来的 2 倍，Hashtable 的扩容为原来的 2 倍加 1。</li></ul><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</p><h1 id="线程安全的容器"><a href="#线程安全的容器" class="headerlink" title="线程安全的容器"></a>线程安全的容器</h1><h2 id="同步容器类（使用了-synchronized）"><a href="#同步容器类（使用了-synchronized）" class="headerlink" title="同步容器类（使用了 synchronized）"></a>同步容器类（使用了 synchronized）</h2><p>Vector、Stack、HashTable</p><p>缺点：</p><p>通过同步方法将访问操作串行化，导致并发环境下效率低下</p><p>复合操作（迭代、条件运算如没有则添加等）非线程安全，需要客户端代码来实现加锁。</p><h2 id="并发容器："><a href="#并发容器：" class="headerlink" title="并发容器："></a>并发容器：</h2><h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p><p>写操作需要加锁，防止并发写入时导致写入数据丢失。</p><p>写操作结束之后需要把原始数组指向新的复制数组。</p><p>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；<br>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。<br>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景</p><h4 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h4><p>CopyOnWriteArraySet 基于 CopyOnWriteArrayList 实现，其唯一的不同是在 add 时调用的是 CopyOnWriteArrayList 的 addIfAbsent 方法，其遍历当前 Object 数组，如 Object 数组中已有了当前元素，则直接返回，如果没有则放入 Object 数组的尾部，并返回。</p><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。<br>默认的并发级别为 16，也就是说默认创建 16 个 Segment。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>Java 容器深入剖析</p>]]></content>
      
      
      <categories>
          
          <category> JAVA容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java容器 概述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（九）——搜素</title>
      <link href="/2020/02/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A0/"/>
      <url>/2020/02/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h1><p>顺序查找对序列本身没有要求（比如不需要是已经排序好的），也不仅限于数字、字符，也可以用于前缀，对象信息的关键信息的匹配（比如查找指定 id 的相应信息）。</p><p>衡量查找性能的一个指标是————ASL(Average Search Length)，ASL=Pi 乘 Ci，Pi 是查找第 i 个元素的概率，Ci 是找到第 i 个已经比较过次数。</p><p>哨兵方式的顺序查找相比较基础的顺序查找在循环的比较部分减少了一般。</p><h3 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 顺序查找</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequentialSearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SequentialSearch</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 哨兵方式顺序查找</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Search2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Search2</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(key == array[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = array[<span class="number">0</span>];</span><br><span class="line">        array[<span class="number">0</span>] = key;</span><br><span class="line">        <span class="keyword">int</span> index = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(array[index] != key) &#123;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        array[<span class="number">0</span>] = temp;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>如果是顺序查找，7 个数最多可能会比较 7 次，但用二分查找，最多只要 3 次就能 OK。</p><p>时间复杂度是 O（logn）(底数为 2)。</p><p>二分查找的优化————插值查找</p><p>如果数据范围是 1<del>100000,让你找 10,那么就不一定要从中间找起了。可以三分之一，四分之一处查找，比如 1</del>10，待查为 3，那可以从前面三分之一为划分点。对于要查找的位置有个精确的计算公式 P=low+（key-a[low])/(a[high]-a[low])*(high-low)</p><h1 id="java-实现-1"><a href="#java-实现-1" class="headerlink" title="java 实现"></a>java 实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 二分查找递归与非递归的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchRecursion</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  searchRecursion(target, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; array[mid]) &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">searchRecursion</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(array[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &lt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> searchRecursion(target, mid + <span class="number">1</span>, end);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> searchRecursion(target, start, mid -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 二分插入排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryInsertSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryInsertSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = array.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = array[i];</span><br><span class="line">            <span class="keyword">int</span> insertIndex = binarySearch(i - <span class="number">1</span>, temp);</span><br><span class="line">            <span class="keyword">if</span>(insertIndex != i) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; insertIndex; j--) &#123;</span><br><span class="line">                    array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                array[insertIndex] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.println(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> end, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">            mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid] &gt; target) &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果相等，也插入到后面</span></span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="杨氏矩阵的的查找"><a href="#杨氏矩阵的的查找" class="headerlink" title="杨氏矩阵的的查找"></a>杨氏矩阵的的查找</h1><p>杨氏矩阵就是行列递增的矩阵。</p><p>杨氏矩阵的操作</p><p>插入。插入一个数，需要移动其他元素<br>删除。给定 x,y 坐标，删除那个数，伴随其他元素移动，怎样移动操作最少？<br>查找 t 是否存在于矩阵中。这也是这篇博客里所要关注的。<br>返回第 k 大的数。涉及到堆查找，后续博客再细说。<br>关于查找 t 是否存在于矩阵，书中给了几种实现的方法：</p><p>递归实现和非递归实现</p><p>优化：<br>每次不都从每行的第一个数开始查找，左右上下进行比较然后查找。<br>分治法。杨氏矩阵行列是递增的，那么对角线也是递增的，可以利用对角线划分的区域来缩小要查找数的范围。（实现略）<br>定位查找法。先定位到第一行最右的数，然后只需要往下走，往左走两种操作即可，相比方法 2 省掉了往右走。</p><h3 id="java-实现-2"><a href="#java-实现-2" class="headerlink" title="java 实现"></a>java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YoungSearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">YoungSearch</span><span class="params">(<span class="keyword">int</span>[][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recursionSearch</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == array.length || y == array[<span class="number">0</span>].length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; array[x][y]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target == array[x][y]) &#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"x: %d, y: %d"</span>, x, y));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> recursionSearch(x + <span class="number">1</span>, y, target) || recursionSearch(x, y + <span class="number">1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array[<span class="number">0</span>].length &amp;&amp; target &gt;= array[i][j]; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(target == array[i][j]) &#123;</span><br><span class="line">                    System.out.println(String.format(<span class="string">"x: %d y: %d"</span>, i, j));</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.简单优化（向左/右/下走）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search2</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> width = array[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> height = array.length;</span><br><span class="line">        <span class="keyword">if</span>(target &gt;= array[<span class="number">0</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; width &amp;&amp; target &gt;= array[<span class="number">0</span>][i]; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(target == array[<span class="number">0</span>][i]) &#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">"x: %d, y: %d"</span>, <span class="number">0</span>, i));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; width - <span class="number">1</span>) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环向下查找</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; height; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(target == array[j][i]) &#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">"x: %d, y: %d"</span>, j, i));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; array[j][i]) &#123;</span><br><span class="line">                <span class="keyword">for</span>(; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(target == array[j][i]) &#123;</span><br><span class="line">                        System.out.println(String.format(<span class="string">"x: %d, y: %d"</span>, j, i));</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &gt; array[j][i]) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &gt; array[j][i]) &#123;</span><br><span class="line">                <span class="keyword">for</span>(; i &lt; width; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(target == array[j][i])&#123;</span><br><span class="line">                        System.out.println(String.format(<span class="string">"x: %d, y: %d"</span>, j, i));</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; array[j][i]) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; width - <span class="number">1</span>) &#123;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.进一步优化（从第一行最右边的数开始，只需要向下和向左两个操作）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search3</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = array[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = array[i][j];</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(target == temp) &#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">"x: %d, y: %d"</span>, i, j));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">0</span> &amp;&amp; target &lt; temp)&#123;</span><br><span class="line">                temp = array[i][--j];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i &lt; array.length - <span class="number">1</span> &amp;&amp; target &gt; temp) &#123;</span><br><span class="line">                temp = array[++i][j];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h1><p>对于待查找的数据列表来说，如果元素变动很少，那么可以先进行排序再查找。但如果这个数据经常需要添加元素，那么每次查找前都需要排序，这并不是一个好的选择。</p><p>就有了分块查找，这个概念再学数据库的时候听过。分块查找里有索引表和分块这两个概念。索引表就是帮助分块查找的一个分块依据，就是一个数组，用来存储每块最大的存储值（范围上限）；分块就是通过索引表把数据分为几块。</p><p>原理</p><p>当需要增加一个元素的时候，先根据索引表，获取这个元素应该在那一块，然后直接把元素加入到相应的块里，而块内的元素直接不需要有序。</p><p>从上面可知，分块查找只需要索引表有序，每一个块里的元素可以是无序的，但第 i 块的每个元素一定比第 i-1 块的每一个元素大（小）。当索引表很大的时候，可以对索引表进行二分查找，锁定块的位置，然后对块内的元素进行顺序查找。总性能不如二分查找，但强过顺序查找，更好的是不需要数列完全有序。<br>举个例子，比如索引表为【10，20，30】,分块一【2，1，4，2】分块二【19，15，18，】分块三【22，27，23】，现在要增加 22 这个数，直接根据索引表把 22 放到分块三最后就行了【22,27,23,22】。</p><p>可以看出，分块查找同时有顺序查找和二分查找的有点————不需要有序、速度快。</p><p>应用场景<br>视频网站对用户观看行为记录，每个用户分别观看了一个视频多久，如果对每条这样的记录都放到一个表里，那太多了，可以根据具体业务做分表，一天一个表，表名如 t_user_watch_xxx_20180806，存储查询的时候就可以根据时间去做一个表的分块，在查询详细的记录。</p><h3 id="java-实现-3"><a href="#java-实现-3" class="headerlink" title="java 实现"></a>java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分块查找</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockSearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] index;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlockSearch</span><span class="params">(<span class="keyword">int</span>[] index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index.length; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = binarySearch(value);</span><br><span class="line">        list.get(i).add(value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = binarySearch(data);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; list.get(i).size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(data == list.get(i).get(j)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; l = list.get(i);</span><br><span class="line">            System.out.println(<span class="string">"ArrayList: "</span> + i +  <span class="string">":"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; l.size(); j++) &#123;</span><br><span class="line">                System.out.println(l.get(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = index.length - <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">int</span> mid = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">            mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target == index[mid]) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; index[mid]) &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 搜素 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（八）——排序算法</title>
      <link href="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="常见的排序算法总结"><a href="#常见的排序算法总结" class="headerlink" title="常见的排序算法总结"></a>常见的排序算法总结</h1><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95_2020-02-20-16-44-05.png" alt="数据结构与算法（八）——排序算法_2020-02-20-16-44-05.png"></p><h1 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h1><p>因为待排序的记录序列中可能存在两个或两个以上的关键字相等的记录， 排序结果可能会存在不唯一的情况。所以就有稳定与不稳定的定义。</p><p>假设 ki=kj( 1 =&lt; i &lt;= n,1 =&lt; j &lt;= n, i != j)，且在排序前的序列中 ri 领先于 rj。如果排序后 ri 仍领先于 rj，则称所用的排序方法是稳定的；反之，若可能使得排序后的序列中 rj 领先于 ri，则称所用的排序方法是不稳定的。只要有一组关键字发生类似情况，就可认为此排序方法是不稳定的。</p><h1 id="内排序和外排序"><a href="#内排序和外排序" class="headerlink" title="内排序和外排序"></a>内排序和外排序</h1><p>根据在排序过程中待排序记录是否全部放在内存中，排序分为内排序和外排序。</p><ul><li>内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。</li><li>外排序是由于排序的记录个数太多，不能同时放置在内存中，整个排序过程需要在内外存之间多次交换数据才能进行。</li></ul><p>内排序，排序算法的性能主要有 3 个影响因素：</p><ul><li>时间性能<br>排序算法的时间开销是衡量其好坏的最重要的标志。<br>在内排序中，主要进行两种操作：比较和移动。<br>高效率的内排序算法应该具有尽可能少的关键字比较次数和尽可能少的记录移动次数。</li><li>辅助空间<br>评估算法的另一个主要标准是执行算法所需要的辅助存储空间。<br>辅助存储空间是除了存放待排序所占用的存储空间外，执行算法所需要的其他存储空间。</li><li>算法的复杂性<br>指算法本身的复杂性，过于复杂的算法也会影响排序的性能。</li></ul><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p><strong>两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。</strong></p><h3 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h3><ul><li>最好：仅需要 n - 1 次比较，时间复杂度为 O(n)；</li><li>最坏：需要 n(n - 1)/2 次比较和交换；</li><li>平均：复杂度为 O(n2)。</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 最简单交换排序，非冒泡排序,比较的不是相邻关键字，但便于理解</span></span><br><span class="line">   <span class="comment">// 比较次数n(n + 1)/2，交换次数会很多，仔细分析下，会把小的数字放到最后去，而冒泡则不会，原因就是比较的是相邻关键字</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">simpleSwapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array.length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = array.length; i &lt; size; ++i) &#123;</span><br><span class="line">           <span class="comment">//for (int j = 0; j &lt; size; j++) &#123; //这种效率更低 n^2</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; size; ++j) &#123;</span><br><span class="line">               <span class="keyword">if</span> (array[j] &lt; array[i]) &#123;</span><br><span class="line">                   CommonUtil.swap(array, i, j);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 正宗的冒泡排序，从最底下开始冒泡，两两比较,每次都将小的往上冒一点</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array.length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, size = array.length; i &lt; size; ++i) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = size - <span class="number">1</span>; j &gt;= i; --j) &#123;</span><br><span class="line">               <span class="keyword">if</span> (array[j] &lt; array[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                   CommonUtil.swap(array, j, j - <span class="number">1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//CommonUtil.printArray(array);</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 冒泡排序优化，如果经过一轮发现已经是有序的，就不再进行排序</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSortBetter</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array.length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, size = array.length; i &lt; size &amp;&amp; flag; ++i) &#123;</span><br><span class="line">           flag = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = size - <span class="number">1</span>; j &gt;= i; --j) &#123;<span class="comment">//经过一轮循环，发现两两已经是有序的了，就置为false</span></span><br><span class="line">               <span class="keyword">if</span> (array[j] &lt; array[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                   CommonUtil.swap(array, j, j - <span class="number">1</span>);</span><br><span class="line">                   flag = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//CommonUtil.printArray(array);</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h1><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>每一次遍历时选取关键字最小的记录作为有序序列的第 i 个记录。</p><h3 id="算法复杂度分析-1"><a href="#算法复杂度分析-1" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h3><ul><li>最好最差的情况，都要进行 n(n-1)/2 次比较；在最好的情况下，不需要进行交换，在最坏的情况下，进行 n-1 次交换。</li><li>平均：复杂度为 O(n2)。</li></ul><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleSelectionSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">simpleSelectionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array.length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = array.length; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; size; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &lt; array[minIndex]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">                CommonUtil.swap(array, i, minIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><h3 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h3><p>将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录递增 1 的有序表。插入排序是进行值移动，而非值交换。所以在量较小的情况下插入排序性能要优于冒泡和简单选择排序。</p><h3 id="算法复杂度分析-2"><a href="#算法复杂度分析-2" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h3><ul><li>最好，只需进行比较 n - 1 次，无需进行移动；</li><li>最坏的情况下，比较(n + 2)(n - 1)/2 次，交换(n + 4)(n - 1)/2 次。</li><li>平均：复杂度 O(n2)</li></ul><h3 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StraightInsertionSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//for循环</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">straightInsertionSort2</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array.length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j, temp, size = array.length; i &lt; size; ++i) &#123;</span><br><span class="line">            temp = array[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; temp; --j) &#123;</span><br><span class="line">                array[j + <span class="number">1</span>] = array[j];<span class="comment">//移动而非交换</span></span><br><span class="line">            &#125;</span><br><span class="line">            array[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a>二分插入排序</h1><h3 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h3><p>二分（折半）插入排序是一种在直接插入排序算法上进行小改动的排序算法。其与直接排序算法最大的区别在于查找插入位置时使用的是二分查找的方式，在速度上有一定提升。</p><h3 id="算法复杂度分析-3"><a href="#算法复杂度分析-3" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h3><p>插入每个记录需要 O(log i)比较，最多移动 i+1 次，最少 2 次。</p><ul><li>最佳： O(n log n)，</li><li>最差：O(n^2)</li><li>平均: O(n^2)。</li><li></li></ul><p>总排序码比较次数比直接插入排序的最差情况好得多，但比最好情况要差，所元素初始序列已经按排序码接近有序时，直接插入排序比二分插入排序比较次数少</p><h3 id="java-实现-1"><a href="#java-实现-1" class="headerlink" title="java 实现"></a>java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryInsertionSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binaryInsertionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array.length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp, left, right, middle;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, size = array.length; i &lt; size; i++) &#123;</span><br><span class="line">            temp = array[i];</span><br><span class="line">            left = <span class="number">0</span>;</span><br><span class="line">            right = i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//寻找合适的位置</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">                middle = (left + right) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (array[middle] &gt; temp) &#123;</span><br><span class="line">                    right = middle - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = middle + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= left; j--) &#123;</span><br><span class="line">                array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            array[left] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h3 id="基本思想-4"><a href="#基本思想-4" class="headerlink" title="基本思想"></a>基本思想</h3><ol><li><p>对一个未排序序列，假设从该序列中的元素中取一个基准值 pivotkey，将小于 pivotkey 放左边，大于 pivotkey 放右边；</p></li><li><p>接着以该 k 为中间，左右两边的分割作为新的序列，重新进行 1 操作。 快排因为用到了递归操作，所以在简单排序中性能不如直接插入排序， 而在大量数据排序时，递归产生的性能影响对于算法的整体性能优势可以忽略。</p></li></ol><h3 id="算法复杂度分析-4"><a href="#算法复杂度分析-4" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h3><ul><li>最坏：待排序为正序或逆序，这样每次分割后的子序列一个之比上一次序列少一个元素，一个为空。如 1 2 3 4 5 pivotkey=1;分割后一个序列为 2 3 4 5 一个为空，最终 O(n^2)</li><li>最好：每一次分割都能平分，很均匀 O(nlogn)</li><li>平均：O(n*logn) 数学归纳法</li></ul><h3 id="java-实现-2"><a href="#java-实现-2" class="headerlink" title="java 实现"></a>java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuickSortWhile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_LIMIT = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array.length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        quick_sort_recursive(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick_sort_recursive</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= MAX_LIMIT) &#123;</span><br><span class="line">            <span class="comment">// 到达一定程度的小数组时使用插入排序</span></span><br><span class="line">            insertSort(arr, start, end);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123; <span class="comment">//尾递归优化</span></span><br><span class="line">            <span class="keyword">int</span> pivot = partition(arr, start, end);</span><br><span class="line"></span><br><span class="line">            quick_sort_recursive(arr, start, pivot - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            start = pivot + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       分区操作：将arr[end]作为中轴，比它小的放在前面，比它大的放在后面</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivotKey = arr[end];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = start, right = end - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (arr[left] &lt;= pivotKey &amp;&amp; left &lt; right) left++;</span><br><span class="line">            <span class="keyword">while</span> (arr[right] &gt;= pivotKey &amp;&amp; left &lt; right) right--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                CommonUtil.swap(arr, left, right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr[left] &gt;= pivotKey) &#123;</span><br><span class="line">            CommonUtil.swap(arr, left, end);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入排序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>, j, temp; i &lt;= end; ++i) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            j = i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= start &amp;&amp; arr[j] &gt; temp) &#123;</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li></ul><h3 id="基本思想-5"><a href="#基本思想-5" class="headerlink" title="基本思想"></a>基本思想</h3><p>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。</p><p>假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为 O(n2)的排序（冒泡排序或插入排序），可能会进行 n 次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。</p><p>一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用 i += step_size 而不是 i++ ）。</p><p>例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为 5 开始进行排序，我们可以通过将这列表放在有 5 列的表中来更好地描述算法，这样他们就应该看起来是这样：</p><p>13 14 94 33 82<br>25 59 94 65 23<br>45 27 73 25 39<br>10</p><p>然后我们对每列进行排序：</p><pre><code>10 14 73 25 2313 27 94 33 3925 59 94 65 8245</code></pre><p>将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时 10 已经移至正确位置了，然后再以 3 为步长进行排序：</p><pre><code>10 14 7325 23 1327 94 3339 25 5994 65 8245</code></pre><p>排序之后变为：</p><pre><code>10 14 1325 23 3327 25 5939 65 7345 94 8294</code></pre><p>最后以 1 步长进行排序（此时就是简单的插入排序了）。</p><h3 id="步长选择及复杂度"><a href="#步长选择及复杂度" class="headerlink" title="步长选择及复杂度"></a>步长选择及复杂度</h3><p>步长的选择是希尔排序的重要部分。只要最终步长为 1 任何步长序列都可以工作。<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95_2020-02-23-23-05-25.png" alt="数据结构与算法（八）——排序算法_2020-02-23-23-05-25.png"></p><ul><li><p>最优时间复杂度<br>O(n)</p></li><li><p>不稳定</p></li></ul><h3 id="java-实现-3"><a href="#java-实现-3" class="headerlink" title="java 实现"></a>java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellsort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = a.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> d=n/<span class="number">2</span>;d&gt;<span class="number">0</span>;d/=<span class="number">2</span>) &#123;<span class="comment">/* 希尔增量序列 */</span></span><br><span class="line">            <span class="comment">/* 插入排序 */</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> p=d;p&lt;n;p++) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[p];</span><br><span class="line">                <span class="keyword">for</span>(j=p;j&gt;=d &amp;&amp; a[j-<span class="number">1</span>] &gt; temp;j=j-d)</span><br><span class="line">                    a[j] = a[j-d];</span><br><span class="line">                a[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><pre><code>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</code></pre><h3 id="基本思想-6"><a href="#基本思想-6" class="headerlink" title="基本思想"></a>基本思想</h3><p>归并过程</p><pre><code>比较a[i]和b[j]的大小，若a[i]≤b[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素b[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。</code></pre><p>原理</p><p>第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</p><pre><code>第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置重复步骤3直到某一指针超出序列尾将另一序列剩下的所有元素直接复制到合并序列尾</code></pre><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>上述我们讲了归并排序的原理，将两个有序数组进行归并排序，但现实中可能不会给我们从上面的演算我们就直到，归并排序的前提是需要两个已经排好顺序的数组，那往往不会有两个已经排好顺序的数组给我们的呀<strong>(一般是杂乱无章的一个数组)</strong>，那这个算法是不是很鸡肋的呢？？</p><p>其实并不是的，首先假设题目给出的数组是这样子的：int[] arr = {2, 7, 8, 1, 4, 9};<br>当我们要做归并的时候就以 arr[3]也就元素为 1 的那个地方分开。是然后用一个指针 L 指向 arr[0]，一个指针 M 指向 arr[3]，用一个指针 R 指向 arr<a href="数组最后一位">5</a>。有了指针的帮助，我们就可以将这个数组切割成是两个有序的数组了（操作的方式就可以和上面一样了）<br>可是上面说了，一般给出的是杂乱无章的一个数组，现在还是达不到要求。比如给出的是这样一个数组：int[] arrays = {9, 2, 5, 1, 3, 2, 9, 5, 2, 1, 8};<br>此时，我们就得用到分治的思想了：</p><p>那么我们也可以这样想将 int[] arr = {2, 7, 8, 1, 4, 9};数组分隔成一份一份的，arr[0]它是一个有序的”数组”,arr[1]它也是一个有序的”数组”,利用指针(L,M,R)又可以像操作两个数组一样进行排序。最终合成{2,7}…….再不断拆分合并，最后又回到了我们的 arr = {1,2,4,7,8,9}，因此归并排序是可以排序杂乱无章的数组的</p><p>这就是我们的分治法—&gt;将一个大问题分成很多个小问题进行解决，最后重新组合起来</p><h3 id="算法复杂度分析-5"><a href="#算法复杂度分析-5" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h3><p>归并排序的时间复杂度为 O(nlogn)</p><h3 id="java-实现-4"><a href="#java-实现-4" class="headerlink" title="java 实现"></a>java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arrays = &#123;<span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    mergeSort(arrays, <span class="number">0</span>, arrays.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"公众号：Java3y"</span> + arrays);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arrays</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> L      指向数组第一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> R      指向数组最后一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arrays, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果只有一个元素，那就不用排序了</span></span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取中间的数，进行拆分</span></span><br><span class="line">        <span class="keyword">int</span> M = (L + R) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左边的数不断进行拆分</span></span><br><span class="line">        mergeSort(arrays, L, M);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右边的数不断进行拆分</span></span><br><span class="line">        mergeSort(arrays, M + <span class="number">1</span>, R);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//合并</span></span><br><span class="line">        merge(arrays, L, M + <span class="number">1</span>, R);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arrays</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> L      指向数组第一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> M      指向数组分隔的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> R      指向数组最后的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arrays, <span class="keyword">int</span> L, <span class="keyword">int</span> M, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左边的数组的大小</span></span><br><span class="line">    <span class="keyword">int</span>[] leftArray = <span class="keyword">new</span> <span class="keyword">int</span>[M - L];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//右边的数组大小</span></span><br><span class="line">    <span class="keyword">int</span>[] rightArray = <span class="keyword">new</span> <span class="keyword">int</span>[R - M + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//往这两个数组填充数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt; M; i++) &#123;</span><br><span class="line">        leftArray[i - L] = arrays[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = M; i &lt;= R; i++) &#123;</span><br><span class="line">        rightArray[i - M] = arrays[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// arrays数组的第一个元素</span></span><br><span class="line">    <span class="keyword">int</span>  k = L;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//比较这两个数组的值，哪个小，就往数组上放</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; leftArray.length &amp;&amp; j &lt; rightArray.length) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//谁比较小，谁将元素放入大数组中,移动指针，继续比较下一个</span></span><br><span class="line">        <span class="keyword">if</span> (leftArray[i] &lt; rightArray[j]) &#123;</span><br><span class="line">            arrays[k] = leftArray[i];</span><br><span class="line"></span><br><span class="line">            i++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arrays[k] = rightArray[j];</span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果左边的数组还没比较完，右边的数都已经完了，那么将左边的数抄到大数组中(剩下的都是大数字)</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; leftArray.length) &#123;</span><br><span class="line">        arrays[k] = leftArray[i];</span><br><span class="line"></span><br><span class="line">        i++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果右边的数组还没比较完，左边的数都已经完了，那么将右边的数抄到大数组中(剩下的都是大数字)</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; rightArray.length) &#123;</span><br><span class="line">        arrays[k] = rightArray[j];</span><br><span class="line"></span><br><span class="line">        k++;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结及参考资料"><a href="#总结及参考资料" class="headerlink" title="总结及参考资料"></a>总结及参考资料</h3><p>除了以上常见的排序算法，还有堆排序、桶排序、基数排序、计数排序等。<br>常见的排序算法</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（七）——堆、哈希表、图</title>
      <link href="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E5%A0%86%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E3%80%81%E5%9B%BE/"/>
      <url>/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E5%A0%86%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E3%80%81%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h1><ul><li>堆(也被称为优先队列(队列+排序规则)，图一最大堆，图二最小堆)</li><li>堆是一种特殊的基于树的满足某些特性的数据结构，整个堆中的所有父子节点的键值都会满足相同的排序条件。堆更准确地可以分为最大堆与最小堆，在最大堆中，父节点的键值永远大于或者等于子节点的值，并且整个堆中的最大值存储于根节点；而最小堆中，父节点的键值永远小于或者等于其子节点的键值，并且整个堆中的最小值存储于根节点。</li></ul><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度:"></a>时间复杂度:</h3><ul><li>访问最大值 / 最小值: O(1)</li><li>插入: O(log(n))</li><li>移除最大值 / 最小值: O(log(n))</li></ul><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E5%A0%86%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E3%80%81%E5%9B%BE_2020-02-20-16-33-06.png" alt="数据结构与算法（七）——堆、哈希表、图_2020-02-20-16-33-06.png"></p><h1 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h1><ul><li>哈希能够将任意长度的数据映射到固定长度的数据。哈希函数返回的即是哈希值，如果两个不同的键得到相同的哈希值，即将这种现象称为碰撞。</li><li>Hash Map: Hash Map 是一种能够建立起键与值之间关系的数据结构，Hash Map 能够使用哈希函数将键转化为桶或者槽中的下标，从而优化对于目标值的搜索速度。</li></ul><h3 id="碰撞解决"><a href="#碰撞解决" class="headerlink" title="碰撞解决"></a>碰撞解决</h3><ul><li>链地址法（Separate Chaining）: 链地址法中，每个桶是相互独立的，包含了一系列索引的列表。搜索操作的时间复杂度即是搜索桶的时间（固定时间）与遍历列表的时间之和。</li><li>开地址法（Open Addressing）: 在开地址法中，当插入新值时，会判断该值对应的哈希桶是否存在，如果存在则根据某种算法依次选择下一个可能的位置，直到找到一个尚未被占用的地址。所谓开地址法也是指某个元素的位置并不永远由其哈希值决定。</li></ul><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E5%A0%86%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E3%80%81%E5%9B%BE_2020-02-20-16-35-27.png" alt="数据结构与算法（七）——堆、哈希表、图_2020-02-20-16-35-27.png"></p><h1 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h1><ul><li>图是一种数据元素间为多对多关系的数据结构，加上一组基本操作构成的抽象数据类型。<ul><li>无向图（Undirected Graph）: 无向图具有对称的邻接矩阵，因此如果存在某条从节点 u 到节点 v 的边，反之从 v 到 u 的边也存在。</li><li>有向图（Directed Graph）: 有向图的邻接矩阵是非对称的，即如果存在从 u 到 v 的边并不意味着一定存在从 v 到 u 的边。</li></ul></li></ul><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E5%A0%86%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E3%80%81%E5%9B%BE_2020-02-20-16-37-36.png" alt="数据结构与算法（七）——堆、哈希表、图_2020-02-20-16-37-36.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 堆、哈希表、图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（六）——树</title>
      <link href="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91/"/>
      <url>/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="树的介绍"><a href="#树的介绍" class="headerlink" title="树的介绍"></a>树的介绍</h1><p>首先它是一种非线性的数据结构，将它命名为“树”是因为它看起来像一颗倒挂的树，根朝上，页朝下。</p><p>当然计算机的树模型，是由现实中的树抽象来的，它指的是 N 个有父子关系的节点的有限集合。对于这个有限的节点集合而言，它满足如下条件：</p><ul><li>当 N=0 时，改节点集合为空，这课树也被称为空树</li><li>在任意的非空树中，有且仅有一个根(root)节点</li><li>当 N&gt;1 时，除根节点以外的其余节点可分为 M 个互为相交的有限集合 T1,T2,…,Tm，其中的每个集合本身又是一棵树，并称其为根的子树（subtree）。</li></ul><h1 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h1><ul><li>节点：树的最基本组成单元，通常包括一个数据元素及若干指针用于指向其他节点。</li><li>节点的度：节点拥有的子树的个数被称为节点的度（degree）</li><li>树的度：树中所有节点的度的最大值就是该树的度</li><li>叶子节点：度为 0 的节点被称为叶子节点或终端节点</li><li>分支节点：度不为 0 的节点被称为分支节点或非终端节点</li><li>子节点,父节点，兄弟节点：节点的子树的根被称为该节点的子节点，而该节点称为子节点的父节点(parent).具有相同父节点的子节点之间互称为兄弟节点。</li><li>节点的层次(level):节点的层次从根开始算起，根的层次值为 1，其余节点的层次值为父节点层次值加 l。</li><li>树的深度(depth):树中节点的最大层次值称为树的深度或高度。</li><li>有序树与无序树:如果将树中节点的各棵子树看成从左到右是有序的(即不能互换),则称该树为有序树,否则称为无序树。</li><li>祖先节点(ancestor)：从根到该节点所经分支上的所有节点</li><li>后代节点(descendant):以某节点为根的子树中任一节点都称为该节点的后代节点。</li><li>森林(forest):森林是两颗或两颗以上互不相交的树的集合，删去一棵树的根，就得到一个森林。</li></ul><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉树指的是每个节点最多只能有两个子树的有序树。通常左边的子树被称作“左子树”(left subtree)，右边的子树被称为“右子树”(right subtree).由此可见，二叉树依然是树，它是一种特殊的树。</p><h3 id="树与二叉树的区别"><a href="#树与二叉树的区别" class="headerlink" title="树与二叉树的区别"></a>树与二叉树的区别</h3><ul><li>树中节点的最大度数没有限制，而二叉树节点的最大度数为 2，也就是说，二叉树是节点的最大度数为 2 的树。</li><li>无序树的节点无左右之分，而二叉树的节点有左，右之分，也就是说，二叉树是有序树。</li></ul><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>一棵深度为 k 的二叉树，如果它包含了 2^k-1 个节点，就把这棵二叉树称为满二叉树。满二叉树的特点是。每一层上的节点数都是最大节点数，即各层节点数分别为 1,2,4,8, 16,…,满二叉树下图所示：<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91_2020-02-20-14-59-36.png" alt="数据结构与算法（六）——树_2020-02-20-14-59-36.png"></p><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>如果一颗二叉树除最后一层外，其余层的所有节点都是满的，并且最后一层或者是满的，或者仅在右边缺少若干连续的节点，则此二叉树就是完全二叉树。</p><h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p>哈夫曼树又被称为最优二叉树，是一种带权路径最短的二叉树。哈夫曼树是二叉树的一种应用，在信息检索中很常用.</p><p>对于哈夫曼树，有一个很重要的定理:对于具有对 n 个叶子节点的哈夫曼树，一共需要 2 乘以 n-1 个节点。因为对于二叉树来说，有三种类型节点，即度数为 2 的节点、度数为 1 的节点和度数为 0 的叶子节点，而哈夫曼树的非叶子节点都是由两个节点合并产生的，所以不会出现度 数为 1 的节点。而生成的非叶子节点的个数为叶子节点个数-1 因此 n 个叶子节点的哈夫曼树，一共需要 Z 乘以 n-1 个节点。</p><h3 id="二叉树的特点"><a href="#二叉树的特点" class="headerlink" title="二叉树的特点"></a>二叉树的特点</h3><ul><li>二叉树第 i 层上的节点数据至多为 2 的 i-1 次方</li><li>深度为 k 的二叉树至多有 2 的 k 次方-1 个节点.满二叉树的每层节点的数量依次为 1, 2, 4,8,…,因此深度为 k 的满二叉树包含的节点数为公比为 2 的等比数列的前 k 项总和，即 2 的 k 次方一 1。</li><li>在任何一棵二叉树中，如果其叶子节点的数量为 n0,度为 2 的子节点数量为 n2，则 n0=n2 + 1。这是因为:如果为任意叶子节点增加一个子节点，则原有叶子节点变成非叶子节点，新增节点变成叶子节点，上述等式不变;如果为任意叶子节点增加两个子节点，则原有叶子节点变成度为 2 的非叶子 lto 点，新增的两个节点变成叶子节点，上述等式依然不变。</li><li>具有 n 个节点的完全二叉树的深度为 log2(n+1)</li></ul><h3 id="二叉树的储存"><a href="#二叉树的储存" class="headerlink" title="二叉树的储存"></a>二叉树的储存</h3><ul><li>顺序存储:采用数组来记录二叉树的所有节点。（可能会造成空间浪费）</li><li>二叉链表存储:每个节点保留一个 left,right 域，分别指向其左、右子节点。</li><li>三叉链表存储:每个节点保留一个 left, right,parent 域，分别指向其左、右子节点和父节点。</li></ul><h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><p>遍历二叉树指的是按某种规律依次访问二叉树的每个节点，对二叉树的遍历过程就是将非线性结构的二叉树的节点排列成线性序列的过程。<br>如果采用顺序结构来保存二叉树，程序遍历二叉树非常容易，无须进行任何思考，直接遍历底层数组即可。如果采用链表来保存二叉树的节点，则有以下两种遍历方式。</p><ul><li>深度优先遍历：这种遍历算法将先访问到树中最深层次的节点<ul><li>先序遍历</li><li>中序遍历</li><li>后序遍历</li></ul></li><li>广度优先遍历：这种遍历算法将逐层访问每层的节点，先访问根（第一层）节点，然后访问第二层的节点…..一次类推。因此，广度优先遍历方法又被称为按层遍历。</li></ul><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>先序遍历指先处理根节点，其处理顺序如下：</p><ol><li>访问根节点</li><li>递归遍历左子树</li><li>递归遍历右子树</li></ol><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>中序遍历指其次处理根节点.其处理顺序如下。</p><ol><li>递归遍历左子树</li><li>访问根节点</li><li>递归遍历右子树</li></ol><h4 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h4><p>后序遍历指最后处理根节点，其处理顺序如下。</p><ol><li>递归遍历左子树</li><li>递归遍历右子树</li><li>访问根节点</li></ol><h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><p>广度优先遍历又称为按层遍历，整个遍历算法是先遍历几叉树的第一层(根节点)，再遍历根节点的两个子’节点(第二层)……依此类推，逐层遍历二叉树的所有节点。</p><p>为了实现广度优先遍历，可以借助于具有 FIFO 特征的队列来实现。如下所示。</p><ul><li>建一个队列(先进先出)，把树的根节点压入队列。</li><li>从队列中弹出一个节点(第一个弹出的就是根节点)，然后把改节点的左，右节点压入队列，如果没有子节点，则说明已经达到叶子节点了。</li><li>用循环重复执行 2 步，知道队列为空。当队列为空时，说明所有的叶子节点(深度最深的层)都已经经过了队列，也就完成了遍历。</li></ul><h4 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h4><p>用栈储存二叉树，栈代替我们完成了递归。</p><h4 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h4><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91_2020-02-20-15-45-37.png" alt="数据结构与算法（六）——树_2020-02-20-15-45-37.png"></p><p>前序遍历：1 2 4 5 7 8 3 6</p><p>中序遍历：4 2 7 5 8 1 3 6</p><p>后序遍历：4 7 8 5 2 6 3 1</p><p>层次遍历：1 2 3 4 5 6 7 8</p><h3 id="二叉树的初始化"><a href="#二叉树的初始化" class="headerlink" title="二叉树的初始化"></a>二叉树的初始化</h3><h4 id="链式储存"><a href="#链式储存" class="headerlink" title="链式储存"></a>链式储存</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by engineer on 2017/10/23.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 二叉树结点定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据域</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="comment">// 左子树</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode&lt;T&gt; leftChild;</span><br><span class="line">    <span class="comment">// 右子树</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode&lt;T&gt; rightChild;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, data, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(TreeNode&lt;T&gt; leftChild, T data, TreeNode&lt;T&gt; rightChild)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.leftChild = leftChild;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.rightChild = rightChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode&lt;T&gt; <span class="title">getLeftChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> leftChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode&lt;T&gt; <span class="title">getRightChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rightChild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建二叉树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 树根</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">TreeNode <span class="title">CreateTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeNode&lt;String&gt; nodeH = <span class="keyword">new</span> TreeNode&lt;&gt;(<span class="string">"H"</span>);</span><br><span class="line">        TreeNode&lt;String&gt; nodeG = <span class="keyword">new</span> TreeNode&lt;&gt;(<span class="string">"G"</span>);</span><br><span class="line"></span><br><span class="line">        TreeNode&lt;String&gt; nodeF = <span class="keyword">new</span> TreeNode&lt;&gt;(nodeH, <span class="string">"F"</span>, <span class="keyword">null</span>);</span><br><span class="line">        TreeNode&lt;String&gt; nodeE = <span class="keyword">new</span> TreeNode&lt;&gt;(nodeG, <span class="string">"E"</span>, <span class="keyword">null</span>);</span><br><span class="line">        TreeNode&lt;String&gt; nodeD = <span class="keyword">new</span> TreeNode&lt;&gt;(<span class="string">"D"</span>);</span><br><span class="line"></span><br><span class="line">        TreeNode&lt;String&gt; nodeC = <span class="keyword">new</span> TreeNode&lt;&gt;(<span class="keyword">null</span>, <span class="string">"C"</span>, nodeF);</span><br><span class="line">        TreeNode&lt;String&gt; nodeB = <span class="keyword">new</span> TreeNode&lt;&gt;(nodeD, <span class="string">"B"</span>, nodeE);</span><br><span class="line">        TreeNode&lt;String&gt; nodeA = <span class="keyword">new</span> TreeNode&lt;&gt;(nodeB, <span class="string">"A"</span>, nodeC);</span><br><span class="line">        <span class="keyword">return</span> nodeA;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问每个结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">visitNode</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        System.out.print(node.getData().toString());</span><br><span class="line">        System.out.print(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序遍历-递归实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preTraversal</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            visitNode(node);</span><br><span class="line">            preTraversal(node.getLeftChild());</span><br><span class="line">            preTraversal(node.getRightChild());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序遍历-递归实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            traversal(node.getLeftChild());</span><br><span class="line">            visitNode(node);</span><br><span class="line">            traversal(node.getRightChild());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后序遍历-递归实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postTraversal</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            postTraversal(node.getLeftChild());</span><br><span class="line">            postTraversal(node.getRightChild());</span><br><span class="line">            visitNode(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="排序二叉树"><a href="#排序二叉树" class="headerlink" title="排序二叉树"></a>排序二叉树</h3><p>排序二叉树是一种特殊结构的二叉树，通过它可以非常方便地对树中的所有节点进行排序和检索</p><p>排序二叉树要么是一颗空二叉树，要么是具有下列性质的二叉树</p><ul><li>若它的左子树不空，则左子树上所有的节点的值均小于它的根节点的值</li><li>若它的右子树不空，则右子树上所有的节点均大于它的根节点的值</li><li>它的左右子树分别为排序二叉树。</li></ul><p>下图显示了一棵排序二叉树. 对于排序二叉树，若按中序遍历就可以得到由小到大的有序序列。中序遍历得:<br>{2,3,4,8,9,9,10,13,15,18)<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91_2020-02-20-15-57-44.png" alt="数据结构与算法（六）——树_2020-02-20-15-57-44.png"></p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>排序二叉树虽然可以快速检索，但在最坏的情况下，如果插入的节点集本身就是有序的，要么是由小到大排列，要么是由大到小排列，那么最后得到的排序二义树将变成链表:在这种情况下，排序二叉树就变成了普通链表，其检索效率就会很低。<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91_2020-02-20-16-07-33.png" alt="数据结构与算法（六）——树_2020-02-20-16-07-33.png"></p><p>为了改变排序二叉树存在的不足，对二叉树进行改进————红黑树，他将这种排序二叉树称为“对称二叉 B 树”。</p><p>红黑树的应用非常广泛，常见的函数库，如 C++中的 map，multimap,以及 Java 中的 TreeMap，TreeSet， Java8 中的 HashMap 的实现也采用了红黑树。</p><p>红黑树从本质上来说就是一颗二叉查找树，但是在二叉树的基础上增加了着色相关的性质，使得红黑树可以保证相对平衡，从而保证红黑树的增删改查的时间复杂度最坏也能达到 O(log N)。</p><p>红黑树是一个更高效的检索二叉树，因此常常用来实现关联数组。典型的，JDK 提供的集合类 TreeMap 本身就是一颗红黑树的实现。 红黑树在原有的排序二叉树上增加如下几个要求：</p><ul><li>性质 l:每个节点要么是红色，要么是黑色。</li><li>性质 2:根节点永远是黑色的。</li><li>除质 3:所有的叶子节点都是空节点(即 null)，并且是黑色的。</li><li>性质 4:每个红色节点的两个子节点都是黑色的。(从每个叶子到根的路径上不会有两个连续的红色节点。)</li><li>性质 5:从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。</li></ul><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91_2020-02-20-16-09-08.png" alt="数据结构与算法（六）——树_2020-02-20-16-09-08.png"></p><p>上图是一棵典型的红黑树，红黑树的 5 条特性确保了从根到叶子的最长的可能路径不多于最短的可能路径的两倍长，使得整棵树大致上是平衡的。树上的增删改查操作的最坏情况时间都与树的高度成正比，所以红黑树在最坏情况下也是高效的。</p><p>在红黑树中一般用黑的 NIL 节点表示叶节点，不包含值，只是标志该分支结束，有时候绘图中会直接省略。</p><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p>当在含 n 个关键字的红黑树上进行 insert 和 delete 操作时，修改后的树可能不满足上面给出的 5 个红黑树的基本特性，所以需要改变树中的某些节点的颜色以及指针结构。 这些指针结构的修改是通过旋转完成的，旋转分为左旋和右旋:</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91_2020-02-20-16-16-55.png" alt="数据结构与算法（六）——树_2020-02-20-16-16-55.png"></p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p>疯狂 java 笔记之树和二叉树</p><p>图解红黑树</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（五）——队列</title>
      <link href="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/"/>
      <url>/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="队列介绍"><a href="#队列介绍" class="headerlink" title="队列介绍"></a>队列介绍</h1><p>队列是数据结构中比较重要的一种类型，它支持 FIFO，尾部添加、头部删除（先进队列的元素先出队列），跟我们生活中的排队类似。</p><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><ul><li>索引: O(n)</li><li>搜索: O(n)</li><li>插入: O(1)</li><li>移除: O(1)</li></ul><h1 id="队列类型"><a href="#队列类型" class="headerlink" title="队列类型"></a>队列类型</h1><h3 id="单队列"><a href="#单队列" class="headerlink" title="单队列"></a>单队列</h3><p>单队列就是常见的队列, 每次添加元素时，都是添加到队尾：<br>以数组实现的队列为例，初始时队列长度固定为 4，font 和 rear 均为 0：<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%98%9F%E5%88%97_2020-02-20-13-45-34.png" alt="数据结构与算法（五）——队列_2020-02-20-13-45-34.png"><br>每添加一个元素，rear 后移一位。当添加四个元素后， rear 到了索引为 4 的位置：<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%98%9F%E5%88%97_2020-02-20-13-46-12.png" alt="数据结构与算法（五）——队列_2020-02-20-13-46-12.png"><br>这时 a1,a2 出队，front 后移动到 2：<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%98%9F%E5%88%97_2020-02-20-13-46-40.png" alt="数据结构与算法（五）——队列_2020-02-20-13-46-40.png"><br>这时想要再添加两个元素，但 rear 后移两位后就会越界：<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%98%9F%E5%88%97_2020-02-20-13-47-26.png" alt="数据结构与算法（五）——队列_2020-02-20-13-47-26.png"><br>明明有三个空位，却只能再放入一个！这就是单队列的“假溢出”情况。<br>针对这种情况，解决办法就是后面满了，就再从头开始，也就是头尾相接的循环。这就是 “循环队列” 的概念。</p><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>循环队列中，<br>rear = (rear - size) % size</p><p>接着上面的例子，当 rear 大于 队列长度时，rear = ( 5 - 5) % 5 = 0 :<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%98%9F%E5%88%97_2020-02-20-13-52-12.png" alt="数据结构与算法（五）——队列_2020-02-20-13-52-12.png"><br>这样继续添加时，还可以添加几个元素：<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%98%9F%E5%88%97_2020-02-20-13-52-37.png" alt="数据结构与算法（五）——队列_2020-02-20-13-52-37.png"><br>那如何判断队列是否装满元素了呢，单使用 front == rear 无法判断究竟是空的还是满了。</p><p>两种方法：</p><ul><li>加个标志 flag ,初始为 false，添加满了置为 true；</li><li>不以 front = rear 为放满标志，改为 (rear - front) % size = 1。</li></ul><p>法 2 的公式放满元素时空余了一个位置，这个公式是什么意思呢？<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%98%9F%E5%88%97_2020-02-20-13-53-37.png" alt="数据结构与算法（五）——队列_2020-02-20-13-53-37.png"><br>接着上面的情况，当 rear 从后面添加元素跑到前面 0 时，再添加一个元素 a6，rear 后移一位到 1，这时 front = 2, (1 - 2) % 5 = 1, 满足放满条件。</p><p>因此，当 rear &gt; font 时，队列中元素个数 = rear - font;</p><p>当 rear &lt; font 时，队列中元素分为两部分： size - font 和 rear ,也就是 rear + size - font。以上述图片为例，队列中元素个数 = 1 + 5 - 2 = 4.</p><h1 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 1.单向队列（Queue）：只能在一端插入数据，另一端删除数据。</span></span><br><span class="line"><span class="comment">     * 2.双向队列（Deque）：每一端都可以进行插入数据和删除数据操作。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  与栈不同的是，队列中的数据不总是从数组的0下标开始的</span></span><br><span class="line"><span class="comment">     *  选择的做法是移动队头和队尾的指针。</span></span><br><span class="line"><span class="comment">     *  为了避免队列不满却不能插入新的数据，我们可以让队尾指针绕回到数组开始的位置，这也称为“循环队列”。</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="comment">// 单向循环队列，顺序存储结构实现</span></span><br><span class="line">    <span class="keyword">private</span> Object[] objQueue;</span><br><span class="line">    <span class="comment">//队列大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="comment">//顶部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top;</span><br><span class="line">    <span class="comment">//底部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bottom;</span><br><span class="line">    <span class="comment">//实际元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> item;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        maxSize = size;</span><br><span class="line">        objQueue = <span class="keyword">new</span> Object[maxSize];</span><br><span class="line">        top = <span class="number">0</span>;</span><br><span class="line">        bottom = -<span class="number">1</span>;</span><br><span class="line">        item = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入队</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(item == maxSize)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(obj+<span class="string">" add error, queue is full"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环队列，首尾结合，下标控制队首和队尾位置</span></span><br><span class="line">        <span class="keyword">if</span>(bottom == maxSize-<span class="number">1</span>)&#123;</span><br><span class="line">            bottom = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        objQueue[++bottom] = obj;</span><br><span class="line">        item++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出对</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(item == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"queue is null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Object obj = objQueue[top];</span><br><span class="line">        <span class="comment">//声明原顶栈可以回收空间(GC)</span></span><br><span class="line">        objQueue[top] = <span class="keyword">null</span>;</span><br><span class="line">        top++;</span><br><span class="line">        <span class="comment">//重置下标</span></span><br><span class="line">        <span class="keyword">if</span>(top == maxSize)&#123;</span><br><span class="line">            top = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        item--;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//链式存储结构实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeQueue</span>&lt;<span class="title">Object</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> NodeQueue next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NodeQueue</span><span class="params">(Object data, NodeQueue next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队列头 出</span></span><br><span class="line">    <span class="keyword">private</span> NodeQueue queueTop;</span><br><span class="line">    <span class="comment">//队列尾 进</span></span><br><span class="line">    <span class="keyword">private</span> NodeQueue queueBottom;</span><br><span class="line">    <span class="comment">//队列大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queueTop = <span class="keyword">null</span>;</span><br><span class="line">        queueBottom = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入队</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNodeQueue</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            queueTop = <span class="keyword">new</span> NodeQueue(obj,<span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//指向同一存储地址</span></span><br><span class="line">            queueBottom = queueTop;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            NodeQueue&lt;Object&gt; nodeQueue = <span class="keyword">new</span> NodeQueue(obj,<span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//让尾节点的next指向新增的节点</span></span><br><span class="line">            queueBottom.next = nodeQueue;</span><br><span class="line">            <span class="comment">//以新节点作为尾节点</span></span><br><span class="line">            queueBottom = nodeQueue;</span><br><span class="line">        &#125;</span><br><span class="line">        size ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出队</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">removeNodeQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"queue is null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        NodeQueue nodeQueue = queueTop;</span><br><span class="line">        queueTop = queueTop.next;</span><br><span class="line">        <span class="comment">//声明原队列头next可以回收空间(GC)</span></span><br><span class="line">        nodeQueue.next = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> nodeQueue.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"&#123; "</span>);</span><br><span class="line">        <span class="keyword">for</span>(NodeQueue nodeQueue = queueTop ; nodeQueue != <span class="keyword">null</span> ; nodeQueue = nodeQueue.next)&#123;</span><br><span class="line">            sb.append(nodeQueue.data.toString()+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString()+<span class="string">"&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue queue = <span class="keyword">new</span> Queue();</span><br><span class="line">        queue.addNodeQueue(<span class="string">"123"</span>);</span><br><span class="line">        queue.addNodeQueue(<span class="string">"abc"</span>);</span><br><span class="line">        queue.addNodeQueue(<span class="string">"ddd"</span>);</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">        queue.removeNodeQueue();</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">        queue.removeNodeQueue();</span><br><span class="line">        queue.removeNodeQueue();</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="队列应用"><a href="#队列应用" class="headerlink" title="队列应用"></a>队列应用</h1><ol><li>模拟现实世界中的队列，如售票柜台的队列以及其他先到先服务的场景。</li><li>计算客户在呼叫中心等待的时间。</li><li>异步数据的传输（文件输入输出、管道、嵌套字）。</li><li>操作系统中的优先级任务执行。</li><li>短信群体发送 应用的发布订阅模式</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（四）——栈</title>
      <link href="/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88/"/>
      <url>/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="栈介绍"><a href="#栈介绍" class="headerlink" title="栈介绍"></a>栈介绍</h1><ul><li>栈（stack）又称为堆栈或堆叠，栈作为一种数据结构，它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶</li><li>java 中 Stack 是 Vector 的一个子类，只定义了默认构造函数，用来创建一个空栈。</li><li>栈是元素的集合，其包含了两个基本操作：push 操作可以用于将元素压入栈，pop 操作可以将栈顶元素移除。</li><li>栈是一种特殊的线性表，其入栈和出栈只允许在一端进行。</li><li>遵循后入先出（LIFO）原则。</li></ul><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>数据结构中，栈是一种线性数据结构，遵从 LIFO（后进先出）的操作顺序，所有操作都是在顶部进行。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88_2020-02-17-17-16-10.png" alt="数据结构与算法（四）——栈_2020-02-17-17-16-10.png"></p><p>有点像羽毛球桶。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88_2020-02-17-17-17-12.png" alt="数据结构与算法（四）——栈_2020-02-17-17-17-12.png"></p><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><ul><li>索引: O(n)</li><li>搜索: O(n)</li><li>插入: O(1)</li><li>移除: O(1)</li></ul><h1 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h1><h3 id="数组实现-Stack-本是用数组实现的"><a href="#数组实现-Stack-本是用数组实现的" class="headerlink" title="数组实现( Stack 本是用数组实现的)"></a>数组实现( Stack 本是用数组实现的)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="comment">//小贴士：通常可以利用栈实现字符串逆序，还可以利用栈判断分隔符是否匹配，如&lt;a[b&#123;c&#125;]&gt;，可以正进反出，栈为空则成功。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**基于数组实现的顺序栈，连续存储的线性实现，需要初始化容量**/</span></span><br><span class="line">    <span class="comment">//固定数据类型</span></span><br><span class="line">    <span class="comment">//private int[] array;</span></span><br><span class="line">    <span class="comment">//动态数据类型</span></span><br><span class="line">    <span class="keyword">private</span> Object[] objArray;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(maxSize &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            objArray = <span class="keyword">new</span> Object[maxSize];</span><br><span class="line">            <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">            top = -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"初始化大小错误：maxSize="</span> + maxSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入栈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">objPush</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="comment">//扩容</span></span><br><span class="line">        grow();</span><br><span class="line">        <span class="comment">//++在前表示先运算再赋值，优先级高，在后表示先赋值再运算，优先级低</span></span><br><span class="line">        objArray[++top] = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出栈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">objPop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object obj = peekTop();</span><br><span class="line">        <span class="comment">//声明原顶栈可以回收空间(GC)</span></span><br><span class="line">        objArray[top--] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看栈顶</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">peekTop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(top != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> objArray[top];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"stack is null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态扩容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// &lt;&lt; 左移运算符，1表示乘以2的1次方</span></span><br><span class="line">        <span class="keyword">if</span>(top == maxSize-<span class="number">1</span>)&#123;</span><br><span class="line">            maxSize = maxSize&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            objArray = Arrays.copyOf(objArray,maxSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**基于链式存储，不连续存储的非线性实现**/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">Object</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object data, Node next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node nodeTop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nodePush</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="comment">//栈顶指向新元素，新元素的next指向原栈顶元素</span></span><br><span class="line">        nodeTop = <span class="keyword">new</span> Node(obj,nodeTop);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">nodePop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node old = nodeTop;</span><br><span class="line">        <span class="comment">//声明原顶栈可以回收空间(GC)</span></span><br><span class="line">        old.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//栈顶指向下一个元素</span></span><br><span class="line">        nodeTop = nodeTop.next;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> old.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"[ "</span>);</span><br><span class="line">        <span class="keyword">for</span>(Node&lt;Object&gt; node = nodeTop; node != <span class="keyword">null</span>; node = node.next)&#123;</span><br><span class="line">            sb.append(node.data.toString() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString()+<span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Stack stack = new Stack(1);</span></span><br><span class="line"><span class="comment">//        stack.objPush("abc");</span></span><br><span class="line"><span class="comment">//        stack.objPush(123);</span></span><br><span class="line"><span class="comment">//        stack.objPush("de");</span></span><br><span class="line"><span class="comment">//        stack.objPush("cd");</span></span><br><span class="line"><span class="comment">//        stack.objPush("er");</span></span><br><span class="line"><span class="comment">//        stack.objPush("hello");</span></span><br><span class="line"><span class="comment">//        stack.objPush(666);</span></span><br><span class="line"><span class="comment">//        stack.objPush(545);</span></span><br><span class="line"><span class="comment">//        stack.objPush("word");</span></span><br><span class="line"><span class="comment">//        while (stack.top != -1)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(stack.objPop());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println(stack.peekTop());</span></span><br><span class="line">        Stack stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        stack.nodePush(<span class="string">"111"</span>);</span><br><span class="line">        stack.nodePush(<span class="string">"222"</span>);</span><br><span class="line">        stack.nodePush(<span class="string">"aaa"</span>);</span><br><span class="line">        stack.nodePush(<span class="string">"bbb"</span>);</span><br><span class="line">        System.out.println(stack);</span><br><span class="line">        <span class="keyword">while</span> (stack.size &gt; <span class="number">1</span>)</span><br><span class="line">        System.out.println(stack.nodePop());</span><br><span class="line">        System.out.println(stack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * description:LinkedList 模拟 Stack</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * author: shixinzhang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * data: 10/23/2016</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListStack</span> <span class="keyword">extends</span> <span class="title">LinkedList</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedListStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.push(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">调用：</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPush</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    LinkedListStack stack = <span class="keyword">new</span> LinkedListStack();</span><br><span class="line">    System.out.println(<span class="string">"栈是否为空: "</span> + stack.isEmpty());</span><br><span class="line"></span><br><span class="line">    stack.push(<span class="string">"shixin"</span>);</span><br><span class="line">    stack.push(<span class="string">"好帅"</span>);</span><br><span class="line">    stack.push(<span class="string">"技巧一流"</span>);</span><br><span class="line">    stack.push(<span class="string">"haha"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"栈中元素: "</span> + stack);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"获取顶端元素 peek :"</span> + stack.peek());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"顶端元素出栈 pop :"</span> + stack.pop());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"出栈后栈内元素:"</span> + stack);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"search(好帅) 的位置:"</span> + stack.search(<span class="string">"好帅"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h1><ul><li>符号匹配</li><li>中缀表达式转换为后缀表达式</li><li>计算后缀表达式</li><li>实现函数的嵌套调用</li><li>HTML 和 XML 文件中的标签匹配</li><li>网浏览器中已访问页面的历史记录</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（三）——链表</title>
      <link href="/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="链表介绍"><a href="#链表介绍" class="headerlink" title="链表介绍"></a>链表介绍</h1><p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，是一种物理存储单元上非连续、非顺序的存储结构。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括存储数据元素的数据域和存储下一个结点地址的指针域两个部分。 相比于线性表顺序结构，操作复杂。数据元素的逻辑顺序也是通过链表中的指针链接次序实现的。</p><h1 id="物理储存"><a href="#物理储存" class="headerlink" title="物理储存"></a>物理储存</h1><p>链表的分布式没有顺序的，非连续的，也就是随心所欲，想在哪在哪，那怎么找到下一个的，就是靠指针连接的。以单向链表为例，如下图：<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8_2020-02-14-16-43-24.png" alt="数据结构与算法（三）——链表_2020-02-14-16-43-24.png"></p><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><ul><li>索引: O(n)</li><li>搜索: O(n)</li><li>插入: O(1)</li><li>移除: O(1)</li></ul><h1 id="链表的分类"><a href="#链表的分类" class="headerlink" title="链表的分类"></a>链表的分类</h1><ul><li>单向链表<br>链表中的节点仅指向下一个节点，并且最后一个节点指向空。<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8_2020-02-14-16-46-29.png" alt="数据结构与算法（三）——链表_2020-02-14-16-46-29.png"></li><li>双向链表<br>其中每个节点具有两个指针 p、n，使得 p 指向先前节点并且 n 指向下一个节点；最后一个节点的 n 指针指向 null。<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8_2020-02-14-16-47-56.png" alt="数据结构与算法（三）——链表_2020-02-14-16-47-56.png"></li><li>循环链表<br>每个节点指向下一个节点并且最后一个节点指向第一个节点的链表。<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8_2020-02-14-16-49-21.png" alt="数据结构与算法（三）——链表_2020-02-14-16-49-21.png"></li></ul><h1 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h1><h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLink</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Node head = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Object data;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Node next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        Node addNode = <span class="keyword">new</span> Node(data); <span class="comment">//实例化一个节点</span></span><br><span class="line">        <span class="comment">//判断是不是第一个节点,如果是的话，我就把这个加入到头节点,因为是头节点所有就没有前驱节点了</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = addNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果不是第一个节点 得找到当前链表的最后一个节点 把要加入的节点的当做最后一个节点的后继节点</span></span><br><span class="line">            Node temp = head; <span class="comment">//定义一个临时节点 把头节点赋值给他 然后一直找，直到找到最后一个节点</span></span><br><span class="line">            <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到当前链表最后一个节点，然后把要加入的这个节点当做尾节点的后继</span></span><br><span class="line">            temp.next = addNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == head) &#123;</span><br><span class="line">            System.out.println(<span class="string">"链表的长度为0"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 说明不是只有一个元素</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Node temp = head;</span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(temp.data);</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取链表的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先需要判断指定位置是否正确</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertNode</span><span class="params">(<span class="keyword">int</span> index, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">1</span> || index &gt; length() + <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"下标校验不通过。"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//临时节点，从头节点开始</span></span><br><span class="line">        Node temp = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录遍历的当前位置</span></span><br><span class="line">        <span class="keyword">int</span> currentPos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化要插入的节点</span></span><br><span class="line">        Node insertNode = <span class="keyword">new</span> Node(value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//找到上一个节点的位置了</span></span><br><span class="line">            <span class="keyword">if</span> ((index - <span class="number">1</span>) == currentPos) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//temp表示的是上一个节点</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//将原本由上一个节点的指向交由插入的节点来指向</span></span><br><span class="line">                insertNode.next = temp.next;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//将上一个节点的指针域指向要插入的节点</span></span><br><span class="line">                temp.next = insertNode;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            currentPos++;</span><br><span class="line">            temp = temp.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定位置的节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//首先需要判断指定位置是否正确，</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">1</span> || index &gt; length() + <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"下标校验不通过。"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//临时节点，从头节点开始</span></span><br><span class="line">        Node temp = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录遍历的当前位置</span></span><br><span class="line">        <span class="keyword">int</span> currentPos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//先找到要删除节点 上一个节点的位置</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index - <span class="number">1</span> == currentPos) &#123;</span><br><span class="line">                <span class="comment">//temp 表示要删除的节点</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//temp.next表示的是想要删除的节点</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//将想要删除的节点存储一下</span></span><br><span class="line">                Node deleteNode = temp.next;</span><br><span class="line">                <span class="comment">//把想要删除的下一个节点由上一个节点交互</span></span><br><span class="line">                temp.next = deleteNode.next;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            currentPos++;</span><br><span class="line">            temp = temp.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getOne</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">//首先需要判断指定位置是否正确，</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">1</span> || index &gt; length()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"下标校验不通过"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//临时节点</span></span><br><span class="line">        Node temp = head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录遍历的当前位置</span></span><br><span class="line">        <span class="keyword">int</span> currentPos = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index==currentPos)&#123;</span><br><span class="line">                <span class="keyword">return</span> temp.data;</span><br><span class="line">            &#125;</span><br><span class="line">            currentPos++;</span><br><span class="line">            temp=temp.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyLink myLink = <span class="keyword">new</span> MyLink();</span><br><span class="line">        myLink.addNode(<span class="string">"1"</span>);</span><br><span class="line">        myLink.addNode(<span class="string">"aaaa"</span>);</span><br><span class="line">        myLink.traverse();</span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">        myLink.delete(<span class="number">1</span>);</span><br><span class="line">        myLink.addNode(<span class="string">"333"</span>);</span><br><span class="line">        myLink.traverse();</span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">        Object one = myLink.getOne(<span class="number">1</span>);</span><br><span class="line">        System.out.println(one);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 链表通常由一连串节点组成，每个节点包含任意的实例数据（data fields）和一或两个用来指向上一个/或下一个节点的位置的链接（"links"）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node head; <span class="comment">//链表头</span></span><br><span class="line">    <span class="keyword">private</span> Node tail; <span class="comment">//链表尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size; <span class="comment">//节点数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双端链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object data;</span><br><span class="line">        <span class="keyword">private</span> Node prev; <span class="comment">//上一个</span></span><br><span class="line">        <span class="keyword">private</span> Node next; <span class="comment">//下一个</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向链表头添加数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addHead</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(object);</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            head = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            head.prev = node;</span><br><span class="line">            node.next = head;</span><br><span class="line">            head = node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//头部指向下一个，prev值为null则说明是链表的头部</span></span><br><span class="line">        <span class="keyword">if</span>(size != <span class="number">0</span>)&#123;</span><br><span class="line">            head.prev = <span class="keyword">null</span>;</span><br><span class="line">            head = head.next;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *向链表尾添加数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTail</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(object);</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            head = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node.prev = tail;</span><br><span class="line">            tail.next = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除尾部</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteTail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//尾部指向上一个，next值为null则说明是链表的尾部</span></span><br><span class="line">        <span class="keyword">if</span>(size != <span class="number">0</span>)&#123;</span><br><span class="line">            tail.next = <span class="keyword">null</span>;</span><br><span class="line">            tail = tail.prev;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node node = head;</span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.print(<span class="string">"["</span>+node.data+<span class="string">"-&gt;"</span>);</span><br><span class="line">            node = node.next;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList linkedList = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        linkedList.addHead(<span class="string">"123"</span>);</span><br><span class="line"><span class="comment">//        linkedList.addHead("abc");</span></span><br><span class="line"><span class="comment">//        linkedList.addHead("%$$");</span></span><br><span class="line"><span class="comment">//        linkedList.addTail("+_+");</span></span><br><span class="line"><span class="comment">//        linkedList.addTail("hello");</span></span><br><span class="line">        linkedList.addTail(<span class="string">"word"</span>);</span><br><span class="line">        linkedList.deleteHead();</span><br><span class="line">        linkedList.deleteTail();</span><br><span class="line">        linkedList.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表的优缺点"><a href="#链表的优缺点" class="headerlink" title="链表的优缺点"></a>链表的优缺点</h1><ul><li>优点：空间没有限制<br>插入删除元素很快</li><li>缺点：存取速度很慢</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（二）——数组</title>
      <link href="/2020/02/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/"/>
      <url>/2020/02/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数组介绍"><a href="#数组介绍" class="headerlink" title="数组介绍"></a>数组介绍</h1><p>数组——数据结构的鼻祖。数组几乎能表示一切的数据结构。在 Java 中，数组是用来存放同一种数据类型的集合，注意只能存放同一种数据类型(Object 类型数组除外)。</p><h1 id="物理储存"><a href="#物理储存" class="headerlink" title="物理储存"></a>物理储存</h1><p>数组的内存空间都是连续的，如下图：<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84_2020-02-14-16-41-07.png" alt="数据结构与算法（二）——数组_2020-02-14-16-41-07.png"></p><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><ul><li>查找: O(n)</li><li>插入: O(1)</li><li>删除: O(n)</li></ul><h3 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a>数组的声明</h3><ol><li>第一种方式<br>数据类型 [] 数组名称 = new 数据类型[数组长度];</li><li>第二种方式<br>数据类型 [] 数组名称 = {数组元素 1，数组元素 2，……}</li></ol><h3 id="访问数组元素和赋值"><a href="#访问数组元素和赋值" class="headerlink" title="访问数组元素和赋值"></a>访问数组元素和赋值</h3><p>数组是存在下标索引的，通过下标可以获取指定位置的元素，数组小标是从 0 开始的，也就是说下标 0 对应的就是数组中第 1 个元素，可以很方便的对数组中的元素进行存取操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明数组,声明一个长度为3，只能存放int类型的数据</span></span><br><span class="line"><span class="keyword">int</span> [] myArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//给myArray第一个元素赋值1</span></span><br><span class="line">myArray[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//访问myArray的第一个元素</span></span><br><span class="line">System.out.println(myArray[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>上面的 myArray 数组，我们只能赋值三个元素，也就是下标从 0 到 2，如果你访问 myArray[3] ，那么会报数组下标越界异常。</p><h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><p>数组有个 length 属性，是记录数组的长度的，我们可以利用 length 属性来遍历数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明数组2,声明一个数组元素为 1,2,3的int类型数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> [] myArray2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; myArray2.length ; i++)&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(myArray2[i]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ys.array;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> </span>&#123;</span><br><span class="line">     <span class="comment">//定义一个数组</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> [] intArray;</span><br><span class="line">     <span class="comment">//定义数组的实际有效长度</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> elems;</span><br><span class="line">     <span class="comment">//定义数组的最大长度</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//默认构造一个长度为50的数组</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">MyArray</span><span class="params">()</span></span>&#123;</span><br><span class="line">         elems = <span class="number">0</span>;</span><br><span class="line">         length = <span class="number">50</span>;</span><br><span class="line">         intArray = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//构造函数，初始化一个长度为length 的数组</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">MyArray</span><span class="params">(<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">         elems = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">this</span>.length = length;</span><br><span class="line">         intArray = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//获取数组的有效长度</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> elems;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 遍历显示元素</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; elems ; i++)&#123;</span><br><span class="line">             System.out.print(intArray[i]+<span class="string">" "</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 添加元素</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> value,假设操作人是不会添加重复元素的，如果有重复元素对于后面的操作都会有影响。</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span>添加成功返回true,添加的元素超过范围了返回false</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(elems == length)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             intArray[elems] = value;</span><br><span class="line">             elems++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 根据下标获取元素</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span>查找下标值在数组下标有效范围内，返回下标所表示的元素</span></span><br><span class="line"><span class="comment">      * 查找下标超出数组下标有效值，提示访问下标越界</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;elems)&#123;</span><br><span class="line">             System.out.println(<span class="string">"访问下标越界"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> intArray[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 查找元素</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> searchValue</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span>查找的元素如果存在则返回下标值，如果不存在，返回 -1</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> searchValue)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> i ;</span><br><span class="line">         <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; elems ;i++)&#123;</span><br><span class="line">             <span class="keyword">if</span>(intArray[i] == searchValue)&#123;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(i == elems)&#123;</span><br><span class="line">             <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> i;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 删除元素</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span>如果要删除的值不存在，直接返回 false;否则返回true，删除成功</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> k = find(value);</span><br><span class="line">         <span class="keyword">if</span>(k == -<span class="number">1</span>)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">if</span>(k == elems-<span class="number">1</span>)&#123;</span><br><span class="line">                 elems--;</span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i&lt; elems-<span class="number">1</span> ; i++)&#123;</span><br><span class="line">                     intArray[i] = intArray[i+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                 &#125;</span><br><span class="line">                  elems--;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 修改数据</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> oldValue原值</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> newValue新值</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span>修改成功返回true，修改失败返回false</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> oldValue,<span class="keyword">int</span> newValue)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> i = find(oldValue);</span><br><span class="line">         <span class="keyword">if</span>(i == -<span class="number">1</span>)&#123;</span><br><span class="line">             System.out.println(<span class="string">"需要修改的数据不存在"</span>);</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             intArray[i] = newValue;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="数组的局限性"><a href="#数组的局限性" class="headerlink" title="数组的局限性"></a>数组的局限性</h1><ol><li>插入快：无序数组只需要在数组末尾插入；有序数组需要在指定的位置插入</li><li>查找慢：根据下标取值是很快的，但根据元素查找的话，如果是无序数组，需要一个个遍历，是很慢的。有序数组，根据特定的算法会快一些（各种排序算法）。</li><li>删除慢：根据元素值删除，我们要先找到该元素所处的位置，然后将元素后面的值整体向前面移动一个位置。也需要比较多的时间。</li><li>数组一旦创建后，大小就固定了，不能动态扩展数组的元素个数。如果初始化你给一个很大的数组大小，那会白白浪费内存空间，如果给小了，后面数据个数增加了又添加不进去了。</li><li>需要大块连续的内存块</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构和算法（一）——简介</title>
      <link href="/2020/02/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E7%AE%80%E4%BB%8B/"/>
      <url>/2020/02/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要学习数据结构与算法"><a href="#为什么要学习数据结构与算法" class="headerlink" title="为什么要学习数据结构与算法"></a>为什么要学习数据结构与算法</h1><p>首先，学编程一定要学数据结构与算法，不会数据结构与算法一样可以编程。这矛盾吗？一点都不矛盾。学开车一定要懂发动机吗？但是你懂的发动机无疑能够更懂得汽车，汽车怎么开的更快、功耗降低。。。学习数据结构与算法能够让你了解该用什么数据结构储存数据，这涉及到编程中关键的性能和效率问题。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>数据结构是计算机存储、组织数据的方式，指相互之间存在一种或多种特定关系的数据元素的集合。</p><h3 id="数据结构的基本功能"><a href="#数据结构的基本功能" class="headerlink" title="数据结构的基本功能"></a>数据结构的基本功能</h3><ol><li>如何插入一条新的数据项</li><li>如何寻找某一特定的数据项</li><li>如何删除某一特定的数据项</li><li>如何迭代的访问各个数据项，以便进行显示或其他操作</li></ol><h3 id="常用的数据结构及优缺点"><a href="#常用的数据结构及优缺点" class="headerlink" title="常用的数据结构及优缺点"></a>常用的数据结构及优缺点</h3><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E7%AE%80%E4%BB%8B_2020-02-04-18-49-33.png" alt="数据结构和算法（一）——简介_2020-02-04-18-49-33.png"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E7%AE%80%E4%BB%8B_2020-02-04-18-52-35.png" alt="数据结构和算法（一）——简介_2020-02-04-18-52-35.png"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E7%AE%80%E4%BB%8B_2020-02-14-16-59-11.png" alt="数据结构和算法（一）——简介_2020-02-14-16-59-11.png"></p><h3 id="数据结构的选择"><a href="#数据结构的选择" class="headerlink" title="数据结构的选择"></a>数据结构的选择</h3><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E7%AE%80%E4%BB%8B_2020-02-14-17-02-10.png" alt="数据结构和算法（一）——简介_2020-02-14-17-02-10.png"></p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><pre><code>算法简单来说就是解决问题的步骤。</code></pre><p>在 Java 中，算法通常都是由类的方法来实现的。前面的数据结构，比如链表为啥插入、删除快，而查找慢，平衡的二叉树插入、删除、查找都快，这都是实现这些数据结构的算法所造成的。后面我们讲的各种排序实现也是算法范畴的重要领域。</p><h3 id="算法的五个要素"><a href="#算法的五个要素" class="headerlink" title="算法的五个要素"></a>算法的五个要素</h3><ol><li>有穷性：对于任意一组合法输入值，在执行又穷步骤之后一定能结束，即：算法中的每个步骤都能在有限时间内完成。</li><li>确定性：在每种情况下所应执行的操作，在算法中都有确切的规定，使算法的执行者或阅读者都能明确其含义及如何执行。并且在任何条件下，算法都只有一条执行路径。</li><li>可行性：算法中的所有操作都必须足够基本，都可以通过已经实现的基本操作运算有限次实现之。</li><li>有输入：作为算法加工对象的量值，通常体现在算法当中的一组变量。有些输入量需要在算法执行的过程中输入，而有的算法表面上可以没有输入，实际上已被嵌入算法之中。</li><li>有输出：它是一组与“输入”有确定关系的量值，是算法进行信息加工后得到的结果，这种确定关系即为算法功能。</li></ol><h3 id="算法的设计原则"><a href="#算法的设计原则" class="headerlink" title="算法的设计原则"></a>算法的设计原则</h3><ol><li>正确性：首先，算法应当满足以特定的“规则说明”方式给出的需求。其次，对算法是否“正确”的理解可以有以下四个层次：<ul><li>程序语法错误。</li><li>程序对于几组输入数据能够得出满足需要的结果。</li><li>程序对于精心选择的、典型、苛刻切带有刁难性的几组输入数据能够得出满足要求的结果。</li><li>程序对于一切合法的输入数据都能得到满足要求的结果。<br>　　 PS：通常以第 三 层意义的正确性作为衡量一个算法是否合格的标准。</li></ul></li><li>可读性：算法为了人的阅读与交流，其次才是计算机执行。因此算法应该易于人的理解；另一方面，晦涩难懂的程序易于隐藏较多的错误而难以调试。</li><li>健壮性：当输入的数据非法时，算法应当恰当的做出反应或进行相应处理，而不是产生莫名其妙的输出结果。并且，处理出错的方法不应是中断程序执行，而是应当返回一个表示错误或错误性质的值，以便在更高的抽象层次上进行处理。</li><li>高效率与低存储量需求：通常算法效率值得是算法执行时间；存储量是指算法执行过程中所需要的最大存储空间，两者都与问题的规模有关。</li></ol><h3 id="算法复杂度及分析"><a href="#算法复杂度及分析" class="headerlink" title="算法复杂度及分析"></a>算法复杂度及分析</h3><ul><li>如何度量一个算法的执行速度并评价其效率？</li></ul><ol><li>_渐进复杂度_： 在评价算法的运行时间时，我们往往可以忽略其在处理小规模问题时的性能，转而关注其在处理足够大规模问题时的性能，即所谓的渐进复杂度。原因不难理解，小规模的问题所需的处理时间相对更少，不同算法在效率方面的差异并不明显；只有在处理大规模的问题时，这方面的差异才有质的区别。</li><li>_基本操作次数_： 即便是同一算法、同一输入，在不同的硬<br>件平台上、使用不同的操作系统所需要的计算时间都不相同。然而实际上，无论在何种计算环境中，每一次基本操作都可以在常数时间内完成，因此如果根据算法所需执行的基本操作次数来表示，就可以更加客观地反映算法的效率。</li><li>_实测统计_： 而有些算法的时间复杂度极难从理论上作出分析，此时我们可以采用实验的方法，随机选择足够多规模不同的输入，通过实测统计得出运行时间随输入规模而增长的趋势。</li><li>_只关注时间复杂度_： 就渐进复杂度的意义而言，在任何一个算法的任何一次运行过程中，其实际占用的存储空间都不会多于其间执行的基本操作次数。从这个意义上说，时间复杂度本身就是空间复杂度的一个上界。<br><strong>注：当然，空间复杂度本身也有其存在的意义，尤其是在对空间效率非常在乎的应用场合，或者是当问题的输入规模极为庞大时。</strong></li></ol><ul><li>表示算法复杂度的度量记号大 O 级别</li></ul><ol><li>O(1)：最低的复杂度，无论数据量大小，耗时都不变，都可以在一次计算后获得。哈希算法就是典型的 O(1)</li><li>O(n)：线性，n 表示数据的量，当量增大，耗时也增大，常见有遍历算法</li><li>O(n²)：平方，表示耗时是 n 的平方倍，当看到循环嵌循环的时候，基本上这个算法就是平方级的，如：冒泡排序等</li><li>O(log n)：对数，通常 ax=n,那么数 x 叫做以 a 为底 n 的对数,也就是 x=logan，这里是 a 通常是 2，如：数量增大 8 倍，耗时只增加了 3 倍，二分查找就是对数级的算法，每次剔除一半</li><li>O(n log n)：线性对数，就是 n 乘以 log n,按照上面说的数据增大 8 倍，耗时就是 8*3=24 倍，归并排序就是线性对数级的算法</li></ol><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E7%AE%80%E4%BB%8B_2020-02-14-16-09-13.png" alt="数据结构和算法（一）——简介_2020-02-14-16-09-13.png"></p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p>数据结构与算法(java 描述)</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 简介 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM之性能监控工具</title>
      <link href="/2020/01/08/JVM%E4%B9%8B%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/"/>
      <url>/2020/01/08/JVM%E4%B9%8B%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CPU飙升到100%的原因</title>
      <link href="/2020/01/08/CPU%E9%A3%99%E5%8D%87%E5%88%B0100-%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
      <url>/2020/01/08/CPU%E9%A3%99%E5%8D%87%E5%88%B0100-%E7%9A%84%E5%8E%9F%E5%9B%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是-cpu-使用率？"><a href="#什么是-cpu-使用率？" class="headerlink" title="什么是 cpu 使用率？"></a>什么是 cpu 使用率？</h3><p>CPU％= 1 - idleTime / sysTime * 100<br>idleTime：CPU 空闲的时间<br>sysTime：CPU 处于用户模式和内核模式的时间总和</p><h3 id="与-cpu-有关的是什么？"><a href="#与-cpu-有关的是什么？" class="headerlink" title="与 cpu 有关的是什么？"></a>与 cpu 有关的是什么？</h3><p><strong>计算密集型程序的 CPU 密集程度更高</strong>。<br>那么，JAVA 应用程序中的哪些操作更加 CPU 密集？<br>以下列出了常见的 CPU 密集型操作：</p><ol><li>频繁的 GC; 如果访问量很高，可能会导致频繁的 GC 甚至 FGC。当调用量很大时，内存分配将如此之快以至于 GC 线程将连续执行，这将导致 CPU 飙升。</li><li>序列化和反序列化。稍后将给出一个示例：当程序执行 xml 解析时，调用量会增加，从而导致 CPU 变满。</li><li>序列化和反序列化;</li><li>正则表达式。我遇到了正则表达式使 CPU 充满的情况; 原因可能是 Java 正则表达式使用的引擎实现是 NFA 自动机，它将在字符匹配期间执行回溯。</li><li>线程上下文切换; 有许多已启动的线程，这些线程的状态在 Blocked（锁定等待，IO 等待等）和 Running 之间发生变化。当锁争用激烈时，这种情况很容易发生。</li><li>有些线程正在执行非阻塞操作，例如 while(true)语句。如果在程序中计算需要很长时间，则可以使线程休眠。</li></ol><h3 id="cpu-是否与进程和线程有关？"><a href="#cpu-是否与进程和线程有关？" class="headerlink" title="cpu 是否与进程和线程有关？"></a>cpu 是否与进程和线程有关？</h3><p>线程的等待及阻塞不会使用 CPU 资源，线程的频繁的上下文切换（锁竞争激烈）容易造成 CPU 飙升。</p><h3 id="一问一答"><a href="#一问一答" class="headerlink" title="一问一答"></a>一问一答</h3><ol><li><p>while 的无限循环会导致 CPU 使用率飙升吗？<br>会。<br>首先，无限循环将调用 CPU 寄存器进行计数，此操作将占用 CPU 资源。那么，如果线程始终处于无限循环状态，CPU 是否会切换线程？<br>除非操作系统时间片到期，否则无限循环不会放弃占用的 CPU 资源，并且无限循环将继续向系统请求时间片，直到系统没有空闲时间来执行任何其他操作。<br>stackoverflow 中也提出了这个问题：<a href="https://stackoverflow.com/questions/2846165/why-does-an-infinite-loop-of-the-unintended-kind-increase-the-cpu-use" target="_blank" rel="noopener">为什么无意的无限循环增加了 CPU 的使用？</a></p></li><li><p>频繁的 Young GC 会导致 CPU 占用率飙升吗？<br>会。<br>Young GC 本身就是 JVM 用于垃圾收集的操作，它需要计算内存和调用寄存器。因此，频繁的 Young GC 必须占用 CPU 资源。<br>让我们来看一个现实世界的案例。for 循环从数据库中查询数据集合，然后再次封装新的数据集合。如果内存不足以存储，JVM 将回收不再使用的数据。因此，如果所需的存储空间很大，您可能会收到 CPU 使用率警报。</p></li><li><p>对于 CPU 占用率高的应用程序，线程数是否较大？<br>不是。<br>高 CPU 使用率的关键因素是计算密集型操作。如果一个线程中有大量计算，则 CPU 使用率也可能很高。这也是数据脚本任务需要在大规模集群上运行的原因。</p></li><li><p>如果分时操作系统中 CPU 的值 us 或 sy 值很高，这意味着什么？<br>您可以使用命令查找 CPU 的值 us 和 sy 值 top<br>us：用户空间占用 CPU 的百分比。简单来说，高我们是由程序引起的。通过分析线程堆栈很容易找到有问题的线程。整编：微信公众号，搜云库技术团队，ID：souyunku<br>sy：内核空间占用 CPU 的百分比。当 sy 为高时，如果它是由程序引起的，那么它基本上是由于线程上下文切换。</p></li></ol><h3 id="如何找出-CPU-使用率高的原因"><a href="#如何找出-CPU-使用率高的原因" class="headerlink" title="如何找出 CPU 使用率高的原因"></a>如何找出 CPU 使用率高的原因</h3><p>如果发现应用程序服务器的 CPU 使用率很高，请首先检查线程数，JVM，系统负载等参数，然后使用这些参数来证明问题的原因。其次，使用 jstack 打印堆栈信息并使用工具分析线程使用情况<a href="/2020/01/08/JVM%E4%B9%8B%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/" title="JVM之性能监控工具">JVM之性能监控工具</a></p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzA3MTUzOTcxOQ==&mid=2452969215&idx=1&sn=1dc1a52231895d8cd15f0f33f774a8ef&scene=21#wechat_redirect" target="_blank" rel="noopener">这六种原因，真能让 Java 应用 CPU 使用率飙升至 100% 吗？</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux之shell脚本学习</title>
      <link href="/2019/12/16/linux%E4%B9%8Bshell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/12/16/linux%E4%B9%8Bshell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-shell？"><a href="#什么是-shell？" class="headerlink" title="什么是 shell？"></a>什么是 shell？</h2><p>代理，linux 命令与 linux 内核间的代理； 对一个纯文本的文件进行解析，然后执行这些功能，也可以说 Shell 脚本就是一系列命令的集合。</p><h2 id="shell-能做什么？"><a href="#shell-能做什么？" class="headerlink" title="shell 能做什么？"></a>shell 能做什么？</h2><ul><li>将一些复杂的命令简单化(平时我们提交一次 github 代码可能需要很多步骤，但是可以用 Shell 简化成一步)</li><li>可以写一些脚本自动实现一个工程中自动更换最新的 sdk(库)</li><li>自动打包、编译、发布等功能</li><li>清理磁盘中空文件夹</li><li>总之一切有规律的活脚本都可以尝试一下</li></ul><h2 id="shell-不能做什么？"><a href="#shell-不能做什么？" class="headerlink" title="shell 不能做什么？"></a>shell 不能做什么？</h2><ul><li>需要精密的运算的时候</li><li>需要语言效率很高的时候</li><li>需要一些网络操作的时候</li><li>总之 Shell 就是可以快速开发一个脚本简化开发流程，并不可以用来替代高级语言</li></ul><h2 id="shell-工作原理"><a href="#shell-工作原理" class="headerlink" title="shell 工作原理"></a>shell 工作原理</h2><p>Shell 可以被称作是脚本语言，因为它本身是不需要编译的，而是通过解释器解释之后再编译执行，和传统语言相比多了解释的过程所以效率会略差于传统的直接编译的语言。</p><h2 id="hello-world-脚本"><a href="#hello-world-脚本" class="headerlink" title="hello world 脚本"></a>hello world 脚本</h2><blockquote><p>#!/bin/bash<br>echo “Hello World”</p></blockquote><h2 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h2><blockquote><p>cd 到该目录下<br>chmod +x ./test.sh #给脚本权限<br>./test.sh #执行脚本<br>也可以直接 sh test.sh，无须#!/bin/bash</p></blockquote><p><img src="/images/linux%E4%B9%8Bshell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0_2019-12-19-15-29-37.png" alt="linux之shell脚本学习_2019-12-19-15-29-37.png"></p><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="创建变量"><a href="#创建变量" class="headerlink" title="创建变量"></a>创建变量</h4><blockquote><p>myText=”hello world”<br>muNum=100</p></blockquote><p>“=”前后不能有空格，命名规则就和其它语言一样。</p><h4 id="访问变量"><a href="#访问变量" class="headerlink" title="访问变量"></a>访问变量</h4><blockquote><p>myText=”hello world”<br>muNum=100<br>echo $myText<br>echo muNum</p></blockquote><p>当想要访问变量的时候，需要使用$，否则输出的将是纯文本内容:</p><blockquote><p>root@8f24935911d1:/home/qn/shell# ./hello.sh<br>hello world<br>muNum</p></blockquote><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除 + - * /"></a>加减乘除 + - * /</h4><blockquote><p>#!/bin/bash<br>echo “Hello World !”<br>a=3<br>b=5<br>val=<code>expr $a + $b</code><br>echo “Total value : $val”<br>val=<code>expr $a - $b</code><br>echo “Total value : $val”<br>val=<code>expr $a \* $b</code><br>echo “Total value : $val”<br>val=<code>expr $a / $b</code><br>echo “Total value : $val”</p></blockquote><p>定义变量的时候“=”前后是不能有空格的，但是进行四则运算的时候运算符号前后一定要有空格，乘法的时候需要进行转义</p><blockquote><p>root@8f24935911d1:/home/qn/shell# ./hello.sh<br>Hello World !<br>Total value : 8<br>Total value : -2<br>Total value : 15<br>Total value : 0</p></blockquote><h4 id="其它运算符-、-、-、！、-o、-a"><a href="#其它运算符-、-、-、！、-o、-a" class="headerlink" title="其它运算符 =、==、!=、！、-o、-a"></a>其它运算符 =、==、!=、！、-o、-a</h4><p><img src="/images/linux%E4%B9%8Bshell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0_2019-12-19-15-49-19.png" alt="linux之shell脚本学习_2019-12-19-15-49-19.png"></p><blockquote><p>a=3<br>b=5<br>val=<code>expr $a / $b</code><br>echo “Total value : $val”<br>val=<code>expr $a % $b</code><br>echo “Total value : $val”<br>if [ $a == $b ]<br>then<br>&emsp;&emsp;echo “a is equal to b”<br>fi<br>if [ $a != $b ]<br>then<br>&emsp;&emsp;echo “a is not equal to b”<br>fi</p></blockquote><blockquote><p>root@8f24935911d1:/home/qn/shell# ./hello.sh<br>Total value : 0<br>Total value : 3<br>a is not equal to b</p></blockquote><h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p><img src="/images/linux%E4%B9%8Bshell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0_2019-12-19-15-58-30.png" alt="linux之shell脚本学习_2019-12-19-15-58-30.png"></p><blockquote><p>a=10<br>b=20<br>if [ $a -eq $b ]<br>then<br>&emsp;&emsp;echo “true”<br>else<br>&emsp;&emsp;echo “false”<br>fi<br>if [ $a -ne $b ]<br>then<br>&emsp;&emsp;echo “true”<br>else<br>&emsp;&emsp;echo “false”<br>fi<br>if [ $a -gt $b ]<br>then<br>&emsp;&emsp;echo “true”<br>else<br>&emsp;&emsp;echo “false”<br>fi<br>if [ $a -lt $b ]<br>then<br>&emsp;&emsp;echo “true”<br>else<br>&emsp;&emsp;echo “false”<br>fi<br>if [ $a -ge $b ]<br>then<br>&emsp;&emsp;echo “true”<br>else<br>&emsp;&emsp;echo “false”<br>fi<br>if [ $a -le $b ]<br>then<br>&emsp;&emsp;echo “true”<br>else<br>&emsp;&emsp;echo “false”<br>fi</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux脚本之crontab(定时任务)</title>
      <link href="/2019/12/16/linux%E8%84%9A%E6%9C%AC%E4%B9%8Bcrontab-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/2019/12/16/linux%E8%84%9A%E6%9C%AC%E4%B9%8Bcrontab-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>crontab 命令常见于 Unix 和类 Unix 的操作系统之中，用于设置周期性被执行的指令。</li><li>该命令从标准输入设备读取指令，并将其存放于 crontab 文件中</li><li>crontab 储存的指令被守护进程激活，crond 常常在后台运行，每一分钟检查是否有预定的作业需要执行。这类作业一般称为 cron jobs。</li></ul><h2 id="安装-cron-docker-ubuntu"><a href="#安装-cron-docker-ubuntu" class="headerlink" title="安装 cron(docker ubuntu)"></a>安装 cron(docker ubuntu)</h2><h3 id="确认是否安装"><a href="#确认是否安装" class="headerlink" title="确认是否安装"></a>确认是否安装</h3><p>一般 linux 版本都已经安装了 crontab，我们可以执行 crontab 确认：</p><blockquote><p>-bash: crontab: command not found</p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote><p>apt-get install cron</p></blockquote><p>如果报出这个错误：Unable to locate package，这个错误一般是因为软件源未更新造成的，于是采用命令：sudo apt-get update 来更新软件源</p><h3 id="确认-cron-安装成功"><a href="#确认-cron-安装成功" class="headerlink" title="确认 cron 安装成功"></a>确认 cron 安装成功</h3><blockquote><p>crontab -l</p></blockquote><h3 id="设置定时任务"><a href="#设置定时任务" class="headerlink" title="设置定时任务"></a>设置定时任务</h3><blockquote><p>crontab -e</p></blockquote><p>_/1 _ * * * cd /home/qn/shell&amp;&amp;sh test.sh &gt; time.log</p><h3 id="启动定时任务"><a href="#启动定时任务" class="headerlink" title="启动定时任务"></a>启动定时任务</h3><blockquote><p>service cron start</p></blockquote><h2 id="安装日志服务-rsyslog"><a href="#安装日志服务-rsyslog" class="headerlink" title="安装日志服务 rsyslog"></a>安装日志服务 rsyslog</h2><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><blockquote><p>vi /etc/rsyslog.d/50-default.conf</p></blockquote><p>cron.* /var/log/cron.log #将 cron 前面的注释符去掉</p><h3 id="启动日志服务"><a href="#启动日志服务" class="headerlink" title="启动日志服务"></a>启动日志服务</h3><blockquote><p>service rsyslog start</p></blockquote><h3 id="重启-cron"><a href="#重启-cron" class="headerlink" title="重启 cron"></a>重启 cron</h3><blockquote><p>service cron restart</p></blockquote><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><blockquote><p>tail -f /var/log/cron.log</p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>时程表的格式如下:</p><blockquote><p>f1 f2 f3 f4 f5 program</p></blockquote><p>其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执行的程式。</p>]]></content>
      
      
      <categories>
          
          <category> linux脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 定时任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka的原理解析</title>
      <link href="/2019/12/05/Kafka%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
      <url>/2019/12/05/Kafka%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>Kafka 是最初由 Linkedin 公司开发，是一个分布式、支持分区的（<code>partition</code>）、多副本的（<code>replica</code>），基于<code>zookeeper</code>协调的分布式消息系统，它的最大的特性就是可以实时的处理大量数据。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>消息队列的性能好坏，其<strong>文件存储机制设计</strong>是衡量一个消息队列服务技术水平和最关键指标之一。下面将从 Kafka 文件存储机制和物理结构角度，分析 Kafka 是如何实现高效文件存储，及实际应用效果。</p><h2 id="kafka-特性"><a href="#kafka-特性" class="headerlink" title="kafka 特性"></a>kafka 特性</h2><h3 id="高吞吐量、低延迟"><a href="#高吞吐量、低延迟" class="headerlink" title="高吞吐量、低延迟"></a>高吞吐量、低延迟</h3><p>kafka 每秒可以处理几十万条消息，它的延迟最低只有几毫秒。（每个 topic 可以分多个 partition, consumer group 多个 consume thread 对 partition 进行消费）</p><h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>kafka 支持热扩展，水平扩展（partition）</p><h3 id="持久性、可靠性"><a href="#持久性、可靠性" class="headerlink" title="持久性、可靠性"></a>持久性、可靠性</h3><p>消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</p><h3 id="容错性"><a href="#容错性" class="headerlink" title="容错性"></a>容错性</h3><p>允许集群中节点失败（若副本数量为 n,则允许 n-1 个节点失败）</p><h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h3><p>支持数千个客户端同时读写</p><h2 id="kafka-使用场景"><a href="#kafka-使用场景" class="headerlink" title="kafka 使用场景"></a>kafka 使用场景</h2><h3 id="日志收集"><a href="#日志收集" class="headerlink" title="日志收集"></a>日志收集</h3><p>一个公司可以用 Kafka 可以收集各种服务的 log，通过 kafka 以统一接口服务的方式开放给各种 consumer，例如 hadoop、Hbase、Solr 等。</p><h3 id="消息系统"><a href="#消息系统" class="headerlink" title="消息系统"></a>消息系统</h3><p>解耦和生产者和消费者、缓存消息等。</p><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p>轨迹，访问量等信息，被各服务推送到 topic，消费者通过订阅这些消息做监控分析。</p><h3 id="运营指标"><a href="#运营指标" class="headerlink" title="运营指标"></a>运营指标</h3><p>Kafka 也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</p><h3 id="流式处理"><a href="#流式处理" class="headerlink" title="流式处理"></a>流式处理</h3><p>比如 spark streaming 和 storm</p><h3 id="事件源"><a href="#事件源" class="headerlink" title="事件源"></a>事件源</h3><p>略</p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><p>kafka 集群节点,在集群中每个 broker 都有一个唯一 brokerid，不得重复。</p><h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><ul><li>在 Kafka 中的每一条消息都有一个 Topic。一般来说在我们应用中产生不同类型的数据，都可以设置不同的主题。</li><li>一个主题一般会有多个消息的订阅者，当生产者发布消息到某个主题时，订阅了这个主题的消费者都可以接收到生产者写入的新消息。</li></ul><h3 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h3><p>kafka 是面对分布式系统的，同时一个 topic 对应 partition，一个 partition 有对个副本,会从所有的副本中选取一个 leader 出来。所有读写操作都是通过 leader 来进行的。一个 partition 是个有序队列。</p><h3 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h3><p>在分区中的每条消息都会按照时间顺序分配到一个单调递增的顺序编号，也就是我们的 Offset。Offset 是一个 Long 型的数字。</p><h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>负责发布消息到 Kafka broker。</p><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>消息消费者，向 Kafka broker 读取消息的客户端。</p><h3 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h3><p>各个 consumer（consumer 线程）可以组成一个组（Consumer group），partition 中的每个 message 只能被组（Consumer group）中的一个 consumer（consumer 线程）消费。</p><h2 id="Zookeeper-在-kafka-的作用"><a href="#Zookeeper-在-kafka-的作用" class="headerlink" title="Zookeeper 在 kafka 的作用"></a>Zookeeper 在 kafka 的作用</h2><blockquote><p>kafka 用 zk 做 meta 信息存储，consumer 的消费状态，group 的管理以及 offse t 的值。考虑到 zk 本身的一些因素以及整个架构较大概率存在单点问题，新版本中确实逐渐弱化了 zookeeper 的作用。新的 consumer 使用了 kafka 内部的 group coordination 协议，也减少了对 zookeeper 的依赖</p></blockquote><h3 id="zookeeper-储存"><a href="#zookeeper-储存" class="headerlink" title="zookeeper 储存"></a>zookeeper 储存</h3><ul><li>储存结构图</li></ul><p><img src="/images/Kafka%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90_2019-12-09-15-48-21.png" alt="Kafka的原理解析_2019-12-09-15-48-21.png"></p><ul><li>broker 注册</li></ul><p>/brokers/ids/[0..n] 向 zookeeper 注册自己的节点信息，是一个临时节点，及 broker.id,当 id&gt;0 才会正常启动；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Schema:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"jmx_port"</span>: jmx端口号,</span><br><span class="line"><span class="string">"timestamp"</span>: kafka broker初始启动时的时间戳,</span><br><span class="line"><span class="string">"host"</span>: 主机名或ip地址,</span><br><span class="line"><span class="string">"version"</span>: 版本编号默认为<span class="number">1</span>,</span><br><span class="line"><span class="string">"port"</span>: kafka broker的服务端端口号,由server.properties中参数port确定</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"jmx_port"</span>: -<span class="number">1</span>,</span><br><span class="line"><span class="string">"timestamp"</span>:<span class="string">"1525741823119"</span></span><br><span class="line"><span class="string">"version"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="string">"host"</span>: <span class="string">"hadoop1"</span>,</span><br><span class="line"><span class="string">"port"</span>: <span class="number">9092</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>topic 注册</li></ul><p>/brokers/topics/[topic] 向 zookeeper 注册 topic 信息，以及 topic 下所有 partition 分配信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Schema:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"jmx_port"</span>: jmx端口号,</span><br><span class="line"><span class="string">"timestamp"</span>: kafka broker初始启动时的时间戳,</span><br><span class="line"><span class="string">"host"</span>: 主机名或ip地址,</span><br><span class="line"><span class="string">"version"</span>: 版本编号默认为<span class="number">1</span>,</span><br><span class="line"><span class="string">"port"</span>: kafka broker的服务端端口号,由server.properties中参数port确定</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"jmx_port"</span>: -<span class="number">1</span>,</span><br><span class="line"><span class="string">"timestamp"</span>:<span class="string">"1525741823119"</span></span><br><span class="line"><span class="string">"version"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="string">"host"</span>: <span class="string">"hadoop1"</span>,</span><br><span class="line"><span class="string">"port"</span>: <span class="number">9092</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>partition 注册</li></ul><p>/brokers/topics/[topic]/partitions/[partitionId]/state 注册 partition 状态信息（副本 leader 所在的 brokerId）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Schema:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"controller_epoch"</span>: 表示kafka集群中的中央控制器选举次数,</span><br><span class="line"><span class="string">"leader"</span>: 表示该partition选举leader的brokerId,</span><br><span class="line"><span class="string">"version"</span>: 版本编号默认为<span class="number">1</span>,</span><br><span class="line"><span class="string">"leader_epoch"</span>: 该partition leader选举次数,</span><br><span class="line"><span class="string">"isr"</span>: [同步副本组brokerId列表]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"controller_epoch"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="string">"leader"</span>: <span class="number">3</span>,</span><br><span class="line"><span class="string">"version"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="string">"leader_epoch"</span>: <span class="number">0</span>,</span><br><span class="line"><span class="string">"isr"</span>: [<span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>控制器选举次数</li></ul><p>/controller_epoch –&gt; int (epoch) 注册 broker leader 选举次数</p><ul><li>broker leader 注册</li></ul><p>/controller -&gt; int (broker id of the controller) 存储 center controller 中央控制器所在 kafka broker 的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Schema:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"version"</span>: 版本编号默认为<span class="number">1</span>,</span><br><span class="line"><span class="string">"brokerid"</span>: kafka集群中broker唯一编号,</span><br><span class="line"><span class="string">"timestamp"</span>: kafka broker中央控制器变更时的时间戳</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"version"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="string">"brokerid"</span>: <span class="number">0</span>,</span><br><span class="line"><span class="string">"timestamp"</span>: <span class="string">"1525741822769"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Consumer 注册信息</li></ul><p>/consumers/[groupId]/ids/[consumerIdString] 每个 Consumer 启动时，都会向 zookeeper 注册自己的信息，是一个临时节点；consumerIdString 产生规则：即表示此 consumer 目前所消费的 topic + partitions 列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Schema:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"version"</span>: 版本编号默认为<span class="number">1</span>,</span><br><span class="line"><span class="string">"subscription"</span>: &#123; <span class="comment">//订阅topic列表</span></span><br><span class="line"><span class="string">"topic名称"</span>: consumer中topic消费者线程数</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"pattern"</span>: <span class="string">"static"</span>,</span><br><span class="line"><span class="string">"timestamp"</span>: <span class="string">"consumer启动时的时间戳"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"version"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="string">"subscription"</span>: &#123;</span><br><span class="line"><span class="string">"topic2"</span>: <span class="number">1</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"pattern"</span>: <span class="string">"white_list"</span>,</span><br><span class="line"><span class="string">"timestamp"</span>: <span class="string">"1525747915336"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Consumer owner</li></ul><p>/consumers/[groupId]/owners/[topic]/[partitionId] -&gt; consumerIdString + threadId 索引编号</p><ol><li>首先进行”Consumer Id 注册”;</li><li>然后在”Consumer id 注册”节点下注册一个 watch 用来监听当前 group 中其他 consumer 的”退出”和”加入”;只要此 znode path 下节点列表变更,都会触发此 group 下 consumer 的负载均衡.(比如一个 consumer 失效,那么其他 consumer 接管 partitions).</li><li>在”Broker id 注册”节点下,注册一个 watch 用来监听 broker 的存活情况;如果 broker 列表变更,将会触发所有的 groups 下的 consumer 重新 balance.</li></ol><ul><li>Consumer offset</li></ul><p>/consumers/[groupId]/offsets/[topic]/[partitionId] -&gt; long (offset)<br>用来跟踪每个 consumer 目前所消费的 partition 中最大的 offset<br>此 znode 为持久节点,可以看出 offset 跟 group_id 有关,以表明当消费者组(consumer group)中一个消费者失效,<br>重新触发 balance,其他 consumer 可以继续消费</p><h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><h3 id="消息写入"><a href="#消息写入" class="headerlink" title="消息写入"></a>消息写入</h3><ul><li>序列化 ProducerRecord</li></ul><p>每个消息是一个 ProducerRecord 对象，必须指定消息所属的 Topic 和消息值 Value，此外还可以指定消息所属的 Partition 以及消息的 Key。</p><ul><li>推送到 partition</li></ul><p>对于每条待发送的消息而言，如果该消息指定了 key，则 partitioner（分区器）会根据 key 的哈希值来选择目标分区，将具有相同 key 的所有消息都路由到相同的分区中；若该消息未指定 key，则 partitioner 使用轮询的方式确认目标分区</p><ul><li>找到分区副本 leader</li></ul><p>Producers 直接发送消息到 broker 上的 leader partition（分区副本选举）</p><ol><li>producer 先从 zookeeper 的 “/brokers/…/state”节点找到该 partition 的 leader</li><li>producer 将消息发送给该 leader</li><li>leader 将消息写入本地 log</li><li>followers 从 leader pull 消息，写入本地 log 后向 leader 发送 ACK</li><li>leader 收到所有 ISR 中的 replication 的 ACK 后，增加 HW（high watermark，最后 commit 的 offset）并向 producer 发送 ACK</li></ol><h3 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h3><ul><li>批量发送</li></ul><p>消息写入到目标分区的一块内存缓冲池中。而 producer 的另一个工作线程(I/O 发送线程，也称 Sender 线程)则负责实时地从该缓冲区中提取准备就绪的消息封装进一个批次(batch),统一发送给对应的 broker。</p><ul><li>同步异步发送</li></ul><p>Kafka producer 发送消息的主方法是 send 方法，producer 在底层完全实现了异步化发送，并且通过 Java 提供的 Future 同时实现了同步发送和异步发送+回调(Callback)(默认异步)两种发送方式。最后 producer 程序结束时需要关闭 producer。</p><h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><ul><li>asks 参数</li></ul><ol><li>acks 设置为 0，表示 producer 不会等待 broker 的响应；所以 producer 无法知道消息是否发送成功，这样有可能会导致数据丢失，但同时，acks 值为 0 会得到最大的系统吞吐量。</li><li>若 acks 设置为 1，表示 producer 会在 leader partition 收到消息时得到 broker 的一个确认，这样会有更好的可靠性，因为客户端会等待直到 broker 确认收到消息。</li><li>若设置为-1，producer 会在所有备份的 partition 收到消息时得到 broker 的确认，这个设置可以得到最高的可靠性保证。</li></ol><ul><li>bootstrap.servers</li></ul><p>broker 列表</p><ul><li>buffer.memory 参数</li></ul><ol><li>指定 producer 端用于缓存消息的缓冲区的大小，单位是字节，默认 32M，采用异步发送消息的架构；</li><li>Java 版 Producer 启动时会首先创建一块内存缓冲区用于保存待发送消息，然后由另一个专属线程负责从缓冲区中读取消息执行真正的发送，这部分内存空间的大小就是由 buffer.memory 参数指定。该参数指定的内存大小几乎可以认为是 producer 程序使用的内存大小，若 producer 程序要给很多分区发送消息，那么就需要仔细设置该参数防止过小的内存缓冲区降低了 producer 程序整体的吞吐量。</li></ol><ul><li>batch.size 参数</li></ul><ol><li>batch.size 是 producer 调优吞吐量与延时性能最重要的参数之一，producer 会将发往同一分区的多条消息封装进一个 batch 中，当 batch 满了或者 batch 没满(linger.ms 参数=0，默认消息立即发送)producer 会发送该 batch。</li><li>Batch 小，吞吐量低，延时低，Batch 大，吞吐量高，延时高</li><li>Batch.size 默认为 16KB。</li></ol><ul><li>request.timeout.ms 参数</li></ul><p>当 producer 发送请求给 broker 后，broker 需要在规定时间范围内将处理结果返回给 producer。超时时间默认 30s</p><h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><h3 id="订阅-topic"><a href="#订阅-topic" class="headerlink" title="订阅 topic"></a>订阅 topic</h3><p>kafka 以 Consumer Group 的方式去订阅 topic,topic 的每条消息只能发送到订阅它的消费者组(Consumer Group)的其中一个实例上，并且每个消费者至多使用一个消费者组来标示自己。</p><h3 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h3><ul><li>Consumer 端使用 zookeeper 用来注册 consumer 信息,其中包括 consumer 消费的 partition 列表等,同时也用来发现 broker 列表,并和 partition leader 建立 socket 连接,并获取消息。</li><li>订阅 topic 后，当 consumer 调用 poll(拉取模型)时，会自动加入相应的 Consumer Group；只要 consumer 持续 poll，consumer 将持续的从分配给他的 topic partitions 接收消息；</li><li>consumer 会在后台持续向服务发送心跳，如果 consumer 进程崩溃或者在 session.timeout.ms 期间没有发送心跳，这个 consumer 将会被认为已经死掉了，他的分区将会被重新分配。</li></ul><h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><ul><li>bootstrap.servers</li></ul><p>broker 列表</p><ul><li>enable.auto.commit</li></ul><p>将以配置项 auto.commit.interval.ms 指定的频率自动提交 offset</p><ul><li>auto.commit.interval.ms</li></ul><p>提交 offset 的频率</p><ul><li>group.id</li></ul><p>指定该 consumer 所属的 Consumer Group</p><ul><li>deserializer</li></ul><p>字节转换</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="Consumer-Group-解析"><a href="#Consumer-Group-解析" class="headerlink" title="Consumer Group 解析"></a>Consumer Group 解析</h3><blockquote><p>什么是 consumer group? 一言以蔽之，consumer group 是 kafka 提供的可扩展且具有容错性的消费者机制。既然是一个组，那么组内必然可以有多个消费者或消费者实例(consumer instance)，它们共享一个公共的 ID，即 group ID。组内的所有消费者协调在一起来消费订阅主题(subscribed topics)的所有分区(partition)。当然，每个分区只能由同一个消费组内的一个 consumer 来消费。</p></blockquote><ul><li>架构图</li></ul><p><img src="/images/Kafka%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90_2019-12-09-17-17-24.png" alt="Kafka的原理解析_2019-12-09-17-17-24.png"></p><ul><li>核心</li></ul><ol><li>唯一标识</li></ol><p>group.id 是一个字符串，唯一标识一个 consumer group</p><ol start="2"><li>限制</li></ol><p>consumer group 下订阅的 topic 下的每个分区只能分配给某个 group 下的一个 consumer(当然该分区还可以被分配给其他 group)，所以如果想同时对一个 topic 做消费的话，启动多个 consumer group 就可以了。</p><ol start="3"><li>水平扩展</li></ol><p>kafka 为了保证吞吐量，只允许同一个 consumer group 下的一个 consumer 线程去访问一个 partition，这样就避免了阻塞（悲观锁）；如果觉得效率不高的时候，可以加 partition 的数量来横向扩展，那么再加新的 consumer thread 去消费；当启动一个 consumer group 去消费一个 topic 的时候，无论 topic 里面有多个少个 partition，无论我们 consumer group 里面配置了多少个 consumer thread，这个 consumer group 下面的所有 consumer thread 一定会消费全部的 partition；即便这个 consumer group 下只有一个 consumer thread，那么这个 consumer thread 也会去消费所有的 partition。</p><ol start="4"><li>最优设计</li></ol><p>consumer group 下的 consumer thread 的数量等于 partition 数量，这样效率是最高的。</p><ul><li>Consumer Rebalance</li></ul><ol><li>什么是 rebalance</li></ol><p>rebalance 本质上是一种协议，规定了一个 consumer group 下的所有 consumer 如何达成一致来分配订阅 topic 的每个分区。比如某个 group 下有 20 个 consumer，它订阅了一个具有 100 个分区的 topic。正常情况下，Kafka 平均会为每个 consumer 分配 5 个分区。这个分配的过程就叫 rebalance。</p><ol start="2"><li>rebalance 的触发条件有三种</li></ol><ul><li><p>组成员发生变更(新 consumer 加入组、已有 consumer 主动离开组或已有 consumer 崩溃了——这两者的区别后面会谈到)</p></li><li><p>订阅主题数发生变更——这当然是可能的，如果你使用了正则表达式的方式进行订阅，-那么新建匹配正则表达式的 topic 就会触发 rebalance</p></li><li><p>订阅主题的分区数发生变更</p></li><li><p>Consumer Group 管理</p></li></ul><p>依赖 zookeeper 来实现对于 consumer group 的管理。（具体见 zookeeper 上 cunsumer 的储存）</p><h3 id="offsite-量的维护"><a href="#offsite-量的维护" class="headerlink" title="offsite 量的维护"></a>offsite 量的维护</h3><p>kafka 消息是顺序读取，必须维护上一次读到哪里的 offset 信息。<br>维护 offset 有两套机制，<code>high level API</code> 的 offset 存于 Zookeeper 中；<code>low level API</code> 的 offset 由自己维护。消息生产端不用维护 offset，因为消息 offset 默认是自增的。</p><ul><li>high level api</li></ul><p>offset 是维护在 Zookeeper 上，先拿 message 处理，再定时自动 commit offsite+1（也可以改成手动）, 并且 kakfa 处理 message 是没有锁操作的。<br>因此如果处理 message 失败，此时还没有 commit offsite+1，当 consumer thread 重启后会重复消费这个 message。<br>但是作为高吞吐量高并发的实时处理系统，at least once 的情况下，至少一次会被处理到，是可以容忍的。</p><ul><li>low level api</li></ul><p>如果无法容忍，就得使用 low level api 来自己程序维护这个 offsite 信息，那么想什么时候 commit offsite+1 就自己搞定了。<br>lance 到一个 partition 上，一起插进去，offsite 作为自增 id 自己增加就好。</p><h3 id="消费模型"><a href="#消费模型" class="headerlink" title="消费模型"></a>消费模型</h3><p>消息由生产者发送到 Kafka 集群后，会被消费者消费。一般来说我们的消费模型有两种：推送模型（push）、拉取模型（pull）</p><ul><li><p>推送模型<br>基于推送模型的消息系统，由消息代理记录消费状态。消息代理将消息推送到消费者后，标记这条消息为已经被消费，但是这种方式无法很好地保证消费的处理语义。<br>比如当我们已经把消息发送给消费者之后，由于消费进程挂掉或者由于网络原因没有收到这条消息，如果我们在消费代理将其标记为已消费，这个消息就永久丢失了。<br>如果我们利用生产者收到消息后回复这种方法，消息代理需要记录消费状态，这种不可取。<br>如果采用 Push，消息消费的速率就完全由消费代理控制，一旦消费者发生阻塞，就会出现问题。</p></li><li><p>拉取模型</p></li></ul><p>Kafka 采取拉取模型(Poll)，由自己控制消费速度，以及消费的进度，消费者可以按照任意的偏移量进行消费。比如消费者可以消费已经消费过的消息进行重新处理，或者消费最近的消息等等。</p><h3 id="kafka-吞吐量大的原因？"><a href="#kafka-吞吐量大的原因？" class="headerlink" title="kafka 吞吐量大的原因？"></a>kafka 吞吐量大的原因？</h3><ol><li>kafka 针对一个 partition，不是通过对多个 consumer thread 加悲观锁来防止重复消费，而是一个 partition 只能同时被一个 consumer thread 消费，如果消息数量太大觉得效率不高要增大吞吐量，直接横向扩展 partition 数量，同时增加一个 consumer group 下的 consumer thread 数量即可。这样没有锁竞争，充分发挥了横向的扩展性，吞吐量极高。</li><li>kafka 分布式并发的读和写都非常快，写的性能体现在以 o(1)的时间复杂度进行顺序写入。读的性能体现在以 o(1)的时间复杂度进行顺序读取，<br>对 topic 进行 partition 分区，consume group 中的 consume 线程可以以很高能性能进行顺序读。</li><li>大量使用操作系统页缓存，内存操作速度快且命中率高</li><li>Kafka 不直接参与物理 I/O 操作，而是交由最擅长此事的操作系统来完成</li><li>使用以 sendfile 为代表的零拷贝技术加强网络间的数据传输速率</li></ol><h3 id="kafka-消息持久化"><a href="#kafka-消息持久化" class="headerlink" title="kafka 消息持久化"></a>kafka 消息持久化</h3><p>Kafka 由操作系统自行决定什么时候把页缓存中的数据写回磁盘上。Kafka 依赖操作系统的 flush“刷盘”功能实现消息真正写入物理磁盘，而默认的刷盘间隔是 5s，通常情况下，该间隔太短，适当增加例如 2min 可以大程度上提升操作系统物理写入操作的性能。<br>此外，传统持久化方式是优先使用内存，内存不足后再一次性写入磁盘，Kafka 相反，当操作系统决定将页缓存中的数据写入到磁盘上时，会优先写入到磁盘（文件系统的持久化日志），减少了 Kafka 程序对内存的消耗，将内存主要供于页缓存使用<br>此外持久化到磁盘上的好处如下：</p><ol><li>解耦消息发送与消息消费</li><li>实现灵活的消息处理：如重置消费位点等</li></ol><h3 id="消息可靠性和稳定性和容错性"><a href="#消息可靠性和稳定性和容错性" class="headerlink" title="消息可靠性和稳定性和容错性"></a>消息可靠性和稳定性和容错性</h3><ul><li>broker 上的可靠性</li></ul><p>因为消息会持久化到磁盘上，所以如果正常 stop 一个 broker，其上的数据不会丢失；但是如果不正常 stop，可能会使存在页面缓存来不及写入磁盘的消息丢失，这可以通过配置 flush 页面缓存的周期、阈值缓解，但是同样会频繁的写磁盘会影响性能，又是一个选择题，根据实际情况配置。</p><ul><li>消息消费的可靠性</li></ul><ol><li>At most once 消息可能会丢，绝对不会重复传输；</li><li>At least once 消息绝对不会丢，但是可能会重复传输；</li><li>Exactly once 每条信息肯定会被传输一次且仅传输一次，这是用户想要的。</li></ol><p>Kafka 提供的是<code>At least once</code>模型，因为消息的读取进度由 offset 提供，offset 可以由消费者自己维护也可以维护在 zookeeper 里，但是当消息消费后 consumer 挂掉，offset 没有即时写回，就有可能发生重复读的情况，这种情况同样可以通过调整 commit offset 周期、阈值缓解，甚至消费者自己把消费和 commit offset 做成一个事务解决，但是如果你的应用不在乎重复消费，那就干脆不要解决，以换取最大的性能。</p><ul><li><p>消息生产的可靠性</p></li><li><p>acks 设置为 0，表示 producer 不会等待 broker 的响应；所以 producer 无法知道消息是否发送成功，这样有可能会导致数据丢失，但同时，acks 值为 0 会得到最大的系统吞吐量。</p></li><li><p>若 acks 设置为 1，表示 producer 会在 leader partition 收到消息时得到 broker 的一个确认，这样会有更好的可靠性，因为客户端会等待直到 broker 确认收到消息。</p></li><li><p>若设置为-1，producer 会在所有备份的 partition 收到消息时得到 broker 的确认，这个设置可以得到最高的可靠性保证。</p></li><li><p>备份</p></li></ul><p>Kafka 的备份的单元是 partition，也就是每个 partition 都都会有 leader partiton 和 follow partiton。其中 leader partition 是用来进行和 producer 进行写交互，follow 从 leader 副本进行拉数据进行同步，从而保证数据的冗余，防止数据丢失的目的。</p><h3 id="中央控制器的选举"><a href="#中央控制器的选举" class="headerlink" title="中央控制器的选举"></a>中央控制器的选举</h3><p>集群中的 kafka 节点会根据选举机制选出一个 leader，作为 kafka broker controller，又称为控制器；其他节点因为选举失败，会创建一个 watch 对象，时刻盯着 leader，如果 leader 宕机（或者未通过 zookeeper 心跳监测），那么此时所有节点又会再次选举。</p><h3 id="partiton-中文件存储方式"><a href="#partiton-中文件存储方式" class="headerlink" title="partiton 中文件存储方式"></a>partiton 中文件存储方式</h3><p>-每个 partion(目录)相当于一个巨型文件被平均分配到多个大小相等 segment(段)数据文件中。但每个段 segment file 消息数量不一定相等，这种特性方便 old segment file 快速被删除。 -每个 partiton 只需要支持顺序读写就行了，segment 文件生命周期由服务端配置参数决定。这样做的好处就是能快速删除无用文件，有效提高磁盘利用率。</p><h3 id="副本集合（ISR）"><a href="#副本集合（ISR）" class="headerlink" title="副本集合（ISR）"></a>副本集合（ISR）</h3><ul><li>Kafka 动态维护了一个同步状态的副本的集合（a set of in-sync replicas），简称 ISR。</li><li>在这个集合中的节点都是和 leader 保持高度一致的，任何一条消息必须被这个集合中的每个节点读取并追加到日志中了，才回通知外部这个消息已经被提交了。因此这个集合中的任何一个节点随时都可以被选为 leader.ISR 在 ZooKeeper 中维护。</li><li>ISR 中有 f+1 个节点，就可以允许在 f 个节点 down 掉的情况下不会丢失消息并正常提供服。ISR 的成员是动态的，如果一个节点被淘汰了，当它重新达到“同步中”的状态时，他可以重新加入 ISR.这种 leader 的选择方式是非常快速的，适合 kafka 的应用场景。</li></ul><h3 id="分区副本的选举"><a href="#分区副本的选举" class="headerlink" title="分区副本的选举"></a>分区副本的选举</h3><ul><li><code>什么是分区副本</code>？分区（partition）概念见图 3，在 kafka 的集群中，会存在着多个主题 topic，在每一个 topic 中，又被划分为多个 partition，为了防止数据不丢失，每一个 partition 又有多个副本（Replica）</li><li><code>首领副本</code>：也就是 leader 主副本，每个分区都有一个首领副本，为了保证数据一致性，所有的生产者与消费者的请求都会经过该副本来处理。</li><li><code>跟随着副本</code>：除了首领副本外的其他所有副本都是跟随者副本，跟随者副本不处理来自客户端的任何请求，只负责从首领副本同步数据，保证与首领保持一致。如果首领副本发生崩溃，就会从这其中选举出一个 leader。</li><li><code>首选首领副本</code>：创建分区时指定的首选首领。如果不指定，则为分区的第一个副本。</li></ul><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><ul><li><p>每个 log entry 格式为”4 个字节的数字 N 表示消息的长度” + “N 个字节的消息内容”;每个日志都有一个 offset 来唯一的标记一条消息,offset 的值为 8 个字节的数字,表示此消息在此 partition 中所处的起始位置..每个 partition 在物理存储层面,有多个 log file 组成(称为 segment).segment file 的命名为”最小 offset”.kafka.例如”00000000000.kafka”;其中”最小 offset”表示此 segment 中起始消息的 offset.</p></li><li><p>获取消息时,需要指定 offset 和最大 chunk 尺寸,offset 用来表示消息的起始位置,chunk size 用来表示最大获取消息的总长度(间接的表示消息的条数).根据 offset,可以找到此消息所在 segment 文件,然后根据 segment 的最小 offset 取差值,得到它在 file 中的相对位置,直接读取输出即可.</p></li></ul><p><img src="/images/Kafka%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90_2019-12-10-13-45-56.png" alt="Kafka的原理解析_2019-12-10-13-45-56.png"></p>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot实战之kafka</title>
      <link href="/2019/12/05/springboot%E5%AE%9E%E6%88%98%E4%B9%8Bkafka/"/>
      <url>/2019/12/05/springboot%E5%AE%9E%E6%88%98%E4%B9%8Bkafka/</url>
      
        <content type="html"><![CDATA[<h2 id="使用idea创建一个maven项目"><a href="#使用idea创建一个maven项目" class="headerlink" title="使用idea创建一个maven项目"></a>使用idea创建一个maven项目</h2><h3 id="kafka安装"><a href="#kafka安装" class="headerlink" title="kafka安装"></a>kafka安装</h3><p>详见<a href="/2019/12/04/docker%E4%BD%BF%E7%94%A8%E4%B9%8BKafka%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/" title="docker使用之Kafka的安装使用">docker使用之Kafka的安装使用</a></p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--参数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8089</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">kafka</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">bootstrap-servers</span>: <span class="string">localhost:9092</span></span><br><span class="line">    <span class="attr">producer</span>:<span class="string"></span></span><br><span class="line">      <span class="meta">key-serializer</span>: <span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line">      <span class="meta">value-serializer</span>: <span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line">    <span class="attr">consumer</span>:<span class="string"></span></span><br><span class="line">      <span class="meta">group-id</span>: <span class="string">myGroup</span></span><br><span class="line">      <span class="meta">key-deserializer</span>: <span class="string">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class="line">      <span class="meta">value-deserializer</span>: <span class="string">org.apache.kafka.common.serialization.StringDeserializer</span></span><br></pre></td></tr></table></figure><h3 id="消息体"><a href="#消息体" class="headerlink" title="消息体"></a>消息体</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.kafka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">private</span> Date sendTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getSendTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sendTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSendTime</span><span class="params">(Date sendTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sendTime = sendTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.kafka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.GsonBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.kafka.core.KafkaTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaSender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String,String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Gson gson = <span class="keyword">new</span> GsonBuilder().create();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Message message = <span class="keyword">new</span> Message();</span><br><span class="line">        message.setId(System.currentTimeMillis());</span><br><span class="line">        message.setMsg(UUID.randomUUID().toString());</span><br><span class="line">        message.setSendTime(<span class="keyword">new</span> Date());</span><br><span class="line">        kafkaTemplate.send(<span class="string">"test"</span>, gson.toJson(message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.kafka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line"><span class="keyword">import</span> org.springframework.kafka.annotation.KafkaListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConsumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@KafkaListener</span>(topics = &#123;<span class="string">"test"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(ConsumerRecord&lt;?, ?&gt; record)</span> </span>&#123;</span><br><span class="line">        Optional&lt;?&gt; kafkaMessage = Optional.ofNullable(record.value());</span><br><span class="line">        <span class="keyword">if</span> (kafkaMessage.isPresent()) &#123;</span><br><span class="line">            Object message = kafkaMessage.get();</span><br><span class="line">            System.out.println(<span class="string">"接收信息"</span>+message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.qn.kafka.KafkaSender;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ConfigurableApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">        KafkaSender sender = context.getBean(KafkaSender<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            sender.send();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3_000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>直接运行启动类：<br><img src="/images/springboot%E5%AE%9E%E6%88%98%E4%B9%8Bkafka_2019-12-05-14-54-28.png" alt="springboot实战之kafka_2019-12-05-14-54-28.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/c16350e88abe" target="_blank" rel="noopener">Spring Boot集成Kafka</a></p>]]></content>
      
      
      <categories>
          
          <category> springBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker使用之Kafka的安装使用</title>
      <link href="/2019/12/04/docker%E4%BD%BF%E7%94%A8%E4%B9%8BKafka%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/12/04/docker%E4%BD%BF%E7%94%A8%E4%B9%8BKafka%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><blockquote><p>docker pull wurstmeister/zookeeper</p></blockquote><blockquote><p>docker pull wurstmeister/kafka</p></blockquote><h3 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h3><blockquote><p>docker run -d –name zookeeper -p 2181 -t wurstmeister/zookeeper</p></blockquote><blockquote><p>docker run -d –name kafka –publish 9092:9092 –link zookeeper –env KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181 –env KAFKA_ADVERTISED_HOST_NAME=127.0.0.1 –env KAFKA_ADVERTISED_PORT=9092 –volume /etc/localtime:/etc/localtime wurstmeister/kafka:latest</p></blockquote><h3 id="查看启动镜像"><a href="#查看启动镜像" class="headerlink" title="查看启动镜像"></a>查看启动镜像</h3><blockquote><p>docker ps</p></blockquote><p><img src="/images/docker%E4%BD%BF%E7%94%A8%E4%B9%8BKafka%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8_2019-12-04-16-04-31.png" alt="docker使用之Kafka的安装使用_2019-12-04-16-04-31.png"></p><h2 id="测试消息发送"><a href="#测试消息发送" class="headerlink" title="测试消息发送"></a>测试消息发送</h2><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><blockquote><p>docker exec -it 83156456fb03 /bin/bash</p></blockquote><h3 id="进入-kafka-默认目录"><a href="#进入-kafka-默认目录" class="headerlink" title="进入 kafka 默认目录"></a>进入 kafka 默认目录</h3><blockquote><p>cd /opt/kafka_2.12-2.3.0/</p></blockquote><h3 id="创建-topic"><a href="#创建-topic" class="headerlink" title="创建 topic"></a>创建 topic</h3><blockquote><p>bin/kafka-topics.sh –create –zookeeper zookeeper:2181 –replication-factor 1 –partitions 1 –topic test</p></blockquote><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><blockquote><p>bin/kafka-console-producer.sh –broker-list localhost:9092 –topic test</p></blockquote><p><img src="/images/docker%E4%BD%BF%E7%94%A8%E4%B9%8BKafka%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8_2019-12-04-16-11-42.png" alt="docker使用之Kafka的安装使用_2019-12-04-16-11-42.png"></p><h3 id="接受消息"><a href="#接受消息" class="headerlink" title="接受消息"></a>接受消息</h3><blockquote><p>bin/kafka-console-consumer.sh –bootstrap-server localhost:9092 –topic test –from-beginning</p></blockquote><p><img src="/images/docker%E4%BD%BF%E7%94%A8%E4%B9%8BKafka%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8_2019-12-04-16-13-40.png" alt="docker使用之Kafka的安装使用_2019-12-04-16-13-40.png"></p><h2 id="java-生产者与消费者"><a href="#java-生产者与消费者" class="headerlink" title="java 生产者与消费者"></a>java 生产者与消费者</h2><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.kafka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.KafkaProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.Producer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafKaProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//broker地址</span></span><br><span class="line">        props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//请求时候需要验证</span></span><br><span class="line">        props.put(<span class="string">"acks"</span>, <span class="string">"all"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//请求失败时候需要重试</span></span><br><span class="line">        props.put(<span class="string">"retries"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//内存缓存区大小</span></span><br><span class="line">        props.put(<span class="string">"buffer.memory"</span>, <span class="number">33554432</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定消息key序列化方式</span></span><br><span class="line">        props.put(<span class="string">"key.serializer"</span>,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定消息本身的序列化方式</span></span><br><span class="line">        props.put(<span class="string">"value.serializer"</span>,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line"></span><br><span class="line">        Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">                <span class="comment">// 生产一条消息的时间有点长</span></span><br><span class="line">                producer.send(<span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"test"</span>, <span class="string">"测试用例"</span>+Integer.toString(i)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Message sent successfully"</span>);</span><br><span class="line">        producer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.kafka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecords;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.KafkaConsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafKaConsumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123; <span class="string">"deprecation"</span>, <span class="string">"resource"</span> &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">        props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);   <span class="comment">// "localhost:9092"</span></span><br><span class="line">        <span class="comment">//每个消费者分配独立的组号</span></span><br><span class="line">        props.put(<span class="string">"group.id"</span>, <span class="string">"test1"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果value合法，则自动提交偏移量</span></span><br><span class="line">        props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"true"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置多久一次更新被消费消息的偏移量</span></span><br><span class="line">        props.put(<span class="string">"auto.commit.interval.ms"</span>, <span class="string">"1000"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置会话响应的时间，超过这个时间kafka可以选择放弃消费或者消费下一条消息</span></span><br><span class="line">        props.put(<span class="string">"session.timeout.ms"</span>, <span class="string">"30000"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//props.put("auto.offset.reset", "earliest");</span></span><br><span class="line"></span><br><span class="line">        props.put(<span class="string">"key.deserializer"</span>,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">        props.put(<span class="string">"value.deserializer"</span>,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line"></span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">        System.out.println(<span class="string">"建立消费者"</span>);</span><br><span class="line">        consumer.subscribe(Collections.singletonList(<span class="string">"test"</span>));  <span class="comment">//核心函数1：订阅topic</span></span><br><span class="line">        System.out.println(<span class="string">"订阅成功"</span>);</span><br><span class="line">        <span class="comment">//消费轮询</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                ConsumerRecords&lt;String,String&gt; records = consumer.poll(<span class="number">100000</span>);</span><br><span class="line">                <span class="keyword">for</span>(ConsumerRecord&lt;String,String&gt; record : records) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"取出数据："</span>+ record.value());</span><br><span class="line">                    System.out.printf(<span class="string">"offset = %d ,key = %s, value = %s%n"</span>,record.offset(),record.key(),record.value());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            consumer.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://johng.cn/install-kafka-with-docker/" target="_blank" rel="noopener">使用 docker 安装 kafka</a></p><p><a href="https://blog.51cto.com/59465168/2319494" target="_blank" rel="noopener">Kafka 的使用和错误解决</a></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker kafka安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud实战之Config（4）</title>
      <link href="/2019/12/02/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%884%EF%BC%89/"/>
      <url>/2019/12/02/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%884%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>在<a href="/2019/11/29/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%882%EF%BC%89/" title="springcloud实战之Config（2）">springcloud实战之Config（2）</a> ，我们简单的实现了动态刷新。但如果有大量的微服务，就需要为每个 client 去 refresh,明显是不合理的。而 Spring Cloud Bus 可以完美解决这一问题。</p><h2 id="通过消息总线-Spring-Cloud-Bus-更新客户端配置文件（使用-Kafka）"><a href="#通过消息总线-Spring-Cloud-Bus-更新客户端配置文件（使用-Kafka）" class="headerlink" title="通过消息总线 Spring Cloud Bus 更新客户端配置文件（使用 Kafka）"></a>通过消息总线 Spring Cloud Bus 更新客户端配置文件（使用 Kafka）</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h4><p>Spring bus 的一个核心思想是通过分布式的启动器对 spring boot 应用进行扩展，也可以用来建立一个多个应用之间的通信频道。目前唯一实现的方式是用 AMQP 消息代理作为通道，同样特性的设置（有些取决于通道的设置）在更多通道的文档中。其实本质是利用了 MQ 的广播机制在分布式的系统中传播消息，目前常用的有 Kafka 和 RabbitMQ。</p><h4 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h4><p><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%884%EF%BC%89_2019-12-04-16-28-26.png" alt="springcloud实战之Config（4）_2019-12-04-16-28-26.png"></p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ul><li>提交代码触发 post 请求给 bus/refresh</li><li>server 端接收到请求并发送给 Spring Cloud Bus</li><li>Spring Cloud bus 接到消息并通知给其它客户端</li><li>其它客户端接收到通知，请求 Server 端获取最新配置</li><li>全部客户端均获取到最新的配置</li></ul><h3 id="安装-kafka"><a href="#安装-kafka" class="headerlink" title="安装 kafka"></a>安装 kafka</h3><p>详见<a href="/2019/12/04/docker%E4%BD%BF%E7%94%A8%E4%B9%8BKafka%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/" title="docker使用之Kafka的安装使用">docker使用之Kafka的安装使用</a></p><h3 id="server-模块整合"><a href="#server-模块整合" class="headerlink" title="server 模块整合"></a>server 模块整合</h3><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8769</span></span><br><span class="line"><span class="comment">#避免配置中心向自己发布服务导致程序报错服务启动不了。</span></span><br><span class="line"><span class="comment">#如果不加项目启动时报错：Cannot execute request on any known server</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://localhost:9999/eureka</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">spring-cloud-config-server</span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">config</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">server</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">git</span>:<span class="string"></span></span><br><span class="line">          <span class="attr">uri</span>: <span class="string">https://github.com/qn101630/qn101630.github.io.git # 配置git仓库的地址</span></span><br><span class="line">          <span class="meta">search-paths</span>: <span class="string">config-repo # git仓库地址下的相对地址，可以配置多个，用,分割。</span></span><br><span class="line">          <span class="attr">username</span>: <span class="string">qn101630                               # git仓库的账号</span></span><br><span class="line">          <span class="attr">password</span>: <span class="string">qn192837QN</span></span><br><span class="line">          <span class="meta">default-label</span>: <span class="string">code</span></span><br><span class="line"><span class="comment">    # bus消息总线</span></span><br><span class="line">    <span class="attr">stream</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">kafka</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">binder</span>:<span class="string"></span></span><br><span class="line">          <span class="attr">brokers</span>: <span class="string">localhost:9092</span></span><br><span class="line">    <span class="attr">bus</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">trace</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">enabled</span>: <span class="string">true</span></span><br><span class="line"><span class="comment">#          skip-ssl-validation: true</span></span><br><span class="line"><span class="comment"># 暴露服务端端口 以便客户端刷新</span></span><br><span class="line"><span class="attr">management</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">endpoints</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">web</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">exposure</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">include</span>: <span class="string">"*"</span></span><br></pre></td></tr></table></figure><h3 id="client-整合"><a href="#client-整合" class="headerlink" title="client 整合"></a>client 整合</h3><p>与 server 整合一致，添加同样的配置与依赖</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li>运行 Eureka、server、client(8771)、client(8772);直接访问<code>http://localhost:8771/testConfig</code>，返回配置信息</li><li>修改配置项，push 到 Git,这时候我们需要在 server 端 post<blockquote><p>curl -X POST <a href="http://localhost:8769/actuator/bus-refresh" target="_blank" rel="noopener">http://localhost:8769/actuator/bus-refresh</a></p></blockquote></li><li>再次访问<code>http://localhost:8771/testConfig</code>，返回修改后的配置</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/qqxx6661/article/details/88701051" target="_blank" rel="noopener">通过消息总线 Spring Cloud Bus 实现配置文件刷新</a></p>]]></content>
      
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> config实战 动态刷新（Bus） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud实战之Config（3）</title>
      <link href="/2019/12/02/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%883%EF%BC%89/"/>
      <url>/2019/12/02/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%883%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>我们在前文中，完成了</p><ul><li>利用<code>springcloud config</code>与<code>git</code>完成了统一的配置，即配置中心</li><li>开启了<code>rehash</code>，完成了初步的动态刷新</li></ul><h2 id="高可用问题"><a href="#高可用问题" class="headerlink" title="高可用问题"></a>高可用问题</h2><p>前文中我们实现<code>client</code>对配置中心配置的读取，是通过直连的方式（写死的 url）,这显然不符合要求，因为我们的配置中心的<code>server</code>需要有多个（高可用）。</p><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>将配置中心<code>server</code>与<code>client</code>作为微服务处理，在<code>Eureka</code>中注册,通过服务化的方式进行访问，同时开启多个指向同一个 git 地址的 server，就可以实现高可用。</p><h2 id="代码改造"><a href="#代码改造" class="headerlink" title="代码改造"></a>代码改造</h2><h3 id="服务端改造"><a href="#服务端改造" class="headerlink" title="服务端改造"></a>服务端改造</h3><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>添加对 Eureka 的依赖，父 pom 已经添加，此处省略。</p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://localhost:9999/eureka</span></span><br></pre></td></tr></table></figure><h3 id="客户端改造"><a href="#客户端改造" class="headerlink" title="客户端改造"></a>客户端改造</h3><h4 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h4><p>同上</p><h4 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h4><p>bootstrap.yml</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://localhost:9999/eureka</span></span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li>测试服务化：启动 Eureka、server(8769)、server(8770)、client，访问<code>http://localhost:8771/testConfig</code>，得到配置信息;</li><li>测试高可用：关闭 server(8769),再次访问以上地址，得到配置信息;</li><li>测试动态刷新，修改配置，上传 git,post 请求<code>curl -v -X POST http://localhost:8771/actuator/refresh</code>，再次访问以上地址，得到修改后的配置信息。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://windmt.com/2018/04/19/spring-cloud-8-config-with-eureka/" target="_blank" rel="noopener">配置中心（服务化与高可用）</a></p>]]></content>
      
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> condig实战 服务化与高可用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis中“#”和“$的区别</title>
      <link href="/2019/12/02/Mybatis%E4%B8%AD%E2%80%9C-%E2%80%9D%E5%92%8C%E2%80%9C-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/12/02/Mybatis%E4%B8%AD%E2%80%9C-%E2%80%9D%E5%92%8C%E2%80%9C-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="动态-SQL"><a href="#动态-SQL" class="headerlink" title="动态 SQL"></a>动态 SQL</h3><p>动态 SQL 是 <code>mybatis</code> 的强大特性之一，也是它优于其他 ORM 框架的一个重要原因。<code>mybatis</code> 在对 sql 语句进行预编译之前，会对 sql 进行动态解析，解析为一个 BoundSql 对象，也是在此处对动态 SQL 进行处理的。在动态 SQL 解析阶段， <code>#{ }</code> 和 <code>${ }</code> 会有不同的表现</p><h3 id="和-的异同"><a href="#和-的异同" class="headerlink" title="#和$的异同"></a>#和$的异同</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><p>都可以获取对象中的属性值,<code>$[name]</code> 和<code>#[name]</code>相同</p><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><p><code>#</code> 可以防止 sql 注入，先把 sql 中使用#的地方变成?占位，再设置参数值,会把传入的参数使用引号包起来，参数值?: ‘name’，如下：</p><blockquote><p>SELECT * FROM user WHERE name = #{name} AND password = #{password}</p></blockquote><blockquote><p>SELECT * FROM user WHERE name = ? AND password = ?</p></blockquote><p><code>$</code> 在动态解析的时候，会将我们传入的参数当做 String 字符串填充到我们的语句中，进行预编译，此时的<code>SQL</code>语句已经不包含变量了，完全已经是常量数据了。相当于我们普通没有变量的 sql 了。如下：</p><blockquote><p>select * from user where name = “xxx”;</p></blockquote><p>由于预编译的存在，<code>$</code>的使用会导致<strong>sql 注入</strong>，可以拼接 sql，如下：</p><blockquote><p>SELECT * FROM user WHERE name = $[name] AND password  = $[password]</p></blockquote><p>但如果 name = OR 1 = 1 OR，sql 注入就会影响到 sql 语句的原意，如下：</p><blockquote><p>SELECT * FROM user WHERE name = OR 1 = 1 OR AND password =</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>#</code>方式能够很大程度防止 sql 注入，<code>$</code>方式无法防止 Sql 注入。<br><code>$</code>方式一般用于传入数据库对象，例如传入表名.<br>一般能用<code>#</code>的就别用<code>$</code>.</p>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> $和# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud实战之Config（2）</title>
      <link href="/2019/11/29/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%882%EF%BC%89/"/>
      <url>/2019/11/29/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="Refresh"><a href="#Refresh" class="headerlink" title="Refresh"></a>Refresh</h2><h3 id="依赖（父-pom-已经添加过）"><a href="#依赖（父-pom-已经添加过）" class="headerlink" title="依赖（父 pom 已经添加过）"></a>依赖（父 pom 已经添加过）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="对需要刷新的类加上注解-RefreshScope"><a href="#对需要刷新的类加上注解-RefreshScope" class="headerlink" title="对需要刷新的类加上注解@RefreshScope"></a>对需要刷新的类加上注解@RefreshScope</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span> <span class="comment">//不配置这个注解刷新的时候会报错</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个@Value会根据配置的配置中心地址找到git仓库对应的配置和本地服务的配置文件</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;config.hello&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String hello;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"testConfig"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"读取到配置中心："</span> + hello;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="client-端配置，将端口暴露"><a href="#client-端配置，将端口暴露" class="headerlink" title="client 端配置，将端口暴露"></a>client 端配置，将端口暴露</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">endpoints</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">web</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">exposure</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">include</span>: <span class="string">refresh</span></span><br></pre></td></tr></table></figure><h3 id="Server-端配置，将端口暴露"><a href="#Server-端配置，将端口暴露" class="headerlink" title="Server 端配置，将端口暴露"></a>Server 端配置，将端口暴露</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">endpoints</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">web</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">exposure</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">include</span>: <span class="string">"*"</span></span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>启动 server 与 client,修改 git 上的 dev 配置属性，通过 post 请求的方式更新配置文件：<br><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%882%EF%BC%89_2019-12-02-14-18-14.png" alt="springcloud实战之Config（2）_2019-12-02-14-18-14.png"><br><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%882%EF%BC%89_2019-12-02-14-18-50.png" alt="springcloud实战之Config（2）_2019-12-02-14-18-50.png"><br>再次访问 <code>http://localhost:8771/testConfig</code>就可以得到最新的配置结果。</p><h2 id="Webhook"><a href="#Webhook" class="headerlink" title="Webhook"></a>Webhook</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><blockquote><p>WebHook 是当某个事件发生时，通过发送 http post 请求的方式来通知信息接收方。Webhook 来监测你在 Github.com 上的各种事件，最常见的莫过于 push 事件。如果你设置了一个监测 push 事件的 Webhook，那么每当你的这个项目有了任何提交，这个 Webhook 都会被触发，这时 Github 就会发送一个 HTTP POST 请求到你配置好的地址。</p></blockquote><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><blockquote><p>如此一来，你就可以通过这种方式去自动完成一些重复性工作，比如，你可以用 Webhook 来自动触发一些持续集成（CI）工具的运作，比如 Travis CI；又或者是通过 Webhook 去部署你的线上服务器。下图就是 github 上面的 webhook 配置。</p></blockquote><p><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%882%EF%BC%89_2019-12-03-13-59-00.png" alt="springcloud实战之Config（2）_2019-12-03-13-59-00.png"></p><ul><li>Payload URL ：触发后回调的 URL</li><li>Content type ：数据格式，两种一般使用 json</li><li>Secret ：用作给 POST 的 body 加密的字符串。采用 HMAC 算法</li><li>events ：触发的事件列表。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果项目少配置少的情况可以通过/refresh 来手动刷新配置，可以利用 Webhook 的机制每次提交代码发送请求来刷新客户端，当客户端越来越多的时候，需要每个客户端都执行一遍；如果项目比较复杂的情况呢这种肯定是行不通的，Spring Cloud Bus 消息总线可以解决配置修改的真正的动态刷新。详见<a href="/2019/12/02/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%884%EF%BC%89/" title="springcloud实战之Config（4）">springcloud实战之Config（4）</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/qqxx6661/article/details/88604499" target="_blank" rel="noopener">配置中心 Spring Cloud Config 初体验</a></p>]]></content>
      
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> config实战 动态刷新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker使用教程</title>
      <link href="/2019/11/28/docker%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2019/11/28/docker%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker简单介绍与安装（win10）</title>
      <link href="/2019/11/28/docker%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85%EF%BC%88win10%EF%BC%89/"/>
      <url>/2019/11/28/docker%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85%EF%BC%88win10%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="环境配置的难题"><a href="#环境配置的难题" class="headerlink" title="环境配置的难题"></a>环境配置的难题</h2><p>软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？</p><p>用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。</p><p>如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说：”它在我的机器可以跑了”（It works on my machine），言下之意就是，其他机器很可能跑不了。</p><p>环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，<strong>安装的时候，把原始环境一模一样地复制过来。</strong></p><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>资源占用多<br>虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。</li><li>冗余步骤多<br>虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。</li><li>启动慢<br>启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。</li></ol><h2 id="Linux-容器"><a href="#Linux-容器" class="headerlink" title="Linux 容器"></a>Linux 容器</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><ol><li>由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。</li><li>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</li><li>容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。</li></ol><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>启动快<br>容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。</li><li>资源占用少<br>容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。</li><li>体积小<br>容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。</li></ol><h2 id="Docker-是什么？"><a href="#Docker-是什么？" class="headerlink" title="Docker 是什么？"></a>Docker 是什么？</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><ol><li>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。</li><li>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</li></ol><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ol><li>提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</li><li>提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</li><li>组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</li></ol><h2 id="Docker-的安装"><a href="#Docker-的安装" class="headerlink" title="Docker 的安装"></a>Docker 的安装</h2><p>详见———&gt; <a href="https://www.runoob.com/docker/windows-docker-install.html" target="_blank" rel="noopener">菜鸟教程 Docker 安装</a></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 介绍 安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eureka与Zookeeper的区别</title>
      <link href="/2019/11/28/Eureka%E4%B8%8EZookeeper%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/11/28/Eureka%E4%B8%8EZookeeper%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="生态"><a href="#生态" class="headerlink" title="生态"></a>生态</h2><blockquote><p>在微服务的开发过程中，如果使用的是 Dubbo 那就必须使用到 Zookeeper ，在使用 Spring Cloud Eureka 时，自然其功能更强大得多。Spring Cloud Eureka 后来者居上，Dubbo 早在几年前停止了维护，在其停止了维护的几年里正是互联网发展的大好时期，Eureka 借机快速发展，夺得了一大片市场，可以说已经超越了 Dubbo 了，17 年的时候，阿里巴巴又突然宣布重启对 Dubbo 的维护，在其重启的发布会上，其主导维护者也表示，将希望加入 Eureka 的生态…</p></blockquote><h2 id="CAP-定理"><a href="#CAP-定理" class="headerlink" title="CAP 定理"></a>CAP 定理</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>一个系统不可能同时满足一致性（C）、可用性(A)、分区容错性（P）</li><li>图解：</li></ul><p><img src="/images/Eureka%E4%B8%8EZookeeper%E7%9A%84%E5%8C%BA%E5%88%AB_2019-11-28-10-31-07.png" alt="Eureka与Zookeeper的区别_2019-11-28-10-31-07.png"></p><h3 id="三个指标"><a href="#三个指标" class="headerlink" title="三个指标"></a>三个指标</h3><ul><li>一致性：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）。</li><li>可用性：在一个分布式系统的集群中一部分节点故障后，该集群是否还能够正常响应客户端的读写请求。（对数据更新具备高可用性）。</li><li>分区容错性：大多数的分布式系统都分布在多个子网络中，而每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。在一个分布式系统中一般分区容错是无法避免的，因此可以认为 CAP 中的 P 总是成立的。CAP 理论告诉我们，在 C 和 A 之间是无法同时做到。</li></ul><h2 id="Zookeeper-保证-CP"><a href="#Zookeeper-保证-CP" class="headerlink" title="Zookeeper 保证 CP"></a>Zookeeper 保证 CP</h2><ul><li>任何时候对 Zookeeper 的访问请求能得到一致的数据结果，同时系统对网络分割具备容错性</li><li>在使用 Zookeeper 获取服务列表时，如果此时的 Zookeeper 集群中的 Leader 宕机了，该集群就要进行 Leader 的选举，又或者 Zookeeper 集群中半数以上服务器节点不可用（例如有三个节点，如果节点一检测到节点三挂了 ，节点二也检测到节点三挂了，那这个节点才算是真的挂了），那么将无法处理该请求。所以说，Zookeeper 不能保证服务可用性。</li></ul><h2 id="Eureka-保证-AP"><a href="#Eureka-保证-AP" class="headerlink" title="Eureka 保证 AP"></a>Eureka 保证 AP</h2><ul><li>各个节点是平等的，几个节点挂掉，其他节点依然可以提供服务，首先报证可用性。</li><li>每个 Eureka Client 本地都有一份它最新获取到的服务注册表的缓存信息，即使所有的 Eureka Server 都挂掉了，依然可以根据本地缓存的服务信息正常工作。</li><li>如果 Eureka 服务节点在短时间里丢失了大量的心跳连接（注：可能发生了网络故障），那么这个 Eureka 节点会进入<strong>自我保护模式</strong>。 此时，这个 Eureka 节点对于新的服务还能提供注册服务，对于”死亡“的仍然保留，以防还有客户端向其发起请求。当网络故障恢复后，这个 Eureka 节点会退出自我保护模式。</li><li>Eureka 不能保证每次获取的服务列表都是最新的</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于服务发现来讲，保证服务的高可用尤为重要，哪怕返回前几分钟的服务信息，也比出现网络故障要好。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://dockone.io/article/78" target="_blank" rel="noopener">为什么不应该使用 Zookeeper 做服务发现</a></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务发现 zookeeper eureka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud实战之Config（1）</title>
      <link href="/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%881%EF%BC%89/"/>
      <url>/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="springcloud-Config-实践"><a href="#springcloud-Config-实践" class="headerlink" title="springcloud Config 实践"></a>springcloud Config 实践</h1><h2 id="创建一个远程仓库（本地建立一个配置仓库由-idea-提交给-git"><a href="#创建一个远程仓库（本地建立一个配置仓库由-idea-提交给-git" class="headerlink" title="创建一个远程仓库（本地建立一个配置仓库由 idea 提交给 git)"></a>创建一个远程仓库（本地建立一个配置仓库由 idea 提交给 git)</h2><h3 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h3><p><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%881%EF%BC%89_2019-11-22-21-48-43.png" alt="springcloud实战之Config（1）_2019-11-22-21-48-43.png"></p><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p><a href="https://github.com/qn101630/qn101630.github.io/tree/code/config-repo" target="_blank" rel="noopener">我的配置仓库</a></p><h2 id="创建一个-config-server-组件"><a href="#创建一个-config-server-组件" class="headerlink" title="创建一个 config-server 组件"></a>创建一个 config-server 组件</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8769</span></span><br><span class="line"><span class="comment">#避免配置中心向自己发布服务导致程序报错服务启动不了。</span></span><br><span class="line"><span class="comment">#如果不加项目启动时报错：Cannot execute request on any known server</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">register-with-eureka</span>: <span class="string">false</span></span><br><span class="line">    <span class="meta">fetch-registry</span>: <span class="string">false</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">spring-cloud-config-server</span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">config</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">server</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">git</span>:<span class="string"></span></span><br><span class="line">          <span class="attr">uri</span>: <span class="string">https://github.com/qn101630/qn101630.github.io.git # 配置git仓库的地址，这是我的公开git,可以不用登录密码</span></span><br><span class="line">          <span class="meta">search-paths</span>: <span class="string">config-repo # git仓库地址下的相对地址，可以配置多个，用,分割。</span></span><br><span class="line">          <span class="attr">username</span>: <span class="string">qn101630                               # git仓库的账号</span></span><br><span class="line">          <span class="attr">password</span>: <span class="string">qn192837QN</span></span><br><span class="line">          <span class="meta">default-label</span>: <span class="string">code</span></span><br></pre></td></tr></table></figure><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span> <span class="comment">//启用配置中心服务，作为一个接口对外提供</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigServerApp<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问远程配置"><a href="#访问远程配置" class="headerlink" title="访问远程配置"></a>访问远程配置</h3><p>访问地址：<a href="http://localhost:8769/spring-cloud-config-dev.properties" target="_blank" rel="noopener">http://localhost:8769/spring-cloud-config-dev.properties</a></p><h2 id="创建一个-config-client-组件"><a href="#创建一个-config-client-组件" class="headerlink" title="创建一个 config-client 组件"></a>创建一个 config-client 组件</h2><h3 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>config-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--无法引入：spring-cloud-config-server--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><h4 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8771</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">register-with-eureka</span>: <span class="string">false</span></span><br><span class="line">    <span class="meta">fetch-registry</span>: <span class="string">false</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">spring-cloud-config-client</span></span><br></pre></td></tr></table></figure><h4 id="bootstrap-yml"><a href="#bootstrap-yml" class="headerlink" title="bootstrap.yml"></a>bootstrap.yml</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">config</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">name</span>: <span class="string">spring-cloud-config</span></span><br><span class="line">      <span class="attr">profile</span>: <span class="string">dev</span></span><br><span class="line">      <span class="attr">uri</span>: <span class="string">http://localhost:8769/</span></span><br><span class="line">      <span class="attr">label</span>: <span class="string">code</span></span><br></pre></td></tr></table></figure><h3 id="启动类-1"><a href="#启动类-1" class="headerlink" title="启动类"></a>启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ClientApp<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="业务类"><a href="#业务类" class="headerlink" title="业务类"></a>业务类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个@Value会根据配置的配置中心地址找到git仓库对应的配置和本地服务的配置文件</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;config.hello&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String hello;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"testConfig"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"读取到配置中心："</span> + hello;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最终测试"><a href="#最终测试" class="headerlink" title="最终测试"></a>最终测试</h2><p>启动项目后访问：<a href="http://localhost:8769/hello" target="_blank" rel="noopener">http://localhost:8769/hello</a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>目前我们的配置信息是由 client 去拉取，但是 git 上的配置发生了改变，client 无法及时的获取更改后的配置，必须重新启动 client 才可以，这显然是不合适的，所以我们还要实现动态获取配置，详情请见<a href="/2019/11/29/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%882%EF%BC%89/" title="springcloud实战之Config（2）">springcloud实战之Config（2）</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/qqxx6661/article/details/88604499" target="_blank" rel="noopener">配置中心 Spring Cloud Config 初体验</a></p>]]></content>
      
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> config实战 初体验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud解析之Config</title>
      <link href="/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BConfig/"/>
      <url>/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BConfig/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么需要配置中心？"><a href="#为什么需要配置中心？" class="headerlink" title="为什么需要配置中心？"></a>为什么需要配置中心？</h2><p>微服务架构没有配置中心：</p><ul><li>配置文件分散在各个项目里，不方便维护</li><li>配置内容安全与权限，实际开发中，开发人员是不知道线上环境的配置的</li><li>更新配置后，项目需要重启   </li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><blockquote><p>把原本放在本地文件的配置抽取出来放在中心服务器，本质是配置信息从本地迁移到云端。从而能够提供更好的管理、发布能力。</p></blockquote><hr><p><img src="/images/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BConfig_2019-11-22-21-30-17.png" alt="springcloud解析之Config_2019-11-22-21-30-17.png"></p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ul><li>Config-Client : 提供了基于Spring 的客户端</li><li>Config-Server : 负责将远程的配置返回给客户端</li><li>Remote Repository : 远程仓库（svn/git)</li><li>Local Repository : 将远程仓库的配置clone到本地的临时目录</li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>提供服务端和客户端支持</li><li>集中管理各环境的配置文件</li><li>配置文件修改之后，可以快速的生效</li><li>可以进行版本管理</li><li>支持大的并发查询</li><li>支持各种语言</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>动态配置能力弱 </li><li>调整配置需要重新部署，添加代码比较多</li><li>治理能力弱 </li><li>安全审计能力弱</li><li>不算严格企业级 </li><li>适用于小型项目</li></ul>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> config 配置中心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud实战之Zuul</title>
      <link href="/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BZuul/"/>
      <url>/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BZuul/</url>
      
        <content type="html"><![CDATA[<h1 id="新建-Zuul-子模块"><a href="#新建-Zuul-子模块" class="headerlink" title="新建 Zuul 子模块"></a>新建 Zuul 子模块</h1><h2 id="Zuul-服务网关体验"><a href="#Zuul-服务网关体验" class="headerlink" title="Zuul 服务网关体验"></a>Zuul 服务网关体验</h2><ul><li>依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>配置</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">zuul</span></span><br><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8773</span></span><br><span class="line"><span class="comment">#服务中心注册</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">serviceUrl</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://localhost:9999/eureka/</span></span><br><span class="line"><span class="comment">#自定义负载均衡策略</span></span><br><span class="line"><span class="meta">provider-user</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">ribbon</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName</span>: <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br><span class="line"><span class="comment"># 服务网关设置</span></span><br><span class="line"><span class="attr">zuul</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">routes</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">hello</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">path</span>: <span class="string">/producer/**</span></span><br><span class="line">      <span class="attr">serviceId</span>: <span class="string">provider-user</span></span><br></pre></td></tr></table></figure><ul><li>启动类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//启用服务网关</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ZuulApp<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>熔断器 Filter</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiFallbackProvider</span> <span class="keyword">implements</span> <span class="title">FallbackProvider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRoute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置熔断的服务名</span></span><br><span class="line">        <span class="comment">//如果是所有服务则设置为*</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"provider-user"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">fallbackResponse</span><span class="params">(String route, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClientHttpResponse() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> HttpStatus <span class="title">getStatusCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> HttpStatus.OK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRawStatusCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getStatusText</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"&#123;code:0,message:service error =_=&#125;"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> InputStream <span class="title">getBody</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ByteArrayInputStream(getStatusText().getBytes()</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> HttpHeaders <span class="title">getHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">                headers.setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line">                <span class="keyword">return</span> headers;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><ol><li>启动 Eureka 客户端、三个提供者服务（不同端口）、Zuul 网关模块，访问地址：<a href="http://localhost:8773/producer/user/1" target="_blank" rel="noopener">http://localhost:8773/producer/user/1</a></li><li>访问 15 次，发现请求是随机访问到三个提供者服务（说明自定义的负载均衡策略生效了，zuul 默认的负载均衡策略是轮询）。</li><li>关掉两个提供者服务，再次请求以上地址，发现可能返回服务降级内容（不超过两次）。</li><li>关掉最后一个提供者，再次请求会返回服务降级内容（说明熔断器生效）。</li></ol><hr><p><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8Bzuul%EF%BC%88%E4%BA%8C%EF%BC%89_2019-11-20-15-57-24.png" alt="springcloud实战之zuul（二）_2019-11-20-15-57-24.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/qqxx6661/article/details/88767696" target="_blank" rel="noopener">[菜鸟 SpringCloud 实战入门]第九章：服务网关 Zuul 体验</a></p>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zuul实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud解析之Zuul</title>
      <link href="/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BZuul/"/>
      <url>/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BZuul/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-Zuul"><a href="#什么是-Zuul" class="headerlink" title="什么是 Zuul?"></a>什么是 Zuul?</h2><ul><li>服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供 REST API 的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。</li><li>Spring Cloud Netflix 中的 Zuul 就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。</li></ul><h2 id="为什么需要-Zuul"><a href="#为什么需要-Zuul" class="headerlink" title="为什么需要 Zuul?"></a>为什么需要 Zuul?</h2><ul><li>客户端直接与微服务通信：</li></ul><ol><li>客户端会多次请求不同的微服务，增加了客户端的复杂性。</li><li>存在跨域请求，在一定场景下处理相对复杂。</li><li>认证复杂，每个服务都需要独立认证。</li><li>难以重构，随着项目的迭代，可能需要重新划分微服务。</li><li>某些微服务可能使用了防火墙/浏览器不友好的协议，直接访问会有一定困难。</li></ol><ul><li>使用网关优点：</li></ul><ol><li>易于监控。可在微服务网关收集监控数据并将其推送到外部系统进行分析。</li><li>易于认证。可在微服务网关上进行认证。然后再将请求转发到后端的微服务，而无须在每个微服务中进行认证。</li><li>减少了客户端与各个微服务之间的交互次数。</li></ol><ul><li>Zuul 提供了不同类型的 filter 用于处理请求，这些 filter 可以让我们实现以下功能：</li></ul><ol><li>权限控制和安全性：可以识别认证需要的信息和拒绝不满足条件的请求</li><li>监控：监控请求信息</li><li>动态路由：根据需要动态地路由请求到后台的不同集群</li><li>压力测试</li><li>负载均衡</li><li>静态资源处理：直接在 zuul 处理静态资源的响应而不需要转发这些请求到内部集群中</li></ol><h2 id="Zuul-的执行过程"><a href="#Zuul-的执行过程" class="headerlink" title="Zuul 的执行过程"></a>Zuul 的执行过程</h2><p><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BZuul%EF%BC%88%E4%B8%80%EF%BC%89_2019-11-20-13-55-29.png" alt="springcloud实战之Zuul（一）_2019-11-20-13-55-29.png"></p><hr><ul><li>Zuul 内部的处理使用 ZuulServlet 完成，ZuulServlet 继承 HttpServlet，重写了 service 方法，service 方法内部分别是 pre、route、post 和 error 类型的 filter 进行调用。</li><li>filter 的执行顺序：先执行 pre 类型的 filter；如果 pre filter 执行失败那么执行 error 和 post 类型的 filter，pre filter 执行成功的话执行 route 类型的 filter；如果 route filter 执行失败那么执行 error 和 post 类型的 filter，route filter 执行成功的话执行 post filter；如果 post filter 执行失败那么执行 error 类型的 filter，post filter 执行成功的话，结束。上述过程中执行失败指的是 ZuulException 被 catch，如果是其他 Exception 的话，那么执行 error 类型的 filter，然后结束。</li><li>要在 SpringCloud 中使用 Zuul，需要加上<code>@EnableZuulProxy</code>注解。加上这个注解之后 SpringCloud 会构造一些 bean，比如 ZuulHandlerMapping、DiscoveryClientRouteLocator、各种 filter 等。其中<code>DiscoveryClientRouteLocato</code>r 是一个基于服务发现的路由规则生成器，它会基于 zuul 的配置构造路由规则。<code>ZuulHandlerMapping</code>是一个 HandlerMapping 的实现，它跟基于路由规则注册 handler，其中 key 为路由规则对应的路径，handler 都是 ZuulController，ZuulController 内部使用 ZuulServlet 进行请求的处理。</li><li>Zuul 把真正的服务调用放在了 filter 中实现。它提供了<code>SimpleHostRoutingFilter</code>和<code>RibbonRoutingFilter</code>这 2 个 route 类型的 filter 用于执行服务。从名字也可以看出来，SimpleHostRoutingFilter 用于执行基于 host 方式的调用 url 接口，RibbonRoutingFilter 基于服务发现的方式调用服务。<strong>一般我们都建议使用 RibbonRoutingFilter，因为它内部使用 ribbon，更加健壮。</strong></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://fangjian0423.github.io/2017/02/22/springcloud-zuul/" target="_blank" rel="noopener">SpringCloud 网关服务 zuul 介绍</a></p><p><a href="https://www.cnblogs.com/duanxz/p/7527765.html" target="_blank" rel="noopener">服务网关 zuul 之一：入门介绍</a></p>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ribbon服务网关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud实战之Hystrix（2）</title>
      <link href="/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BHystrix%EF%BC%882%EF%BC%89/"/>
      <url>/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BHystrix%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="多应用监控"><a href="#多应用监控" class="headerlink" title="多应用监控"></a>多应用监控</h2><h2 id="新建一个子模块-hystrix-dashboard-turbine"><a href="#新建一个子模块-hystrix-dashboard-turbine" class="headerlink" title="新建一个子模块 hystrix-dashboard-turbine"></a>新建一个子模块 hystrix-dashboard-turbine</h2><ul><li>依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hystrix-dashboard-turbine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring boot 1.X：spring-cloud-starter-hystrix-dashboard--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-netflix-turbine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>配置</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line"><span class="comment">  # 服务端口号</span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8767</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line"><span class="comment">    # 服务名，即serviceId</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">hystrix-dashboard-turbine</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">serviceUrl</span>:<span class="string"></span></span><br><span class="line"><span class="comment">      # 安全认证的服务注册中心地址</span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://localhost:9999/eureka</span></span><br><span class="line"><span class="comment"># 熔断器turbine</span></span><br><span class="line"><span class="attr">turbine</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">aggregator</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">cluster-config</span>: <span class="string">default</span></span><br><span class="line">  <span class="meta">cluster-name-expression</span>: <span class="string">new String("default")</span></span><br><span class="line">  <span class="meta">app-config</span>: <span class="string">consumer-feign, consumer-feign-2</span></span><br></pre></td></tr></table></figure><ul><li>启动类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableTurbine</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TurbineApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(TurbineApp<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复制一个提供者服务"><a href="#复制一个提供者服务" class="headerlink" title="复制一个提供者服务"></a>复制一个提供者服务</h2><ul><li>依赖</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span><br><span class="line">         xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;springcloud&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.qn&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;provider-user-2&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><ul><li>配置</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">7901 #自定义boot项目访问端口</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">provider-user-2</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">instance</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">hostname</span>: <span class="string">localhost</span></span><br><span class="line"><span class="comment">    # 发呆时间，即服务失效时间（缺省为90s）,就是超过15秒没有续约就会从注册表中剔除</span></span><br><span class="line">    <span class="meta">lease-expiration-duration-in-seconds</span>: <span class="string">15</span></span><br><span class="line"><span class="comment">    # 心跳时间，即服务续约间隔时间（缺省为30s）</span></span><br><span class="line">    <span class="meta">lease-renewal-interval-in-seconds</span>: <span class="string">5</span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://localhost:9999/eureka</span></span><br></pre></td></tr></table></figure><h2 id="复制一个-Feign-客户端"><a href="#复制一个-Feign-客户端" class="headerlink" title="复制一个 Feign 客户端"></a>复制一个 Feign 客户端</h2><ul><li>依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>consumer-feign-2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring boot 1.X：spring-cloud-starter-hystrix--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring boot 1.X：spring-cloud-starter-hystrix-dashboard--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>配置</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8901</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">consumer-feign-2</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">instance</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">hostname</span>: <span class="string">localhost</span></span><br><span class="line"><span class="comment">    # 发呆时间，即服务失效时间（缺省为90s）,就是超过15秒没有续约就会从注册表中剔除</span></span><br><span class="line">    <span class="meta">lease-expiration-duration-in-seconds</span>: <span class="string">15</span></span><br><span class="line"><span class="comment">    # 心跳时间，即服务续约间隔时间（缺省为30s）</span></span><br><span class="line">    <span class="meta">lease-renewal-interval-in-seconds</span>: <span class="string">5</span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://localhost:9999/eureka</span></span><br><span class="line"><span class="meta">PROVIDER-USER</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">ribbon</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName</span>: <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br><span class="line"><span class="comment"># 在feign使用hystrix</span></span><br><span class="line"><span class="attr">feign</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">hystrix</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">enabled</span>: <span class="string">true</span></span><br><span class="line"><span class="comment"># 熔断器DashBoard: actuator在boot2.0调整后开关web端点的配置，*代表开启所有</span></span><br><span class="line"><span class="attr">management</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">endpoints</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">web</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">exposure</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">include</span>: <span class="string">"*"</span></span><br></pre></td></tr></table></figure><ul><li>Service 接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个feign接口，通过@ FeignClient（“服务名”），来指定调用哪个服务</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value =<span class="string">"PROVIDER-USER-2"</span>,fallback = ServiceHystrixImpl<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">getUser2</span><span class="params">(@PathVariable Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>fallback 服务降级</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHystrixImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser2</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">12345l</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查看监控"><a href="#查看监控" class="headerlink" title="查看监控"></a>查看监控</h2><ol><li>启动 hystrix-dashboard-turbine、俩个 Feign 客户端、两个提供者服务、eureka 客户端。</li><li>访问网址<a href="http://localhost:8767/hystrix" target="_blank" rel="noopener">http://localhost:8767/hystrix</a> ，输入输入： <a href="http://localhost:8767/turbine.stream" target="_blank" rel="noopener">http://localhost:8767/turbine.stream</a> ，然后点击 Monitor Stream ,可以看到出现了监控列表，分别访问<a href="http://localhost:8900/order/1、http://localhost:8901/order/1，显示界面如下：" target="_blank" rel="noopener">http://localhost:8900/order/1、http://localhost:8901/order/1，显示界面如下：</a><br><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BHystrix%EF%BC%88%E4%B8%89%EF%BC%89_2019-11-19-17-19-13.png" alt="springcloud实战之Hystrix（三）_2019-11-19-17-19-13.png"></li></ol>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多应用监控 turbine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud实战之Hystrix（1）</title>
      <link href="/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BHystrix%EF%BC%881%EF%BC%89/"/>
      <url>/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BHystrix%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="使用上一章建立的-Feign-客户端"><a href="#使用上一章建立的-Feign-客户端" class="headerlink" title="使用上一章建立的 Feign 客户端"></a>使用上一章建立的 Feign 客户端</h1><h2 id="简单实践-与-Feign-集成"><a href="#简单实践-与-Feign-集成" class="headerlink" title="简单实践(与 Feign 集成)"></a>简单实践(与 Feign 集成)</h2><ul><li>添加配置文件</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">hystrix</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">enabled</span>: <span class="string">true</span></span><br></pre></td></tr></table></figure><ul><li>fallback 类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHystrixImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">12345l</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修改 Service 接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个feign接口，通过@ FeignClient（“服务名”），来指定调用哪个服务，fallback定义服务降级</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value =<span class="string">"PROVIDER-USER"</span>,fallback = ServiceHystrixImpl<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">getUser</span><span class="params">(@PathVariable Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">启动Feign客户端，访问提供者服务，url地址同上，停止服务提供者，再次访问，会返回服务降级内容。</span><br></pre></td></tr></table></figure><h2 id="熔断器监控-Hystrix-Dashboard-单一应用"><a href="#熔断器监控-Hystrix-Dashboard-单一应用" class="headerlink" title="熔断器监控 Hystrix Dashboard(单一应用)"></a>熔断器监控 Hystrix Dashboard(单一应用)</h2><ul><li>添加依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>consumer-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring boot 1.X：spring-cloud-starter-hystrix--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring boot 1.X：spring-cloud-starter-hystrix-dashboard--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>添加配置文件内容</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 熔断器DashBoard: actuator在boot2.0调整后开关web端点的配置，*代表开启所有</span></span><br><span class="line"><span class="attr">management</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">endpoints</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">web</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">exposure</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">include</span>: <span class="string">"*"</span></span><br></pre></td></tr></table></figure><ul><li>启动类添加注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//通过注解@EnableEurekaClient 表明自己是一个eurekaclient.</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="comment">//开启Feign的功能</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="comment">//注解开启Hystrix仪表盘</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="comment">//注解开启Hystrix</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerFeignApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConsumerFeignApp<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><ol><li>启动 Feign 客户端，访问网址<a href="http://localhost:8900/hystrix/，显示界面如下：" target="_blank" rel="noopener">http://localhost:8900/hystrix/，显示界面如下：</a><br><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BHystrix%EF%BC%88%E4%BA%8C%EF%BC%89_2019-11-19-15-36-15.png" alt="springcloud实战之Hystrix（二）_2019-11-19-15-36-15.png"></li><li>输入<a href="http://localhost:8900/actuator/hystrix.stream,点击monitor,显示界面如下：" target="_blank" rel="noopener">http://localhost:8900/actuator/hystrix.stream,点击monitor,显示界面如下：</a><br><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BHystrix%EF%BC%88%E4%BA%8C%EF%BC%89_2019-11-19-15-39-54.png" alt="springcloud实战之Hystrix（二）_2019-11-19-15-39-54.png"></li><li>只使用 Hystrix Dashboard 的话, 你只能看到单个应用内的服务信息, 这明显不够. 我们需要一个工具能让我们汇总系统内多个服务的数据并显示到 Hystrix Dashboard 上,这个工具就是 Turbine.详见<a href="/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BHystrix%EF%BC%882%EF%BC%89/" title="springcloud实战之Hystrix（2）">springcloud实战之Hystrix（2）</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hystrix实战 单应用监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud解析之Hystrix</title>
      <link href="/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BHystrix/"/>
      <url>/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BHystrix/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么需要熔断器？"><a href="#为什么需要熔断器？" class="headerlink" title="为什么需要熔断器？"></a>为什么需要熔断器？</h2><ul><li>传统分布式系统面临一些性能上的问题，当复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败。这时可能会出现<strong>服务雪崩</strong>。</li><li>对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。</li></ul><h2 id="什么是服务雪崩？"><a href="#什么是服务雪崩？" class="headerlink" title="什么是服务雪崩？"></a>什么是服务雪崩？</h2><blockquote><p>多个微服务之间调用的时候，假设微服务 A 调用微服务 B 和微服务 C，微服务 B 和微服务 C 又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务 A 的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”。</p></blockquote><h2 id="什么是熔断器-Hystrix？"><a href="#什么是熔断器-Hystrix？" class="headerlink" title="什么是熔断器 Hystrix？"></a>什么是熔断器 Hystrix？</h2><ul><li>Hystrix 是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix 能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。</li><li>“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。</li></ul><h2 id="Hystrix-能做什么"><a href="#Hystrix-能做什么" class="headerlink" title="Hystrix 能做什么"></a>Hystrix 能做什么</h2><p><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BHystrix%EF%BC%88%E4%B8%80%EF%BC%89_2019-11-19-14-44-07.png" alt="springcloud实战之Hystrix（一）_2019-11-19-14-44-07.png"></p><ol><li><p>断路器</p><blockquote><p>当 Hystrix Command 请求后端服务失败数量超过一定比例(默认 50%), 断路器会切换到开路状态(Open). 这时所有请求会直接失败而不会发送到后端服务. 断路器保持在开路状态一段时间后(默认 5 秒), 自动切换到半开路状态(HALF-OPEN). 这时会判断下一次请求的返回情况, 如果请求成功, 断路器切回闭路状态(CLOSED), 否则重新切换到开路状态(OPEN). Hystrix 的断路器就像我们家庭电路中的保险丝, 一旦后端服务不可用, 断路器会直接切断请求链, 避免发送大量无效请求影响系统吞吐量, 并且断路器有自我检测并恢复的能力。</p></blockquote></li><li><p>服务降级</p><blockquote><p>对于查询操作, 我们可以实现一个 fallback 方法, 当请求后端服务出现异常的时候, 可以使用 fallback 方法返回的值. fallback 方法的返回值一般是设置的默认值或者来自缓存。</p></blockquote></li><li><p>资源隔离</p><blockquote><p>在 Hystrix 中, 主要通过线程池来实现资源隔离. 通常在使用的时候我们会根据调用的远程服务划分出多个线程池. 例如调用产品服务的 Command 放入 A 线程池, 调用账户服务的 Command 放入 B 线程池. 这样做的主要优点是运行环境被隔离开了. 这样就算调用服务的代码存在 bug 或者由于其他原因导致自己所在线程池被耗尽时, 不会对系统的其他服务造成影响. 但是带来的代价就是维护多个线程池会对系统带来额外的性能开销. 如果是对性能有严格要求而且确信自己调用服务的客户端代码不会出问题的话, 可以使用 Hystrix 的信号模式(Semaphores)来隔离资源.</p></blockquote></li><li><p>服务监控 hystrixDashboard</p><blockquote><p>除了隔离依赖服务的调用以外，Hystrix 还提供了准实时的调用监控（Hystrix Dashboard），Hystrix 会持续地记录所有通过 Hystrix 发起的请求的执行信息，并以统计报表和图形的形式展示给用户，包括每秒执行多少请求多少成功，多少失败等。Netflix 通过 hystrix-metrics-event-stream 项目实现了对以上指标的监控。Spring Cloud 也提供了 Hystrix Dashboard 的整合，对监控内容转化成可视化界面。</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hystrix 熔断器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud实战之Euraka</title>
      <link href="/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BEuraka/"/>
      <url>/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BEuraka/</url>
      
        <content type="html"><![CDATA[<h1 id="eureka-服务实践"><a href="#eureka-服务实践" class="headerlink" title="eureka 服务实践"></a>eureka 服务实践</h1><h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><ul><li>jdk1.8</li><li>maven 3.6.2</li><li>IntelliJ IDEA</li><li>springCloud Finchley.RELEASE</li><li>springBoot 2.0.3</li></ul><h2 id="project-依赖"><a href="#project-依赖" class="headerlink" title="project 依赖"></a>project 依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--子项目--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>consumer-order<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>provider-user<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>appEureka<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>consumer-order-ribbon<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--参数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--springBoot--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--springCloud版本序列配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Finchley.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Spring Cloud 基础--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Spring Cloud 服务注册组件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--此处的依赖是SpringBoot2.0以后专用的，如果您使用的SpringBoot版本低于2.0请使用spring-cloud-starter-eureka-server--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring boot 2.0.3版本解决方案：spring-cloud-starter-feign--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--Spring Boot 执行器组件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="eureka-客户端依赖、启动类、配置"><a href="#eureka-客户端依赖、启动类、配置" class="headerlink" title="eureka 客户端依赖、启动类、配置"></a>eureka 客户端依赖、启动类、配置</h2><ul><li>依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xmlversion="1.0"encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">projectxmlns="http:</span>//<span class="attr">maven.apache.org</span>/<span class="attr">POM</span>/<span class="attr">4.0.0</span>"</span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>appEureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>启动类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span><span class="comment">//开启Eurekaserver</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Eureka</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">    SpringApplication.run(Eureka<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配置</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 端口号</span></span><br><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">9999</span></span><br><span class="line"><span class="comment"># 服务注册相关配置</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line"><span class="comment">  # 服务实例主机名</span></span><br><span class="line">  <span class="attr">instance</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">hostname</span>: <span class="string">localhost</span></span><br><span class="line"><span class="comment">  # 服务提供者配置</span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line"><span class="comment">    # 不进行注册（当服务注册中心是单点而非高可用时的配置方式）</span></span><br><span class="line">    <span class="attr">registerWithEureka</span>: <span class="string">false</span></span><br><span class="line"><span class="comment">    # 不获取注册信息（当服务注册中心是单点而非高可用时的配置方式）</span></span><br><span class="line">    <span class="attr">fetchRegistry</span>: <span class="string">false</span></span><br><span class="line"><span class="comment">    # 服务注册中心地址</span></span><br><span class="line">    <span class="attr">serviceUrl</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure><h2 id="消费者依赖、启动类、配置、bean、业务类"><a href="#消费者依赖、启动类、配置、bean、业务类" class="headerlink" title="消费者依赖、启动类、配置、bean、业务类"></a>消费者依赖、启动类、配置、bean、业务类</h2><ul><li>依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xmlversion="1.0"encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">projectxmlns="http:</span>//<span class="attr">maven.apache.org</span>/<span class="attr">POM</span>/<span class="attr">4.0.0</span>"</span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>consumer-order<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>启动类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerApp</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">    SpringApplication.run(ConsumerApp<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配置</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line"><span class="attr">port</span>:<span class="string">8900</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line"><span class="attr">application</span>:<span class="string"></span></span><br><span class="line"><span class="attr">name</span>:<span class="string">consumer-order</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line"><span class="attr">instance</span>:<span class="string"></span></span><br><span class="line">   <span class="attr">hostname</span>: <span class="string">localhost</span></span><br><span class="line"><span class="comment">   # 发呆时间，即服务失效时间（缺省为90s）,就是超过15秒没有续约就会从注册表中剔除</span></span><br><span class="line">   <span class="meta">lease-expiration-duration-in-seconds</span>: <span class="string">15</span></span><br><span class="line"><span class="comment">   # 心跳时间，即服务续约间隔时间（缺省为30s）</span></span><br><span class="line">   <span class="meta">lease-renewal-interval-in-seconds</span>: <span class="string">5</span></span><br><span class="line"><span class="attr">client</span>:<span class="string"></span></span><br><span class="line"><span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line"><span class="attr">defaultZone</span>:<span class="string">http://localhost:9999/eureka</span></span><br></pre></td></tr></table></figure><ul><li>bean</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"><span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id=id;</span><br><span class="line"><span class="keyword">this</span>.date=newDate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Longget <span class="title">Id</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id=id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getDate</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(Datedate)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.date=date;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>业务类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span></span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> EurekaClient eurekaClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/order/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Userget <span class="title">Order</span><span class="params">(@PathVariableLongid)</span></span>&#123;</span><br><span class="line">InstanceInfo nextServerFromEureka=eurekaClient.getNextServerFromEureka(<span class="string">"PROVIDER-USER"</span>,<span class="keyword">false</span>);</span><br><span class="line">Stringurl=nextServerFromEureka.getHomePageUrl();</span><br><span class="line">Useruser=restTemplate.getForObject(url+<span class="string">"/user/"</span>+id,User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提供者依赖、配置、启动类、bean、业务类"><a href="#提供者依赖、配置、启动类、bean、业务类" class="headerlink" title="提供者依赖、配置、启动类、bean、业务类"></a>提供者依赖、配置、启动类、bean、业务类</h2><ul><li>依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xmlversion="1.0"encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">projectxmlns="http:</span>//<span class="attr">maven.apache.org</span>/<span class="attr">POM</span>/<span class="attr">4.0.0</span>"</span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>provider-user<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>配置</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line"><span class="attr">port</span>:<span class="string">7900#自定义boot项目访问端口</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line"><span class="attr">application</span>:<span class="string"></span></span><br><span class="line"><span class="attr">name</span>:<span class="string">provider-user</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line"><span class="attr">instance</span>:<span class="string"></span></span><br><span class="line">   <span class="attr">hostname</span>: <span class="string">localhost</span></span><br><span class="line"><span class="comment">   # 发呆时间，即服务失效时间（缺省为90s）,就是超过15秒没有续约就会从注册表中剔除</span></span><br><span class="line">   <span class="meta">lease-expiration-duration-in-seconds</span>: <span class="string">15</span></span><br><span class="line"><span class="comment">   # 心跳时间，即服务续约间隔时间（缺省为30s）</span></span><br><span class="line">   <span class="meta">lease-renewal-interval-in-seconds</span>: <span class="string">5</span></span><br><span class="line"><span class="attr">client</span>:<span class="string"></span></span><br><span class="line"><span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line"><span class="attr">defaultZone</span>:<span class="string">http://localhost:9999/eureka</span></span><br></pre></td></tr></table></figure><ul><li>启动类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span><span class="comment">//启用eureka客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderApp</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">SpringApplication.run(ProviderApp<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>bean</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"><span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id=id;</span><br><span class="line"><span class="keyword">this</span>.date=newDate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Longget <span class="title">Id</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id=id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getDate</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(Datedate)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.date=date;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>业务类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> EurekaClient eurekaClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">publicUsergetUser(<span class="meta">@PathVariableLongid</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> User(id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li>启动 eureka、消费者、提供者，访问 eureka 客户端<br><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8Beureka%EF%BC%88%E4%BA%8C%EF%BC%89_2019-11-14-10-26-57.png" alt="springcloud实战之eureka（二）_2019-11-14-10-26-57.png"></li><li>消费者通过 eureka 访问提供者<br><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8Beureka%EF%BC%88%E4%BA%8C%EF%BC%89_2019-11-14-10-31-56.png" alt="springcloud实战之eureka（二）_2019-11-14-10-31-56.png"></li></ul>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eureka实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud解析之Eureka</title>
      <link href="/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BEureka/"/>
      <url>/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BEureka/</url>
      
        <content type="html"><![CDATA[<h2 id="Eureka-是什么？"><a href="#Eureka-是什么？" class="headerlink" title="Eureka 是什么？"></a>Eureka 是什么？</h2><ul><li><code>Netflix</code>提供的一种高可用的服务发现解决方案。</li><li>基于 REST 的服务，主要用于定位运行在 AWS 域中的中间层服务，以达到负载均衡和中间层服务故障转移的目的。SpringCloud 将它集成在其子项目<code>spring-cloud-netflix</code>中，实现 SpringCloud 的服务发现功能。</li></ul><h2 id="Eureka-组件"><a href="#Eureka-组件" class="headerlink" title="Eureka 组件"></a>Eureka 组件</h2><ul><li>Eureka 服务器和 Eureka 客户端。Eureka 服务器用作服务注册服务器。</li><li>Eureka 客户端是一个 java 客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。</li></ul><h2 id="Eureka-架构图"><a href="#Eureka-架构图" class="headerlink" title="Eureka 架构图"></a>Eureka 架构图</h2><p><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8Beureka%EF%BC%88%E4%B8%80%EF%BC%89_2019-11-18-13-35-14.png" alt="springcloud实战之eureka（一）_2019-11-18-13-35-14.png"></p><h2 id="Eureka-功能"><a href="#Eureka-功能" class="headerlink" title="Eureka 功能"></a>Eureka 功能</h2><h3 id="心跳监测"><a href="#心跳监测" class="headerlink" title="心跳监测"></a>心跳监测</h3><p>在应用启动后，将会向 Eureka Server 发送心跳,默认周期为 30 秒，如果 Eureka Server 在多个心跳周期内没有接收到某个节点的心跳，Eureka Server 将会从服务注册表中把这个服务节点移除(默认 90 秒)。</p><h3 id="心跳保护"><a href="#心跳保护" class="headerlink" title="心跳保护"></a>心跳保护</h3><p>如果 Eureka 服务节点在短时间里丢失了大量的心跳连接（注：可能发生了网络故障），那么这个 Eureka 节点会进入<strong>自我保护模式</strong>。 此时，这个 Eureka 节点对于新的服务还能提供注册服务，对于”死亡“的仍然保留，以防还有客户端向其发起请求。当网络故障恢复后，这个 Eureka 节点会退出自我保护模式。</p><h3 id="客户端缓存"><a href="#客户端缓存" class="headerlink" title="客户端缓存"></a>客户端缓存</h3><ul><li>Eureka 集群中所有节点都失效，或者发生网络分割故障导致客户端不能访问任何一台 Eureka 服务器；Eureka 服务的消费者仍然可以通过 Eureka 客户端缓存来获取现有的服务注册信息。</li><li>甚至最极端的环境下，所有正常的 Eureka 节点都不对请求产生相应，也没有更好的服务器解决方案来解决这种问题时；得益于 Eureka 的客户端缓存技术，消费者服务仍然可以通过 Eureka 客户端查询与获取注册服务信息，这点很重要。</li></ul><h3 id="服务同步"><a href="#服务同步" class="headerlink" title="服务同步"></a>服务同步</h3><p>如果某台服务器宕机，Eureka 不会有类似于 ZooKeeper 的选举 leader 的过程；客户端请求会自动切换到新的 Eureka 节点；当宕机的服务器重新恢复后，Eureka 会再次将其纳入到服务器集群管理之中；而对于它来说，所有要做的无非是同步一些新的服务注册信息而已。所以，再也不用担心有“掉队”的服务器恢复以后，会从 Eureka 服务器集群中剔除出去的风险了。</p><h2 id="服务发现是什么？"><a href="#服务发现是什么？" class="headerlink" title="服务发现是什么？"></a>服务发现是什么？</h2><ul><li>服务发现有<strong>客户端发现模式</strong>和<strong>服务端发现模式</strong>两种。区别在于服务发现 Balance 策略是由使用方自己实现还是作为一项服务来供使用方调用。</li><li>服务发现依赖于服务注册表，系统中每个服务实例启动时，会将自己的网络位置信息发送到服务注册表，服务注册表利用<strong>心跳机制</strong>即时更新。实例关闭或者服务注册表检测到实例心跳超时情况下，实例信息就会从服务注册表移出。</li></ul><h2 id="两种服务发现模式"><a href="#两种服务发现模式" class="headerlink" title="两种服务发现模式"></a>两种服务发现模式</h2><ul><li>客户端发现模式是由服务请求方负责发现所有可用实例在网络中的具体位置，并根据具体的 Balance 策略将请求路由到具体的实例处理。</li><li>服务端发现模式则是请求方把请求经由 Load Balancer，Load Balancer 查询服务注册表后根据自己的 Balance 策略将请求路由到目标服务的一台具体实例上进行处理。</li></ul>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eureka 服务发现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud实战之Feign</title>
      <link href="/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BFeign/"/>
      <url>/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BFeign/</url>
      
        <content type="html"><![CDATA[<h1 id="创建一个-Feign-客户端"><a href="#创建一个-Feign-客户端" class="headerlink" title="创建一个 Feign 客户端"></a>创建一个 Feign 客户端</h1><h2 id="简单实践"><a href="#简单实践" class="headerlink" title="简单实践"></a>简单实践</h2><ul><li>依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>consumer-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>配置</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8900</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">consumer-order-ribbon</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">instance</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">hostname</span>: <span class="string">localhost</span></span><br><span class="line"><span class="comment">    # 发呆时间，即服务失效时间（缺省为90s）,就是超过15秒没有续约就会从注册表中剔除</span></span><br><span class="line">    <span class="meta">lease-expiration-duration-in-seconds</span>: <span class="string">15</span></span><br><span class="line"><span class="comment">    # 心跳时间，即服务续约间隔时间（缺省为30s）</span></span><br><span class="line">    <span class="meta">lease-renewal-interval-in-seconds</span>: <span class="string">5</span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://localhost:9999/eureka</span></span><br></pre></td></tr></table></figure><ul><li>启动类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//通过注解@EnableEurekaClient 表明自己是一个eurekaclient.</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="comment">//开启Feign的功能</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerFeignApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConsumerFeignApp<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>服务接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个feign接口，通过@ FeignClient（“服务名”），来指定调用哪个服务</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value =<span class="string">"provider-user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">getUser</span><span class="params">(@PathVariable Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>业务类（数据类同上省略）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/order/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getOrder</span><span class="params">(@PathVariable Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUser(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">启动eureka、同时启动两个提供者、启动Feign客户端，访问地址http://localhost:8900/order/1，可以看到，轮流访问两个提供者服务。说明 Feign 默认是集成了 Ribbon 的轮询方案。</span><br></pre></td></tr></table></figure><h2 id="Feign-如何结合-Ribbon-切换均衡算法"><a href="#Feign-如何结合-Ribbon-切换均衡算法" class="headerlink" title="Feign 如何结合 Ribbon 切换均衡算法"></a>Feign 如何结合 Ribbon 切换均衡算法</h2><ul><li>可以在 application.yml 中指定，如下:</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">PROVIDER-USER</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">ribbon</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName</span>: <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重启Feign客户端，访问上面那个url，可以发现随机访问负载策略是生效的。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> feign实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud解析之Feign</title>
      <link href="/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BFeign/"/>
      <url>/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BFeign/</url>
      
        <content type="html"><![CDATA[<h2 id="Feign-是什么？"><a href="#Feign-是什么？" class="headerlink" title="Feign 是什么？"></a>Feign 是什么？</h2><ul><li>Feign 是一个声明式 WebService 客户端。</li><li>使用 Feign 能让编写的 WebService 客户端更加简洁。</li><li>它的使用方法式定义一个接口，然后在上面添加注解</li><li>Spring Cloud 对 Feign 进行了封装，使其支持了 Spring MVC 标准注解和 HttpMessageConverters。</li><li>Feign 可以与 Eureka 和 Ribbon 组合使用以支持负载均衡。</li></ul><h2 id="为什么要使用-Feign"><a href="#为什么要使用-Feign" class="headerlink" title="为什么要使用 Feign?"></a>为什么要使用 Feign?</h2><ul><li>Feign 旨在使编写 Java Http 客户端变得更容易。</li><li>让我们的服务接口化，改变前面的 Ribben+RestTemplate 的模板化的调用方式。</li><li>Feign 封装了 Ribbon，可以结合 Ribbon 自定义负载均衡策略</li><li><strong>但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用</strong>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> feign 服务接口化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud实战之Ribbon</title>
      <link href="/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BRibbon/"/>
      <url>/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BRibbon/</url>
      
        <content type="html"><![CDATA[<h1 id="创建一个消费者（用于实践负载均衡）"><a href="#创建一个消费者（用于实践负载均衡）" class="headerlink" title="创建一个消费者（用于实践负载均衡）"></a>创建一个消费者（用于实践负载均衡）</h1><h2 id="默认简单轮询负载均衡策略"><a href="#默认简单轮询负载均衡策略" class="headerlink" title="默认简单轮询负载均衡策略"></a>默认简单轮询负载均衡策略</h2><ul><li>依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>consumer-order-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>配置</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8900</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">consumer-order-ribbon</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://localhost:9999/eureka</span></span><br><span class="line">  <span class="attr">instance</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">prefer-ip-address</span>: <span class="string">true</span></span><br></pre></td></tr></table></figure><ul><li>启动类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConsumerApp<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 向程序的ioc注入一个bean: restTemplate;</span></span><br><span class="line"><span class="comment">    * 并通过<span class="doctag">@LoadBalanced</span>注解表明这个restRemplate开启负载均衡的功能。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>bean</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.date = <span class="keyword">new</span> Date();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.date = date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>业务类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/order/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getOrder</span><span class="params">(@PathVariable Long id)</span></span>&#123;</span><br><span class="line">        User user = restTemplate.getForObject(<span class="string">"http://PROVIDER-USER/user/"</span>+ id, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><hr><p>启动消费者（ribbon）、提供者（7900，7901）、eureka 客户端，访问如下界面刷新 10 次<br><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8Bribbon%EF%BC%88%E4%BA%8C%EF%BC%89_2019-11-14-17-21-44.png" alt="springcloud实战之ribbon（二）_2019-11-14-17-21-44.png"></p><hr><p>两个提供者服务各被访问 5 次</p><h2 id="自定义负载均衡策略"><a href="#自定义负载均衡策略" class="headerlink" title="自定义负载均衡策略"></a>自定义负载均衡策略</h2><ul><li>负载均衡策略类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonConfigration</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置负载均衡策略为 随机，默认是轮训</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">ribbonRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomRule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>负载均衡配置类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RibbonClient</span>(name = <span class="string">"PROVIDER-USER"</span>, configuration = RibbonConfigration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Component</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">RibbonConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><hr><p>如上，访问 20 次，可以看到负载策略是随机访问的</p><h2 id="配置文件的方式"><a href="#配置文件的方式" class="headerlink" title="配置文件的方式"></a>配置文件的方式</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">PROVIDER-USER</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">ribbon</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName</span>: <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br></pre></td></tr></table></figure><p>此方式配置轮询策略，会优先于第二种配置类的方式。</p>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ribbon实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud解析之Ribbon</title>
      <link href="/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BRibbon/"/>
      <url>/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BRibbon/</url>
      
        <content type="html"><![CDATA[<h2 id="Ribbon-是什么？"><a href="#Ribbon-是什么？" class="headerlink" title="Ribbon 是什么？"></a>Ribbon 是什么？</h2><blockquote><p>springcloud 的客户端负载均衡组件</p></blockquote><h2 id="Ribbon-架构图"><a href="#Ribbon-架构图" class="headerlink" title="Ribbon 架构图"></a>Ribbon 架构图</h2><p><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8Bribbon%EF%BC%88%E4%B8%80%EF%BC%89_2019-11-18-10-30-38.png" alt="springcloud实战之ribbon（一）_2019-11-18-10-30-38.png"></p><h2 id="服务端负载均衡"><a href="#服务端负载均衡" class="headerlink" title="服务端负载均衡"></a>服务端负载均衡</h2><blockquote><p>硬件负载均衡和软件负载均衡</p></blockquote><ul><li>硬件负载均衡主要通过在服务器节点之间按照专门用于负载均衡的设备，比如 F5 等</li><li>软件负载均衡则是通过在服务器上安装一些用于负载均衡功能或模块等软件来完成请求分发工作，比如 Nginx 等</li><li>服务端负载均衡架构图<br><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8Bribbon%EF%BC%88%E4%B8%80%EF%BC%89_2019-11-14-11-01-18.png" alt="springcloud实战之ribbon（一）_2019-11-14-11-01-18.png"></li></ul><h2 id="客户端负载均衡"><a href="#客户端负载均衡" class="headerlink" title="客户端负载均衡"></a>客户端负载均衡</h2><ul><li>客户端负载均衡和服务端负载均衡最大的不同点在于上面所提到<strong>服务清单所存储的位置</strong>。</li><li>在客户端负载均衡中，所有客户端节点都维护着自己要访问的服务端清单，而这些服务端端清单来自于服务注册中心，比如上一章我们介绍的 Eureka 服务端。同服务端负载均衡的架构类似，在客户端负载均衡中也需要心跳去维护服务端清单的健康性，默认会创建针对各个服务治理框架的 Ribbon 自动化整合配置。</li></ul><h2 id="Ribbon-实现软负载均衡主要有这三点"><a href="#Ribbon-实现软负载均衡主要有这三点" class="headerlink" title="Ribbon 实现软负载均衡主要有这三点"></a>Ribbon 实现软负载均衡主要有这三点</h2><ol><li>服务发现：就是发现依赖服务的列表，通俗来说就是依据服务的名字把它的所有服务实例找出来</li><li>服务选择规则：依据指定的服务规则，从多个有效服务中选择一个服务发起请求</li><li>服务监听：定时检测服务存活情况，及时高效剔除不可用的服务。</li></ol><h2 id="Ribbon-主要组件"><a href="#Ribbon-主要组件" class="headerlink" title="Ribbon 主要组件"></a>Ribbon 主要组件</h2><p><code>ServerList</code>、<code>IRule</code>、<code>ServerListFilter</code>;<br>首先通过 <code>ServerList</code> 获取所有可用服务列表，再通过 <code>ServerListFilter</code> 过滤掉一部分服务，最后 <code>IRule</code> 从过滤后的服务中选择一个实例进行 <code>http</code> 请求</p><h2 id="Ribbon-负载均衡策略"><a href="#Ribbon-负载均衡策略" class="headerlink" title="Ribbon 负载均衡策略"></a>Ribbon 负载均衡策略</h2><ul><li>简单轮询负载均衡（RoundRobin）</li><li>随机负载均衡 （Random）</li><li>随机选择状态为 UP 的 Server</li><li>加权响应时间负载均衡 （WeightedResponseTime）</li><li>区域感知轮询负载均衡（ZoneAware）</li></ul><h2 id="Ribbon-配置"><a href="#Ribbon-配置" class="headerlink" title="Ribbon 配置"></a>Ribbon 配置</h2><p>连接超时、重试、重试算法</p><h2 id="Ribbon-功能"><a href="#Ribbon-功能" class="headerlink" title="Ribbon 功能"></a>Ribbon 功能</h2><ul><li>易于与服务发现组件（比如 Netflix 的 Eureka）集成</li><li>使用 Archaius 完成运行时配置</li><li>使用 JMX 暴露运维指标，使用 Servo 发布</li><li>多种可插拔的序列化选择</li><li>异步和批处理操作</li><li>自动 SLA 框架</li><li>系统管理/指标控制台</li></ul>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ribbon 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务之初见</title>
      <link href="/2019/11/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%9D%E8%A7%81/"/>
      <url>/2019/11/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%9D%E8%A7%81/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是微服务架构"><a href="#什么是微服务架构" class="headerlink" title="什么是微服务架构"></a>什么是微服务架构</h1><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%98%AF%E4%BB%80%E4%B9%88_2019-11-20-13-53-42.png" alt="微服务是什么_2019-11-20-13-53-42.png"></p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间相互协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务和服务之间采用轻量级的通信机制相互沟通（通常是基于 HTTP 的 Restful API).每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境、类生产环境等</p><h1 id="单体应用-VS-微服务架构"><a href="#单体应用-VS-微服务架构" class="headerlink" title="单体应用 VS 微服务架构"></a>单体应用 VS 微服务架构</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>提升开发交流，每个服务足够内聚，足够小，代码容易理解；</li><li>服务独立测试、部署、升级、发布；</li><li>按需定制的 DFX，资源利用率，每个服务可以各自进行 x 扩展和 z 扩展，而且，每个服务可以根据自己的需要部署到合适的硬件服务器上；每个服务按</li><li>需要选择 HA 的模式，选择接受服务的实例个数；</li><li>容易扩大开发团队，可以针对每个服务（service）组件开发团队；</li><li>提高容错性（fault isolation），一个服务的内存泄露并不会让整个系统瘫痪；</li><li>新技术的应用，系统不会被长期限制在某个技术栈上；</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>没有银弹，微服务提高了系统的复杂度；</li><li>开发人员要处理分布式系统的复杂性；</li><li>服务之间的分布式通信问题；</li><li>服务的注册与发现问题；</li><li>服务之间的分布式事务问题；</li><li>数据隔离再来的报表处理问题；</li><li>服务之间的分布式一致性问题；</li><li>服务管理的复杂性，服务的编排；</li><li>不同服务实例的管理。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.zhihu.com/question/65502802" target="_blank" rel="noopener">什么是微服务架构？</a></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务介绍 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
