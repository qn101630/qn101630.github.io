<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python——基础（一）</title>
      <link href="/2020/11/18/Python%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/11/18/Python%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="语法规范"><a href="#语法规范" class="headerlink" title="语法规范"></a>语法规范</h1><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># print absolute value of an integer:</span></span><br><span class="line"><span class="attr">a</span> = <span class="string">100</span></span><br><span class="line"><span class="attr">if</span> <span class="string">a &gt;= 0:</span></span><br><span class="line">    <span class="attr">print(a)</span></span><br><span class="line"><span class="attr">else</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">print(-a)</span></span><br></pre></td></tr></table></figure><ul><li>以 # 开头的语句是注释，注释是给人看的，可以是任意内容，解释器会忽略掉注释。</li><li>其他每一行都是一个语句，当语句以冒号:结尾时，缩进的语句视为代码块。</li><li>按照约定俗成的惯例，应该始终坚持使用4个空格的缩进。</li><li>Python程序是大小写敏感的，如果写错了大小写，程序会报错。</li></ul><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_的组合，且不能用数字开头，比如：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">a</span> = <span class="string">1</span></span><br><span class="line"><span class="attr">t_007</span> = <span class="string">'T007'</span></span><br><span class="line"><span class="attr">Answer</span> = <span class="string">True</span></span><br></pre></td></tr></table></figure><h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><p>Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。</p><p>对于很大的数，例如10000000000，很难数清楚0的个数。Python允许在数字中间以_分隔，因此，写成10_000_000_000和10000000000是完全一样的。</p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x109和12.3x108是完全相等的。</p><p>浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是以单引号’或双引号”括起来的任意文本，比如’abc’，”xyz”等等。</p><p>如果字符串内部既包含’又包含”怎么办？可以用转义字符\来标识，比如：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'I\'m</span> <span class="string">\"OK\"!'</span></span><br></pre></td></tr></table></figure><p>转义字符\可以转义很多字符，比如\n表示换行，\t表示制表符，字符\本身也要转义，所以\表示的字符就是\，可以在Python的交互式命令行用print()打印字符串看看：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="string">print('I\'m ok.')</span></span><br><span class="line"><span class="meta">I'm</span> <span class="string">ok.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="string">print('I\'m learning\nPython.')</span></span><br><span class="line"><span class="meta">I'm</span> <span class="string">learning</span></span><br><span class="line"><span class="attr">Python.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="string">print('\\\n\\')</span></span><br><span class="line">\</span><br><span class="line">\</span><br></pre></td></tr></table></figure><p>如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还允许用r’’表示’’内部的字符串默认不转义，可以自己试试：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="string">print('\\\t\\')</span></span><br><span class="line"><span class="attr">\ </span>      <span class="string">\</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="string">print(r'\\\t\\')</span></span><br><span class="line"><span class="attr">\\\t\\</span></span><br></pre></td></tr></table></figure><p>如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用’’’…’’’的格式表示多行内容，可以自己试试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(<span class="string">''</span><span class="string">'line1</span></span><br><span class="line"><span class="string">... line2</span></span><br><span class="line"><span class="string">... line3'</span><span class="string">''</span>)</span><br><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br></pre></td></tr></table></figure><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="string">True</span></span><br><span class="line"><span class="attr">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="string">False</span></span><br><span class="line"><span class="attr">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="string">3 &gt; 2</span></span><br><span class="line"><span class="attr">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="string">3 &gt; 5</span></span><br><span class="line"><span class="attr">False</span></span><br></pre></td></tr></table></figure><h2 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h2><p>空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。</p><h1 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h1><p>如何输出格式化的字符串。我们经常会输出类似’亲爱的xxx你好！你xx月的话费是xx，余额是xx’之类的字符串，而xxx的内容都是根据变量变化的。</p><ol><li><p>%运算符就是用来格式化字符串的。</p><p> 在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。</p> <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">print('%2d-%02d'</span> <span class="string">% (3, 1))</span></span><br><span class="line"><span class="meta">print('%.2f'</span> <span class="string">% 3.1415926)</span></span><br></pre></td></tr></table></figure></li><li><p>format()</p><p> 另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多：</p> <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="string">'Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%'.format('小明', 17.125)</span></span><br><span class="line"><span class="meta">'Hello,</span> <span class="string">小明, 成绩提升了 17.1%'</span></span><br></pre></td></tr></table></figure></li><li><p>f-string</p><p> 最后一种格式化字符串的方法是使用以f开头的字符串，称之为f-string，它和普通字符串不同之处在于，字符串如果包含{xxx}，就会以对应的变量替换：</p> <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="string">r = 2.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="string">s = 3.14 * r ** 2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="string">print(f'The area of a circle with radius &#123;r&#125; is &#123;s:.2f&#125;')</span></span><br><span class="line"><span class="attr">The</span> <span class="string">area of a circle with radius 2.5 is 19.62</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux——Find（二）</title>
      <link href="/2020/11/09/Linux%E2%80%94%E2%80%94Find%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/11/09/Linux%E2%80%94%E2%80%94Find%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>F i n d 是一个非常有效的工具，它可<br>以遍历当前目录甚至于整个文件系统来查找某些文件或目录。</p><h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><p>F i n d 命令的一般形式为：</p><blockquote><p>find pathname -options [-print -exec -ok]</p></blockquote><p>让我们来看看该命令的参数：</p><ul><li>pathname find命令所查找的目录路径。例如用 .来表示当前目录，用/来表示系统根目录。</li><li>-print find命令将匹配的文件输出到标准输出。</li><li>-exec find命令对匹配的文件执行该参数所给出的 s h e l l命令。相应命令的形式为 ‘ c o m m -<br>and’ {} ;，注意{ }和\；之间的空格。</li><li>-ok 和- e x e c的作用相同，只不过以一种更为安全的模式来执行该参数所给出的 s h e l l命令，<br>在执行每一个命令之前，都会给出提示，让用户来确定是否执行。</li></ul><h1 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h1><p>find 命令有很多选项或表达式，每一个选项前面跟随一个横杠 -。让我们先来看一下该命令的主要选项，然后再给出一些例子。</p><ul><li>-name 按照文件名查找文件。</li><li>-perm 按照文件权限来查找文件。</li><li>-prune 使用这一选项可以使f i n d命令不在当前指定的目录中查找，如果同时使用了 - d e p t h<br>选项，那么- p r u n e选项将被f i n d命令忽略。</li><li>-user 按照文件属主来查找文件。</li><li>-group 按照文件所属的组来查找文件。</li><li>-mtime -n +n 按照文件的更改时间来查找文件， - n表示文件更改时间距现在n天以内，+ n<br>表示文件更改时间距现在 n天以前。F i n d命令还有- a t i m e和- c t i m e选项，但它们都和- m t i m e选项相似，所以我们在这里只介绍 - m t i m e选项。</li><li>-nogroup 查找无有效所属组的文件，即该文件所属的组在 / e t c / g r o u p s中不存在。</li><li>-nouser 查找无有效属主的文件，即该文件的属主在 / e t c / p a s s w d中不存在。</li><li>-newer file1 ! file2 查找更改时间比文件f i l e 1新但比文件f i l e 2旧的文件。</li><li>-type 查找某一类型的文件，诸如：<br>b - 块设备文件。<br>d - 目录。<br>c - 字符设备文件。<br>p - 管道文件。<br>l - 符号链接文件。<br>f - 普通文件。</li><li>-size n[c] 查找文件长度为n块的文件，带有c时表示文件长度以字节计。</li><li>-depth 在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找。</li><li>-fstype 查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件<br>/ e t c / f s t a b中找到，该配置文件中包含了本系统中有关文件系统的信息。</li><li>-mount 在查找文件时不跨越文件系统 m o u n t点。</li><li>-follow 如果f i n d命令遇到符号链接文件，就跟踪至链接所指向的文件。</li><li>-cpio 对匹配的文件使用c p i o命令，将这些文件备份到磁带设备中。</li></ul><h1 id="使用name选项"><a href="#使用name选项" class="headerlink" title="使用name选项"></a>使用name选项</h1><p>不管当前路径是什么，如果想要在自己的根目录 $ H O M E中查找文件名符合 * . t x t的文件，使用<del>作为’ p a t h n a m e参数，波浪号</del>代表了你的$ H O M E目录。</p><blockquote><p>$ find ~ -name “*.txt” -print</p></blockquote><p>或：</p><blockquote><p>$ find . -print</p></blockquote><p>想要在当前目录及子目录中查找所有的‘ * . t x t’文件，可以用：</p><blockquote><p>$ find . -name “*.txt” -print</p></blockquote><p>想要的当前目录及子目录中查找文件名以一个大写字母开头的文件，可以用：</p><blockquote><p>$ find . -name “[A-Z]*” -print</p></blockquote><p>想要在 /etc 目录中查找文件名以 host 开头的文件，可以用：</p><blockquote><p>$ find /etc -name “host*” -print</p></blockquote><p>要想让系统高负荷运行，就从根目录开始查找所有的文件。如果希望在系统管理员那里保留一个好印象的话，最好在这么做之前考虑清楚！</p><blockquote><p>$ find / -name “*” -print</p></blockquote><p>如果想在当前目录查找文件名以两个小写字母开头，跟着是两个数字，最后是 * . t x t的文件，下面的命令就能够返回名为 a x 3 7 . t x t的文件：</p><blockquote><p>$ find . -name “[a-z][a-z][0–9][0–9].txt” -print</p></blockquote><h1 id="使用perm选项"><a href="#使用perm选项" class="headerlink" title="使用perm选项"></a>使用perm选项</h1><p>如果希望按照文件权限模式来查找文件的话，可以采用 - p e r m选项。</p><p>为了在当前目录下查找文件权限位为 7 5 5的文件，即文件属主可以读、写、执行，其他用户可以读、执行的文件，可以用：</p><blockquote><p>$ find . -perm 755 -print</p></blockquote><p>如果希望在当前目录下查找所有用户都可读、写、执行的文件（要小心这种情况），我们可以使用f i n d命令的- p e r m选项。在八进制数字前面要加一个横杠 -。在下面的命令中 - p e r m代表按照文件权限查找，而‘ 0 0 7’和你在c h m o d命令的绝对模式中所采用的表示法完全相同。</p><blockquote><p>$ find . -perm -007 -print</p></blockquote><h1 id="忽略某个目录"><a href="#忽略某个目录" class="headerlink" title="忽略某个目录"></a>忽略某个目录</h1><p>可以使用- p r u n e选项来指出需要忽略的目录。在使用 - p r u n e选项时要当心，因为如果你同时使用了- d e p t h选项，那么- p r u n e选项就会被f i n d命令忽略。</p><p>如果希望在/ a p p s目录下查找文件，但不希望在 / a p p s / b i n目录下查找，可以用：</p><blockquote><p>$ find /apps -name “/apps/bin” -prune -o -print</p></blockquote><h1 id="使用user和nouser选项"><a href="#使用user和nouser选项" class="headerlink" title="使用user和nouser选项"></a>使用user和nouser选项</h1><p>如果希望按照文件属主查找文件，可以给出相应的用户名。例如，在 $ H O M E目录中查找文件属主为d a v e的文件，可以用：</p><blockquote><p>$ find ~ -user dave -print</p></blockquote><p>在/ e t c目录下查找文件属主为u u c p的文件：</p><blockquote><p>$ find /etc -user uucp -print</p></blockquote><p>为了查找属主帐户已经被删除的文件，可以使用 - n o u s e r选项。</p><blockquote><p>$ find /home -nouser -print</p></blockquote><h1 id="使用group和nogroup选项"><a href="#使用group和nogroup选项" class="headerlink" title="使用group和nogroup选项"></a>使用group和nogroup选项</h1><p>就像u s e r和n o u s e r选项一样，针对文件所属于的用户组， f i n d命令也具有同样的选项，为了在/ a p p s目录下查找属于a c c t s用户组的文件，可以用：</p><blockquote><p>$ find /apps -group accts -print</p></blockquote><p>要查找没有有效所属用户组的所有文件，可以使用 n o g r o u p选项。下面的f i n d命令从文件系统的根目录处查找这样的文件:</p><blockquote><p>$ fine/-nogroup-print</p></blockquote><h1 id="按照更改时间查找文件"><a href="#按照更改时间查找文件" class="headerlink" title="按照更改时间查找文件"></a>按照更改时间查找文件</h1><p>如果希望按照更改时间来查找文件，可以使用 m t i m e选项。</p><p>希望在系统根目录下查找更改时间在 5日以内的文件，可以用：</p><blockquote><p>$ find / -mtime -5 -print</p></blockquote><p>为了在/ v a r / a d m目录下查找更改时间在3日以前的文件，可以用：</p><p>$ find /var/adm -mtime +3 -print</p><h1 id="使用type选项"><a href="#使用type选项" class="headerlink" title="使用type选项"></a>使用type选项</h1><p>如果要在 / e t c目录下查找所有的目录，可以用：</p><blockquote><p>$ find /etc -type d -print</p></blockquote><p>为了在当前目录下查找除目录以外的所有类型的文件，可以用：</p><blockquote><p>$ find . ! -type d -print</p></blockquote><p>为了在/ e t c目录下查找所有的符号链接文件，可以用：</p><blockquote><p>$ find /etc -type l -print</p></blockquote><h1 id="使用size选项"><a href="#使用size选项" class="headerlink" title="使用size选项"></a>使用size选项</h1><p>可以按照文件长度来查找文件，这里所指的文件长度既可以用块（ b l o c k）来计量，也可以用字节来计量。</p><p>以字节计量文件长度的表达形式为 N c；以块计量文件长度只用数字表示即可。</p><p>为了在当前目录下查找文件长度大于 1 M字节的文件，可以用：</p><blockquote><p>$ find . -size +1000000c -print</p></blockquote><p>为了在/ h o m e / a p a c h e目录下查找文件长度恰好为 1 0 0字节的文件，可以用：</p><blockquote><p>$ find /home/apache -size 100c -print</p></blockquote><p>为了在当前目录下查找长度超过 1 0块的文件（一块等于5 1 2字节），可以用：</p><blockquote><p>$ find . -size +10 -print</p></blockquote><h1 id="使用depth选项"><a href="#使用depth选项" class="headerlink" title="使用depth选项"></a>使用depth选项</h1><p>在使用f i n d命令时，可能希望先匹配所有的文件，再在子目录中查找。使用 d e p t h选项就可以使f i n d命令这样做。这样做的一个原因就是，当在使用 f i n d命令向磁带上备份文件系统时，希望首先备份所有的文件，其次再备份子目录中的文件。</p><p>在下面的例子中， f i n d命令从文件系统的根目录开始，查找一个名为 C O N . F I L E的文件。<br>它将首先匹配所有的文件然后再进入子目录中查找。</p><blockquote><p>$ find / -name “CON.FILE” -depth -print</p></blockquote><h1 id="使用mount选项"><a href="#使用mount选项" class="headerlink" title="使用mount选项"></a>使用mount选项</h1><p>在当前的文件系统中查找文件（不进入其他文件系统），可以使用f i n d命令的m o u n t选项。</p><p>在下面的例子中，我们从当前目录开始查找位于本文件系统中文件名以 X C结尾的文件：</p><blockquote><p>$ find . -name “*.XC” -mount -print</p></blockquote><h1 id="使用cpio选项"><a href="#使用cpio选项" class="headerlink" title="使用cpio选项"></a>使用cpio选项</h1><p>c p i o命令可以用来向磁带设备备份文件或从中恢复文件。</p><blockquote><p>find etc home apps  -depth -print | cpio -ivcdC65536 -o /dev/rmt0</p></blockquote><h1 id="使用exec或ok来执行shell命令"><a href="#使用exec或ok来执行shell命令" class="headerlink" title="使用exec或ok来执行shell命令"></a>使用exec或ok来执行shell命令</h1><p>当匹配到一些文件以后，可能希望对其进行某些操作，这时就可以使用 - e x e c选项。</p><p>e x e c选项后面跟随着所要执行的命令，然后是一对儿 { }，一个空格和一个 \，最后是一个<br>分号。</p><p>为了用ls -l命令列出所匹配到的文件，可以把 ls -l命令放在f i n d命令的- e x e c选项中，例如：</p><blockquote><p>find . -type f -exec ls -l { } \ ;</p></blockquote><p>当使用诸如m v或r m命令时，可以使用-ok 选项的安全模式。</p><p>它将在对每个匹配到的文件进行操作之前提示你。</p><blockquote><p>find . -name “*.log” -mtime +5 -ok rm {} \ ;</p></blockquote><h1 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h1><p>在使用f i n d命令的- e x e c选项处理匹配到的文件时， f i n d命令将所有匹配到的文件一起传递给e x e c执行。</p><p>不幸的是，有些系统对能够传递给 e x e c的命令长度有限制，这样在 f i n d命令运行几分钟之后，就会出现溢出错误。错误信息通常是“参数列太长”或“参数列溢出”。</p><p>这就是x a rg s命令的用处所在，特别是与 f i n d命令一起使用。 F i n d命令把匹配到的文件传递给 x a rg s命令，而x a rg s命令每次只获取一部分文件而不是全部，不像 - e x e c选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。</p><p>下面的例子在整个系统中查找内存信息转储文件 (core dump) ，然后把结果保存到/tmp/core.log 文件中：</p><blockquote><p>$ find . -name “core” -print | xargs echo “” &gt;/tmp/core.log</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch——分词及映射（五）</title>
      <link href="/2020/11/03/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticsearch%E2%80%94%E2%80%94%E5%88%86%E8%AF%8D%E5%8F%8A%E6%98%A0%E5%B0%84%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2020/11/03/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticsearch%E2%80%94%E2%80%94%E5%88%86%E8%AF%8D%E5%8F%8A%E6%98%A0%E5%B0%84%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在对数据库的数据进行检索时，我们是以表映射字段内容，条件语句的遍量需要是字段精确值或者字段相连的一部分。</p><p>而Elasticsearch则不同，将具体内容进行分析和倒排索引，每个索引可以与多个文档作映射，索引内容可以为精确值，也可以为进行分析处理后的符合我们要求的值。</p><p>比如 我们通过谷歌查询springboot 和 SpringBoot，都可以检索到一系列文章，而且大体相同。</p><h1 id="精确值和全文"><a href="#精确值和全文" class="headerlink" title="精确值和全文"></a>精确值和全文</h1><p>精确值 如它们听起来那样精确。例如日期或者用户 ID，但字符串也可以表示精确值，例如用户名或邮箱地址。对于精确值来讲，Foo 和 foo 是不同的，2014 和 2014-09-15 也是不同的。</p><p>全文 是指文本数据（通常以人类容易识别的语言书写），例如一个推文的内容或一封邮件的内容。</p><p>精确值很容易查询。结果是二进制的：要么匹配查询，要么不匹配。这种查询很容易用 SQL 表示：</p><blockquote><p>WHERE name    = “John Smith” AND user_id = 2 AND date    &gt; “2014-09-15”</p></blockquote><p>全文我们更希望做到相关查询，不是说查询条件多一个字或者少一个字就查询不到，而是希望搜索引擎“理解”我们的意思。</p><ul><li>搜索 UK ，会返回包含 United Kindom 的文档。</li><li>搜索 jump ，会匹配 jumped ， jumps ， jumping ，甚至是 leap 。</li></ul><h1 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h1><p>Elasticsearch 使用一种称为 倒排索引 的结构，它适用于快速的全文搜索。一个倒排索引由文档中所有不重复词的列表构成，对于其中每个词，有一个包含它的文档列表。</p><p>例如，假设我们有两个文档，每个文档的 content 域包含如下内容：</p><p>The quick brown fox jumped over the lazy dog<br>Quick brown foxes leap over lazy dogs in summer</p><p>为了创建倒排索引，我们首先将每个文档的 content 域拆分成单独的 词（我们称它为 词条 或 tokens ），创建一个包含所有不重复词条的排序列表，然后列出每个词条出现在哪个文档。结果如下所示：</p><table><thead><tr><th>Term</th><th>Doc_1</th><th>Doc_2</th></tr></thead><tbody><tr><td>Quick</td><td></td><td>X</td></tr><tr><td>The</td><td>X</td><td></td></tr><tr><td>brown</td><td>X</td><td>X</td></tr><tr><td>dog</td><td>X</td><td></td></tr><tr><td>dogs</td><td></td><td>X</td></tr><tr><td>fox</td><td>X</td><td></td></tr><tr><td>foxes</td><td></td><td>X</td></tr><tr><td>in</td><td></td><td>X</td></tr><tr><td>jumped</td><td>X</td><td></td></tr><tr><td>lazy</td><td>X</td><td>X</td></tr><tr><td>leap</td><td></td><td>X</td></tr><tr><td>over</td><td>X</td><td>X</td></tr><tr><td>quick</td><td>X</td><td></td></tr><tr><td>summer</td><td></td><td>X</td></tr><tr><td>the</td><td>X</td><td></td></tr></tbody></table><p>现在，如果我们想搜索 quick brown ，我们只需要查找包含每个词条的文档：</p><table><thead><tr><th>Term</th><th>Doc_1</th><th>Doc_2</th></tr></thead><tbody><tr><td>brown</td><td>X</td><td>X</td></tr><tr><td>quick</td><td>X</td><td></td></tr><tr><td>Total</td><td>2</td><td>1</td></tr></tbody></table><p>两个文档都匹配，但是第一个文档比第二个匹配度更高。如果我们使用仅计算匹配词条数量的简单 相似性算法 ，那么，我们可以说，对于我们查询的相关性来讲，第一个文档比第二个文档更佳。</p><p>但是我想要用quick就可以查到Quick和quick相关的文档，dog能够查到dog和dogs。jumped 和 leap, 尽管没有相同的词根，但他们的意思很相近。他们是同义词。</p><p>如果我们将词条规范为标准模式，那么我们可以找到与用户搜索的词条不完全一致，但具有足够相关性的文档。例如：</p><ul><li>Quick 可以小写化为 quick 。</li><li>foxes 可以 词干提取 –变为词根的格式– 为 fox 。类似的， dogs 可以为提取为 dog 。</li><li>jumped 和 leap 是同义词，可以索引为相同的单词 jump 。</li></ul><p>但是这样我们查询Quick+fox还是无法达到要求，因为在我们的索引中，已经没有 Quick 了。但是，如果我们对搜索的字符串使用与 content 域相同的标准化规则，会变成查询 +quick +fox ，这样两个文档都会匹配！</p><p>这非常重要。你只能搜索在索引中出现的词条，所以索引文本和查询字符串必须标准化为相同的格式。</p><p>而分词和标准化的过程称为 分析。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>分析 包含下面的过程：</p><ul><li>首先，将一块文本分成适合于倒排索引的独立的 词条 ，</li><li>之后，将这些词条统一化为标准格式以提高它们的“可搜索性”，或者 recall</li></ul><p>这些都要通过分析器来完成。</p><p>分析器 实际上是将三个功能封装到了一个包里：</p><ol><li><p>字符过滤器</p><p> 首先，字符串按顺序通过每个 字符过滤器 。他们的任务是在分词前整理字符串。一个字符过滤器可以用来去掉HTML，或者将 &amp; 转化成 and。</p></li><li><p>分词器</p><p> 其次，字符串被 分词器 分为单个的词条。一个简单的分词器遇到空格和标点的时候，可能会将文本拆分成词条。</p></li><li><p>Token 过滤器</p><p> 最后，词条按顺序通过每个 token 过滤器 。这个过程可能会改变词条（例如，小写化 Quick ），删除词条（例如， 像 a， and， the 等无用词），或者增加词条（例如，像 jump 和 leap 这种同义词）。</p></li></ol><p>Elasticsearch附带了可以直接使用的预包装的分析器。</p><ol><li><p>标准分析器</p><p> 标准分析器是Elasticsearch默认使用的分析器。它是分析各种语言文本最常用的选择。它根据 Unicode 联盟 定义的 单词边界 划分文本。删除绝大部分标点。最后，将词条小写。它会产生</p><p> set, the, shape, to, semi, transparent, by, calling, set_trans, 5</p></li><li><p>简单分析器</p><p> 简单分析器在任何不是字母的地方分隔文本，将词条小写。它会产生</p><p> set, the, shape, to, semi, transparent, by, calling, set, trans</p></li><li><p>空格分析器</p><p> 空格分析器在空格的地方划分文本。它会产生</p><p> Set, the, shape, to, semi-transparent, by, calling, set_trans(5)</p></li><li><p>语言分析器</p><p> 特定语言分析器可用于 很多语言。它们可以考虑指定语言的特点。例如， 英语 分析器附带了一组英语无用词（常用单词，例如 and 或者 the ，它们对相关性没有多少影响），它们会被删除。 由于理解英语语法的规则，这个分词器可以提取英语单词的 词干 。</p><p> 英语 分词器会产生下面的词条：</p><p> set, shape, semi, transpar, call, set_tran, 5</p><p> ss注意看 transparent、 calling 和 set_trans 已经变为词根格式。</p></li></ol><p>什么时候用到分析器？</p><p>当我们 索引 一个文档，它的全文域被分析成词条以用来创建倒排索引。 但是，当我们在全文域 搜索 的时候，我们需要将查询字符串通过 相同的分析过程 ，以保证我们搜索的词条格式与索引中的词条格式一致。</p><p>全文查询，理解每个域是如何定义的，因此它们可以做正确的事：</p><ul><li>当你查询一个 全文 域时， 会对查询字符串应用相同的分析器，以产生正确的搜索词条列表。</li><li>当你查询一个 精确值 域时，不会分析查询字符串，而是搜索你指定的精确值。</li></ul><h1 id="指定分析器"><a href="#指定分析器" class="headerlink" title="指定分析器"></a>指定分析器</h1><p>当Elasticsearch在你的文档中检测到一个新的字符串域，它会自动设置其为一个全文 字符串 域，使用 标准 分析器对它进行分析。</p><p>你不希望总是这样。可能你想使用一个不同的分析器，适用于你的数据使用的语言。有时候你想要一个字符串域就是一个字符串域—​不使用分析，直接索引你传入的精确值，例如用户ID或者一个内部的状态域或标签。</p><p>要做到这一点，我们必须手动指定这些域的映射。</p><p>通常我们只对String类型的域设置分析器，其他类型的域如Integer、date，通常使用精确查询。</p><p>string 域映射的两个最重要属性是 index 和 analyzer 。</p><p>index 属性控制怎样索引字符串。它可以是下面三个值：</p><ul><li>analyzed  首先分析字符串，然后索引它。换句话说，以全文索引这个域。</li><li>not_analyzed  索引这个域，所以它能够被搜索，但索引的是精确值。不会对它进行分析。</li><li>no  不索引这个域。这个域不会被搜索到。</li></ul><p>对于 analyzed 字符串域，用 analyzer 属性指定在搜索和索引时使用的分析器。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;</span></span><br><span class="line">    <span class="attr">"tweet":</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">"type":</span>     <span class="string">"string"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">"analyzer":</span> <span class="string">"english"</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>只能添加域映射，而不能更改现有域的映射。如果一个域的映射已经存在，那么该域的数据可能已经被索引。如果你意图修改这个域的映射，索引的数据可能会出错，不能被正常的搜索。</p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch 分词及映射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch——持久化（四）</title>
      <link href="/2020/11/03/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticsearch%E2%80%94%E2%80%94%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2020/11/03/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticsearch%E2%80%94%E2%80%94%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h1><p>Lucene 为了加快写索引的速度，采用了延迟写入的策略。</p><p>虽然这种策略提高了写入的效率，但其最大的弊端是，如果数据在内存中还没有持久化到磁盘上时发生了类似断电等不可控情况，就可能丢失数据。</p><p>为了避免丢失数据，Elasticsearch 添加了事务日志（Translog），事务日志记录了所有还没有被持久化磁盘的数据。</p><h1 id="写操作及操作系统缓存"><a href="#写操作及操作系统缓存" class="headerlink" title="写操作及操作系统缓存"></a>写操作及操作系统缓存</h1><p>Elasticsearch数据的写入并不是直接写入磁盘，这样效率太低，而是先写入内存。</p><p>因为内存中的数据还会继续写入，所以内存中的数据并不是以段的形式存储的，是检索不到的。</p><p>所以，Elasticsearch 是一个准实时的搜索引擎，而不是一个实时的搜索引擎。</p><p>刷新：</p><p>当达到默认的时间（1 秒钟）或者内存的数据达到一定量时，会触发一次刷新（Refresh）。</p><p>将内存中的数据刷新到一个新的段中，但是该段并没有持久化到硬盘中，而是缓存在操作系统的文件缓存系统中。虽然数据还在内存中，但是内存里的数据和文件缓存系统里的数据有以下区别。</p><p>内存中的数据是搜索不到，文件缓存系统中的数据是可以搜索的。</p><p>打开操作系统缓存，使其可被搜索。</p><p>清空内存，日志不做处理</p><p>当日志数据的大小超过 512MB 或者时间超过 30 分钟时，需要触发一次刷新。</p><p>在文件缓存系统中创建一个新的段，并把内存中的数据写入，使其可被搜索。</p><p>清空内存，准备接收新的数据。</p><p>将文件系统缓存中的数据通过 Fsync 函数刷新到硬盘中。</p><p>生成提交点。</p><p>删除旧的日志，创建一个空的日志。</p><h1 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h1><p>根据 Routing 字段进行的单个文档的查询，在 Elasticsearch 集群中可以在主分片或者副本分片上进行。</p><p>客户端向集群发送查询请求，集群再随机选择一个节点作为协调点（Node 1），负责处理这次查询。</p><p>Node 1 使用文档的 routing id 来计算要查询的文档在哪个分片上（在本例中落在了 0 分片上）分片 0 的副本分片存在所有的三个节点上。</p><p>在这种情况下，协调节点可以把请求转发到任意节点，本例将请求转发到 Node 2 上。</p><p>Node 2 执行查找，并将查找结果返回给协调节点 Node 1，Node 1 再将文档返回给客户端。</p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch 持久化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper——原理（二）</title>
      <link href="/2020/11/02/zookeeper%E2%80%94%E2%80%94%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/11/02/zookeeper%E2%80%94%E2%80%94%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>总体来说 ZooKeeper 运行于一个集群环境中，选举出某个服务器作为群首（Leader），其他服务器追随群首（Follower）。群首作为中心处理所有对 ZooKeeper 系统变更的请求，它就像一个定序器，建立了所有对 ZooKeeper 状态的更新的顺序，追随者接收群首所发出更新操作请求，并对这些请求进行处理，以此来保障状态更新操作不会发生碰撞。</p><h1 id="请求、事务、标识符"><a href="#请求、事务、标识符" class="headerlink" title="请求、事务、标识符"></a>请求、事务、标识符</h1><p>ZooKeeper 服务器会在本地处理只读请求（exists、getData、getChildren），例如一个服务器接收客户端的 getData 请求，服务器读取该状态信息，并把这些信息返回给客户端。</p><p>那些会改变 ZooKeeper 状态的客户端请求（create，delete 和 setData）将会转发到群首，群首执行对应的请求，并形成状态的更新，称为事务（transaction）。</p><p>在群首产生了一个事务，就会为该事务分配一个标识符，称为会话 id（zxid），通过 Zxid 对事务进行标识，就可以按照群首所指定的顺序在各个服务器中按序执行。服务器之间在进行新的群首选举时也会交换 zxid 信息，这样就可以知道哪个无故障服务器接收了更多的事务，并可以同步他们之间的状态信息。</p><p>会话 id（Zxid） 为一个 long 型（64 位）整数，分为两部分：时间戳（epoch）部分和计数器（counter）部分。每一部分为 32 位。</p><h1 id="群首选举"><a href="#群首选举" class="headerlink" title="群首选举"></a>群首选举</h1><ol><li><p>群首作用</p><p> 群首为集群中的服务器选择出来的一个服务器，群首将每一个改变状态请求转换为一个事务，将这些事务发送给追随者，确保集群按照群首确定的顺序接受并处理这些事务。</p></li><li><p>新服务器加入</p><p> 一个服务器进入 LOOKING 状态，就会发送向集群中每个服务器发送一个通知信息，该消息中包括该服务器的投票（vote）信息，投票中包含服务器标识符（sid）和最近执行事务的 zxid 信息。</p><p> 有群首：</p><p> 每个服务器启动后进入 LOOKING 状态，开始选举一个新的群首或者查找已经存在的群首。如果群首已经存在，其他服务器就会通知这个新启动的服务器，告知哪个服务器是群首，于此同时，新服务器会与群首建立连接，以确保自己的状态与群首一致。</p><p> 无群首：</p><p> 如果群首中的所有的服务器均处于 LOOKING 状态，这些服务器之间就会进行通信来选举一个群首，通过信息交换对群首选举达成共识的选择。在本次选举过程中胜出的服务器将进入 LEADING 状态，而集群中其他服务器将会进入 FOLLOWING 状态。</p></li><li><p>投票规则</p><p> 当一个服务器收到一个投票信息，该服务器将会根据以下规则修改自己的投票信息：</p><ul><li><p>将接收的 voteId 和 voteZxid 作为一个标识符，并获取接收方当前的投票中的 zxid，用 myZxid 和 mySid 表示接收方服务器自己的值。</p></li><li><p>如果（voteZxid &gt; myZxid）或者（voteZxid == myZxid 且 voteId &gt;mySid）,保留当前的投票信息。</p></li><li><p>否则，修改自己的投票信息，将 voteZxid 赋值给 myZxid，将 voteId 赋值给 mySid。</p><p>从上面的投票过程可以看出，只有最新的服务器将赢得选举，因为其拥有最近一次的 zxid。如果多个服务器拥有的最新的 zxid 值，其中的 sid 值最大的将会赢得选举。</p></li></ul></li><li><p>同步</p><p> 当一个服务器连接到仲裁数量的服务器发来的投票都一样时，就表示群首选举成功，如果被选举的群首为某个服务器自己，该服务器将会开始行使群首角色，否则就会成为一个追随者并尝试连接被选举的群首服务器。</p><p> 一旦连接成功，追随者和群首之间将会进行状态同步，在同步完成后，追随者才可以进行新的请求。</p></li></ol><h1 id="zab"><a href="#zab" class="headerlink" title="zab"></a>zab</h1><p>在接收到一个写请求操作后，追随者会将请求转发给群首，群首将会探索性的执行该请求，并将执行结果以事务的方式对状态更新进行广播。</p><p>如何确认一个事务是否已经提交，ZooKeeper 由此引入了 zab 协议，即原子广播协议（ZooKeeper Atomic Broadeast protocol）。该协议提交一个事务非常简单，类型于一个两阶段提交。</p><ol><li>群首向所有追随者发送一个 PROPOSAL 消息 p。</li><li>当一个追随者接收到消息 p 后，会响应群首一个 ACK 消息，通知群首其已接受该提案（proposal）。</li><li>当收到仲裁数量的服务器发送的确认消息后（该仲裁数包括群首自己），群首就会发送消息通知追随者进行提交（COMMIT）操作。</li></ol><h1 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h1><p>除了群首和参与选举的（包含群首）的服务器，还有一种角色：观察者。</p><p>不同于追随者的是，观察者不参与选举过程，他们仅仅学习经由 INFORM 消息提交的提议。</p><p>引入观察者的一个主要原因是提高读请求的可扩展性。通过加入多个观察者，我们可以在不牺牲写操作的吞吐率的前提下服务更多的读操作。</p><p>但是引入观察者也不是完全没有开销，每一个新加入的观察者将对应于每一个已提交事务点引入的一条额外消息。</p><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><ol><li><p>日志</p><p> 服务器通过事务日志来持久化事务。在接受一个提议时，一个服务器就会将提议的事务持久化到事务日志中，该事务日志保存在服务器本地磁盘中，而事务将会按照顺序追加其后。写事务日志是写请求操作的关键路径，因此 ZooKeeper 必须有效处理写日志问题。</p><p> 在持久化事务到磁盘时，还有一个重要说明：现代操作系统通常会缓存脏页（Dirty Page），并将他们异步写入磁盘介质。然而，我们需要在继续之前，要确保事务已经被持久化。因此我们需要冲刷（Flush）事务到磁盘介质。</p><p> 冲刷在这里就是指我们告诉操作系已经把脏页写入到磁盘，并在操作完成后返回。同时为了提高 ZooKeeper 系统的运行速度，也会使用组提交和补白的。其中组提交是指一次磁盘写入时追加多个事务，可以减少磁盘寻址的开销。补白是指在文件中预分配磁盘存储块。</p></li><li><p>副本</p><p> 快照是 ZooKeeper 数据树的拷贝副本，每一个服务器会经常以序列化整个数据树的方式来提取快照，并将这个提取的快照保存到文件。服务器在进行快照时不需要进行协作，也不需要暂停处理请求。因此服务器在进行快照时还会继续处理请求，所以当快照完成时，数据树可能又发生了变化，称为快照是模糊的，因为它们不能反映出在任意给定的时间点数据树的准确的状态。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> zookeeper 原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper——应用（三）</title>
      <link href="/2020/11/02/zookeeper%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2020/11/02/zookeeper%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>我们将锁抽象成目录，多个线程在此目录下创建瞬时的序列节点，因为Zk会为我们保证节点的序列性，所以可以利用节点的序列进行锁的判断。</p><ol><li>首先创建序列节点进行升序排序，然后获取当前目录下最小的节点，判断最小节点是不是当前节点，如果是那么获取锁成功，如果不是那么获取锁失败。</li><li>获取锁失败的节点获取当前节点上一个顺序节点，对此节点注册监听，当节点删除的时候通知当前节点。</li><li>当unlock的时候删除节点之后会通知下一个节点。</li></ol><h1 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h1><p>解决思路：</p><ol><li>把公共配置抽取出来</li><li>对公共配置进行维护</li><li>修改公共配置后应用不需要重新部署案</li></ol><p>采用方案：</p><ol><li>公共配置抽取存放于zookeeper中并落地数据库或配置文件中</li><li>对公共配置修改后发布到zookeeper中并落地数据库或配置文件中</li><li>对应用开启配置实时监听，zookeeper配置文件一旦被修改，应用可通过watch实时监听到并获取</li></ol><h1 id="注册与发现"><a href="#注册与发现" class="headerlink" title="注册与发现"></a>注册与发现</h1><p>Eureka VS ZK</p><p><img src="/images/zookeeper%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89_2020-11-02-10-49-42.png" alt="zookeeper——应用（三）_2020-11-02-10-49-42.png"></p><p>Eureka的哲学是，同时保留”好数据“与”坏数据“总比丢掉任何”好数据“要更好</p><p>从注册发现的角度上来看 Eureka 优于 ZK。</p>]]></content>
      
      
      <categories>
          
          <category> zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper 应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中间件—zookeeper——基础（一）</title>
      <link href="/2020/11/02/zookeeper%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/11/02/zookeeper%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>zookeeper就是一个分布式应用协调服务，提供一组简单的 API，使得开发人员可以实现通用的协作任务，例如选举主节点，管理组内成员的关系，管理元数据等，同时 ZooKeeper 的服务组件运行在一组专用的服务器之上，也保证了高容错性和可扩展性。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><ol><li>分布式锁</li><li>ZK配置中心</li><li>服务注册和发现</li></ol><p>详情见<a href="/2020/11/02/zookeeper%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89/" title="zookeeper——应用（三）">zookeeper——应用（三）</a></p><h1 id="不适用场景"><a href="#不适用场景" class="headerlink" title="不适用场景"></a>不适用场景</h1><p>ZooKeeper 不适合用作海量的数据存储，对于需要海量的应用数据的情况，可以使用数据库和分布式文件系统。</p><p>所以在设计应用时，最佳实践是把应用数据和协同数据独立分开。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>ZooKeeper 采用类似于文件系统的层级树状结构进行管理 Znode，并且暴露操作 API 接口。</p><p><img src="/images/zookeeper%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89_2020-11-02-09-42-06.png" alt="zookeeper——基础（一）_2020-11-02-09-42-06.png"></p><p>znode 的类型分为持久节点、临时节点、有序节点，组合 4 中类型，持久的，临时的，持久有序的，临时有序的。</p><p>持久节点只能调用delete删除<br>临时节点在当创建该节点的客户端崩溃或者关闭了与 ZooKeeper 的连接时，这个节点就会被删除。<br>有序节点是被分配唯一一个单调递增的整数。</p><h1 id="API接口"><a href="#API接口" class="headerlink" title="API接口"></a>API接口</h1><p>zookeeper提供了一系列简单api处理自身的文件系统，对于实现什么场景、处理什么工作由开发人员决定。</p><ul><li>create /path data 创建一个名为/path 的 znode 节点，并包含数据 data。</li><li>delete /path 删除名为/path 的 znode。</li><li>exists /path 检查是否存在名为/path 的节点。</li><li>setData /path data</li><li>getData /path</li><li>getChildren /path</li></ul><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>ZooKeeper 服务器端运行于两种模式下：独立模式和仲裁模式。</p><p>独立服务器只有一个单独的服务器，ZooKeeper 状态无法复制。</p><p>而在仲裁模式下，具有一组 ZooKeeper 服务器，称为 ZooKeeper 集合，它们之间可以进行状态的复制，并同时服务客户端的请求。不过服务器集合并不会让客户端等待每个服务器完成数据保存后再继续，而是在满足仲裁数目的服务器保存或者同步了状态就会返回给客户端。</p><p>在解决这一分布式数据一致性，ZooKeeper 采用 ZAB(ZooKeeper Atomic Broadcast)的一致性协议，关于 ZAB 协议后面会详细的介绍。</p><p>ZooKeeper 客户端在服务器集群中执行任何请求前必须先与服务器建立会话（session），客户端提交给 ZooKeeper 的所有操作均关联在一个会话上。</p><p>客户端初始化连接到集合中某个服务器或一个独立的服务器，客户端提供TCP 协议与服务器进行连接并通信，但当会话无法与当前连接的服务器继续通信时，会话就可能转移到另外一个服务器，ZooKeeper 客户端透明地转移一个会话到不同的服务器。</p><p>需要指明的，会话提供了顺序保障，同一个会话中的请求会以 FIFO（先进先出）顺序执行。</p><h1 id="监视和通知"><a href="#监视和通知" class="headerlink" title="监视和通知"></a>监视和通知</h1><p>ZooKeeper 客户端获得服务器的数据或者变化，不是通过轮询的模式，而是基于通知的机制，客户端向 ZooKeeper 服务器端注册需要接收通知的 znode，通过对 znode 设置监视点来接收通知。</p><p>需要强调的是监视点是一个单次触发的操作。</p><p>监视点是由读取操作所设置的一次性触发器，每个监视点有一个特定操作来触发，即通过监视点，客户端可以对指定的 znode 节点注册一个通知请求，在发生时就会收到一个单次的通知。监视点只会存在内存，而不会持久化到硬盘，当客户端与服务端的连接断开时，它的所有的监视点会从内存中清除。因为客户端也会维护一份监视点的数据，在重连之后，监视点数据会再次同步到服务端。</p><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>在客户端库中有 2 个主要的类：ZooKeeper 和 ClientCnxn。</p><p>写客户端应用程序时通过实例化 ZooKeeper 类来建立一个会话。一旦建立起一个会话，ZooKeeper 就会使用一个会话标识符来关联这个会话。这个会话标识符实际上是有服务端所生产的。</p><p>ClientCnxn 类管理连接到 server 的 socket 连接。该类维护一个可连接的 ZooKeeper 的服务列表，并当连接断掉的时候无缝地切换到其他服务器，当重连到一个其他的服务器时会使用同一个会话，客户端也会重置所有的监视点到刚连接的服务器上。</p><h1 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h1><p>会话（session）是 ZooKeeper 的一个重要的抽象。保证请求有序，临时 znode 节点，监控点都与会话密切相关。因此会话的跟踪机制对 ZooKeeper 来说也是非常重要的。</p><p>在独立模式下，单个服务器会跟踪所有的会话，而在仲裁模式下则由群首服务器来跟踪和维护。而追随者服务器仅仅是简单地把客户端连接的会话信息转发到群首服务器。</p><p>为了保证会话的存活，服务器需要接收会话的心跳信息。心跳的形式可以是一个新的请求或者显式的 ping 信息。两种情况下，服务器通过更新会话的过期时间来触发会话活跃，在仲裁模式下，群首服务器发送一个 PING 信息给它的追随者们，追随者们返回自从最新一次 PING 消息之后的一个 session 列表。群首服务器每半个 tick 就会发送一个 ping 信息给追随者们。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要对zookeeper的基本架构有个了解，具体内部实现原理详见<a href="/2020/11/02/zookeeper%E2%80%94%E2%80%94%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/" title="zookeeper——原理（二）">zookeeper——原理（二）</a></p>]]></content>
      
      
      <categories>
          
          <category> zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志——Slf4j</title>
      <link href="/2020/10/23/%E6%97%A5%E5%BF%97%E2%80%94%E2%80%94Slf4j/"/>
      <url>/2020/10/23/%E6%97%A5%E5%BF%97%E2%80%94%E2%80%94Slf4j/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>SLF4J 不是一个真正的日志实现，而是一个抽象层，它允许你在后台使用任意一个日志类库。</p><p>如果一个项目已经使用了log4j，而你加载了一个类库，比方说 Apache Active MQ——它依赖于于另外一个日志类库logback，那么你就需要把它也加载进去。但如果Apache Active MQ使用了SLF4J，你可以继续使用你的日志类库而无需忍受加载和维护一个新的日志框架的痛苦。</p><p>除此之外，还有一个SLF4J API的特性是使得我坚持使用SLF4J而抛弃我长期间钟爱的Log4j的理由，是被称为 <code>占位符(place holder)</code>，在代码中表示为“{}”的特性。</p><h1 id="与-log4j"><a href="#与-log4j" class="headerlink" title="与 log4j"></a>与 log4j</h1><p>需要导入的jar包：</p><p><img src="/images/%E6%97%A5%E5%BF%97%E2%80%94%E2%80%94Log4j_2020-05-18-13-39-06.png" alt="日志——Log4j_2020-05-18-13-39-06.png"></p><h1 id="与-logback"><a href="#与-logback" class="headerlink" title="与 logback"></a>与 logback</h1><p>需要导入的jar包，logback-classic.jar、logback-core.jar、slf4j-api.jar</p><h1 id="main方法："><a href="#main方法：" class="headerlink" title="main方法："></a>main方法：</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xm.exam.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Slf4jTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(Slf4jTest<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">// slf4j日志记录器</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 普通的日志记录</span></span><br><span class="line">        logger.debug(<span class="string">"普通的日志记录"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &#123;&#125;占位符记录日志</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            logger.debug(<span class="string">"这是第&#123;&#125;条记录"</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用\转义&#123;&#125;</span></span><br><span class="line">        logger.debug(<span class="string">"Set \\&#123;&#125; differs from &#123;&#125;"</span>, <span class="string">"3"</span>); <span class="comment">// output:Set &#123;&#125; differs</span></span><br><span class="line">                                                        <span class="comment">// from 3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个参数</span></span><br><span class="line">        logger.debug(<span class="string">"两个占位符，可以传两个参数&#123;&#125;----&#123;&#125;"</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 多个参数(可变参数)</span></span><br><span class="line">        logger.debug(<span class="string">"debug:多个占位符，&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;"</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 多个参数(可变参数)</span></span><br><span class="line">        logger.info(<span class="string">"info:多个占位符，&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;"</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 多个参数(可变参数)</span></span><br><span class="line">        logger.error(<span class="string">"error:多个占位符，&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;"</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 Slf4j </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志——Logback</title>
      <link href="/2020/10/22/%E6%97%A5%E5%BF%97%E2%80%94%E2%80%94Logback/"/>
      <url>/2020/10/22/%E6%97%A5%E5%BF%97%E2%80%94%E2%80%94Logback/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>logbcak相当于log4j的改进版，相对于log4j有一些优点：</p><ol><li><p>更快的实现  Logback的内核重写了，在一些关键执行路径上性能提升10倍以上。而且logback不仅性能提升了，初始化内存加载也更小了。</p></li><li><p>非常充分的测试  Logback经过了几年，数不清小时的测试。Logback的测试完全不同级别的。在作者的观点，这是简单重要的原因选择logback而不是log4j。</p></li><li><p>Logback-classic非常自然实现了SLF4j    Logback-classic实现了 SLF4j。在使用SLF4j中，你都感觉不到logback-classic。而且因为logback-classic非常自然地实现了SLF4J，  所 以切换到log4j或者其他，非常容易，只需要提供成另一个jar包就OK，根本不需要去动那些通过SLF4JAPI实现的代码。</p></li><li><p>非常充分的文档  官方网站有两百多页的文档。</p></li><li><p>自动重新加载配置文件  当配置文件修改了，Logback-classic能自动重新加载配置文件。扫描过程快且安全，它并不需要另外创建一个扫描线程。这个技术充分保证了应用程序能跑得很欢在JEE环境里面。</p></li><li><p>Lilith   Lilith是log事件的观察者，和log4j的chainsaw类似。而lilith还能处理大数量的log数据 。</p></li><li><p>谨慎的模式和非常友好的恢复  在谨慎模式下，多个FileAppender实例跑在多个JVM下，能 够安全地写道同一个日志文件。RollingFileAppender会有些限制。Logback的FileAppender和它的子类包括 RollingFileAppender能够非常友好地从I/O异常中恢复。</p></li><li><p>配置文件可以处理不同的情况   开发人员经常需要判断不同的Logback配置文件在不同的环境下（开发，测试，生产）。而这些配置文件仅仅只有一些很小的不同，可以通过,和来实现，这样一个配置文件就可以适应多个环境。</p></li><li><p>Filters（过滤器）  有些时候，需要诊断一个问题，需要打出日志。在log4j，只有降低日志级别，不过这样会打出大量的日志，会影响应用性能。在Logback，你可以继续 保持那个日志级别而除掉某种特殊情况，如alice这个用户登录，她的日志将打在DEBUG级别而其他用户可以继续打在WARN级别。要实现这个功能只需 加4行XML配置。可以参考MDCFIlter 。</p></li><li><p>SiftingAppender（一个非常多功能的Appender）  它可以用来分割日志文件根据任何一个给定的运行参数。如，SiftingAppender能够区别日志事件跟进用户的Session，然后每个用户会有一个日志文件。</p></li><li><p>自动压缩已经打出来的log  RollingFileAppender在产生新文件的时候，会自动压缩已经打出来的日志文件。压缩是个异步过程，所以甚至对于大的日志文件，在压缩过程中应用不会受任何影响。</p></li><li><p>堆栈树带有包版本  Logback在打出堆栈树日志时，会带上包的数据。</p></li><li><p>自动去除旧的日志文件  通过设置TimeBasedRollingPolicy或者SizeAndTimeBasedFNATP的maxHistory属性，你可以控制已经产生日志文件的最大数量。如果设置maxHistory 12，那那些log文件超过12个月的都会被自动移除。</p></li></ol><p>总之，logback比log4j太优秀了，让我们的应用全部建立logback上吧 ！</p><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>Logback 的基本结构充分通用，可应用于各种不同环境。目前，logback 分为三个模块：Core、Classic 和 Access。</p><ol><li><p>Core模块是其他两个模块的基础。</p></li><li><p>Classic 模块扩展了core模块。Classic 模块相当于 log4j的显著改进版。Logback-classic 直接实现了 SLF4J API，因此你可以在 logback 与其他记录系统如 log4j 和 java.util.logging (JUL)之间轻松互相切换。</p></li><li><p>Access 模块与 Servlet 容器集成，提供 HTTP 访问记录功能。本文不讲述 access 模块。</p></li></ol><h1 id="主要类"><a href="#主要类" class="headerlink" title="主要类"></a>主要类</h1><ol><li><p>Logger</p><p> 位于 logback-classic模块中，作为日志的记录器，把它关联到应用的对应的context后，主要用于存放日志对象，也可以定义日志类型、级别。详解可以见log4j logger</p></li><li><p>Appender</p><p> 位于logback-core中，主要用于指定日志输出的目的地，目的地可以是控制台、文件、远程套接字服务器、MySQL、PostreSQL、Oracle和其他数据库、JMS和远程UNIX Syslog守护进程等。</p></li><li><p>Layout</p><p> 位于logback-core中，负责把事件转换成字符串，格式化日志信息的输出，详细可以见log4j的layout详解</p></li><li><p>filter</p><p> Filter主要应用在appeder上，只在appender级别起作用，起到过滤日志相关作用。</p></li></ol><h1 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h1><p>logback有5种级别，分别是TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR，定义于ch.qos.logback.classic.Level类中。</p><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>logback一般通过logback.xml进行配置</p><p>配置读取步骤：</p><ol><li><p>尝试在classpath下查找文件logback-test.xml</p></li><li><p>如果文件不存在，则查找文件logback.xml</p></li><li><p>如果两个文件都不存在，则用BasicConfigurator自动对自己进行配置，把记录输出到控制台</p></li></ol><h2 id="configuration"><a href="#configuration" class="headerlink" title="configuration"></a>configuration</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">"true"</span> <span class="attr">scanPeriod</span>=<span class="string">"60 seconds"</span> <span class="attr">debug</span>=<span class="string">"false"</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。</p></li><li><p>scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。</p></li><li><p>debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。</p></li></ol><h1 id="contextName"><a href="#contextName" class="headerlink" title="contextName"></a>contextName</h1><p>每个logger都关联到logger上下文，默认上下文名称为“default”。但可以使用contextName标签设置成其他名字，用于区分不同应用程序的记录</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"glmapper-name"</span> <span class="attr">value</span>=<span class="string">"glmapper-demo"</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">contextName</span>&gt;</span>$&#123;glmapper-name&#125;<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="property"><a href="#property" class="headerlink" title="property"></a>property</h1><p>用来定义变量值的标签，property标签有两个属性，name和value；其中name的值是变量的名称，value的值时变量定义的值。通过property定义的值会被插入到logger上下文中。定义变量后，可以使“${name}”来使用变量。如上面的xml所示。</p><h1 id="logger"><a href="#logger" class="headerlink" title="logger"></a>logger</h1><p>用来设置某一个包或者具体的某一个类的日志打印级别以及指定appender。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.xpwi"</span>  <span class="attr">level</span>=<span class="string">"debug"</span> <span class="attr">additivity</span>=<span class="string">"false"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"FILE"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>继承，如果level没有设置级别，则继承最近的父 logger（该logger需显示定义level,直到rootLogger）的日志级别。</p></li><li><p>append累加：默认日志输出到当前logger的appender和所有祖先logger的appender中，可通过配置 “additivity”属性修改默认行为。默认为true。</p></li></ol><h1 id="root"><a href="#root" class="headerlink" title="root"></a>root</h1><p>根logger，也是一种logger，且只有一个level属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 至多只能配置一个root --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"debug"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"FILE"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="appender"><a href="#appender" class="headerlink" title="appender"></a>appender</h1><p>负责写日志的组件,下面是其中一种类型配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"FILE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 当前活动日志文件名：用日期命名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;LOG_FILE_LOCATION&#125;/MyLog%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 文件滚动策略根据%d&#123;patter&#125;中的“patter”而定，此处为每天产生一个文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 归档文件名“.zip或.gz结尾”,表示归档文件自动压缩 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">FileNamePattern</span>&gt;</span>$&#123;LOG_FILE_LOCATION&#125;/MyLog%d&#123;yyyy-MM-dd&#125;.log.zip<span class="tag">&lt;/<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文件保留天数--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志文件最大的大小--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>10MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125;[%-5level][%thread]%logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置日志级别 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果跟该日志水平相匹配，则接受 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果跟该日志水平不匹配，则过滤掉 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="自定义Appender"><a href="#自定义Appender" class="headerlink" title="自定义Appender"></a>自定义Appender</h1><p>继承 AppenderBase 就可以轻松地写自己的 appender。AppenderBase 处理过滤器、状态<br>信息和大多数 appender 共享的其他功能。派生类只需要实现一个方法：append(Object<br>eventObject)。</p><h1 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h1><p>配置日志的输出格式</p><h1 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h1><p>Logback提供两类Filter，一类是Regular Filter;另外一类是Turbo Filter。</p><p>Regular Filter主要应用在appeder上，只在appender级别起作用，Appender实例上可以绑定一个Regular Filter实例链。Regular Filter继承实现”ch.qos.logback.core.filter.Filter”类，自定义自己的regular filter需要继承ch.qos.logback.core.filter.Filter类，并实现decide()方法。</p><ol><li><p>LevelFilter：级别过滤器，根据日志级别进行过滤。</p></li><li><p>EvaluatorFilter： 求值过滤器，评估、鉴别日志是否符合指定条件。</p></li><li><p>ThresholdFilter ：临界值过滤器，过滤掉低于指定临界值的日志。当日志级别等于或高于临界值时，过滤器返回NEUTRAL；当日志级别低于临界值时，日志会被拒绝。</p></li></ol><h1 id="自定义filter"><a href="#自定义filter" class="headerlink" title="自定义filter"></a>自定义filter</h1><p>创建自己的过滤器很容易。只需要继承 Filter 抽象类并实现 decide()方法。将filter引入append即可。</p>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 Logback </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容器——ConcurrentHashMap—1.8</title>
      <link href="/2020/10/20/%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ConcurrentHashMap%E2%80%941.8/"/>
      <url>/2020/10/20/%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ConcurrentHashMap%E2%80%941.8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>1.8 相比 1.7的话，主要有以下改变。</p><ul><li>数组+链表的形式改为数组+链表+红黑树的形式，提高了遍历效率</li><li>去除 <code>Segment + HashEntry + Unsafe</code> 的实现，改为 <code>Synchronized + CAS + Node + Unsafe</code> 的实现，其实 Node 和 HashEntry 的内容一样，但是HashEntry是一个内部类。用 Synchronized + CAS 代替 Segment ，这样锁的粒度更小了，并且不是每次都要加锁了，CAS尝试失败了在加锁。</li><li>put()方法中 初始化数组大小时，1.8不用加锁，因为用了个 sizeCtl 变量，将这个变量置为-1，就表明table正在初始化。</li></ul><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>ConcurrentHashMap做到了线程安全，其并发性通过CAS+synchronized锁来实现</p><p>ConcurrentHashMap底层和Hashmap一样通过数组+链表+红黑树的方式实现。</p><p><img src="/images/%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ConcurrentHashMap%E2%80%941.8_2020-10-20-10-38-10.png" alt="容器——ConcurrentHashMap—1.8_2020-10-20-10-38-10.png"></p><h1 id="需知"><a href="#需知" class="headerlink" title="需知"></a>需知</h1><ol><li><p>初始默认容量为 16</p></li><li><p>最大容量 1&lt;&lt;30</p></li><li><p>负载因子 0.75f</p></li><li><p>链表转为红黑树阈值 8</p></li><li><p>红黑树转为链表阈值 6</p></li><li><p>sizeCtl：</p><ul><li>默认为0，用来控制table的初始化和扩容操作</li><li>-1 代表table正在初始化</li><li>-N 取-N对应的二进制的低16位数值为M，此时有M-1个线程进行扩容</li><li>如果table未初始化，表示table需要初始化的大小。</li><li>如果table初始化完成，表示table的容量，默认是table大小的0.75倍</li></ul></li><li><p>扩容节点的 hash 值</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// 表示该节点正在处理中</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// 表示该节点是树的根节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// 暂时保留</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// 正常节点的hash值可用的位数</span></span><br></pre></td></tr></table></figure></li></ol><p>Node是ConcurrentHashMap中存放key、value以及key的hash值的数据结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">//具体内部方法参照源码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当链表转化成红黑树时，用TreeNode存储对象:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    TreeNode parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    <span class="comment">//具体方法见源码内部</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在数组中，转变为红黑树后存放的不是TreeNode对象，而是TreeBin对象，TreeBin就是封装TreeNode的容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    TreeNode root;</span><br><span class="line">    <span class="keyword">volatile</span> TreeNode first;</span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line">    <span class="comment">// values for lockState</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br><span class="line">    <span class="comment">//具体方法见源码内部</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ForwardingNode：在扩容时才会出现的特殊节点，其 key,value,hash 全部为 null。并拥有 nextTable 指针引用新的 table 数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line">   .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;<span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;&#125;</span><br></pre></td></tr></table></figure><h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash  <span class="comment">// n为bucket的个数</span></span><br></pre></td></tr></table></figure><h1 id="tabAt"><a href="#tabAt" class="headerlink" title="tabAt"></a>tabAt</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用 <code>Unsafe.getObjectVolatie()</code> 来获取，而不是直接用table[index]的原因跟ConcurrentHashMap的弱一致性有关。在java内存模型中，我们已经知道每个线程都有一个工作内存，里面存储着table的副本，虽然table是volatile修饰的，但不能保证线程每次都拿到table中的最新元素，<code>Unsafe.getObjectVolatile</code> 可以直接获取指定内存的数据，保证了每次拿到数据都是最新的。</p><h1 id="casTabAt"><a href="#casTabAt" class="headerlink" title="casTabAt"></a>casTabAt</h1><p>cas在指定的位置设置元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="setTabAt"><a href="#setTabAt" class="headerlink" title="setTabAt"></a>setTabAt</h1><p>该方法用来设置 table 数组中索引为 i 的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了保证线程安全，一般在锁方法内部执行。</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>ConcurrentHashMap的构造方法都没有实际对table进行初始化，对table的初始化会放在put时。防止不必要的扩容，影响效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node[] initTable() &#123;</span><br><span class="line">    Node[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123; <span class="comment">//如果表为空则执行初始化操作</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)  <span class="comment">//如果sizeCtl小于0，说明此时有其他线程在初始化或扩展表</span></span><br><span class="line">            Thread.yield(); <span class="comment">// 使当前线程由执行状态，变成为就绪状态，让出cpu时间</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123; <span class="comment">//通过cas操作去竞争初始化表的操作，设定为-1表示要初始化了</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;<span class="comment">//如果指定了大小就创建指定大小的数组，否则创建默认的大小</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    Node[] nt = (Node[])<span class="keyword">new</span> Node[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;  <span class="comment">//sizeCtl长度为数组长度的3/4</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h1><p>在扩容过程中，依然支持并发更新操作；也支持并发插入。 </p><ol><li>遍历整个table，当前节点为空，则采用CAS的方式在当前位置放入fwd（特殊的扩容节点，表示已扩容）</li><li>当前节点已经为fwd(with hash field “MOVED”)，则已经有有线程处理完了了，直接跳过 ，这里是控制并发扩容的核心 </li><li>当前节点为链表节点或红黑树，重新计算链表节点的hash值，移动到nextTable相应的位置（构建了一个反序链表和顺序链表，分别放置在i和i+n的位置上）。移动完成后，用Unsafe.putObjectVolatile在tab的原位置赋为为fwd, 表示当前节点已经完成扩容。</li></ol><h1 id="addCount"><a href="#addCount" class="headerlink" title="addCount"></a>addCount</h1><ol><li>当插入结束的时候，会对 size 进行加一。也会进行是否须要扩容的判断。</li><li>优先使用计数盒子（若是不是空，说明并发了），若是计数盒子是空，使用 baseCount 变量。对其加 X。</li><li>若是修改 baseCount 失败，使用计数盒子。若是这次修改失败，在另外一个方法死循环插入。</li><li>检查是否须要扩容。</li><li>若是 size 大于等于 sizeCtl 阈值，且长度小于 1 &lt;&lt; 30，能够扩容成 1 &lt;&lt; 30，但不能扩容成 1 &lt;&lt; 31。</li><li>若是已经在扩容，帮助其扩容</li><li>若是没有在扩容，自行开启扩容，更新 sizeCtl 变量为负数，赋值为标识符高 16 位 + 2。</li></ol><h1 id="put"><a href="#put" class="headerlink" title="put"></a>put</h1><ol><li>根据key定位到table的具体位置。</li><li>如果当前的数组为空，说明这是第一插入数据，则会对table进行初始化；</li><li>插入数据，这里分为3中情况：<ul><li>插入位置为空，直接将数据放入table的第一个位置中(CAS)；</li><li>插入位置不为空，并且是一个ForwardingNode（f.hash=MOVED）节点，说明该位置上的链表或红黑树正在进行扩容，然后让当前线程加进去并发扩容，提高效率；</li><li>插入位置不为空，也不是ForwardingNode节点，若为链表则从第一节点开始组个往下遍历，如果有key的hashCode相等并且值也相等，那么就将该节点的数据替换掉，否则将数据加入到链表末段；若为红黑树，则按红黑树的规则放进相应的位置；(对于链表和红黑树的操作需加SYNC锁)</li></ul></li><li>数据插入成功后，判断当前位置上的节点的数量，如果节点数据大于转换红黑树阈值（默认为8），则将链表转换成红黑树，提高get操作的速度；</li><li>数据量+1，addCount统计数据总量，并判断当前table是否需要扩容；</li></ol><h1 id="get"><a href="#get" class="headerlink" title="get"></a>get</h1><ol><li><p>计算hash值，定位到该table索引位置，如果是首节点符合就返回</p></li><li><p>如果遇到扩容的时候，会调用标志正在扩容节点ForwardingNode的find方法，查找该节点，匹配就返回</p></li><li><p>以上都不符合的话，就往下遍历节点，匹配就返回，否则最后就返回null</p></li></ol><h1 id="size"><a href="#size" class="headerlink" title="size"></a>size</h1><p>在JDK1.8版本中，对于size的计算，在扩容和addCount()方法就已经有处理了，可以注意一下Put函数，里面就有addCount()函数，早就计算好的，然后你size的时候直接给你。</p><h1 id="synchronized-锁升级"><a href="#synchronized-锁升级" class="headerlink" title="synchronized 锁升级"></a>synchronized 锁升级</h1><p>针对 synchronized 获取锁的方式，JVM 使用了锁升级的优化方式，就是先使用偏向锁优先同一线程然后再次获取锁，如果失败，就升级为 CAS 轻量级锁，如果失败就会短暂自旋，防止线程被系统挂起。最后如果以上都失败就升级为重量级锁。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>主要设计上的变化有以下几点:</p><ol><li>不采用 segment 而采用 node，锁住 node 来实现减小锁粒度。</li><li>设计了 MOVED 状态 当 resize 的中过程中 线程 2 还在 put 数据，线程 2 会帮助 resize（扩容并发）。</li><li>使用 3 个 CAS 操作来确保 node 的一些操作的原子性，这种方式代替了锁。</li><li>sizeCtl 的不同值来代表不同含义，起到了控制的作用。</li><li>采用 synchronized 而不是 ReentrantLock</li></ol>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 ConcurrentHashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM——垃圾回收器</title>
      <link href="/2020/10/13/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
      <url>/2020/10/13/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。</p><h1 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h1><p>串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。新生代、老年代使用串行回收；</p><p>新生代复制算法、老年代标记-整理；垃圾收集的过程中会 Stop The World（服务暂停）。</p><p>参数控制：</p><p><code>-XX:+UseSerialGC</code></p><p><img src="/images/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_2020-04-07-10-47-01.png" alt="JVM——垃圾回收_2020-04-07-10-47-01.png"></p><h1 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h1><p>ParNew收集器其实就是Serial收集器的多线程版本。</p><p>新生代并行，老年代串行；新生代复制算法、老年代标记-整理。</p><p>参数控制：</p><ul><li><code>-XX:+UseParNewGC</code> ParNew收集器</li><li><code>-XX:ParallelGCThreads</code> 限制线程数量</li></ul><p><img src="/images/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_2020-04-07-10-50-21.png" alt="JVM——垃圾回收_2020-04-07-10-50-21.png"></p><h1 id="Parallel收集器"><a href="#Parallel收集器" class="headerlink" title="Parallel收集器"></a>Parallel收集器</h1><p>Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。</p><p>可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-整理</p><p>参数控制： </p><p><code>-XX:+UseParallelGC</code> 使用Parallel收集器+ 老年代串行</p><h1 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h1><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在JDK 1.6中才开始提供。</p><p>参数控制： </p><p><code>-XX:+UseParallelOldGC</code> 使用Parallel收集器+ 老年代并行</p><h1 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h1><p>是一种以获取最短回收停顿时间为目标的收集器。</p><p>CMS收集器是基于标记-清除算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些。</p><p>收集过程：</p><ol><li><p>初始标记（CMS initial mark）：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快。</p></li><li><p>并发标记（CMS concurrent mark）：就是进行GC Roots Tracing的过程。</p></li><li><p>重新标记（CMS remark）：为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，<strong>这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短</strong>。</p></li><li><p>并发清除（CMS concurrent sweep）：回收对象</p></li></ol><p>由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew）</p><p>优点: </p><p>并发收集、低停顿</p><p>缺点: </p><ul><li>产生大量空间碎片、并发阶段会降低吞吐量</li><li>CMS收集器无法处理浮动垃圾，可能会出现“Concurrent Mode Failure（并发模式故障）”失败而导致Full GC产生。</li></ul><p>参数控制：</p><ul><li><code>-XX:+UseConcMarkSweepGC</code> 使用CMS收集器</li><li><code>-XX:+ UseCMSCompactAtFullCollection</code> Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长</li><li><code>-XX:+CMSFullGCsBeforeCompaction</code> 设置进行几次Full GC后，进行一次碎片整理</li><li><code>-XX:ParallelCMSThreads</code> 设定CMS的线程数量（一般情况约等于可用CPU数量）</li></ul><p><img src="/images/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_2020-04-07-11-04-55.png" alt="JVM——垃圾回收_2020-04-07-11-04-55.png"></p><h1 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h1><p>G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li><p>并行与并发 </p><p>G1 能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短“Stop The World”停顿时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</p></li><li><p>空间整合</p><p>G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。</p></li><li><p>可预测停顿</p><p>这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p></li><li><p>分代收集</p><p>与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同方式去处理新创建的对象和已存活一段时间、熬过多次GC的旧对象来获取更好的收集效果。</p></li></ol><h2 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h2><p>在G1之前的其他收集器进行收集的范围都是整个新生代或者老生代，而G1不再是这样。</p><p>使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。</p><p><img src="/images/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_2020-04-07-11-16-13.png" alt="JVM——垃圾回收_2020-04-07-11-16-13.png"></p><h2 id="可预测的时间模型"><a href="#可预测的时间模型" class="headerlink" title="可预测的时间模型"></a>可预测的时间模型</h2><p>G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）。</p><p>这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p><h2 id="避免全堆扫描"><a href="#避免全堆扫描" class="headerlink" title="避免全堆扫描"></a>避免全堆扫描</h2><p>G1把Java堆分为多个Region，就是“化整为零”。但是Region不可能是孤立的，一个对象分配在某个Region中，可以与整个Java堆任意的对象发生引用关系。在做可达性分析确定对象是否存活的时候，需要扫描整个Java堆才能保证准确性，这显然是对GC效率的极大伤害。</p><p>为了避免全堆扫描的发生，虚拟机为G1中每个Region维护了一个与之对应的Remembered Set。虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。</p><h2 id="收集过程"><a href="#收集过程" class="headerlink" title="收集过程"></a>收集过程</h2><p>G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。和CMS类似，G1收集器收集老年代对象会有短暂停顿。</p><ol><li><p>初始标记</p><p>仅仅只是标记一下GC Roots 能直接关联到的对象，并且修改TAMS（Nest Top Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可以的Region中创建对象，此阶段需要停顿线程，但耗时很短。</p></li><li><p>并发标记</p><p>从GC Root 开始对堆中对象进行可达性分析，找到存活对象，此阶段耗时较长，但可与用户程序并发执行。</p></li><li><p>最终标记</p><p>为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。</p></li><li><p>筛选回收</p><p>首先对各个Region中的回收价值和成本进行排序，根据用户所期望的GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/images/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_2020-04-07-13-41-42.png" alt="JVM——垃圾回收_2020-04-07-13-41-42.png"></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm 垃圾回收器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务——分布式事务（四）</title>
      <link href="/2020/09/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2020/09/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式事务产生的原因"><a href="#分布式事务产生的原因" class="headerlink" title="分布式事务产生的原因"></a>分布式事务产生的原因</h1>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 分布式事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务——分布式session（三）</title>
      <link href="/2020/09/14/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8Fsession%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2020/09/14/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8Fsession%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>服务器集群情况下通常要考虑分布式session一致性问题，以下提供了四种解决方案。</p><h1 id="Session复制"><a href="#Session复制" class="headerlink" title="Session复制"></a>Session复制</h1><p>如果此时 Tomcat1 Session 存在用户信息，而 Tomcat2 上没有存在。这时如果我们将 Tomcat1 的 Session 复制到 Tomcat2 上，后面 Nginx 将请求转发到 Tomcat2 上，由于 Tomcat2 存在 Session ，这时就不需要再重新登录了。</p><p>优点：</p><p>只需要修改 Tomcat 配置就好，我们应用代码都不用修改了。</p><p>缺点：</p><ul><li>第一，Session 复制传输需要占用内网带宽。</li><li>第二，我们的例子就只有两台机器，这个复制性能还可以。但是假设我们有 N 台机器，那么每次复制都要复制给 N-1 台机器，如果机器很多，可能会形成网络风暴，复制性能也会呈指数级下降。</li><li>第三， Tomcat 需要保存所有的 Session 数据，这个方案的 Session 存储在内存中，容易受到机器的总内存的限制。我们没办法通过加机器的方式水平扩展，我们能做的方式就是加大机器内存。但是机器内存越大，价格真的很贵！！！</li></ul><h1 id="Session-前端存储"><a href="#Session-前端存储" class="headerlink" title="Session 前端存储"></a>Session 前端存储</h1><p>不存 Tomcat Session 里，把信息存到浏览器的 Cookie 中。每个用户浏览器存储自己的 Cookie 信息，服务端不需要存储，这就解决了 Session 复制方案的缺陷。</p><p>用户每次请求发送Cookie，判断 Cookie 里用户信息。</p><p>优点：代价小，实现简单</p><p>缺点：</p><ul><li>不安全，需要额外加密</li><li>消耗外围带宽</li><li>储存大小受限制</li></ul><h1 id="Session-粘滞"><a href="#Session-粘滞" class="headerlink" title="Session 粘滞"></a>Session 粘滞</h1><p>修改 Nginx 默认的负载均衡策略，使用 IP Hash 的方式。</p><p>Nginx 会使用请求者的 IP 来做 Hash，然后分发到一台机器上，这样可以保证同一 IP 的请求都落在同一台 Tomcat 上。</p><p>优点：</p><ul><li>只要请求来源 IP 足够的随机，那么 IP HASH 之后两台应用上的流量将会足够随机。</li><li>方便水平扩展，只要修改 Nginx 配置即可。</li></ul><p>缺点：</p><ul><li>公司内网IP出口通常固定，容易变成单点</li><li>Tomcat重启，session丢失，相关用户重新登录</li></ul><h1 id="后端集中储存"><a href="#后端集中储存" class="headerlink" title="后端集中储存"></a>后端集中储存</h1><p>使用中间件session保存session信息，每次去请求redis。</p><p>优点：</p><p>Web 应用重启或扩容，Session 也无需丢失，当然前提是 Redis 不能宕机</p><p>缺点:</p><p>每次请求redis,增加网络开销。</p><p><a href="https://zhuanlan.zhihu.com/p/25010950" target="_blank" rel="noopener">Spring Session + Redis实现分布式Session共享</a></p><p><a href="https://zhuanlan.zhihu.com/p/148503037" target="_blank" rel="noopener">SpringBoot 一个依赖搞定 session 共享，没有比这更简单的方案了！</a></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 分布式session </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql——优化（六）</title>
      <link href="/2020/09/14/Mysql%E2%80%94%E2%80%94%E4%BC%98%E5%8C%96%EF%BC%88%E5%85%AD%EF%BC%89/"/>
      <url>/2020/09/14/Mysql%E2%80%94%E2%80%94%E4%BC%98%E5%8C%96%EF%BC%88%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>MySQL常见瓶颈</p><ul><li>CPU：CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候</li><li>IO：磁盘I/O瓶颈发生在装入数据远大于内存容量的时候<br>服务器硬件的性能瓶颈：top，free，iostat 和 vmstat来查看系统的性能状态</li></ul><h1 id="性能下降SQL慢-执行时间长-等待时间长-原因分析"><a href="#性能下降SQL慢-执行时间长-等待时间长-原因分析" class="headerlink" title="性能下降SQL慢 执行时间长 等待时间长 原因分析"></a>性能下降SQL慢 执行时间长 等待时间长 原因分析</h1><ul><li>查询语句写的烂</li><li>索引失效（单值、复合）</li><li>关联查询太多join（设计缺陷或不得已的需求）</li><li>服务器调优及各个参数设置（缓冲、线程数等）</li></ul><h1 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h1><p>常见的分析手段有慢查询日志，EXPLAIN 分析查询，profiling分析以及show命令查询系统状态及系统变量，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。</p><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><ol><li>全值匹配我最爱</li><li>最佳左前缀法则，比如建立了一个联合索引(a,b,c)，那么其实我们可利用的索引就有(a), (a,b), (a,b,c)</li><li>不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描</li><li>存储引擎不能使用索引中范围条件右边的列</li><li>尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少select is null ,is not null 也无法使用索引<br>like “xxxx%” 是可以用到索引的，like “%xxxx” 则不行(like “%xxx%” 同理)。like以通配符开头(‘%abc…’)索引失效会变成全表扫描的操作，</li><li>字符串不加单引号索引失效</li><li>少用or，用它来连接时会索引失效</li><li>&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN 可用到索引，&lt;&gt;，not in ，!= 则不行，会导致全表扫描</li></ol><h2 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h2><h3 id="小表驱动大表"><a href="#小表驱动大表" class="headerlink" title="小表驱动大表"></a>小表驱动大表</h3><pre><code>slect * from A where id in (select id from B)`等价于#等价于select id from Bselect * from A where A.id=B.id</code></pre><p>当 B 表的数据集必须小于 A 表的数据集时，用 in 优于 exists</p><pre><code>select * from A where exists (select 1 from B where B.id=A.id)#等价于select * from Aselect * from B where B.id = A.id`</code></pre><p>当 A 表的数据集小于B表的数据集时，用 exists优于用 in</p><h3 id="orderBy优化"><a href="#orderBy优化" class="headerlink" title="orderBy优化"></a>orderBy优化</h3><ul><li>order by子句，尽量使用 Index 方式排序，避免使用 FileSort 方式排序</li><li>MySQL 支持两种方式的排序，FileSort 和 Index，Index效率高，它指 MySQL 扫描索引本身完成排序，FileSort 效率较低；</li><li>ORDER BY 满足两种情况，会使用Index方式排序；①ORDER BY语句使用索引最左前列 ②使用where子句与ORDER BY子句条件列组合满足索引最左前列</li><li>尽可能在索引列上完成排序操作，遵照索引建的最佳最前缀</li><li>如果不在索引列上，filesort 有两种算法，mysql就要启动双路排序和单路排序<ul><li>双路排序：MySQL 4.1之前是使用双路排序,字面意思就是两次扫描磁盘，最终得到数据</li><li>单路排序：从磁盘读取查询需要的所有列，按照order by 列在 buffer对它们进行排序，然后扫描排序后的列表进行输出，效率高于双路排序</li></ul></li><li>优化策略<ul><li>增大sort_buffer_size参数的设置</li><li>增大max_lencth_for_sort_data参数的设置</li></ul></li></ul><h3 id="groupBy优化"><a href="#groupBy优化" class="headerlink" title="groupBy优化"></a>groupBy优化</h3><ul><li>group by实质是先排序后进行分组，遵照索引建的最佳左前缀</li><li>当无法使用索引列，增大 max_length_for_sort_data 参数的设置，增大sort_buffer_size参数的设置</li><li>where高于having，能写在where限定的条件就不要去having限定了</li></ul><h3 id="数据类型优化"><a href="#数据类型优化" class="headerlink" title="数据类型优化"></a>数据类型优化</h3><ul><li>更小的通常更好：一般情况下，应该尽量使用可以正确存储数据的最小数据类型。</li><li>简单就好：简单的数据类型通常需要更少的CPU周期。例如，整数比字符操作代价更低，因为字符集和校对规则（排序规则）使字符比较比整型比较复杂。</li><li>尽量避免NULL：通常情况下最好指定列为NOT NULL</li></ul><h2 id="分表分库"><a href="#分表分库" class="headerlink" title="分表分库"></a>分表分库</h2><h3 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h3><ol><li><p>垂直拆分</p><p> 垂直分表，通常是按照业务功能的使用频次，把主要的、热门的字段放在一起做为主要表。然后把不常用的，按照各自的业务属性进行聚集，拆分到不同的次要表中；主要表和次要表的关系一般都是一对一的。</p></li><li><p>水平拆分(数据分片)</p><p> 单表的容量不超过500W，否则建议水平拆分。是把一个表复制成同样表结构的不同表，然后把数据按照一定的规则划分，分别存储到这些表中，从而保证单表的容量不会太大，提升性能；当然这些结构一样的表，可以放在一个或多个数据库中。</p></li></ol><p>水平分割的几种方法：</p><ul><li>使用MD5哈希，做法是对UID进行md5加密，然后取前几位（我们这里取前两位），然后就可以将不同的UID哈希到不同的用户表（user_xx）中了。</li><li>还可根据时间放入不同的表，比如：article_201601，article_201602。</li><li>按热度拆分，高点击率的词条生成各自的一张表，低热度的词条都放在一张大表里，待低热度的词条达到一定的贴数后，再把低热度的表单独拆分成一张表。</li><li>根据ID的值放入对应的表，第一个表user_0000，第二个100万的用户数据放在第二个表user_0001中，随用户增加，直接添加用户表就行了。</li></ul><h3 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h3><p>一个库里表太多了，导致了海量数据，系统性能下降，把原本存储于一个库的表拆分存储到多个库上， 通常是将表按照功能模块、关系密切程度划分出来，部署到不同库上。优点：</p><ul><li>减少增量数据写入时的锁对查询的影响</li><li>由于单表数量下降，常见的查询操作由于减少了需要扫描的记录，使得单表单次查询所需的检索行数变少，减少了磁盘IO，时延变短</li></ul><h2 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a>三范式</h2><ul><li>第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。</li><li>第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。</li><li>第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在”A → B → C”的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系：关键字段 → 非关键字段 x → 非关键字段y</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql——锁（五）</title>
      <link href="/2020/09/10/Mysql%E2%80%94%E2%80%94%E9%94%81%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2020/09/10/Mysql%E2%80%94%E2%80%94%E9%94%81%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据库本质上是一种共享资源，因此在最大程度提供并发访问性能的同时，仍需要确保每个用户能以一致的方式读取和修改数据。锁机制（Locking）就是解决这类问题的最好武器。</p><h1 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h1><p>从对数据操作的类型分类：</p><ul><li><code>读锁</code>（共享锁）：针对同一份数据，多个读操作可以同时进行，不会互相影响</li><li><code>写锁</code>（排他锁）：当前写操作没有完成前，它会阻断其他写锁和读锁</li></ul><p>为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，但是管理锁是很耗资源的事情（涉及获取，检查，释放锁等动作），因此数据库系统需要在高并发响应和系统性能两方面进行平衡，这样就产生了“锁粒度（Lock granularity）”的概念。</p><ul><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低（MyISAM 和 MEMORY 存储引擎采用的是表级锁）；</li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高（InnoDB 存储引擎既支持行级锁也支持表级锁，但默认情况下是采用行级锁）；</li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li></ul><p>从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。</p><h1 id="例"><a href="#例" class="headerlink" title="例"></a>例</h1><p>首先新建表 test，其中 id 为主键，name 为辅助索引，address 为唯一索引。</p><p><img src="/images/Mysql%E2%80%94%E2%80%94%E9%94%81%EF%BC%88%E4%BA%94%EF%BC%89_2020-09-14-09-53-54.png" alt="Mysql——锁（五）_2020-09-14-09-53-54.png"></p><h2 id="INSERT-方法中的行锁"><a href="#INSERT-方法中的行锁" class="headerlink" title="INSERT 方法中的行锁"></a>INSERT 方法中的行锁</h2><p>如果两个事务先后对主键相同的行记录执行 INSERT 操作，因为事务 A 先拿到了行锁，事务 B 只能等待直到事务 A 提交后行锁被释放。同理，如果针对唯一索引字段 address 进行插入操作，也需要获取行锁，图同主键插入过程类似，不再重复。</p><p>但是，如果两个事务都针对辅助索引字段 name 进行插入，不需要等待获取锁，因为辅助索引字段即使值相同，在数据库中也是操作不同的记录行，不会冲突。</p><p>Update 方法与 Insert 方法结果类似。</p><h2 id="SELECT-FOR-UPDATE-下的表锁与行锁"><a href="#SELECT-FOR-UPDATE-下的表锁与行锁" class="headerlink" title="SELECT FOR UPDATE 下的表锁与行锁"></a>SELECT FOR UPDATE 下的表锁与行锁</h2><p>事务 A SELECT FOR UPDATE 语句会拿到表 test 的 Table Lock，此时事务 B 去执行插入操作会阻塞，直到事务 A 提交释放表锁后，事务 B 才能获取对应的行锁执行插入操作。</p><p>但是如果事务 A 的 SELECT FOR UPDATE 语句紧跟 WHERE id = 1 的话，那么这条语句只会获取行锁，不会是表锁，此时不阻塞事务 B 对于其他主键的修改操作。</p><h2 id="辅助索引下的间隙锁"><a href="#辅助索引下的间隙锁" class="headerlink" title="辅助索引下的间隙锁"></a>辅助索引下的间隙锁</h2><p>先看下 test 表下的数据情况：</p><p><img src="/images/Mysql%E2%80%94%E2%80%94%E9%94%81%EF%BC%88%E4%BA%94%EF%BC%89_2020-09-14-09-58-49.png" alt="Mysql——锁（五）_2020-09-14-09-58-49.png"></p><p>间隙锁可以说是行锁的一种，不同的是它锁住的是一个范围内的记录，作用是避免幻读，即区间数据条目的突然增减。解决办法主要是：</p><ul><li>防止间隙内有新数据被插入，因此叫间隙锁</li><li>防止已存在的数据，在更新操作后成为间隙内的数据（例如更新 id = 7 的 name 字段为 1，那么 name = 1 的条数就从 2 变为 3）</li></ul><p>InnoDB 自动使用间隙锁的条件为：</p><ul><li>Repeatable Read 隔离级别，这是 MySQL 的默认工作级别</li><li>检索条件必须有索引（没有索引的话会走全表扫描，那样会锁定整张表所有的记录）</li></ul><p>当 InnoDB 扫描索引记录的时候，会首先对选中的索引行记录加上行锁，再对索引记录两边的间隙（向左扫描扫到第一个比给定参数小的值， 向右扫描扫描到第一个比给定参数大的值， 以此构建一个区间）加上间隙锁。如果一个间隙被事务 A 加了锁，事务 B 是不能在这个间隙插入记录的。</p><p>我们这里所说的 “间隙锁” 其实不是 GAP LOCK，而是 <code>RECORD LOCK + GAP LOCK</code>，InnoDB 中称之为 <code>NEXT_KEY LOCK</code>。</p><p>下面看个例子，我们建表时指定 name 列为辅助索引，目前这列的取值有 [1,2,10]。间隙范围有 (-∞, 1]、[1,1]、[1,2]、[2,10]、[10, +∞)</p><p>Round 1:</p><p>事务 A SELECT … WHERE name = 1 FOR UPDATE;<br>对 (-∞, 2) 增加间隙锁</p><ul><li>事务 B INSERT … name = 1 阻塞</li><li>事务 B INSERT … name = -100 阻塞</li><li>事务 B INSERT … name = 2 成功</li><li>事务 B INSERT … name = 3 成功</li></ul><p>Round 2:</p><p>事务 A SELECT … WHERE name = 2 FOR UPDATE;<br>对 [1, 10) 增加间隙锁</p><ul><li>事务 B INSERT … name = 1 阻塞</li><li>事务 B INSERT … name = 9 阻塞</li><li>事务 B INSERT … name = 10 成功</li><li>事务 B INSERT … name = 0 成功</li></ul><p>Round 3:</p><p>事务 A SELECT … WHERE name &lt;= 2 FOR UPDATE;<br>对 (-∞, +∞) 增加间隙锁</p><ul><li>事务 B INSERT … name = 3 阻塞</li><li>事务 B INSERT … name = 300 阻塞</li><li>事务 B INSERT … name = -300 阻塞</li></ul><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。</p><p>死锁有双重原因：真正的数据冲突；存储引擎的实现方式。</p><p>检测死锁：数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB存储引擎能检测到死锁的循环依赖并立即返回一个错误。</p><p>死锁恢复：死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。</p><p>外部锁的死锁检测：发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁， 这需要通过设置锁等待超时参数 innodb_lock_wait_timeout 来解决</p><p>死锁影响性能：死锁会影响性能而不是会产生严重错误，因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。有时当发生死锁时，禁用死锁检测（使用innodb_deadlock_detect配置选项）可能会更有效，这时可以依赖innodb_lock_wait_timeout设置进行事务回滚。</p><p>InnoDB避免死锁：</p><ul><li>为了在单个InnoDB表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每个元祖（行）使用SELECT … FOR UPDATE语句来获取必要的锁，即使这些行的更改语句是在之后才执行的。</li><li>在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁、更新时再申请排他锁，因为这时候当用户再申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁</li><li>如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会</li><li>通过SELECT … LOCK IN SHARE MODE获取行的读锁后，如果当前事务再需要对该记录进行更新操作，则很有可能造成死锁。</li><li>改变事务隔离级别</li></ul><p>如果出现死锁，可以用 show engine innodb status;命令来确定最后一个死锁产生的原因。返回结果中包括死锁相关事务的详细信息，如引发死锁的 SQL 语句，事务已经获得的锁，正在等待什么锁，以及被回滚的事务等。据此可以分析死锁产生的原因和改进措施。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql——事务（四）</title>
      <link href="/2020/09/10/Mysql%E2%80%94%E2%80%94%E4%BA%8B%E5%8A%A1%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2020/09/10/Mysql%E2%80%94%E2%80%94%E4%BA%8B%E5%8A%A1%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<div class="output_wrapper" id="output_wrapper_id" style="font-size: 16px; color: rgb(62, 62, 62); line-height: 1.6; word-spacing: 2px; letter-spacing: 2px; font-family: 'Helvetica Neue', Helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', Arial, sans-serif;"><h1 id="h" style="color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.6em;"><span style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;">前言</span></h1><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">事务的特性和隔离级别在之前的文章已经详细介绍过，了解请移步<a href="/2020/04/27/Spring%E2%80%94%E2%80%94%E4%BA%8B%E5%8A%A1%E7%90%86%E8%AE%BA/" title="Spring——事务理论">Spring——事务理论</a>。</p><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">本章主要讨论Mysql的事务机制及MVCC 多版本并发控制、事务的日志、事务的实现。</p><h1 id="hmysql" style="color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.6em;"><span style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;">Mysql默认隔离级别</span></h1><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">InnoDB 存储引擎在 REPEATABLE-READ（可重读） 事务隔离级别下使用的是 <code style="font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(233, 105, 0); background: rgb(248, 248, 248);">Next-Key Lock</code> 算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。</p><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 SERIALIZABLE(可串行化) 隔离级别，而且保留了比较好的并发性能。</p><h1 id="hmvcc" style="color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.6em;"><span style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;">MVCC 多版本并发控制</span></h1><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">MySQL的大多数事务型存储引擎实现都不是简单的行级锁。基于提升并发性考虑，一般都同时实现了多版本并发控制（MVCC），包括Oracle、PostgreSQL。只是实现机制各不相同。</p><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">可以认为 MVCC 是行级锁的一个变种，但它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只是锁定必要的行。</p><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">MVCC 的实现是通过保存数据在某个时间点的快照来实现的。也就是说不管需要执行多长时间，每个事物看到的数据都是一致的。</p><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">InnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列来实现。这两个列，一个保存了行的创建时间，一个保存行的过期时间（删除时间）。</p><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">当然存储的并不是真实的时间，而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">REPEATABLE READ（可重读）隔离级别下MVCC如何工作：</p><ul style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; padding-left: 32px; list-style-type: disc;"><li style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;">SELECT：InnoDB会根据以下两个条件检查每行记录：<ul style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; padding-left: 32px; list-style-type: disc;"><li style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;"><span style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;">InnoDB只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行，要么是在开始事务之前已经存在要么是事务自身插入或者修改过的</span></li><li style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;">行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除<br>只有符合上述两个条件的才会被查询出来</li></ul></li><li style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;"><span style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;">INSERT：InnoDB为新插入的每一行保存当前系统版本号作为行版本号</span></li><li style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;"><span style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;">DELETE：InnoDB为删除的每一行保存当前系统版本号作为行删除标识</span></li><li style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;"><span style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;">UPDATE：InnoDB为插入的一行新纪录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识</span></li></ul><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">保存这两个额外系统版本号，使大多数操作都不用加锁。使数据操作简单，性能很好，并且也能保证只会读取到符合要求的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作和一些额外的维护工作。</p><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">MVCC 只在 COMMITTED READ（读提交）和REPEATABLE READ（可重复读）两种隔离级别下工作。</p><h1 id="h-1" style="color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.6em;"><span style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;">事务日志</span></h1><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">InnoDB 使用日志来减少提交事务时的开销。因为日志中已经记录了事务，就无须在每个事务提交时把缓冲池的脏块刷新(flush)到磁盘中。</p><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">InnoDB 用日志把随机IO变成顺序IO。一旦日志安全写到磁盘，事务就持久化了，即使断电了，InnoDB可以重放日志并且恢复已经提交的事务。</p><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">事务日志可以帮助提高事务效率：</p><ul style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; padding-left: 32px; list-style-type: disc;"><li style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;"><span style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;">使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。</span></li><li style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;"><span style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;">事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。</span></li><li style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;">事务日志持久以后，内存中被修改的数据在后台可以慢慢刷回到磁盘。<br>如果数据的修改已经记录到事务日志并持久化，但数据本身没有写回到磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这一部分修改的数据。</li></ul><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">目前来说，大多数存储引擎都是这样实现的，我们通常称之为预写式日志（Write-Ahead Logging），修改数据需要写两次磁盘。</p><h1 id="h-2" style="color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.6em;"><span style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;">事务的实现</span></h1><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">事务的实现是基于数据库的存储引擎。</p><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">事务的隔离性是通过锁实现，而事务的原子性、一致性和持久性则是通过 事务日志实现 。</p><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">事务日志包括：重做日志redo和回滚日志undo</p><ul style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; padding-left: 32px; list-style-type: disc;"><li style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;">redo log（重做日志） 实现持久化和原子性 在innoDB的存储引擎中，事务日志通过重做(redo)日志和innoDB存储引擎的日志缓冲(InnoDB Log Buffer)实现。事务开启时，事务中的操作，都会先写入存储引擎的日志缓冲中，在事务提交之前，这些缓冲的日志都需要提前刷新到磁盘上持久化，这就是DBA们口中常说的“日志先行”(Write-Ahead Logging)。<br>当事务提交之后，在Buffer Pool中映射的数据文件才会慢慢刷新到磁盘。此时如果数据库崩溃或者宕机，那么当系统重启进行恢复时，就可以根据redo log中记录的日志，把数据库恢复到崩溃前的一个状态。未完成的事务，可以继续提交，也可以选择回滚，这基于恢复的策略而定。<br>在系统启动的时候，就已经为redo log分配了一块连续的存储空间，以顺序追加的方式记录Redo Log，通过顺序IO来改善性能。所有的事务共享redo log的存储空间，它们的Redo Log按语句的执行顺序，依次交替的记录在一起。</li><li style="font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;">undo log（回滚日志） 实现一致性<br>undo log 主要为事务的回滚服务。在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。单个事务的回滚，只会回滚当前事务做的操作，并不会影响到其他的事务做的操作。<br>Undo记录的是已部分完成并且写入硬盘的未完成的事务，默认情况下回滚日志是记录下表空间中的（共享表空间或者独享表空间）</li></ul><p style="font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;">二种日志均可以视为一种恢复操作，redo_log是恢复提交事务修改的页操作，而undo_log是回滚行记录到特定版本。二者记录的内容也不同，redo_log是物理日志，记录页的物理修改操作，而undo_log是逻辑日志，根据每行记录进行记录。</p></div>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql——索引（三）</title>
      <link href="/2020/09/10/Mysql%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2020/09/10/Mysql%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>MYSQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构，所以说索引的本质是：数据结构</p><p>可以简单的理解为“排好序的快速查找数据结构”，数据本身之外，数据库还维护者一个满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p><p>平常说的索引，没有特别指明的话，就是B+树（多路搜索树，不一定是二叉树）结构组织的索引。</p><p>索引本身也很大，不可能全部存储在内存中，一般以索引文件的形式存储在磁盘上。</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>创建：</p><ul><li>创建索引：CREATE [UNIQUE] INDEX indexName ON mytable(username(length));<br>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。</li><li>修改表结构(添加索引)：ALTER table tableName ADD [UNIQUE] INDEX indexName(columnName)</li><li>删除：DROP INDEX [indexName] ON mytable;</li><li>查看：SHOW INDEX FROM table_name\G –可以通过添加 \G 来格式化输出信息。</li></ul><p>使用ALERT命令：</p><ul><li>ALTER TABLE tbl_name ADD PRIMARY KEY (column_list): 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</li><li>ALTER TABLE tbl_name ADD UNIQUE index_name (column_list 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。</li><li>ALTER TABLE tbl_name ADD INDEX index_name (column_list) 添加普通索引，索引值可出现多次。</li><li>ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list)该语句指定了索引为 FULLTEXT ，用于全文索引。</li></ul><h1 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h1><p>优势：</p><ul><li>提高数据检索效率，降低数据库IO成本</li><li>降低数据排序的成本，降低CPU的消耗</li></ul><p>劣势：</p><ul><li>索引也是一张表，保存了主键和索引字段，并指向实体表的记录，所以也需要占用内存。</li><li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。</li></ul><h1 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h1><p>数据结构角度：</p><ul><li>B+树索引</li><li>Hash索引</li><li>Full-Text全文索引</li><li>R-Tree索引</li></ul><p>从物理存储角度:</p><ul><li>聚集索引（clustered index）</li><li>非聚集索引（non-clustered index），也叫辅助索引（secondary index） 聚集索引和非聚集索引都是B+树结构</li></ul><p>从逻辑角度:</p><ul><li>主键索引：主键索引是一种特殊的唯一索引，不允许有空值</li><li>普通索引或者单列索引：每个索引只包含单个列，一个表可以有多个单列索引</li><li>多列索引（复合索引、联合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合</li><li>唯一索引或者非唯一索引</li><li>空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建。</li></ul><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>首先要明白索引（index）是在存储引擎（storage engine）层面实现的，而不是server层面。不是所有的存储引擎都支持所有的索引类型。即使多个存储引擎支持某一索引类型，它们的实现和行为也可能有所差别。</p><p>MyISAM 和 InnoDB 存储引擎，都使用 B+Tree的数据结构，它相对与 B-Tree结构，所有的数据都存放在叶子节点上，且把叶子节点通过指针连接到一起，形成了一条数据链表，以加快相邻数据的检索效率。</p><h2 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h2><p>首先来看B-Tree结构，可以让系统高效的找到数据所在的磁盘块。</p><p>为了描述 B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data 为一行记录中除主键外的数据。对于不同的记录，key值互不相同。</p><p><img src="/images/Mysql%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%89%EF%BC%89_2020-09-10-14-33-00.png" alt="Mysql——索引（三）_2020-09-10-14-33-00.png"></p><p>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。</p><p>模拟查找关键字29的过程：</p><ol><li>根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】</li><li>比较关键字29在区间（17,35），找到磁盘块1的指针P2。</li><li>根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】</li><li>比较关键字29在区间（26,30），找到磁盘块3的指针P2。</li><li>根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】</li><li>在磁盘块8中的关键字列表中找到关键字29</li></ol><p>分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。</p><h2 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h2><p>B+Tree 是在 B-Tree 基础上的一种优化,从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。</p><p>而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。</p><p>在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。</p><p>B+Tree相对于B-Tree有几点不同：</p><ol><li>非叶子节点只存储键值信息；</li><li>所有叶子节点之间都有一个链指针；</li><li>数据记录都存放在叶子节点中</li></ol><p>将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示：</p><p><img src="/images/Mysql%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%89%EF%BC%89_2020-09-10-14-40-43.png" alt="Mysql——索引（三）_2020-09-10-14-40-43.png"></p><p>通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。</p><p>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为10^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。</p><p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2-4层。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。</p><h2 id="MyISAM主键索引与辅助索引的结构"><a href="#MyISAM主键索引与辅助索引的结构" class="headerlink" title="MyISAM主键索引与辅助索引的结构"></a>MyISAM主键索引与辅助索引的结构</h2><p>MyISAM引擎的索引文件和数据文件是分离的。MyISAM引擎索引结构的叶子节点的数据域，存放的并不是实际的数据记录，而是数据记录的地址。索引文件与数据文件分离，这样的索引称为”非聚簇索引”。MyISAM的主索引与辅助索引区别并不大，只是主键索引不能有重复的关键字。</p><p><img src="/images/Mysql%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%89%EF%BC%89_2020-09-10-14-45-16.png" alt="Mysql——索引（三）_2020-09-10-14-45-16.png"></p><p>通过索引查找数据的流程：先从索引文件中查找到索引节点，从中拿到数据的文件指针，再到数据文件中通过文件指针定位了具体的数据。辅助索引类似。</p><h2 id="InnoDB主键索引与辅助索引的结构"><a href="#InnoDB主键索引与辅助索引的结构" class="headerlink" title="InnoDB主键索引与辅助索引的结构"></a>InnoDB主键索引与辅助索引的结构</h2><p>InnoDB引擎索引结构的叶子节点的数据域，存放的就是实际的数据记录（对于主索引，此处会存放表中所有的数据记录；对于辅助索引此处会引用主键，检索的时候通过主键到主键索引中找到对应数据行），或者说，InnoDB的数据文件本身就是主键索引文件，这样的索引被称为”“聚簇索引”，一个表只能有一个聚簇索引。</p><p>主键索引：</p><p><img src="/images/Mysql%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%89%EF%BC%89_2020-09-10-14-47-38.png" alt="Mysql——索引（三）_2020-09-10-14-47-38.png"></p><p>在Innodb中，索引分叶子节点和非叶子节点，非叶子节点就像新华字典的目录，单独存放在索引段中，叶子节点则是顺序排列的，在数据段中。Innodb的数据文件可以按照表来切分（只需要开启innodb_file_per_table)，切分后存放在xxx.ibd中，默认不切分，存放在xxx.ibdata中。</p><p>普通索引：</p><p>这次我们以示例中学生表中的name列建立辅助索引，它的索引结构跟主键索引的结构有很大差别，在最底层的叶子结点有两行数据，第一行的字符串是辅助索引，按照ASCII码进行排序，第二行的整数是主键的值。这就意味着，对name列进行条件搜索，需要两个步骤：</p><p>① 在辅助索引上检索name，到达其叶子节点获取对应的主键；② 使用主键在主索引上再进行对应的检索操作</p><p>这也就是所谓的“回表查询”</p><p><img src="/images/Mysql%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%89%EF%BC%89_2020-09-10-14-49-39.png" alt="Mysql——索引（三）_2020-09-10-14-49-39.png"></p><p>在查找时都是通过先查找到索引节点才能拿到相对应的数据，如果我们在设计表结构时没有显式指定索引列的话，MySQL 会从表中选择数据不重复的列建立索引，如果没有符合的列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，并且这个字段长度为6个字节，类型为整型。</p><p>InnoDB 存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为16KB，可通过参数 innodb_page_size 将页的大小设置为 4K、8K、16K，在 MySQL 中可通过如下命令查看页的大小：show variables like ‘innodb_page_size’;</p><p>而系统一个磁盘块的存储空间往往没有这么大，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB。InnoDB 在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。</p><h2 id="hash索引"><a href="#hash索引" class="headerlink" title="hash索引"></a>hash索引</h2><ul><li>主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。</li><li>检索算法：在检索查询时，就再次对待查关键字再次执行相同的Hash算法，得到Hash值，到对应Hash表对应位置取出数据即可，如果发生Hash碰撞，则需要在取值时进行筛选。目前使用Hash索引的数据库并不多，主要有Memory等。</li><li>MySQL目前有Memory引擎和NDB引擎支持Hash索引。</li></ul><h2 id="full-text全文索引"><a href="#full-text全文索引" class="headerlink" title="full-text全文索引"></a>full-text全文索引</h2><ul><li>全文索引也是MyISAM的一种特殊索引类型，主要用于全文索引，InnoDB从MYSQL5.6版本提供对全文索引的支持。</li><li>它用于替代效率较低的LIKE模糊匹配操作，而且可以通过多字段组合的全文索引一次性全模糊匹配多个字段。</li><li>同样使用B-Tree存放索引数据，但使用的是特定的算法，将字段数据分割后再进行索引（一般每4个字节一次分割），索引文件存储的是分割前的索引字符串集合，与分割后的索引信息，对应Btree结构的节点存储的是分割后的词信息以及它在分割前的索引字符串集合中的位置。</li></ul><h2 id="R-Tree空间索引"><a href="#R-Tree空间索引" class="headerlink" title="R-Tree空间索引"></a>R-Tree空间索引</h2><p>空间索引是MyISAM的一种特殊索引类型，主要用于地理空间数据类型。</p><h1 id="MySQL高效索引"><a href="#MySQL高效索引" class="headerlink" title="MySQL高效索引"></a>MySQL高效索引</h1><ul><li>就是select的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，换句话说查询列要被所建的索引覆盖。</li><li>索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据，当能通过读取索引就可以得到想要的数据，那就不需要读取行了。一个索引包含（覆盖）满足查询结果的数据就叫做覆盖索引。</li><li>判断标准：使用explain，可以通过输出的extra列来判断，对于一个索引覆盖查询，显示为using index，MySQL查询优化器在执行查询前会决定是否有索引覆盖查询</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql——储存引擎（二）</title>
      <link href="/2020/09/10/Mysql%E2%80%94%E2%80%94%E5%82%A8%E5%AD%98%E5%BC%95%E6%93%8E%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/09/10/Mysql%E2%80%94%E2%80%94%E5%82%A8%E5%AD%98%E5%BC%95%E6%93%8E%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>存储引擎是MySQL的组件，用于处理不同表类型的SQL操作。使用哪一种引擎可以灵活选择，一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求，不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用合适的存储引擎，将会提高整个数据库的性能。</p><p>MySQL服务器使用可插拔的存储引擎体系结构，可以从运行中的 MySQL 服务器加载或卸载存储引擎 。</p><h1 id="数据库引擎命令"><a href="#数据库引擎命令" class="headerlink" title="数据库引擎命令"></a>数据库引擎命令</h1><p>查看：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">--</span> <span class="string">查看支持的存储引擎</span></span><br><span class="line"><span class="attr">SHOW</span> <span class="string">ENGINES</span></span><br><span class="line"></span><br><span class="line"><span class="meta">--</span> <span class="string">查看默认存储引擎</span></span><br><span class="line"><span class="attr">SHOW</span> <span class="string">VARIABLES LIKE 'storage_engine'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">--查看具体某一个表所使用的存储引擎，这个默认存储引擎被修改了！</span></span><br><span class="line"><span class="attr">show</span> <span class="string">create table tablename</span></span><br><span class="line"></span><br><span class="line"><span class="attr">--准确查看某个数据库中的某一表所使用的存储引擎</span></span><br><span class="line"><span class="attr">show</span> <span class="string">table status like 'tablename'</span></span><br><span class="line"><span class="attr">show</span> <span class="string">table status from database where name="tablename"</span></span><br></pre></td></tr></table></figure><p>设置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">--</span> <span class="string">建表时指定存储引擎。默认的就是INNODB，不需要设置</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE t1 (i INT) ENGINE = INNODB;</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE t2 (i INT) ENGINE = CSV;</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE t3 (i INT) ENGINE = MEMORY;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">--</span> <span class="string">修改存储引擎</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE t ENGINE = InnoDB;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">--</span> <span class="string">修改默认存储引擎，也可以在配置文件my.cnf中修改默认引擎</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">default_storage_engine=NDBCLUSTER;</span></span><br></pre></td></tr></table></figure><h1 id="常用的储存引擎"><a href="#常用的储存引擎" class="headerlink" title="常用的储存引擎"></a>常用的储存引擎</h1><p>常见的存储引擎就 InnoDB、MyISAM、Memory、NDB。</p><h1 id="储存引擎对比"><a href="#储存引擎对比" class="headerlink" title="储存引擎对比"></a>储存引擎对比</h1><h2 id="文件储存结构对比"><a href="#文件储存结构对比" class="headerlink" title="文件储存结构对比"></a>文件储存结构对比</h2><p>在 MySQL中建立任何一张数据表，在其数据目录对应的数据库目录下都有对应表的 .frm 文件，.frm 文件是用来保存每个数据表的元数据(meta)信息，包括表结构的定义等，与数据库存储引擎无关，也就是任何存储引擎的数据表都必须有.frm文件，命名方式为 数据表名.frm，如user.frm。</p><p>MyISAM 物理文件结构为：</p><ol><li><code>.frm</code>文件：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等</li><li><code>.MYD</code> (MYData) 文件：MyISAM 存储引擎专用，用于存储MyISAM 表的数据</li><li><code>.MYI</code> (MYIndex)文件：MyISAM 存储引擎专用，用于存储MyISAM 表的索引相关信息</li></ol><p>InnoDB 物理文件结构为：</p><ol><li><code>.frm</code> 文件：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等</li><li><code>.ibd</code> 文件或 <code>.ibdata</code> 文件：这两种文件都是存放 InnoDB 数据的文件，之所以有两种文件形式存放 InnoDB的数据，是因为 InnoDB 的数据存储方式能够通过配置来决定是使用共享表空间存放存储数据，还是用独享表空间存放存储数据。</li></ol><p>独享表空间存储方式使用.ibd文件，并且每个表一个.ibd文件 共享表空间存储方式使用.ibdata文件，所有表共同使用一个.ibdata文件（或多个，可自己配置）</p><h2 id="事务支持对比"><a href="#事务支持对比" class="headerlink" title="事务支持对比"></a>事务支持对比</h2><p>InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</p><h2 id="外键支持对比"><a href="#外键支持对比" class="headerlink" title="外键支持对比"></a>外键支持对比</h2><p>InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；</p><h2 id="索引对比"><a href="#索引对比" class="headerlink" title="索引对比"></a>索引对比</h2><p>InnoDB 是聚簇索引，MyISAM 是非聚簇索引。</p><p>聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。</p><p>而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</p><h2 id="保存行数对比"><a href="#保存行数对比" class="headerlink" title="保存行数对比"></a>保存行数对比</h2><p>InnoDB 不保存表的具体行数，执行select count(*) from table 时需要全表扫描。</p><p>而 MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</p><p>为什么 InnoDB 引擎不像 MyISAM 引擎一样，将总行数存储到磁盘上？这跟 InnoDB 的事务特性有关，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的。</p><h2 id="锁粒度对比"><a href="#锁粒度对比" class="headerlink" title="锁粒度对比"></a>锁粒度对比</h2><p>InnoDB 最小的锁粒度是行锁，MyISAM最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>主要包括以下五大类：</p><ol><li>整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT</li><li>浮点数类型：FLOAT、DOUBLE、DECIMAL</li><li>字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB</li><li>日期类型：Date、DateTime、TimeStamp、Time、Year</li><li>其他数据类型：BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection等</li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql 储存引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql——架构（一）</title>
      <link href="/2020/09/09/MySql%E2%80%94%E2%80%94%E6%9E%B6%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/09/09/MySql%E2%80%94%E2%80%94%E6%9E%B6%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>MySQL与其他数据库相比主要体现在存储引擎的架构上，插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离。</p><h1 id="结构剖析"><a href="#结构剖析" class="headerlink" title="结构剖析"></a>结构剖析</h1><p><img src="/images/MySql%E2%80%94%E2%80%94%E6%9E%B6%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89_2020-09-10-09-53-32.png" alt="MySql——架构（一）_2020-09-10-09-53-32.png"></p><ol><li><p>连接层：最上层是一些客户端和连接服务。主要完成一些类似于连接处理、授权认证、及相关的安全方案。   在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p></li><li><p>服务层：第二层服务层，主要完成大部分的核心服务功能， 包括查询解析、分析、优化、缓存、以及所有的内置函数，所有跨存储引擎的功能也都在这一层实现，包括触发器、存储过程、视图等。</p></li><li><p>引擎层：第三层存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取</p></li><li><p>存储层：第四层为数据存储层，主要是将数据存储在运行于该设备的文件系统之上，并完成与存储引擎的交互。</p></li></ol><h1 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h1><p>客户端请求 —&gt; 连接器（验证用户身份，给予权限） —&gt; 查询缓存（存在缓存则直接返回，不存在则执行后续操作） —&gt; 分析器（对SQL进行词法分析和语法分析操作） —&gt; 优化器（主要对执行的sql优化选择最优的执行方案方法） —&gt; 执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口） —&gt; 去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）</p><p><img src="/images/MySql%E2%80%94%E2%80%94%E6%9E%B6%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89_2020-09-10-10-02-42.png" alt="MySql——架构（一）_2020-09-10-10-02-42.png"></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM——对象</title>
      <link href="/2020/08/04/JVM%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/08/04/JVM%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>类加载后，逻辑上的方法区中便形成了一个包含类信息的class对象，但我们去使用这个类的时候，除了直接调用静态变量、静态方法等，对于成员变量以及实例方法，通常是我们在堆内存中生成一个类的实例，通过类的实例来完成调用。</p><p>创建对象实例通常（例外：复制、反序列化）仅仅是一个new关键字而已，当Java虚拟机遇到一条字节码 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程，类检查通过后，接下来虚拟机将为新生对象分配内存。</p><h1 id="分配内存的方式"><a href="#分配内存的方式" class="headerlink" title="分配内存的方式"></a>分配内存的方式</h1><ol><li><p>指针碰撞</p><p> 假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。</p></li><li><p>空闲列表</p><p> 但如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那<br> 就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分<br> 配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称<br> 为“空闲列表”（Free List）。</p></li></ol><p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定。</p><h1 id="分配内存的线程安全"><a href="#分配内存的线程安全" class="headerlink" title="分配内存的线程安全"></a>分配内存的线程安全</h1><p>对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种可选方案：</p><ol><li><p>同步CAS</p><p> 是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性；</p></li><li><p>本地线程分配缓冲</p><p> 是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation<br> Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。</p><p> 虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。</p></li></ol><p>内存分配完成后，实际上Class文件中的<init>()方法还没有执行，所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。</p><h1 id="对象的结构"><a href="#对象的结构" class="headerlink" title="对象的结构"></a>对象的结构</h1><p>接下来，在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例<br>数据（Instance Data）和对齐填充（Padding）。</p><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><ol><li><p>Mark Word</p><p> 用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特，官方称它为“Mark Word”。</p><p> 对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的最大限度，但对象头里的信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。</p></li><li><p>类型指针</p><p> 对象头的另外一部分是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。</p></li></ol><h2 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h2><p>是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。</p><h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><p>对象的第三部分是对齐填充，这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数（1倍或者2倍），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p><h1 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h1><p>我们知道栈中存储引用与基本数据类型，堆中存储class对象实例。</p><p>jvm在加载class时，创建instanceKlass，表示其元数据，包括常量池、字段、方法等，存放在方法区；instanceKlass是jvm中的数据结构；</p><p>在new一个对象时，jvm创建instanceOopDesc，来表示这个对象，存放在堆区，其引用，存放在栈区；它用来表示对象的实例信息，看起来像个指针实际上是藏在指针里的对象；instanceOopDesc对应java中的对象实例；</p><p>HotSpot并不把instanceKlass暴露给Java，而会另外创建对应的instanceOopDesc来表示java.lang.Class对象，并将后者称为前者的“Java镜像”，klass持有指向oop引用(_java_mirror便是该instanceKlass对Class对象的引用)；</p><p>我们通过栈中的引用定位到堆中的instanceOopDesc，又通过instanceOopDesc中的引用定位到方法区的instanceKlass。</p><p>其中栈中的引用怎么去定位到我们的实例对象，主流有两种方式：</p><ol><li><p>句柄访问</p><p>如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。</p></li><li><p>指针访问</p><p>如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销</p></li></ol><p>这两种对象访问方式各有优势</p><p>使用句柄来访问的最大好处就是reference中存储的是稳定句柄址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</p><p>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本，就虚拟机HotSpot而言，它主要使用第二种方式进行对象访问。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm 对象创建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx——配置文件实战</title>
      <link href="/2020/07/27/web%E6%9C%8D%E5%8A%A1%E5%99%A8Nginx%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AE%9E%E6%88%98/"/>
      <url>/2020/07/27/web%E6%9C%8D%E5%8A%A1%E5%99%A8Nginx%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="配置文件结构"><a href="#配置文件结构" class="headerlink" title="配置文件结构"></a>配置文件结构</h1><p>Nginx 配置文件由三部分组成：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">...</span>              <span class="string">#全局块</span></span><br><span class="line"></span><br><span class="line"><span class="attr">events</span> <span class="string">&#123;         #events块</span></span><br><span class="line">   <span class="attr">...</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">http</span>      <span class="string">#http块</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">    <span class="meta">...</span>   <span class="string">#http全局块</span></span><br><span class="line">    <span class="attr">server</span>        <span class="string">#server块</span></span><br><span class="line">    <span class="meta">&#123;</span> <span class="string"></span></span><br><span class="line">        <span class="meta">...</span>       <span class="string">#server全局块</span></span><br><span class="line">        <span class="attr">location</span> <span class="string">[PATTERN]   #location块</span></span><br><span class="line">        <span class="attr">&#123;</span></span><br><span class="line">            <span class="attr">...</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line">        <span class="attr">location</span> <span class="string">[PATTERN] </span></span><br><span class="line">        <span class="attr">&#123;</span></span><br><span class="line">            <span class="attr">...</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">server</span></span><br><span class="line">    <span class="attr">&#123;</span></span><br><span class="line">      <span class="attr">...</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">    <span class="meta">...</span>     <span class="string">#http全局块</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><ol><li><p>全局块</p><p> 主要设置一些影响 nginx 服务器整体运行的配置指令。<br> 比如： worker_processes 1; ， worker_processes 值越大，可以支持的并发处理量就越多。</p></li><li><p>events块</p><p> events 块涉及的指令主要影响Nginx服务器与用户的网络连接。<br> 比如： worker_connections 1024; ，支持的最大连接数。</p></li><li><p>http块</p><p> http 块又包括 http 全局块和 server 块，是服务器配置中最频繁的部分，包括配置代理、缓存、日志定义等绝大多数功能。<br> server块：配置虚拟主机的相关参数。<br> location块：配置请求路由，以及各种页面的处理情况。</p></li></ol><h1 id="配置文件样例"><a href="#配置文件样例" class="headerlink" title="配置文件样例"></a>配置文件样例</h1><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">########### 每个指令必须有分号结束。#################</span></span><br><span class="line"><span class="comment">#user administrator administrators;  #配置用户或者组，默认为nobody nobody。</span></span><br><span class="line"><span class="comment">#worker_processes 2;  #允许生成的进程数，默认为1</span></span><br><span class="line"><span class="comment">#pid /nginx/pid/nginx.pid;   #指定nginx进程运行文件存放地址</span></span><br><span class="line"><span class="attr">error_log</span> <span class="string">log/error.log debug;  #制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg</span></span><br><span class="line"><span class="attr">events</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">accept_mutex</span> <span class="string">on;   #设置网路连接序列化，防止惊群现象发生，默认为on</span></span><br><span class="line">    <span class="attr">multi_accept</span> <span class="string">on;  #设置一个进程是否同时接受多个网络连接，默认为off</span></span><br><span class="line"><span class="comment">    #use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport</span></span><br><span class="line">    <span class="attr">worker_connections</span>  <span class="string">1024;    #最大连接数，默认为512</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="attr">http</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">include</span>       <span class="string">mime.types;   #文件扩展名与文件类型映射表</span></span><br><span class="line">    <span class="attr">default_type</span>  <span class="string">application/octet-stream; #默认文件类型，默认为text/plain</span></span><br><span class="line"><span class="comment">    #access_log off; #取消服务日志    </span></span><br><span class="line">    <span class="attr">log_format</span> <span class="string">myFormat '$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for'; #自定义格式</span></span><br><span class="line">    <span class="attr">access_log</span> <span class="string">log/access.log myFormat;  #combined为日志格式的默认值</span></span><br><span class="line">    <span class="attr">sendfile</span> <span class="string">on;   #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。</span></span><br><span class="line">    <span class="attr">sendfile_max_chunk</span> <span class="string">100k;  #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。</span></span><br><span class="line">    <span class="attr">keepalive_timeout</span> <span class="string">65;  #连接超时时间，默认为75s，可以在http，server，location块。</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">upstream</span> <span class="string">mysvr &#123;   </span></span><br><span class="line">      <span class="attr">server</span> <span class="string">127.0.0.1:7878;</span></span><br><span class="line">      <span class="attr">server</span> <span class="string">192.168.10.121:3333 backup;  #热备</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">error_page</span> <span class="string">404 https://www.baidu.com; #错误页</span></span><br><span class="line">    <span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">keepalive_requests</span> <span class="string">120; #单连接请求上限次数。</span></span><br><span class="line">        <span class="attr">listen</span>       <span class="string">4545;   #监听端口</span></span><br><span class="line">        <span class="attr">server_name</span>  <span class="string">127.0.0.1;   #监听地址       </span></span><br><span class="line">        <span class="attr">location</span>  <span class="string">~*^.+$ &#123;       #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。</span></span><br><span class="line"><span class="comment">           #root path;  #根目录</span></span><br><span class="line"><span class="comment">           #index vv.txt;  #设置默认页</span></span><br><span class="line">           <span class="attr">proxy_pass</span>  <span class="string">http://mysvr;  #请求转向mysvr 定义的服务器列表</span></span><br><span class="line">           <span class="attr">deny</span> <span class="string">127.0.0.1;  #拒绝的ip</span></span><br><span class="line">           <span class="attr">allow</span> <span class="string">172.18.5.54; #允许的ip           </span></span><br><span class="line">        <span class="meta">&#125;</span> <span class="string"></span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><ol><li><p>浏览器输入监听地址端口，跳转到tomcat主界面</p> <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">listen</span>       <span class="string">8888;   </span></span><br><span class="line">    <span class="attr">server_name</span>  <span class="string">127.0.0.1;   #监听地址</span></span><br><span class="line">   </span><br><span class="line">    <span class="attr">location</span>  <span class="string">/ &#123;       </span></span><br><span class="line">       <span class="attr">root</span> <span class="string">html;  #/html目录</span></span><br><span class="line">       <span class="attr">proxy_pass</span> <span class="string">http://127.0.0.1:8080;  #请求转向</span></span><br><span class="line">       <span class="attr">index</span>  <span class="string">index.html index.htm;      #设置默认页       </span></span><br><span class="line">    <span class="meta">&#125;</span> <span class="string"></span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>根据在浏览器输入的路径不同，跳转到不同端口的服务中。</p> <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">listen</span>       <span class="string">8888;   </span></span><br><span class="line">    <span class="attr">server_name</span>  <span class="string">127.0.0.1;   #监听地址       </span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">location</span>  <span class="string">~ /example1/ &#123;  </span></span><br><span class="line">       <span class="attr">proxy_pass</span> <span class="string">http://127.0.0.1:8080;         </span></span><br><span class="line">    <span class="meta">&#125;</span> <span class="string"></span></span><br><span class="line"></span><br><span class="line">    <span class="attr">location</span>  <span class="string">~ /example2/ &#123;  </span></span><br><span class="line">       <span class="attr">proxy_pass</span> <span class="string">http://127.0.0.1:8081;         </span></span><br><span class="line">    <span class="meta">&#125;</span> <span class="string"></span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure></li></ol><p>location 指令说明：</p><ul><li>~ : 表示uri包含正则表达式，且区分大小写。</li><li>~* : 表示uri包含正则表达式，且不区分大小写。</li><li>= : 表示uri不含正则表达式，要求严格匹配。</li></ul><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>浏览器输入监听地址端口，平均跳转到tomcat不同端口主界面</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">upstream</span> <span class="string">myserver &#123;</span></span><br><span class="line">      <span class="attr">server</span> <span class="string">127.0.0.1:8081;</span></span><br><span class="line">      <span class="attr">server</span> <span class="string">127.0.0.1:8080;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">listen</span>       <span class="string">8888;   #监听端口</span></span><br><span class="line">        <span class="attr">server_name</span>  <span class="string">127.0.0.1;   #监听地址</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">location</span>  <span class="string">/ &#123;</span></span><br><span class="line">           <span class="attr">root</span> <span class="string">html;  #html目录</span></span><br><span class="line">           <span class="attr">index</span> <span class="string">index.html index.htm;  #设置默认页</span></span><br><span class="line">           <span class="attr">proxy_pass</span>  <span class="string">http://myserver;  #请求转向 myserver 定义的服务器列表</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>负载均衡策略</p><p>轮询（默认）</p><p>按请求的时间顺序依次逐一分配，如果服务器down掉，能自动剔除。</p><p>权重</p><p>weight 越高，被分配的客户端越多，默认为 1。比如：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">upstream</span> <span class="string">myserver &#123;</span></span><br><span class="line">      <span class="attr">server</span> <span class="string">127.0.0.1:8081 weight=10;</span></span><br><span class="line">      <span class="attr">server</span> <span class="string">127.0.0.1:8080 weight=5;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>ip</p><p>按请求 ip 的 hash 值分配，每个访客固定访问一个后端服务器。比如：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">upstream</span> <span class="string">myserver &#123;</span></span><br><span class="line">      <span class="attr">ip_hash;</span></span><br><span class="line">      <span class="attr">server</span> <span class="string">127.0.0.1:8081;</span></span><br><span class="line">      <span class="attr">server</span> <span class="string">127.0.0.1:8080;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>fair</p><p>按后端服务器的响应时间来分配，响应时间短的优先分配到请求。比如：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">upstream</span> <span class="string">myserver &#123;</span></span><br><span class="line">      <span class="attr">server</span> <span class="string">127.0.0.1:8081;</span></span><br><span class="line">      <span class="attr">server</span> <span class="string">127.0.0.1:8080;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>我们需要通过能连接到具体网址的代理服务器，来完成正向代理。</p><p>nginx配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span> <span class="string">&#123;  </span></span><br><span class="line">    <span class="attr">resolver</span> <span class="string">114.114.114.114;       #指定DNS服务器IP地址  </span></span><br><span class="line">    <span class="attr">listen</span> <span class="string">8080;  </span></span><br><span class="line">    <span class="attr">location</span> <span class="string">/ &#123;  </span></span><br><span class="line">        <span class="attr">proxy_pass</span> <span class="string">http://$http_host$request_uri;     #设定代理服务器的协议和地址  </span></span><br><span class="line">    <span class="meta">&#125;</span>  <span class="string"></span></span><br><span class="line"><span class="meta">&#125;</span>  <span class="string"></span></span><br><span class="line"></span><br><span class="line"><span class="meta">以上的配置只能访问80</span> <span class="string">端口的网站，而不能访问https443端口的网站，现在的网站基本上都是https的要解决技能访问http80端口也能访问https443端口的网站，需要置两个SERVER节点，一个处理HTTP转发，另一个处理HTTPS转发。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">```properties</span></span><br><span class="line"><span class="attr">server</span> <span class="string">&#123;  </span></span><br><span class="line">    <span class="attr">resolver</span> <span class="string">114.114.114.114;       #指定DNS服务器IP地址  </span></span><br><span class="line">    <span class="attr">listen</span> <span class="string">80;  </span></span><br><span class="line">    <span class="attr">location</span> <span class="string">/ &#123;  </span></span><br><span class="line">        <span class="attr">proxy_pass</span> <span class="string">http://$http_host$request_uri;     #设定代理服务器的协议和地址  </span></span><br><span class="line">                <span class="attr">proxy_set_header</span> <span class="string">HOST $http_host;</span></span><br><span class="line">                <span class="attr">proxy_buffers</span> <span class="string">256 4k;</span></span><br><span class="line">                <span class="attr">proxy_max_temp_file_size</span> <span class="string">0k; </span></span><br><span class="line">                <span class="attr">proxy_connect_timeout</span> <span class="string">30;</span></span><br><span class="line">                <span class="attr">proxy_send_timeout</span> <span class="string">60;</span></span><br><span class="line">                <span class="attr">proxy_read_timeout</span> <span class="string">60;</span></span><br><span class="line">                <span class="attr">proxy_next_upstream</span> <span class="string">error timeout invalid_header http_502;</span></span><br><span class="line">    <span class="meta">&#125;</span>  <span class="string"></span></span><br><span class="line"><span class="meta">&#125;</span>  <span class="string"></span></span><br><span class="line"><span class="attr">server</span> <span class="string">&#123;  </span></span><br><span class="line">    <span class="attr">resolver</span> <span class="string">114.114.114.114;       #指定DNS服务器IP地址  </span></span><br><span class="line">    <span class="attr">listen</span> <span class="string">443;  </span></span><br><span class="line">    <span class="attr">location</span> <span class="string">/ &#123;  </span></span><br><span class="line">       <span class="attr">proxy_pass</span> <span class="string">https://$host$request_uri;    #设定代理服务器的协议和地址  </span></span><br><span class="line">             <span class="attr">proxy_buffers</span> <span class="string">256 4k;</span></span><br><span class="line">             <span class="attr">proxy_max_temp_file_size</span> <span class="string">0k; </span></span><br><span class="line">       <span class="attr">proxy_connect_timeout</span> <span class="string">30;</span></span><br><span class="line">       <span class="attr">proxy_send_timeout</span> <span class="string">60;</span></span><br><span class="line">       <span class="attr">proxy_read_timeout</span> <span class="string">60;</span></span><br><span class="line">       <span class="attr">proxy_next_upstream</span> <span class="string">error timeout invalid_header http_502;</span></span><br><span class="line">    <span class="meta">&#125;</span>  <span class="string"></span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>客户端使用：</p><p>client端：<br>一次代理，直接在shell执行：</p><pre><code>#export http_proxy=http://192.168.1.9:8080</code></pre><p>永久使用：</p><pre><code>#vim .bashrc export http_proxy=http://192.168.1.9:8080#source  .bashrc</code></pre><h2 id="Nginx缓存"><a href="#Nginx缓存" class="headerlink" title="Nginx缓存"></a>Nginx缓存</h2><p>在3天内，通过浏览器地址栏访问 <a href="http://192.168.4.32/a.jpg" target="_blank" rel="noopener">http://192.168.4.32/a.jpg</a> ，不会从服务器抓取资源，3天后（过期）则从服务器重新下载。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># http 区域下添加缓存区配置 </span></span><br><span class="line"><span class="attr">proxy_cache_path</span> <span class="string">/tmp/nginx_proxy_cache levels=1 keys_zone=cache_one:512m inactive=60s max_size=1000m;  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># server 区域下添加缓存配置 </span></span><br><span class="line"><span class="attr">location</span> <span class="string">~ \.(gif|jpg|png|htm|html|css|js)(.*) &#123;  </span></span><br><span class="line">    <span class="attr">proxy_pass</span> <span class="string">http://192.168.4.32:5000；#如果没有缓存则转向请求 </span></span><br><span class="line">    <span class="attr">proxy_redirect</span> <span class="string">off;   </span></span><br><span class="line">    <span class="attr">proxy_cache</span> <span class="string">cache_one;   </span></span><br><span class="line">    <span class="attr">proxy_cache_valid</span> <span class="string">200 1h;            #对不同的 HTTP 状态码设置不同的缓存时间  </span></span><br><span class="line">    <span class="attr">proxy_cache_valid</span> <span class="string">500 1d; </span></span><br><span class="line">    <span class="attr">proxy_cache_valid</span> <span class="string">any 1m;  </span></span><br><span class="line">    <span class="attr">expires</span> <span class="string">3d; </span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>expires 是给一个资源设定一个过期时间，通过 expires 参数设置，可以使浏览器缓存过期时间之前的内容，减少与服务器之间的请求和流量。也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。</p><h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>通过浏览器地址栏访问 <a href="http://www.abc.com/a.html" target="_blank" rel="noopener">www.abc.com/a.html</a> ，访问静态资源服务器的静态资源内容。通过浏览器地址栏访问 <a href="http://www.abc.com/a.jsp" target="_blank" rel="noopener">www.abc.com/a.jsp</a> ，访问动态资源服务器的动态资源内容。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">upstream</span> <span class="string">static &#123;   </span></span><br><span class="line">    <span class="attr">server</span> <span class="string">192.167.4.31:80; </span></span><br><span class="line"><span class="meta">&#125;</span>  <span class="string"></span></span><br><span class="line"></span><br><span class="line"><span class="attr">upstream</span> <span class="string">dynamic &#123;     </span></span><br><span class="line">    <span class="attr">server</span> <span class="string">192.167.4.32:8080; </span></span><br><span class="line"><span class="meta">&#125;</span>  <span class="string"></span></span><br><span class="line"></span><br><span class="line"><span class="attr">server</span> <span class="string">&#123; </span></span><br><span class="line">    <span class="attr">listen</span>       <span class="string">80;   #监听端口  </span></span><br><span class="line">    <span class="attr">server_name</span>  <span class="string">www.abc.com; 监听地址 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">    # 拦截动态资源  </span></span><br><span class="line">    <span class="attr">location</span> <span class="string">~ .*\.(php|jsp)$ &#123;  </span></span><br><span class="line">        <span class="attr">proxy_pass</span> <span class="string">http://dynamic;</span></span><br><span class="line">    <span class="meta">&#125;</span>   <span class="string"></span></span><br><span class="line">      </span><br><span class="line"><span class="comment">    # 拦截静态资源 </span></span><br><span class="line">    <span class="attr">location</span> <span class="string">~ .*\.(jpg|png|htm|html|css|js)$ &#123;  </span></span><br><span class="line">        <span class="attr">root</span> <span class="string">/data/;  #html目录 </span></span><br><span class="line">        <span class="attr">proxy_pass</span> <span class="string">http://static;    </span></span><br><span class="line">        <span class="attr">autoindex</span> <span class="string">on;;  #自动打开文件列表  </span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>一般情况下，通过 nginx 主服务器访问后台目标服务集群，当主服务器挂掉后，自动切换至备份服务器，此时由备份服务器充当主服务器的角色，访问后端目标服务器。</p><p>准备两台nginx服务器，在两台 nginx 服务器上安 keepalived。</p><p>keepalived 相当于一个路由，它通过一个脚本来检测当前服务器是否还活着，如果还活着则继续访问，否则就切换到另一台备份服务器。</p><pre><code>//安装 keepalivedyum install keepalived -y  //检查版本 rpm -q -a keepalived keepalived-1.3.5-16.el7.x86_64</code></pre><p>修改主备服务器 /etc/keepalived/keepalivec.conf 配置文件（可直接替换），完成高可用主从配置。</p><p>keepalived 将 nginx 服务器绑定到一个虚拟 ip ， nginx 高可用集群对外统一暴露这个虚拟 ip，客户端都是通过访问这个虚拟 ip 来访问 nginx 服务器 。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global_defs</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">notification_email</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">acassen@firewall.loc</span></span><br><span class="line">        <span class="attr">failover@firewall.loc</span></span><br><span class="line">        <span class="attr">sysadmin@firewall.loc</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">notification_email_from_Alexandre.Cassen@firewall.loc</span></span><br><span class="line">    <span class="attr">smtp_server</span> <span class="string">192.168.4.32  </span></span><br><span class="line">    <span class="attr">smtp_connect_timeout</span> <span class="string">30</span></span><br><span class="line">    <span class="attr">router_id</span> <span class="string">LVS_DEVEL  # 在 /etc/hosts 文件中配置，通过它能访问到我们的主机 </span></span><br><span class="line"><span class="meta">&#125;</span>  <span class="string"></span></span><br><span class="line"></span><br><span class="line"><span class="attr">vrrp_script_chk_http_port</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">script</span> <span class="string">"/usr/local/src/nginx_check.sh" </span></span><br><span class="line">    <span class="attr">interval</span> <span class="string">2      # 检测脚本执行的时间间隔   </span></span><br><span class="line">    <span class="attr">weight</span> <span class="string">2        # 权重每次加2 </span></span><br><span class="line"><span class="meta">&#125;</span> <span class="string"></span></span><br><span class="line"></span><br><span class="line"><span class="attr">vrrp_instance</span> <span class="string">VI_1 &#123;  </span></span><br><span class="line">    <span class="attr">interface</span> <span class="string">ens7f0 # 网卡，需根据情况修改 </span></span><br><span class="line">    <span class="attr">state</span> <span class="string">MASTER    # 备份服务器上将 MASTER 改为 BACKUP  </span></span><br><span class="line">    <span class="attr">virtual_router_id</span> <span class="string">51 # 主备机的 virtual_router_id 必须相同   </span></span><br><span class="line">    <span class="attr">priority</span> <span class="string">100   # 主备机取不同的优先级，主机值较大，备份机值较小  </span></span><br><span class="line">    <span class="attr">advert_int</span> <span class="string">1  # 每隔多长时间（默认1s）发送一次心跳，检测服务器是否还活着 </span></span><br><span class="line"></span><br><span class="line">    <span class="attr">authentication</span> <span class="string">&#123;  </span></span><br><span class="line">    <span class="attr">auth_type</span> <span class="string">PASS     </span></span><br><span class="line">    <span class="attr">auth_pass</span> <span class="string">1111     </span></span><br><span class="line">    <span class="meta">&#125;</span>  <span class="string"></span></span><br><span class="line"></span><br><span class="line">    <span class="attr">virtual_ipaddress</span> <span class="string">&#123; </span></span><br><span class="line">        <span class="meta">192.168.1.100</span> <span class="string"># VRRP H 虚拟地址，可以绑定多个  </span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>router_id： 在 /etc/hosts 文件中配置，通过它能访问到我们的主机。</p><pre><code>127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4   ::1         localhost localhost.localdomain localhost6 localhost6.localdomain6   127.0.0.1   LVS_DEVEL</code></pre><p>interval： 设置脚本执行的间隔时间</p><p>weight： 当脚本执行失败即 keepalived 或 nginx 挂掉时，权重增加的值（可为负数）。</p><p>interface： 输入 ifconfig 命令查看当前的网卡名是什么。</p><pre><code>ens7f0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500                   inet 192.168.4.32  netmask 255.255.252.0  broadcast 192.168.7.255                   inet6 fe80::e273:9c3c:e675:7c60  prefixlen 64  scopeid 0x20&lt;link&gt;                   ... ...  ... ...</code></pre><p>在 /usr/local/src 目录下添加检测脚本 nginx_check.sh</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash </span></span><br><span class="line"><span class="attr">A</span>=<span class="string">`ps -C nginx -no-header |wc -l` </span></span><br><span class="line"></span><br><span class="line"><span class="attr">if</span> <span class="string">[ $A -eq 0 ];then </span></span><br><span class="line">    <span class="meta">/usr/local/nginx/sbin/nginx</span>  <span class="string"></span></span><br><span class="line">    <span class="attr">sleep</span> <span class="string">2 </span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">if</span> <span class="string">[ ps -C nginx -no-header |wc -l` -eq 0 ];then  </span></span><br><span class="line">        <span class="attr">killall</span> <span class="string">keepalived </span></span><br><span class="line">    <span class="attr">fi</span> <span class="string"></span></span><br><span class="line"><span class="attr">fi</span></span><br></pre></td></tr></table></figure><p>启动两台服务器的 nginx 和 keepalived。</p><pre><code>//启动 nginx ./nginx  //启动 keepalived systemctl start keepalived.service</code></pre><p>查看虚拟 ip 地址 ip a 。把主服务器 192.168.4.32 nginx 和 keepalived停止，再访问虚拟 ip 查看高可用效果。</p><h1 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h1><p><img src="/images/Nginx%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AE%9E%E6%88%98_2020-07-27-15-14-39.png" alt="Nginx——配置文件实战_2020-07-27-15-14-39.png"></p><p>Nginx 启动之后，在 Linux 系统中有两个进程，一个为 master，一个为 worker。master 作为管理员不参与任何工作，只负责给多个 worker 分配不同的任务（worker 一般有多个）。</p><p>客户端发送一个请求首先要经过 master，管理员收到请求后会将请求通知给 worker，多个 worker 以争抢的机制来抢夺任务，得到任务的 worker 会将请求经由 tomcat 等做请求转发、反向代理、访问数据库等（nginx 本身是不直接支持 java 的）。</p><p>Nginx 和 redis 类似，都采用了 io 多路复用机制，每个 worker 都是一个独立的进程，每个进程里只有一个主线程，通过异步非阻塞的方式来处理请求，每个 worker 的线程可以把一个 cpu 的性能发挥到极致，因此，worker 数和服务器的 cpu 数相等是最为适宜的。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx 配置文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx——介绍与安装</title>
      <link href="/2020/07/27/web%E6%9C%8D%E5%8A%A1%E5%99%A8Nginx%E2%80%94%E2%80%94%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85/"/>
      <url>/2020/07/27/web%E6%9C%8D%E5%8A%A1%E5%99%A8Nginx%E2%80%94%E2%80%94%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Nginx 是开源的轻量级 Web 服务器、反向代理服务器，以及负载均衡器和 HTTP 缓存器。其特点是高并发，高性能和低内存。</p><p>Nginx 专为性能优化而开发，性能是其最重要的考量，实现上非常注重效率，能经受高负载的考验，最大能支持 50000 个并发连接数。 Nginx 还支持热部署，它的使用特别容易，几乎可以做到 7x24 小时不间断运行。</p><h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><ol><li><p>正向代理</p><p> Nginx 不仅可以做反向代理，实现负载均衡，还能用做正向代理来进行上网等功能。</p></li></ol><pre><code>![Nginx——介绍与安装_2020-07-27-14-07-31.png](/images/Nginx——介绍与安装_2020-07-27-14-07-31.png)</code></pre><ol start="2"><li><p>反向代理</p><p>客户端对代理服务器是无感知的，客户端不需要做任何配置，用户只请求反向代理服务器，反向代理服务器选择目标服务器，获取数据后再返回给客户端。反向代理服务器和目标服务器对外而言就是一个服务器，只是暴露的是代理服务器地址，而隐藏了真实服务器的IP地址。</p><p><img src="/images/Nginx%E2%80%94%E2%80%94%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85_2020-07-27-14-08-35.png" alt="Nginx——介绍与安装_2020-07-27-14-08-35.png"></p></li></ol><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>将原先请求集中到单个服务器上的情况改为增加服务器的数量，然后将请求分发到各个服务器上，将负载分发到不同的服务器，即负载均衡。</p><p><img src="/images/Nginx%E2%80%94%E2%80%94%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85_2020-07-27-14-09-08.png" alt="Nginx——介绍与安装_2020-07-27-14-09-08.png"></p><h1 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h1><p>为了加快网站的解析速度，可以把静态页面和动态页面由不同的服务器来解析，加快解析速度，降低原来单个服务器的压力。</p><p><img src="/images/Nginx%E2%80%94%E2%80%94%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85_2020-07-27-14-10-09.png" alt="Nginx——介绍与安装_2020-07-27-14-10-09.png"></p><h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><p>为了提高系统的可用性和容错能力，可以增加nginx服务器的数量，当主服务器发生故障或宕机，备份服务器可以立即充当主服务器进行不间断工作。</p><p><img src="/images/Nginx%E2%80%94%E2%80%94%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85_2020-07-27-14-11-38.png" alt="Nginx——介绍与安装_2020-07-27-14-11-38.png"></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装环境 Ubuntu 18.04</p><p>安装</p><pre><code>//更新包sudo apt-get update//下载安装nginxsudo apt-get install nginx</code></pre><p>测试安装</p><pre><code>sudo nginx -t</code></pre><p>显示：</p><pre><code>nginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful</code></pre><p>重启nginx</p><pre><code>sudo service nginx restart</code></pre><h1 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h1><p>删除nginx，-purge包括配置文件</p><pre><code>sudo apt-get --purge remove nginx</code></pre><p>移除全部不使用的软件包</p><pre><code>sudo apt-get autoremove</code></pre><p>罗列出与nginx相关的软件并删除</p><pre><code>dpkg --get-selections|grep nginxsudo apt-get --purge remove nginxsudo apt-get --purge remove nginx-commonsudo apt-get --purge remove nginx-core</code></pre><p>查看nginx正在运行的进程，如果有就kill掉</p><pre><code>ps -ef |grep nginxsudo kill -9 XXX</code></pre><h1 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h1><p>安装完成后</p><pre><code>cd /etc/nginx</code></pre><p>查看目录，显示如下：</p><p><img src="/images/Nginx%E2%80%94%E2%80%94%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85_2020-07-27-14-25-25.png" alt="Nginx——介绍与安装_2020-07-27-14-25-25.png"></p><p>最新版本nginx配置是由4个文件构成：</p><ol><li><code>conf.d</code>：用户自己定义的conf配置文件</li><li><code>sites-available</code>：系统默认设置的配置文件</li><li><code>sites-enabled</code>：由sites-available中的配置文件转换生成</li><li><code>nginx.conf</code>：汇总以上三个配置文件的内容，同时配置我们所需要的参数</li></ol><p>在部署需要的web服务时，我们可以拷贝sites-enabled中的default文件到conf.d并且修改名字为**.conf,然后进行配置,每次配置完都要重启nginx。</p><p>具体配置详见 </p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx 介绍与安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat——性能优化（三）</title>
      <link href="/2020/07/24/web%E6%9C%8D%E5%8A%A1%E5%99%A8Tomcat%E2%80%94%E2%80%94%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2020/07/24/web%E6%9C%8D%E5%8A%A1%E5%99%A8Tomcat%E2%80%94%E2%80%94%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于JavaWeb开发人员而言，Tomcat已成为默认的web服务器，但是在生产环境下使用Tomcat部署应用，我们如果采用Tomcat默认的配置，尤其是内存和线程的配置，其配置都很低，容易成为性能瓶颈，所以我们需要对Tomcat服务器进行优化，提升其运行性能。</p><h1 id="内存优化，"><a href="#内存优化，" class="headerlink" title="内存优化，"></a>内存优化，</h1><p>启动时告诉JVM需要多大内存(调优内存是最直接的方式)<br>Windows 下的 catalina.bat</p><p>Linux 下的 catalina.sh</p><p>在该文件中配置jvm的内存空间，如: JAVA_OPTS=’-Xms256m -Xmx512m’</p><p>-Xms JVM初始化堆的大小</p><p>-Xmx JVM堆的最大值，实际参数大小根据服务器配置或者项目具体设置;</p><h1 id="线程优化"><a href="#线程优化" class="headerlink" title="线程优化"></a>线程优化</h1><p>在server.xml中配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"80"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attr">maxThreads</span>=<span class="string">"600"</span> <span class="attr">minSpareThreads</span>=<span class="string">"100"</span> <span class="attr">maxSpareThreads</span>=<span class="string">"500"</span> <span class="attr">acceptCount</span>=<span class="string">"700"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">connectionTimeout</span>=<span class="string">"20000"</span>  /&gt;</span></span><br></pre></td></tr></table></figure><p>maxSpareThreads=”X” 表示如果最多可以有X个线程，一旦超过X个,则会关闭不在需要的线程</p><p>acceptCount=”X” 当同时连接的人数达到maxThreads时,还可以排队,队列大小为X.超过X就不处理</p><h1 id="IO-优化"><a href="#IO-优化" class="headerlink" title="IO 优化"></a>IO 优化</h1><p>1：同步阻塞IO(JAVA BIO) 同步并阻塞，服务器实现模式为一个连接一个线程(one connection one thread 想想都觉得恐怖，线程可是非常宝贵的资源)，当然可以通过线程池机制改善.</p><p>2：JAVA NIO 又分为同步非阻塞IO，异步阻塞IO与BIO最大的区别one request one thread.可以复用同一个线程处理多个connection(多路复用).</p><p>3：异步非阻塞IO(Java NIO2又叫AIO) 主要与NIO的区别主要是操作系统的底层区别，可以做个比喻：比作快递，NIO就是网购后要自己到官网查下快递是否已经到了(可能是多次)，然后自己去取快递;AIO就是快递员送货上门了(不用关注快递进度)。</p><p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解.</p><p>NIO方式适用于连接数目多且连接比较短(轻操作)的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持.</p><p>AIO方式使用于连接数目多且连接比较长(重操作)的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持.</p><p>在server.xml中</p><p><Connector port="80" protocol="org.apache.coyote.http11.Http11NioProtocol"      connectionTimeout="20000"      URIEncoding="UTF-8"      useBodyEncodingForURI="true"      enableLookups="false"      redirectPort="8443" /> </p><p>实现对Tomcat的IO切换。</p><h1 id="大杀器APR"><a href="#大杀器APR" class="headerlink" title="大杀器APR"></a>大杀器APR</h1><p>APR是从操作系统级别来解决异步的IO问题，大幅度的提高性能. (<a href="http://apr.apache.org/)。" target="_blank" rel="noopener">http://apr.apache.org/)。</a></p><p>APR(Apache Portable Runtime)是一个高可移植库，它是Apache HTTP Server 2.x 的核心，能更好地和其它本地web技术集成，总体上让Java更有效率作为一个高性能web服务器平台而不是简单作为后台容器;</p><p>在产品环境中，特别是直接使用Tomcat做WEB服务器的时候，应该使用Tomcat Native来提高其性能，如果不配APR，基本上300个线程狠快就会用满，以后的请求就只好等待.但是配上APR之后，并发的线程数量明显下降，从原来的300可能会马上下降到只有几十，新的请求会毫无阻塞的进来;</p><p>在局域网环境测，就算是400个并发，也是一瞬间就处理/传输完毕，但是在真实的Internet环境下，页面处理时间只占0.1%都不到，绝大部分时间都用来页面传输，如果不用APR，一个线程同一时间只能处理一个用户，势必会造成阻塞，所以生产环境下用apr是非常必要的.</p><p>安装Apache Tomcat Native Library，直接启动就支持apr(<a href="http://tomcat.apache.org/native-doc/)它本身是基于APR的，排除代码问题Tomcat优化到这个层次,可以应对大部分性能需求" target="_blank" rel="noopener">http://tomcat.apache.org/native-doc/)它本身是基于APR的，排除代码问题Tomcat优化到这个层次,可以应对大部分性能需求</a>;</p><p>最后，优化的前提条件是良好的代码质量和设计。</p>]]></content>
      
      
      <categories>
          
          <category> Tomcat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tomcat 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat——配置（二）</title>
      <link href="/2020/07/24/web%E6%9C%8D%E5%8A%A1%E5%99%A8Tomcat%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/07/24/web%E6%9C%8D%E5%8A%A1%E5%99%A8Tomcat%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Tomcat隶属于Apache基金会，是开源的轻量级Web应用服务器，使用非常广泛。<code>server.xml</code> 是Tomcat中最重要的配置文件，<code>server.xml</code> 的每一个元素都对应了Tomcat中的一个组件；通过对xml文件中元素的配置，可以实现对Tomcat中各个组件的控制。</p><h1 id="server-xml配置实例"><a href="#server-xml配置实例" class="headerlink" title="server.xml配置实例"></a>server.xml配置实例</h1><p>server.xml位于$TOMCAT_HOME/conf目录下；下面是一个server.xml实例。后文中将结合该实例讲解server.xml中，各个元素的含义和作用；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">"8005"</span> <span class="attr">shutdown</span>=<span class="string">"SHUTDOWN"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.startup.VersionLoggerListener"</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.AprLifecycleListener"</span> <span class="attr">SSLEngine</span>=<span class="string">"on"</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.JasperListener"</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.JreMemoryLeakPreventionListener"</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener"</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.ThreadLocalLeakPreventionListener"</span> /&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">GlobalNamingResources</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">"UserDatabase"</span> <span class="attr">auth</span>=<span class="string">"Container"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">type</span>=<span class="string">"org.apache.catalina.UserDatabase"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">description</span>=<span class="string">"User database that can be updated and saved"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">factory</span>=<span class="string">"org.apache.catalina.users.MemoryUserDatabaseFactory"</span>  </span></span><br><span class="line"><span class="tag">               <span class="attr">pathname</span>=<span class="string">"conf/tomcat-users.xml"</span> /&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;/<span class="name">GlobalNamingResources</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">"Catalina"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span>  </span></span><br><span class="line"><span class="tag">                <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span>  </span></span><br><span class="line"><span class="tag">                <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8009"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">"Catalina"</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.LockOutRealm"</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.UserDatabaseRealm"</span>  </span></span><br><span class="line"><span class="tag">                <span class="attr">resourceName</span>=<span class="string">"UserDatabase"</span>/&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;/<span class="name">Realm</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span>  <span class="attr">appBase</span>=<span class="string">"webapps"</span>  </span></span><br><span class="line"><span class="tag">             <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="attr">directory</span>=<span class="string">"logs"</span>  </span></span><br><span class="line"><span class="tag">                <span class="attr">prefix</span>=<span class="string">"localhost_access_log."</span> <span class="attr">suffix</span>=<span class="string">".txt"</span>  </span></span><br><span class="line"><span class="tag">                <span class="attr">pattern</span>=<span class="string">"%h %l %u %t "</span>%<span class="attr">r</span>" %<span class="attr">s</span> %<span class="attr">b</span>" /&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;/<span class="name">Host</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;/<span class="name">Service</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h1><ol><li><p>server</p><p> 在第一部分的例子中，在最外层有一个<Server>元素，shutdown属性表示关闭Server的指令；port属性表示Server接收shutdown指令的端口号，设为-1可以禁掉该端口。</p></li><li><p>Service</p><p> 在第一部分的例子中，Server中包含一个名称为“Catalina”的Service。实际上，Tomcat可以提供多个Service，不同的Service监听不同的端口</p></li><li><p>Connector</p><p> 通过配置Connector，可以控制请求Service的协议及端口号。在第一部分的例子中，Service包含两个Connector：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8009"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p> 通过配置第1个Connector，客户端可以通过8080端口号使用http协议访问Tomcat。其中，protocol属性规定了请求的协议，port规定了请求的端口号，redirectPort表示当强制要求https而请求是http时，重定向至端口号为8443的Connector，connectionTimeout表示连接的超时时间。</p><p> Tomcat监听HTTP请求，使用的是8080端口，而不是正式的80端口；实际上，在正式的生产环境中，Tomcat也常常监听8080端口，而不是80端口。这是因为在生产环境中，很少将Tomcat直接对外开放接收请求，而是在Tomcat和客户端之间加一层代理服务器(如nginx)，用于请求的转发、负载均衡、处理静态文件等；通过代理服务器访问Tomcat时，是在局域网中，因此一般仍使用8080端口。</p><p> 通过配置第2个Connector，客户端可以通过8009端口号使用AJP协议访问Tomcat。AJP协议负责和其他的HTTP服务器(如Apache)建立连接；在把Tomcat与其他HTTP服务器集成时，就需要用到这个连接器。之所以使用Tomcat和其他服务器集成，是因为Tomcat可以用作Servlet/JSP容器，但是对静态资源的处理速度较慢，不如Apache和IIS等HTTP服务器；因此常常将Tomcat与Apache等集成，前者作Servlet容器，后者处理静态资源，而AJP协议便负责Tomcat和Apache的连接。</p></li><li><p>Engine</p><p> Engine组件在Service组件中有且只有一个；Engine是Service组件中的请求处理组件。Engine组件从一个或多个Connector中接收请求并处理，并将完成的响应返回给Connector，最终传递给客户端。</p><p> 在第一部分的例子中，Engine的配置语句如下：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">"Catalina"</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 其中，name属性用于日志和错误信息，在整个Server中应该唯一。defaultHost属性指定了默认的host名称，当发往本机的请求指定的host名称不存在时，一律使用defaultHost指定的host进行处理；因此，defaultHost的值，必须与Engine中的一个Host组件的name属性值匹配。</p></li><li><p>Host</p><p> Host是Engine的子容器。Engine组件中可以内嵌1个或多个Host组件，每个Host组件代表Engine中的一个虚拟主机。Host组件至少有一个，且其中一个的name必须与Engine组件的defaultHost属性相匹配。</p><p> Host虚拟主机的作用，是运行多个Web应用（一个Context代表一个Web应用），并负责安装、展开、启动和结束每个Web应用。</p><p> 在第一部分的例子中，Host的配置如下：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span> <span class="attr">appBase</span>=<span class="string">"webapps"</span> <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></table></figure><p> name属性指定虚拟主机的主机名，一个Engine中有且仅有一个Host组件的name属性与Engine组件的defaultHost属性相匹配；一般情况下，主机名需要是在DNS服务器中注册的网络名，但是Engine指定的defaultHost不需要，原因在前面已经说明。</p><p> unpackWARs指定了是否将代表Web应用的WAR文件解压；如果为true，通过解压后的文件结构运行该Web应用，如果为false，直接使用WAR文件运行Web应用。</p><p> Host的autoDeploy和appBase属性，与Host内Web应用的自动部署有关；</p></li><li><p>context</p><p> Context元素代表在特定虚拟主机上运行的一个Web应用,Context是Host的子容器，每个Host中可以定义任意多的Context元素。</p><p> 在第一部分的例子中，可以看到server.xml配置文件中并没有出现Context元素的配置。这是因为，Tomcat开启了自动部署，Web应用没有在server.xml中配置静态部署，而是由Tomcat通过特定的规则自动部署。</p></li></ol><h1 id="如何配置多个服务"><a href="#如何配置多个服务" class="headerlink" title="如何配置多个服务"></a>如何配置多个服务</h1><p>通过在Server中配置多个Service服务，可以实现通过不同的端口号来访问同一台机器上部署的不同Web应用。</p><p>在server.xml中配置多服务的方法非常简单，分为以下几步：</p><ol><li><p>复制<Service>元素，放在当前<Service>后面。</p></li><li><p>修改端口号：根据需要监听的端口号修改<Connector>元素的port属性；必须确保该端口没有被其他进程占用，否则Tomcat启动时会报错，而无法通过该端口访问Web应用。</p></li></ol><h1 id="其他组件"><a href="#其他组件" class="headerlink" title="其他组件"></a>其他组件</h1><p>除核心组件外，server.xml中还可以配置很多其他组件。下面只介绍第一部分例子中出现的组件，如果要了解更多内容，可以查看Tomcat官方文档。</p><ol><li><p>listener</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.startup.VersionLoggerListener"</span> /&gt;</span>  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.AprLifecycleListener"</span> <span class="attr">SSLEngine</span>=<span class="string">"on"</span> /&gt;</span>  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.JasperListener"</span> /&gt;</span>  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.JreMemoryLeakPreventionListener"</span> /&gt;</span>  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener"</span> /&gt;</span>  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.ThreadLocalLeakPreventionListener"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p> Listener(即监听器)定义的组件，可以在特定事件发生时执行特定的操作；被监听的事件通常是Tomcat的启动和停止。</p></li><li><p>Realm</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.LockOutRealm"</span>&gt;</span>  <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.UserDatabaseRealm"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">resourceName</span>=<span class="string">"UserDatabase"</span>/&gt;</span>  <span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></span><br></pre></td></tr></table></figure><p> Realm，可以把它理解成“域”；Realm提供了一种用户密码与web应用的映射关系，从而达到角色安全管理的作用。在本例中，Realm的配置使用name为UserDatabase的资源实现。而该资源在Server元素中使用GlobalNamingResources配置：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">GlobalNamingResources</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">"UserDatabase"</span> <span class="attr">auth</span>=<span class="string">"Container"</span> <span class="attr">type</span>=<span class="string">"org.apache.catalina.UserDatabase"</span> <span class="attr">description</span>=<span class="string">"User database that can be updated and saved"</span> <span class="attr">factory</span>=<span class="string">"org.apache.catalina.users.MemoryUserDatabaseFactory"</span> <span class="attr">pathname</span>=<span class="string">"conf/tomcat-users.xml"</span> /&gt;</span>  <span class="tag">&lt;/<span class="name">GlobalNamingResources</span>&gt;</span></span><br></pre></td></tr></table></figure><p> GlobalNamingResources元素定义了全局资源，通过配置可以看出，该配置是通过读取$TOMCAT_HOME/ conf/tomcat-users.xml实现的。</p></li><li><p>value</p><p> 在第一部分的例子中，Host元素内定义了Valve组件：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="attr">directory</span>=<span class="string">"logs"</span> <span class="attr">prefix</span>=<span class="string">"localhost_access_log."</span> <span class="attr">suffix</span>=<span class="string">".txt"</span> <span class="attr">pattern</span>=<span class="string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p> 单词Valve的意思是“阀门”，在Tomcat中代表了请求处理流水线上的一个组件；Valve可以与Tomcat的容器(Engine、Host或Context)关联。</p><p> AccessLogValve的作用是通过日志记录其所在的容器中处理的所有请求，在本例中，Valve放在Host下，便可以记录该Host处理的所有请求。AccessLogValve记录的日志就是访问日志，每天的请求会写到一个日志文件里。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Tomcat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tomcat 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat——解析（一）</title>
      <link href="/2020/07/24/web%E6%9C%8D%E5%8A%A1%E5%99%A8Tomcat%E2%80%94%E2%80%94%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/07/24/web%E6%9C%8D%E5%8A%A1%E5%99%A8Tomcat%E2%80%94%E2%80%94%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Tomcat是Apache组织在符合J2EE的JSP、Servlet标准下开发的一个JSP服务器 。</p><p>apache是web服务器，tomcat是应用（java）服务器，它只是一个servlet(jsp也翻译成servlet)容器，可以认为是apache的扩展，但是可以独立于apache运行。 </p><h1 id="tomcat为啥需要JDK"><a href="#tomcat为啥需要JDK" class="headerlink" title="tomcat为啥需要JDK"></a>tomcat为啥需要JDK</h1><p>因为tomcat是用java写的,所以运行需要JRE，但是JRE只是运行时刻化境，不能编译JAVA源程序。</p><p>当有请求时,tomcat会自动将jsp里面的java程序部分提取出来,调用jdk将java程序编译成class,然后再执行这个class.你可以到tomcat的work目录下看看,你可以找到从jsp里面提取出来的java程序, <strong>*_jsp.java,也有编译后的class文件,   *</strong>_jsp.class。 </p><p>所以，如果不装JDK，jsp程序就无法编译。</p><p>因为jsp转换成servlet后需要编译，所以需要jdk,只需要JRE。</p><p>tomcat6以后都是自带了eclipse基金会的JAVA编译器的，到lib目录下看看，绝对有jasper-jdt.jar，所以现代的tomcat都只需要一个JRE就可以了。</p><h1 id="顶层架构"><a href="#顶层架构" class="headerlink" title="顶层架构"></a>顶层架构</h1><p>先上一张Tomcat的顶层结构图（图A），如下：</p><p><img src="/images/Tomcat%E2%80%94%E2%80%94%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89_2020-07-24-09-42-56.png" alt="Tomcat——解析（一）_2020-07-24-09-42-56.png"></p><ol><li><p>Tomcat中只有一个Server，一个Server可以有多个Service，一个Service可以有多个Connector和一个Container； </p></li><li><p>Server掌管着整个Tomcat的生死大权</p></li><li><p>Service 是对外提供服务的； </p></li><li><p>Connector用于接受请求并将请求封装成Request和Response来具体处理； </p></li><li><p>Container用于封装和管理Servlet，以及具体处理request请求；</p></li></ol><p><img src="/images/Tomcat%E2%80%94%E2%80%94%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89_2020-07-24-09-49-43.png" alt="Tomcat——解析（一）_2020-07-24-09-49-43.png"></p><p>小结：多个 Connector 和一个 Container 就形成了一个 Service，有了 Service 就可以对外提供服务了，但是 Service 还要一个生存的环境，必须要有人能够给她生命、掌握其生死大权，那就非 Server 莫属了！所以整个 Tomcat 的生命周期由 Server 控制。</p><h1 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h1><p>对于绝大多数的开发人员来说Server和Service对我们来说确实很远，而我们开发中绝大部分进行配置的内容是属于Connector和Container的</p><p>一个请求发送到Tomcat之后，首先经过Service然后会交给我们的Connector，Connector用于接收请求并将接收的请求封装为Request和Response来具体处理，Request和Response封装完之后再交由Container进行处理，Container处理完请求之后再返回给Connector，最后在由Connector通过Socket将处理的结果返回给客户端。</p><h1 id="Connector架构"><a href="#Connector架构" class="headerlink" title="Connector架构"></a>Connector架构</h1><p>Connector用于接受请求并将请求封装成Request和Response，然后交给Container进行处理，Container处理完之后在交给Connector返回给客户端。</p><p>Connector最底层使用的是Socket来进行连接的，Request和Response是按照HTTP协议来封装的，所以Connector同时需要实现TCP/IP协议和HTTP协议！</p><p><img src="/images/Tomcat%E2%80%94%E2%80%94%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89_2020-07-24-09-59-44.png" alt="Tomcat——解析（一）_2020-07-24-09-59-44.png"></p><ol><li><p>Connector如何接受请求的？ </p><p> Connector就是使用ProtocolHandler来处理请求的，不同的ProtocolHandler代表不同的连接类型，比如：Http11Protocol使用的是普通Socket来连接的，Http11NioProtocol使用的是NioSocket来连接的。</p></li><li><p>如何将请求封装成Request和Response的？ </p><p> Endpoint用来处理底层Socket的网络连接，Processor用于将Endpoint接收到的Socket封装成Request。</p><p> Endpoint的抽象实现AbstractEndpoint里面定义的Acceptor和AsyncTimeout两个内部类和一个Handler接口。Acceptor用于监听请求，AsyncTimeout用于检查异步Request的超时，Handler用于处理接收到的Socket，在内部调用Processor进行处理。</p></li><li><p>封装完之后的Request和Response如何交给Container进行处理的？ </p><p> Adapter将请求适配到Servlet容器进行具体的处理。</p></li></ol><h1 id="Container架构"><a href="#Container架构" class="headerlink" title="Container架构"></a>Container架构</h1><p>结构图如下（图C）：</p><p><img src="/images/Tomcat%E2%80%94%E2%80%94%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89_2020-07-24-10-06-48.png" alt="Tomcat——解析（一）_2020-07-24-10-06-48.png"></p><p>4个子容器的作用分别是：</p><ol><li><p>Engine：引擎，用来管理多个站点，一个Service最多只能有一个Engine； </p></li><li><p>代表一个站点，也可以叫虚拟主机，通过配置Host就可以添加站点； </p></li><li><p>Context：代表一个应用程序，对应着平时开发的一套程序，或者一个WEB-INF目录以及下面的web.xml文件； </p></li><li><p>Wrapper：每一Wrapper封装着一个Servlet；</p></li></ol><p>下面找一个Tomcat的文件目录对照一下，如下图所示：</p><p><img src="/images/Tomcat%E2%80%94%E2%80%94%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89_2020-07-24-10-08-54.png" alt="Tomcat——解析（一）_2020-07-24-10-08-54.png"></p><p>Context和Host的区别是Context表示一个应用，我们的Tomcat中默认的配置下webapps下的每一个文件夹目录都是一个Context，其中ROOT目录中存放着主应用，其他目录存放着子应用，而整个webapps就是一个Host站点。</p><p>我们访问应用Context的时候，如果是ROOT下的则直接使用域名就可以访问，例如：<a href="http://www.ledouit.com，" target="_blank" rel="noopener">www.ledouit.com，</a> 如果是Host（webapps）下的其他应用，则可以使用<a href="http://www.ledouit.com/docs进行访问，当然默认指定的根应用（ROOT）是可以进行设定的，只不过Host站点下默认的主营用是ROOT目录下的。" target="_blank" rel="noopener">www.ledouit.com/docs进行访问，当然默认指定的根应用（ROOT）是可以进行设定的，只不过Host站点下默认的主营用是ROOT目录下的。</a></p><ol><li><p>Container是如何进行处理的以及处理完之后是如何将处理完的结果返回给Connector的？</p><p> Container处理请求是使用Pipeline-Valve管道来处理的！（Valve是阀门之意）</p><p> Pipeline-Valve是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将处理后的请求返回，再让下一个处理着继续处理。</p></li><li><p>处理流程</p><p><img src="/images/Tomcat%E2%80%94%E2%80%94%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89_2020-07-24-10-13-09.png" alt="Tomcat——解析（一）_2020-07-24-10-13-09.png"></p><p> Connector在接收到请求后会首先调用最顶层容器的Pipeline来处理，这里的最顶层容器的Pipeline就是EnginePipeline（Engine的管道）；</p><p> 在Engine的管道中依次会执行EngineValve1、EngineValve2等等，最后会执行StandardEngineValve，在StandardEngineValve中会调用Host管道，然后再依次执行Host的HostValve1、HostValve2等，最后在执行StandardHostValve，然后再依次调用Context的管道和Wrapper的管道，最后执行到StandardWrapperValve。</p><p> 当执行到StandardWrapperValve的时候，会在StandardWrapperValve中创建FilterChain，并调用其doFilter方法来处理请求，这个FilterChain包含着我们配置的与请求相匹配的Filter和Servlet，其doFilter方法会依次调用所有的Filter的doFilter方法和Servlet的service方法，这样请求就得到了处理！</p><p> 当所有的Pipeline-Valve都执行完之后，并且处理完了具体的请求，这个时候就可以将返回的结果交给Connector了，Connector在通过Socket的方式将结果返回给客户端。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Tomacat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tomcat 解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA——IO</title>
      <link href="/2020/07/22/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94IO/"/>
      <url>/2020/07/22/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94IO/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>IO是指Input/Output，即输入和输出。以内存为中心：</p><ul><li>Input指从外部读入数据到内存，例如，把文件从磁盘读取到内存，从网络读取数据到内存等等。</li><li>Output指把数据从内存输出到外部，例如，把数据从内存写入到文件，把数据从内存输出到网络等等。</li></ul><p>IO流是一种顺序读写数据的模式，它的特点是单向流动。数据类似自来水一样在水管中流动，所以我们把它称为IO流。</p><p>Java标准库的java.io包提供了同步IO功能：</p><ul><li>字节流接口：InputStream/OutputStream；</li><li>字符流接口：Reader/Writer。</li></ul><h1 id="File对象"><a href="#File对象" class="headerlink" title="File对象"></a>File对象</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">要构造一个File对象，需要传入文件路径：</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"C:\\Windows\\notepad.exe"</span>);</span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造File对象时，既可以传入绝对路径，也可以传入相对路径。绝对路径是以根目录开头的完整路径，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">"C:\\Windows\\notepad.exe"</span>);</span><br></pre></td></tr></table></figure><p>传入相对路径时，相对路径前面加上当前目录就是绝对路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设当前目录是C:\Docs</span></span><br><span class="line">File f1 = <span class="keyword">new</span> File(<span class="string">"sub\\javac"</span>); <span class="comment">// 绝对路径是C:\Docs\sub\javac</span></span><br><span class="line">File f3 = <span class="keyword">new</span> File(<span class="string">".\\sub\\javac"</span>); <span class="comment">// 绝对路径是C:\Docs\sub\javac</span></span><br><span class="line">File f3 = <span class="keyword">new</span> File(<span class="string">"..\\sub\\javac"</span>); <span class="comment">// 绝对路径是C:\sub\javac</span></span><br></pre></td></tr></table></figure><p>可以用 . 表示当前目录，.. 表示上级目录。</p><p>File对象有3种形式表示的路径，一种是getPath()，返回构造方法传入的路径，一种是getAbsolutePath()，返回绝对路径，一种是getCanonicalPath，它和绝对路径类似，但是返回的是规范路径。</p><p>File对象既可以表示文件，也可以表示目录。特别要注意的是，构造一个File对象，即使传入的文件或目录不存在，代码也不会出错，因为构造一个File对象，并不会导致任何磁盘操作。只有当我们调用File对象的某些方法的时候，才真正进行磁盘操作。</p><p>例如，调用isFile()，判断该File对象是否是一个已存在的文件，调用isDirectory()，判断该File对象是否是一个已存在的目录：</p><p>用File对象获取到一个文件时，还可以进一步判断文件的权限和大小：</p><ul><li>boolean canRead()：是否可读；</li><li>boolean canWrite()：是否可写；</li><li>boolean canExecute()：是否可执行；</li><li>long length()：文件字节大小。</li></ul><p>创建和删除文件：</p><p>当File对象表示一个文件时，可以通过createNewFile()创建一个新文件，用delete()删除该文件：</p><p>创建和删除临时文件：</p><p>有些时候，程序需要读写一些临时文件，File对象提供了createTempFile()来创建一个临时文件，以及deleteOnExit()在JVM退出时自动删除该文件。</p><p>遍历文件和目录：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"C:\\Windows"</span>);</span><br><span class="line">        File[] fs1 = f.listFiles(); <span class="comment">// 列出所有文件和子目录</span></span><br><span class="line">        printFiles(fs1);</span><br><span class="line">        File[] fs2 = f.listFiles(<span class="keyword">new</span> FilenameFilter() &#123; <span class="comment">// 仅列出.exe文件</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> name.endsWith(<span class="string">".exe"</span>); <span class="comment">// 返回true表示接受该文件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        printFiles(fs2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFiles</span><span class="params">(File[] files)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=========="</span>);</span><br><span class="line">        <span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">                System.out.println(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"=========="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和文件操作类似，File对象如果表示一个目录，可以通过以下方法创建和删除目录：</p><ul><li>boolean mkdir()：创建当前File对象表示的目录；</li><li>boolean mkdirs()：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来；</li><li>boolean delete()：删除当前File对象表示的目录，当前目录必须为空才能删除成功。</li></ul><h1 id="Path-对象"><a href="#Path-对象" class="headerlink" title="Path 对象"></a>Path 对象</h1><p>Java标准库还提供了一个Path对象，它位于java.nio.file包。Path对象和File对象类似，但操作更加简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Path p1 = Paths.get(<span class="string">"."</span>, <span class="string">"project"</span>, <span class="string">"study"</span>); <span class="comment">// 构造一个Path对象</span></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        Path p2 = p1.toAbsolutePath(); <span class="comment">// 转换为绝对路径</span></span><br><span class="line">        System.out.println(p2);</span><br><span class="line">        Path p3 = p2.normalize(); <span class="comment">// 转换为规范路径</span></span><br><span class="line">        System.out.println(p3);</span><br><span class="line">        File f = p3.toFile(); <span class="comment">// 转换为File对象</span></span><br><span class="line">        System.out.println(f);</span><br><span class="line">        <span class="keyword">for</span> (Path p : Paths.get(<span class="string">".."</span>).toAbsolutePath()) &#123; <span class="comment">// 可以直接遍历Path</span></span><br><span class="line">            System.out.println(<span class="string">"  "</span> + p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h1><p>InputStream就是Java标准库提供的最基本的输入流。它位于java.io这个包里。java.io包提供了所有同步IO的功能。</p><p>要特别注意的一点是，InputStream并不是一个接口，而是一个抽象类，它是所有输入流的超类。这个抽象类定义的一个最重要的方法就是int read()，签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><p>FileInputStream是InputStream的一个子类。顾名思义，FileInputStream就是从文件流中读取数据。下面的代码演示了如何完整地读取一个FileInputStream的所有字节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个FileInputStream对象:</span></span><br><span class="line">    InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"src/readme.txt"</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = input.read(); <span class="comment">// 反复调用read()方法，直到返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (n == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(n); <span class="comment">// 打印byte的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    input.close(); <span class="comment">// 关闭流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细观察上面的代码，会发现一个潜在的问题：如果读取过程中发生了IO错误，InputStream就没法正确地关闭，资源也就没法及时释放。</p><p>因此，我们需要用try … finally来保证InputStream在无论是否发生IO错误的时候都能够正确地关闭：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream input = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        input = <span class="keyword">new</span> FileInputStream(<span class="string">"src/readme.txt"</span>);</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123; <span class="comment">// 利用while同时读取并判断</span></span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (input != <span class="keyword">null</span>) &#123; input.close(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用try … finally来编写上述代码会感觉比较复杂，更好的写法是利用Java 7引入的新的try(resource)的语法，只需要编写try语句，让编译器自动为我们关闭资源。推荐的写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"src/readme.txt"</span>)) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 编译器在此自动为我们写入finally并调用close()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缓冲：</p><p>在读取流的时候，一次读取一个字节并不是最高效的方法。很多流支持一次性读取多个字节到缓冲区，对于文件和网络流来说，利用缓冲区一次性读取多个字节效率往往要高很多。InputStream提供了两个重载方法来支持读取多个字节：</p><ul><li>int read(byte[] b)：读取若干字节并填充到byte[]数组，返回读取的字节数</li><li>int read(byte[] b, int off, int len)：指定byte[]数组的偏移量和最大填充数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"src/readme.txt"</span>)) &#123;</span><br><span class="line">        <span class="comment">// 定义1000个字节大小的缓冲区:</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>];</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read(buffer)) != -<span class="number">1</span>) &#123; <span class="comment">// 读取到缓冲区</span></span><br><span class="line">            System.out.println(<span class="string">"read "</span> + n + <span class="string">" bytes."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h1><p>和InputStream相反，OutputStream是Java标准库提供的最基本的输出流。</p><p>和InputStream类似，OutputStream也是抽象类，它是所有输出流的超类。这个抽象类定义的一个最重要的方法就是void write(int b)，签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><p>和InputStream类似，OutputStream也提供了close()方法关闭输出流，以便释放系统资源。要特别注意：OutputStream还提供了一个flush()方法，它的目的是将缓冲区的内容真正输出到目的地。</p><p>为什么要有flush()？</p><p>因为向磁盘、网络写入数据的时候，出于效率的考虑，操作系统并不是输出一个字节就立刻写入到文件或者发送到网络，而是把输出的字节先放到内存的一个缓冲区里（本质上就是一个byte[]数组），等到缓冲区写满了，再一次性写入文件或者网络。</p><p>对于很多IO设备来说，一次写一个字节和一次写1000个字节，花费的时间几乎是完全一样的，所以OutputStream有个flush()方法，能强制把缓冲区内容输出。</p><p>通常情况下，我们不需要调用这个flush()方法，因为缓冲区写满了OutputStream会自动调用它，并且，在调用close()方法关闭OutputStream之前，也会自动调用flush()方法。</p><p>但是，在某些情况下，我们必须手动调用flush()方法。比如聊天软件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">"out/readme.txt"</span>)) &#123;</span><br><span class="line">        output.write(<span class="string">"Hello"</span>.getBytes(<span class="string">"UTF-8"</span>)); <span class="comment">// Hello</span></span><br><span class="line">    &#125; <span class="comment">// 编译器在此自动为我们写入finally并调用close()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h1><p>InputStream 可以派生出很多子类：</p><p>如果我们要给FileInputStream添加缓冲功能，则可以从FileInputStream派生一个类：</p><p>BufferedFileInputStream extends FileInputStream<br>如果要给FileInputStream添加计算签名的功能，类似的，也可以从FileInputStream派生一个类：</p><p>DigestFileInputStream extends FileInputStream<br>如果要给FileInputStream添加加密/解密功能，还是可以从FileInputStream派生一个类：</p><p>CipherFileInputStream extends FileInputStream<br>如果要给FileInputStream添加缓冲和签名的功能，那么我们还需要派生BufferedDigestFileInputStream。如果要给FileInputStream添加缓冲和加解密的功能，则需要派生BufferedCipherFileInputStream。</p><p>上述这种通过一个“基础”组件再叠加各种“附加”功能组件的模式，称之为Filter模式（或者装饰器模式：Decorator）。它可以让我们通过少量的类来实现各种功能的组合：</p><p>类似的，OutputStream也是以这种模式来提供各种功能。</p><h1 id="操作zip"><a href="#操作zip" class="headerlink" title="操作zip"></a>操作zip</h1><p>读取zip:</p><p>ZipInputStream是一种FilterInputStream，它可以直接读取zip包的内容：</p><p>我们来看看ZipInputStream的基本用法。</p><p>我们要创建一个ZipInputStream，通常是传入一个FileInputStream作为数据源，然后，循环调用getNextEntry()，直到返回null，表示zip流结束。</p><p>一个ZipEntry表示一个压缩文件或目录，如果是压缩文件，我们就用read()方法不断读取，直到返回-1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (ZipInputStream zip = <span class="keyword">new</span> ZipInputStream(<span class="keyword">new</span> FileInputStream(...))) &#123;</span><br><span class="line">    ZipEntry entry = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> ((entry = zip.getNextEntry()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String name = entry.getName();</span><br><span class="line">        <span class="keyword">if</span> (!entry.isDirectory()) &#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = zip.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写入zip</p><p>ZipOutputStream是一种FilterOutputStream，它可以直接写入内容到zip包。我们要先创建一个ZipOutputStream，通常是包装一个FileOutputStream，然后，每写入一个文件前，先调用putNextEntry()，然后用write()写入byte[]数据，写入完毕后调用closeEntry()结束这个文件的打包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (ZipOutputStream zip = <span class="keyword">new</span> ZipOutputStream(<span class="keyword">new</span> FileOutputStream(...))) &#123;</span><br><span class="line">    File[] files = ...</span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">        zip.putNextEntry(<span class="keyword">new</span> ZipEntry(file.getName()));</span><br><span class="line">        zip.write(getFileDataAsBytes(file));</span><br><span class="line">        zip.closeEntry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码没有考虑文件的目录结构。如果要实现目录层次结构，new ZipEntry(name)传入的name要用相对路径。</p><h1 id="读取classpath资源"><a href="#读取classpath资源" class="headerlink" title="读取classpath资源"></a>读取classpath资源</h1><p>从classpath读取文件就可以避免不同环境下文件路径不一致的问题：如果我们把default.properties文件放到classpath中，就不用关心它的实际存放路径。</p><p>在classpath中的资源文件，路径总是以／开头，我们先获取当前的Class对象，然后调用getResourceAsStream()就可以直接从classpath读取任意的资源文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (InputStream input = getClass().getResourceAsStream(<span class="string">"/default.properties"</span>)) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h1><p>Reader是Java的IO库提供的另一个输入流接口。和InputStream的区别是，InputStream是一个字节流，即以byte为单位读取，而Reader是一个字符流，即以char为单位读取：</p><p>java.io.Reader是所有字符输入流的超类，它最主要的方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><p>这个方法读取字符流的下一个字符，并返回字符表示的int，范围是0~65535。如果已读到末尾，返回-1。</p><p>如果我们读取一个纯ASCII编码的文本文件，上述代码工作是没有问题的。但如果文件中包含中文，就会出现乱码，因为FileReader默认的编码与系统相关，例如，Windows系统的默认编码可能是GBK，打开一个UTF-8编码的文本文件就会出现乱码。</p><p>要避免乱码问题，我们需要在创建FileReader时指定编码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reader reader = <span class="keyword">new</span> FileReader(<span class="string">"src/readme.txt"</span>, StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure><p>和InputStream类似，Reader也是一种资源，需要保证出错的时候也能正确关闭，所以我们需要用try (resource)来保证Reader在无论有没有IO错误的时候都能够正确地关闭：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Reader reader = <span class="keyword">new</span> FileReader(<span class="string">"src/readme.txt"</span>, StandardCharsets.UTF_8) &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Reader还提供了一次性读取若干字符并填充到char[]数组的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] c)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><p>它返回实际读入的字符个数，最大不超过char[]数组的长度。返回-1表示流结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (Reader reader = <span class="keyword">new</span> FileReader(<span class="string">"src/readme.txt"</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1000</span>];</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = reader.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"read "</span> + n + <span class="string">" chars."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然Reader本质上是一个基于InputStream的byte到char的转换器，那么，如果我们已经有一个InputStream，想把它转换为Reader，是完全可行的。InputStreamReader就是这样一个转换器，它可以把任何InputStream转换为Reader。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 持有InputStream:</span></span><br><span class="line">InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"src/readme.txt"</span>);</span><br><span class="line"><span class="comment">// 变换为Reader:</span></span><br><span class="line">Reader reader = <span class="keyword">new</span> InputStreamReader(input, <span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure><h1 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h1><p>是带编码转换器的InputStream，它把byte转换为char，而Writer就是带编码转换器的OutputStream，它把char转换为byte并输出。</p><p>除了CharArrayWriter和StringWriter外，普通的Writer实际上是基于OutputStream构造的，它接收char，然后在内部自动转换成一个或多个byte，并写入OutputStream。因此，OutputStreamWriter就是一个将任意的OutputStream转换为Writer的转换器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Writer writer = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"readme.txt"</span>), <span class="string">"UTF-8"</span>)) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA基础——异常</title>
      <link href="/2020/07/22/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8/"/>
      <url>/2020/07/22/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 使用异常来表示错误，并通过 try … catch 捕获异常；</p><p>Java的异常是class，并且从 <code>Throwable</code> 继承；</p><p>Throwable有两个体系：<code>Error</code> 和 <code>Exception</code>。</p><p>Error是无需捕获的严重错误，Exception是应该捕获的可处理的错误；</p><p>Exception又分为两大类：</p><ul><li>RuntimeException以及它的子类；</li><li>非RuntimeException（包括IOException、ReflectiveOperationException等等）</li></ul><p>RuntimeException无需强制捕获，非RuntimeException（Checked Exception）需强制捕获，或者用throws声明；</p><p>不推荐捕获了异常但不进行任何处理。</p><h1 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h1><p>在Java中，凡是可能抛出异常的语句，都可以用try … catch捕获。把可能发生异常的语句放在 try { … } 中，然后使用catch捕获对应的Exception及其子类。</p><p>存在多个catch的时候，catch的顺序非常重要：子类必须写在前面。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">"IO error"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123; <span class="comment">// 永远捕获不到</span></span><br><span class="line">        System.out.println(<span class="string">"Bad encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面的代码，UnsupportedEncodingException异常是永远捕获不到的，因为它是IOException的子类。当抛出UnsupportedEncodingException异常时，会被catch (IOException e) { … }捕获并执行。</p><p>Java的try … catch机制还提供了finally语句，finally语句块保证有无错误都会执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Bad encoding"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">"IO error"</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"END"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意finally有几个特点：</p><ul><li>finally语句不是必须的，可写可不写；</li><li>finally总是最后执行。</li></ul><p>使用try … catch … finally时：</p><ul><li>多个catch语句的匹配顺序非常重要，子类必须放在前面；</li><li>finally语句保证了有无异常都会执行，它是可选的；</li><li>一个catch语句也可以匹配多个非继承关系的异常。</li></ul><h1 id="主动抛出异常"><a href="#主动抛出异常" class="headerlink" title="主动抛出异常"></a>主动抛出异常</h1><p>如何抛出异常？参考Integer.parseInt()方法，抛出异常分两步：</p><ul><li>创建某个Exception的实例；</li><li>用throw语句抛出。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用printStackTrace()可以打印异常的传播栈，对于调试非常有用；</p><p>捕获异常并再次抛出新的异常时，应该持有原始异常信息；</p><p>通常不要在finally中抛出异常。如果在finally中抛出异常，应该原始异常加入到原有异常中。调用方可通过Throwable.getSuppressed()获取所有添加的Suppressed Exception。</p><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>在一个大型项目中，可以自定义新的异常类型，但是，保持一个合理的异常继承体系是非常重要的。</p><p>一个常见的做法是自定义一个BaseException作为“根异常”，然后，派生出各种业务类型的异常。</p><p>BaseException需要从一个适合的Exception派生，通常建议从RuntimeException派生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他业务类型的异常就可以从BaseException派生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserNotFoundException</span> <span class="keyword">extends</span> <span class="title">BaseException</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFailedException</span> <span class="keyword">extends</span> <span class="title">BaseException</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>自定义的BaseException应该提供多个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述构造方法实际上都是原样照抄RuntimeException。这样，抛出异常的时候，就可以选择合适的构造方法。通过IDE可以根据父类快速生成子类的构造方法。</p><h1 id="使用断言"><a href="#使用断言" class="headerlink" title="使用断言"></a>使用断言</h1><p>断言（Assertion）是一种调试程序的方式。在Java中，使用assert关键字来实现断言。</p><p>我们先看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = Math.abs(-<span class="number">123.45</span>);</span><br><span class="line">    <span class="keyword">assert</span> x &gt;= <span class="number">0</span>;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语句 <code>assert x &gt;= 0</code>; 即为断言，断言条件x &gt;= 0预期为true。如果计算结果为false，则断言失败，抛出AssertionError。</p><p>使用assert语句时，还可以添加一个可选的断言消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> x &gt;= <span class="number">0</span> : <span class="string">"x must &gt;= 0"</span>;</span><br></pre></td></tr></table></figure><p>这样，断言失败的时候，AssertionError会带上消息x must &gt;= 0，更加便于调试。</p><p>ava断言的特点是：断言失败时会抛出AssertionError，导致程序结束退出。因此，断言不能用于可恢复的程序错误，只应该用于开发和测试阶段。</p><p>对于可恢复的程序错误，不应该使用断言。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> arr != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该抛出异常并在上层捕获：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"array cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JVM默认关闭断言指令，即遇到assert语句就自动忽略了，不执行。</p><p>要执行assert语句，必须给Java虚拟机传递-enableassertions（可简写为-ea）参数启用断言。所以，上述程序必须在命令行下运行才有效果：</p><pre><code>$ java -ea Main.java</code></pre>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA基础——泛型</title>
      <link href="/2020/07/22/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B/"/>
      <url>/2020/07/22/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>泛型就是编写模板代码来适应任意类型；</p><p>泛型的好处是使用时不必对类型进行强制转换，它通过编译器对类型进行检查；</p><p>如 <code>ArrayList</code> 内部就是一个 Object[] 数组，配合存储一个当前分配的长度，就可以充当“可变数组”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object e)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用上述ArrayList存储String类型，会有这么几个缺点：</p><ul><li>需要强制转型；</li><li>不方便，易出错。</li></ul><p>我们也不可能为了单独数据类型创建ArrayList,此时就需要利用泛型，比如我们的ArrayList可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T e)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>T</code> 可以是任何class。这样一来，我们就实现了：编写一次模版，可以创建任意类型的ArrayList：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建可以存储String的ArrayList:</span></span><br><span class="line">ArrayList&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="comment">// 创建可以存储Float的ArrayList:</span></span><br><span class="line">ArrayList&lt;Float&gt; floatList = <span class="keyword">new</span> ArrayList&lt;Float&gt;();</span><br><span class="line"><span class="comment">// 创建可以存储Person的ArrayList:</span></span><br><span class="line">ArrayList&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br></pre></td></tr></table></figure><h1 id="使用泛型"><a href="#使用泛型" class="headerlink" title="使用泛型"></a>使用泛型</h1><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>使用泛型时，把泛型参数<T>替换为需要的class类型，例如：ArrayList<String>，ArrayList<Number>等；</li><li>可以省略编译器能自动推断出的类型，例如：List<String> list = new ArrayList&lt;&gt;();</li><li>不指定泛型参数类型时，编译器会给出警告，且只能将<T>视为Object类型；</li></ul><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>使用ArrayList时，如果不定义泛型类型时，泛型类型实际上就是Object：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器警告:</span></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">"Hello"</span>);</span><br><span class="line">list.add(<span class="string">"World"</span>);</span><br><span class="line">String first = (String) list.get(<span class="number">0</span>);</span><br><span class="line">String second = (String) list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>此时，只能把<T>当作Object使用，没有发挥泛型的优势。</p><p>当我们定义泛型类型<String>后，List<T>的泛型接口变为强类型List<String>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无编译器警告:</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"Hello"</span>);</span><br><span class="line">list.add(<span class="string">"World"</span>);</span><br><span class="line"><span class="comment">// 无强制转型:</span></span><br><span class="line">String first = list.get(<span class="number">0</span>);</span><br><span class="line">String second = list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>// 可以省略后面的Number，编译器可以自动推断泛型类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><h1 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h1><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>可以在接口中定义泛型类型，实现此接口的类必须实现正确的泛型类型。</p><h2 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h2><p>除了ArrayList<T>使用了泛型，还可以在接口中使用泛型。例如，<code>Arrays.sort(Object[])</code> 可以对任意类型数组进行排序，但待排序的元素必须实现Comparable<T>这个泛型接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回-1: 当前实例比参数o小</span></span><br><span class="line"><span class="comment">     * 返回0: 当前实例与参数o相等</span></span><br><span class="line"><span class="comment">     * 返回1: 当前实例比参数o大</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如对String[] 排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] ss = <span class="keyword">new</span> String[] &#123; <span class="string">"Orange"</span>, <span class="string">"Apple"</span>, <span class="string">"Pear"</span> &#125;;</span><br><span class="line">Arrays.sort(ss);</span><br><span class="line">System.out.println(Arrays.toString(ss));</span><br></pre></td></tr></table></figure><pre><code>[Apple, Orange, Pear]</code></pre><p>这是因为String本身已经实现了Comparable<String>接口。如果换成我们自定义的Person类型试试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person[] ps = <span class="keyword">new</span> Person[] &#123;</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">"Bob"</span>, <span class="number">61</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">"Alice"</span>, <span class="number">88</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">"Lily"</span>, <span class="number">75</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        Arrays.sort(ps);</span><br><span class="line">        System.out.println(Arrays.toString(ps));</span><br></pre></td></tr></table></figure><p>运行程序，我们会得到 <code>ClassCastException</code>，即无法将Person转型为Comparable。我们修改代码，让Person实现Comparable<T>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br></pre></td></tr></table></figure><p>运行上述代码，可以正确实现按name进行排序。</p><p>也可以修改比较逻辑，例如，按score从高到低排序。请自行修改测试。</p><h1 id="编写泛型"><a href="#编写泛型" class="headerlink" title="编写泛型"></a>编写泛型</h1><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ul><li>编写泛型时，需要定义泛型类型<T>；</li><li>静态方法不能引用泛型类型<T>，必须定义其他类型（例如<K>）来实现静态泛型方法；</li><li>泛型可以同时定义多种类型，例如Map&lt;K, V&gt;。</li></ul><h2 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h2><p>原类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String first;</span><br><span class="line">    <span class="keyword">private</span> String last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(String first, String last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把特定类型String替换为T，并申明<T>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写泛型类时，要特别注意，泛型类型<T>不能用于静态方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对静态方法使用&lt;T&gt;:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pair&lt;T&gt; <span class="title">create</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码会导致编译错误，我们无法在静态方法create()的方法参数和返回类型上使用泛型类型T。</p><p>对于静态方法，我们可以单独改写为“泛型”方法，只需要使用另一个类型即可。对于上面的create()静态方法，我们应该把它改为另一种泛型类型，例如 <code>&lt;K&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态泛型方法应该使用其他类型区分:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K&gt; <span class="function">Pair&lt;K&gt; <span class="title">create</span><span class="params">(K first, K last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;K&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型还可以定义多种类型。例如，我们希望Pair不总是存储两个类型一样的对象，就可以使用类型 <code>&lt;T, K&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> K last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, K last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getLast</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候，需要指出两种类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String, Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="string">"test"</span>, <span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>Java标准库的 <code>Map&lt;K, V&gt;</code> 就是使用两种泛型类型的例子。它对Key使用一种类型，对Value使用另一种类型。</p><h1 id="擦拭法"><a href="#擦拭法" class="headerlink" title="擦拭法"></a>擦拭法</h1><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>Java的泛型是采用擦拭法实现的；</p><p>擦拭法决定了泛型<T>：</p><ul><li>不能是基本类型，例如：int；</li><li>不能获取带泛型类型的Class，例如：Pair<String>.class；</li><li>不能判断带泛型类型的类型，例如：x instanceof Pair<String>；</li><li>不能实例化T类型，例如：new T()。</li></ul><p>泛型方法要防止重复定义方法，例如：<code>public boolean equals(T obj)；</code></p><p>子类可以获取父类的泛型类型 <code>&lt;T&gt;</code>。</p><h2 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h2><p>Java语言的泛型实现方式是擦拭法（Type Erasure）。</p><p>所谓擦拭法是指，<strong>虚拟机对泛型其实一无所知，所有的工作都是编译器做的。</strong></p><p>例如，我们编写了一个泛型类Pair<T>，这是编译器看到的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而虚拟机并不能识别泛型，这是虚拟机执行的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object first;</span><br><span class="line">    <span class="keyword">private</span> Object last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Object first, Object last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，Java使用擦拭法实现泛型，导致了：</p><ul><li>编译器把类型<T>视为Object；</li><li>编译器根据<T>实现安全的强制转型。</li></ul><p>使用泛型的时候，我们编写的代码也是编译器看到的代码,而虚拟机执行的代码并没有泛型。所以，Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型T视为Object处理，但是，在需要转型的时候，编译器会根据T的类型自动为我们实行安全地强制转型。</p><p>了解了Java泛型的实现方式——擦拭法，我们就知道了Java泛型的局限：</p><p>局限一：<T>不能是基本类型，例如int，因为实际类型是Object，Object类型无法持有基本类型：</p><p>局限二：无法取得带泛型的Class。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pair&lt;String&gt; p1 = <span class="keyword">new</span> Pair&lt;&gt;(<span class="string">"Hello"</span>, <span class="string">"world"</span>);</span><br><span class="line">        Pair&lt;Integer&gt; p2 = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        Class c1 = p1.getClass();</span><br><span class="line">        Class c2 = p2.getClass();</span><br><span class="line">        System.out.println(c1==c2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(c1==Pair<span class="class">.<span class="keyword">class</span>)</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为T是Object，我们对Pair<String>和Pair<Integer>类型获取Class时，获取到的是同一个Class，也就是Pair类的Class。</p><p>换句话说，所有泛型实例，无论T的类型是什么，getClass()返回同一个Class实例，因为编译后它们全部都是Pair<Object>。</p><p>局限三：无法判断带泛型的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line"><span class="comment">// Compile error:</span></span><br><span class="line"><span class="keyword">if</span> (p <span class="keyword">instanceof</span> Pair&lt;String&gt;) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因和前面一样，并不存在Pair<String>.class，而是只有唯一的Pair.class。</p><p>局限四：不能实例化T类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Compile error:</span></span><br><span class="line">        first = <span class="keyword">new</span> T();</span><br><span class="line">        last = <span class="keyword">new</span> T();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码无法通过编译，因为构造方法的两行语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first = <span class="keyword">new</span> T();</span><br><span class="line">last = <span class="keyword">new</span> T();</span><br></pre></td></tr></table></figure><p>擦拭后变成了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first = <span class="keyword">new</span> Object();</span><br><span class="line">last = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p>这样一来，创建new Pair<String>()和创建new Pair<Integer>()就全部成了Object，显然编译器要阻止这种类型不对的代码。</p><p>有些时候，一个看似正确定义的方法会无法通过编译。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为，定义的equals(T t)方法实际上会被擦拭成equals(Object t)，而这个方法是继承自Object的，编译器会阻止一个实际上会变成覆写的泛型方法定义。</p><p>一个类可以继承自一个泛型类。例如：父类的类型是Pair<Integer>，子类的类型是IntPair，可以这么继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntPair</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候，因为子类IntPair并没有泛型类型，所以，正常使用即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntPair ip = <span class="keyword">new</span> IntPair(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>在继承了泛型类型的情况下，子类可以获取父类的泛型类型。例如：IntPair可以获取到父类的泛型类型Integer。获取父类的泛型类型代码比较复杂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;IntPair&gt; clazz = IntPair<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Type t = clazz.getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            ParameterizedType pt = (ParameterizedType) t;</span><br><span class="line">            Type[] types = pt.getActualTypeArguments(); <span class="comment">// 可能有多个泛型类型</span></span><br><span class="line">            Type firstType = types[<span class="number">0</span>]; <span class="comment">// 取第一个泛型类型</span></span><br><span class="line">            Class&lt;?&gt; typeClass = (Class&lt;?&gt;) firstType;</span><br><span class="line">            System.out.println(typeClass); <span class="comment">// Integer</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="extends-通配符"><a href="#extends-通配符" class="headerlink" title="extends 通配符"></a>extends 通配符</h1><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>使用类似 <code>&lt;? extends Number&gt;</code> 通配符作为方法参数时表示：</p><ul><li><p>方法内部可以调用获取Number引用的方法，例如：Number n = obj.getFirst();；</p></li><li><p>方法内部无法调用传入Number引用的方法（null除外），例如：obj.setFirst(Number n);。</p></li></ul><p>即一句话总结：使用extends通配符表示可以读，不能写。</p><p>使用类似 <code>&lt;T extends Number&gt;</code> 定义泛型类时表示：</p><ul><li>泛型类型限定为Number以及Number的子类。</li></ul><h2 id="举例-4"><a href="#举例-4" class="headerlink" title="举例"></a>举例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pair&lt;Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        <span class="keyword">int</span> n = add(p);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Pair&lt;Number&gt; p)</span> </span>&#123;</span><br><span class="line">        Number first = p.getFirst();</span><br><span class="line">        Number last = p.getLast();</span><br><span class="line">        <span class="keyword">return</span> first.intValue() + last.intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接运行，会得到一个编译错误：</p><pre><code>incompatible types: Pair&lt;Integer&gt; cannot be converted to Pair&lt;Number&gt;</code></pre><p>有没有办法使得方法参数接受Pair<Integer>？办法是有的，这就是使用 Pair&lt;? extends Number&gt; 使得方法接收所有泛型类型为Number或Number子类的Pair类型。我们把代码改写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pair&lt;Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        <span class="keyword">int</span> n = add(p);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Pair&lt;? extends Number&gt; p)</span> </span>&#123;</span><br><span class="line">        Number first = p.getFirst();</span><br><span class="line">        Number last = p.getLast();</span><br><span class="line">        <span class="keyword">return</span> first.intValue() + last.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，给方法传入 <code>Pair&lt;Integer&gt;</code>类型时，它符合参数 <code>Pair&lt;? extends Number&gt;</code> 类型。这种使用&lt;? extends Number&gt;的泛型定义称之为上界通配符（Upper Bounds Wildcards），即把泛型类型T的上界限定在Number了。</p><p>除了可以传入Pair<Integer>类型，我们还可以传入Pair<Double>类型，Pair<BigDecimal>类型等等，因为Double和BigDecimal都是Number的子类。</p><p>我们再来考察一下Pair<T>的set方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pair&lt;Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        <span class="keyword">int</span> n = add(p);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Pair&lt;? extends Number&gt; p)</span> </span>&#123;</span><br><span class="line">        Number first = p.getFirst();</span><br><span class="line">        Number last = p.getLast();</span><br><span class="line">        p.setFirst(<span class="keyword">new</span> Integer(first.intValue() + <span class="number">100</span>));</span><br><span class="line">        p.setLast(<span class="keyword">new</span> Integer(last.intValue() + <span class="number">100</span>));</span><br><span class="line">        <span class="keyword">return</span> p.getFirst().intValue() + p.getFirst().intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不出意外，我们会得到一个编译错误：</p><pre><code>incompatible types: Integer cannot be converted to CAP#1where CAP#1 is a fresh type-variable:CAP#1 extends Number from capture of ? extends Number</code></pre><p>原因还在于擦拭法。如果我们传入的p是 <code>Pair&lt;Double&gt;</code>，显然它满足参数定义 <code>Pair&lt;? extends Number&gt;</code>，然而，<code>Pair&lt;Double&gt;</code>的 setFirst() 显然无法接受Integer类型。</p><p>这就是 <code>&lt;? extends Number&gt;</code> 通配符的一个重要限制：方法参数签名 <code>setFirst(? extends Number)</code>无法传递任何Number类型给 <code>setFirst(? extends Number)</code>。</p><p>这里唯一的例外是可以给方法参数传入null：</p><p>使用extends限定<code>T</code>类型</p><p>在定义泛型类型Pair<T>的时候，也可以使用extends通配符来限定T的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt; </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>现在，我们只能定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Number&gt; p1 = <span class="keyword">null</span>;</span><br><span class="line">Pair&lt;Integer&gt; p2 = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Pair&lt;Double&gt; p3 = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>因为Number、Integer和Double都符合 <code>&lt;T extends Number&gt;</code>。</p><p>非Number类型将无法通过编译：</p><h1 id="super-通配符"><a href="#super-通配符" class="headerlink" title="super 通配符"></a>super 通配符</h1><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>使用类似&lt;? super Integer&gt;通配符作为方法参数时表示：</p><ul><li>方法内部可以调用传入Integer引用的方法，例如：obj.setFirst(Integer n);；</li><li>方法内部无法调用获取Integer引用的方法（Object除外），例如：Integer n = obj.getFirst();。</li></ul><p>即使用super通配符表示只能写不能读。</p><h2 id="举例-5"><a href="#举例-5" class="headerlink" title="举例"></a>举例</h2><p>考察下面的set方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Pair&lt;Integer&gt; p, Integer first, Integer last)</span> </span>&#123;</span><br><span class="line">    p.setFirst(first);</span><br><span class="line">    p.setLast(last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入Pair<Integer>是允许的，但是传入Pair<Number>是不允许的。</p><p>和extends通配符相反，这次，我们希望接受 <code>Pair&lt;Integer&gt;</code>类型，以及 <code>Pair&lt;Number&gt;</code>、<code>Pair&lt;Object&gt;</code>，因为Number和Object是Integer的父类，setFirst(Number)和setFirst(Object)实际上允许接受Integer类型。</p><p>我们使用super通配符来改写这个方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Pair&lt;? <span class="keyword">super</span> Integer&gt; p, Integer first, Integer last)</span> </span>&#123;</span><br><span class="line">    p.setFirst(first);</span><br><span class="line">    p.setLast(last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再考察 <code>Pair&lt;? super Integer&gt;</code> 的getFirst()方法，它的方法签名实际上是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">? <span class="function"><span class="keyword">super</span> Integer <span class="title">getFirst</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>这里注意到我们无法使用Integer类型来接收getFirst()的返回值，即下面的语句将无法通过编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer x = p.getFirst();</span><br></pre></td></tr></table></figure><p>因为如果传入的实际类型是Pair<Number>，编译器无法将Number类型转型为Integer。</p><p>注意：虽然Number是一个抽象类，我们无法直接实例化它。但是，即便Number不是抽象类，这里仍然无法通过编译。此外，传入Pair<Object>类型时，编译器也无法将Object类型转型为Integer。</p><p>唯一可以接收getFirst()方法返回值的是Object类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = p.getFirst();</span><br></pre></td></tr></table></figure><h1 id="对比extends和super通配符"><a href="#对比extends和super通配符" class="headerlink" title="对比extends和super通配符"></a>对比extends和super通配符</h1><p>我们再回顾一下extends通配符。作为方法参数，<code>&lt;? extends T&gt;</code> 类型和 <code>&lt;? super T&gt;</code> 类型的区别在于：</p><ul><li><code>&lt;? extends T&gt;</code>允许调用读方法T get()获取T的引用，但不允许调用写方法set(T)传入T的引用（传入null除外）；</li><li><code>&lt;? super T&gt;</code>允许调用写方法set(T)传入T的引用，但不允许调用读方法T get()获取T的引用（获取Object除外）。</li></ul><p>一个是允许读不允许写，另一个是允许写不允许读。</p><p>先记住上面的结论，我们来看Java标准库的Collections类定义的copy()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Collections</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把src的每个元素复制到dest中:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;src.size(); i++) &#123;</span><br><span class="line">            T t = src.get(i);</span><br><span class="line">            dest.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的作用是把一个List的每个元素依次添加到另一个List中。它的第一个参数是 <code>List&lt;? super T&gt;</code>，表示目标List，第二个参数 <code>List&lt;? extends T&gt;</code>，表示要复制的List。我们可以简单地用for循环实现复制。在for循环中，我们可以看到，对于类型 <code>&lt;? extends T&gt;</code> 的变量src，我们可以安全地获取类型T的引用，而对于类型 <code>&lt;? super T&gt;</code>的变量dest，我们可以安全地传入T的引用。</p><p>这个copy()方法的定义就完美地展示了extends和super的意图：</p><ul><li>copy()方法内部不会读取dest，因为不能调用dest.get()来获取T的引用；</li><li>copy()方法内部也不会修改src，因为不能调用src.add(T)。</li></ul><h1 id="PECS原则"><a href="#PECS原则" class="headerlink" title="PECS原则"></a>PECS原则</h1><p>何时使用 extends，何时使用 super？为了便于记忆，我们可以用PECS原则：Producer Extends Consumer Super。</p><p>即：如果需要返回T，它是生产者（Producer），要使用extends通配符；如果需要写入T，它是消费者（Consumer），要使用super通配符。</p><h1 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h1><p>实际上，Java的泛型还允许使用无限定通配符（Unbounded Wildcard Type），即只定义一个?：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sample</span><span class="params">(Pair&lt;?&gt; p)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为&lt;?&gt;通配符既没有 extends，也没有 super，因此：</p><ul><li>不允许调用 <code>set(T)</code> 方法并传入引用（null除外）；</li><li>不允许调用 <code>T get()</code> 方法并获取T引用（只能获取Object引用）。</li></ul><p>换句话说，既不能读，也不能写，那只能做一些null判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNull</span><span class="params">(Pair&lt;?&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.getFirst() == <span class="keyword">null</span> || p.getLast() == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&lt;?&gt;</code> 通配符有一个独特的特点，就是：<code>Pair&lt;?&gt;</code> 是所有<code>Pair&lt;T&gt;</code> 的超类：</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA基础——反射</title>
      <link href="/2020/07/21/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%8F%8D%E5%B0%84/"/>
      <url>/2020/07/21/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法； 并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。</p><h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><p>假如你写了一段代码：Object o=new Object();运行了起来！</p><p>首先JVM会启动，你的代码会编译成一个.class文件，然后被类加载器加载进jvm的内存中，你的类Object加载到方法区中，创建了Object类的class对象到堆中，注意这个不是new出来的对象，而是类的类型对象，每个类只有一个class对象，作为方法区类的数据结构的接口。</p><p>jvm创建对象前，会先检查类是否加载，寻找类对应的class对象，若加载好，则为你的对象分配内存，初始化也就是代码:new Object()。</p><p>上面的流程就是你自己写好的代码扔给jvm去跑，跑完就over了，jvm关闭，你的程序也停止了。</p><p>反射能够做到什么那？当我们的程序在运行时，需要动态的加载一些类这些类可能之前用不到所以不用加载到jvm，而是在运行时根据需要才加载。</p><p>上面是说反射在创建实例方面能带来的改变，当然，无论反射和new方式，有一点是绕不过的，就是Class对象。每个类只有一个class对象，作为方法区类的数据结构的接口。</p><p>反射能够获取类的所有属性和方法，也是依靠Class对象。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="获取类名"><a href="#获取类名" class="headerlink" title="获取类名"></a>获取类名</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.alunbar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alunbar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String arts[])</span></span>&#123;</span><br><span class="line">        Class alunbarClass = Alunbar<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        System.out.println(alunbarClass.getName());</span><br><span class="line">        System.out.println(alunbarClass.getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getName()方法获取的类名包含包信息。getSimpleName()方法只是获取类名，不包含包信息。</p><h2 id="获取类修饰符"><a href="#获取类修饰符" class="headerlink" title="获取类修饰符"></a>获取类修饰符</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alunbar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String arts[])</span></span>&#123;</span><br><span class="line">        Class alunbarClass = Alunbar<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        System.out.println(alunbarClass.getModifiers());</span><br><span class="line">        System.out.println(Modifier.isPublic(alunbarClass.getModifiers()));</span><br><span class="line"></span><br><span class="line">        Class birdClass = Bird<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        System.out.println(birdClass.getModifiers());</span><br><span class="line">        System.out.println(Modifier.isPublic(birdClass.getModifiers()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类修饰符有public、private等类型，getModifiers()可以获取一个类的修饰符</p><h2 id="获取包信息"><a href="#获取包信息" class="headerlink" title="获取包信息"></a>获取包信息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.alunbar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alunbar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String arts[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Class birdClass = Bird<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        System.out.println(birdClass.getPackage());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getPackage()方法获取包信息</p><h2 id="获取父类的Class对象"><a href="#获取父类的Class对象" class="headerlink" title="获取父类的Class对象"></a>获取父类的Class对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alunbar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String arts[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Class birdClass = Bird<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Class superclass = birdClass.getSuperclass();</span><br><span class="line">        System.out.println(superclass.getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getSuperclass()方法返回的父类的Class对象。</p><h2 id="获取接口信息"><a href="#获取接口信息" class="headerlink" title="获取接口信息"></a>获取接口信息</h2><p>获取接口信息的方法：</p><p>Class[] interfaces = birdClass.getInterfaces();</p><p>一个类可以实现多个接口，所以getInterfaces()方法返回的是Class[]数组。 注意：getInterfaces()只返回指定类实现的接口，不会返父类实现的接口。</p><h2 id="获取构造函数Constructor"><a href="#获取构造函数Constructor" class="headerlink" title="获取构造函数Constructor"></a>获取构造函数Constructor</h2><p>获取构造函数的方法：</p><p>Class birdClass = Bird.class;<br>Constructor[] constructors = birdClass.getConstructors();</p><p>一个类会有多个构造函数，getConstructors()返回的是Constructor[]数组，包含了所有声明的用public修饰的构造函数。</p><p>如果你已经知道了某个构造的参数，可以通过下面的方法获取到回应的构造函数对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alunbar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String arts[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Class birdClass = Bird<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Constructor constructors = birdClass.getConstructor(<span class="keyword">new</span> Class[]&#123;String<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(NoSuchMethodException  e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(String eat)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面获取构造函数的方式有2点需要注意：<br>1、只能获取到public修饰的构造函数。<br>2、需要捕获NoSuchMethodException异常。</p><h2 id="获取构造函数的参数"><a href="#获取构造函数的参数" class="headerlink" title="获取构造函数的参数"></a>获取构造函数的参数</h2><p>获取到构造函数的对象之后，可以通过getParameterTypes()获取到构造函数的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructors = birdClass.getConstructor(<span class="keyword">new</span> Class[]&#123;String<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">            Class[] parameterTypes = constructors.getParameterTypes();</span><br></pre></td></tr></table></figure><h2 id="初始化对象"><a href="#初始化对象" class="headerlink" title="初始化对象"></a>初始化对象</h2><p>通过反射获取到构造器之后，通过newInstance()方法就可以生成类对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alunbar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String arts[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Class birdClass = Bird<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Constructor constructors = birdClass.getConstructor(<span class="keyword">new</span> Class[]&#123;String<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">            Bird bird = (Bird)constructors.newInstance(<span class="string">"eat tea"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception  e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"没有对应的构造函数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">Bird</span><span class="params">(String eat)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newinstance()方法接受可选数量的参数，必须为所调用的构造函数提供准确的参数。如果构造函数要求String的参数，在调用newinstance()方法是，必须提供String类型的参数。</p><h2 id="获取Methods方法信息"><a href="#获取Methods方法信息" class="headerlink" title="获取Methods方法信息"></a>获取Methods方法信息</h2><p>下面代码是通过反射可以获取到该类的声明的成员方法信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Method[] metchods = birdClass.getMethods();</span><br><span class="line">Method[] metchods1 = birdClass.getDeclaredMethods();</span><br><span class="line">Method eatMetchod = birdClass.getMethod(<span class="string">"eat"</span>, <span class="keyword">new</span> Class[]&#123;<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">Method eatMetchod1 = birdClass.getDeclaredMethod(<span class="string">"eat"</span>, <span class="keyword">new</span> Class[]&#123;<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br></pre></td></tr></table></figure><p>无参的getMethods()获取到所有public修饰的方法，返回的是Method[]数组。 无参的getDeclaredMethods()方法到的是所有的成员方法，和修饰符无关。 对于有参的getMethods()方法，必须提供要获取的方法名以及方法名的参数。</p><p>如果要获取的方法没有参数，则用null替代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method eatMetchod = birdClass.getMethod(<span class="string">"eat"</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>无参的getMethods()和getDeclaredMethods()都只能获取到类声明的成员方法，不能获取到继承父类的方法。</p><h2 id="获取成员方法参数"><a href="#获取成员方法参数" class="headerlink" title="获取成员方法参数"></a>获取成员方法参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class birdClass = Bird<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Class[] parameterTypes = eatMetchod1.getParameterTypes();</span><br></pre></td></tr></table></figure><h2 id="获取成员方法返回类型"><a href="#获取成员方法返回类型" class="headerlink" title="获取成员方法返回类型"></a>获取成员方法返回类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class birdClass = Bird<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Class returnType = eatMetchod1.getReturnType();</span><br></pre></td></tr></table></figure><h2 id="invoke-方法"><a href="#invoke-方法" class="headerlink" title="invoke()方法"></a>invoke()方法</h2><p>java反射提供invoke()方法，在运行时根据业务需要调用相应的方法，这种情况在运行时非常常见，只要通过反射获取到方法名之后，就可以调用对应的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class birdClass = Bird<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Constructor constructors1 = birdClass.getConstructor();</span><br><span class="line">Method eatMetchod = birdClass.getMethod(<span class="string">"eat"</span>, <span class="keyword">new</span> Class[]&#123;<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">System.out.println(eatMetchod.invoke(constructors1.newInstance(), <span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>invoke方法有两个参数，第一个参数是要调用方法的对象，上面的代码中就是Bird的对象，第二个参数是调用方法要传入的参数。如果有多个参数，则用数组。</p><p>如果调用的是static方法，invoke()方法第一个参数就用null代替：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alunbar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String arts[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Class birdClass = Bird<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            Constructor constructors1 = birdClass.getConstructor();</span><br><span class="line">            Method eatMetchod = birdClass.getMethod(<span class="string">"eat"</span>, <span class="keyword">new</span> Class[]&#123;<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">            System.out.println(eatMetchod.invoke(<span class="keyword">null</span>, <span class="number">2</span>));</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception  e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"没有对应的构造函数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">eat</span><span class="params">(<span class="keyword">int</span> eat)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> eat;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(String eat)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>使用反射可以在运行时检查和调用类声明的成员方法，可以用来检测某个类是否有getter和setter方法。getter和setter是java bean必须有的方法。 getter和setter方法有下面的一些规律： getter方法以get为前缀，无参，有返回值 setter方法以set为前缀，有一个参数，返回值可有可无， 下面的代码提供了检测一个类是否有getter和setter方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printGettersSetters</span><span class="params">(Class aClass)</span></span>&#123;</span><br><span class="line">  Method[] methods = aClass.getMethods();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line">    <span class="keyword">if</span>(isGetter(method)) System.out.println(<span class="string">"getter: "</span> + method);</span><br><span class="line">    <span class="keyword">if</span>(isSetter(method)) System.out.println(<span class="string">"setter: "</span> + method);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isGetter</span><span class="params">(Method method)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!method.getName().startsWith(<span class="string">"get"</span>))      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(method.getParameterTypes().length != <span class="number">0</span>)   <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">void</span><span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">method</span>.<span class="title">getReturnType</span>()) <span class="title">return</span> <span class="title">false</span></span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSetter</span><span class="params">(Method method)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!method.getName().startsWith(<span class="string">"set"</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(method.getParameterTypes().length != <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取成员变量"><a href="#获取成员变量" class="headerlink" title="获取成员变量"></a>获取成员变量</h2><p>通过反射可以在运行时获取到类的所有成员变量，还可以给成员变量赋值和获取成员变量的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class birdClass = Bird<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Field[] fields1 = birdClass.getFields();</span><br><span class="line">Field[] fields2 = birdClass.getDeclaredFields();</span><br><span class="line">Field fields3 = birdClass.getField(<span class="string">"age"</span>);</span><br><span class="line">Field fields4 = birdClass.getDeclaredField(<span class="string">"age"</span>);</span><br></pre></td></tr></table></figure><p>getFields()方法获取所有public修饰的成员变量，getField()方法需要传入变量名，并且变量必须是public修饰符修饰。<br>getDeclaredFields方法获取所有生命的成员变量，不管是public还是private。</p><h2 id="获取成员变量类型"><a href="#获取成员变量类型" class="headerlink" title="获取成员变量类型"></a>获取成员变量类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Field fields4 = birdClass.getDeclaredField(<span class="string">"age"</span>);</span><br><span class="line">Object fieldType = fields4.getType();</span><br></pre></td></tr></table></figure><h2 id="成员变量赋值和取值"><a href="#成员变量赋值和取值" class="headerlink" title="成员变量赋值和取值"></a>成员变量赋值和取值</h2><p>一旦获取到成员变量的Field引用，就可以获取通过get()方法获取变量值，通过set()方法给变量赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class birdClass = Bird<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Field fields3 = birdClass.getField(<span class="string">"age"</span>);</span><br><span class="line">Bird bird = <span class="keyword">new</span> Bird();</span><br><span class="line">Object value = fields3.get(bird);</span><br><span class="line">fields3.set(bird, value);</span><br></pre></td></tr></table></figure><h2 id="访问私有变量"><a href="#访问私有变量" class="headerlink" title="访问私有变量"></a>访问私有变量</h2><p>有很多文章讨论禁止通过反射访问一个对象的私有变量，但是到目前为止所有的jdk还是允许通过反射访问私有变量。</p><p>使用 Class.getDeclaredField(String name)或者Class.getDeclaredFields()才能获取到私有变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateField</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>  String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrivateField</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateFieldTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Class privateFieldClass = PrivateField<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Field privateName = privateFieldClass.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        privateName.setAccessible(<span class="keyword">false</span>);</span><br><span class="line">        PrivateField privateField = <span class="keyword">new</span> PrivateField(<span class="string">"Alunbar"</span>);</span><br><span class="line">        String privateFieldValue = (String) privateName.get(privateField);</span><br><span class="line">        System.out.println(<span class="string">"私有变量值："</span> + privateFieldValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码有点需要注意：必须调用setAccessible(true)方法，这是针对私有变量而言，public和protected等都不需要。这个方法是允许通过反射访问类的私有变量。</p><h2 id="访问私有方法"><a href="#访问私有方法" class="headerlink" title="访问私有方法"></a>访问私有方法</h2><p>和私有变量一样，私有方法也是不允许其他的类随意调用的，但是通过反射可以饶过这一限制。 使用Class.getDeclaredMethod(String name, Class[] parameterTypes)或者Class.getDeclaredMethods()方法获取到私有方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">accesPrivateMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"成功访问私有方法"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateMethodTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Class privateMethodClass = PrivateMethod<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line">        Method privateStringMethod = privateMethodClass.getDeclaredMethod(<span class="string">"accesPrivateMethod"</span>, <span class="keyword">null</span>);</span><br><span class="line">        privateStringMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        String returnValue = (String)privateStringMethod.invoke(<span class="keyword">new</span> PrivateMethod(), <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"returnValue = "</span> + returnValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和访问私有变量一样，也要调用setAccessible(true)方法，允许通过反射访问类的私有方法。</p><h2 id="访问类注解信息"><a href="#访问类注解信息" class="headerlink" title="访问类注解信息"></a>访问类注解信息</h2><p>通过反射可以在运行时获取到类、方法、变量和参数的注解信息。</p><p>访问类的所有注解信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class aClass = TheClass<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Annotation[] annotations = aClass.getAnnotations();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Annotation annotation : annotations)&#123;</span><br><span class="line">    <span class="keyword">if</span>(annotation <span class="keyword">instanceof</span> MyAnnotation)&#123;</span><br><span class="line">        MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">        System.out.println(<span class="string">"name: "</span> + myAnnotation.name());</span><br><span class="line">        System.out.println(<span class="string">"value: "</span> + myAnnotation.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问类特定的注解信息："><a href="#访问类特定的注解信息：" class="headerlink" title="访问类特定的注解信息："></a>访问类特定的注解信息：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class aClass = TheClass<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Annotation annotation = aClass.getAnnotation(MyAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(annotation <span class="keyword">instanceof</span> MyAnnotation)&#123;</span><br><span class="line">    MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">    System.out.println(<span class="string">"name: "</span> + myAnnotation.name());</span><br><span class="line">    System.out.println(<span class="string">"value: "</span> + myAnnotation.value());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问方法注解信息："><a href="#访问方法注解信息：" class="headerlink" title="访问方法注解信息："></a>访问方法注解信息：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Method method = ... <span class="comment">//obtain method object</span></span><br><span class="line">Annotation[] annotations = method.getDeclaredAnnotations();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Annotation annotation : annotations)&#123;</span><br><span class="line">    <span class="keyword">if</span>(annotation <span class="keyword">instanceof</span> MyAnnotation)&#123;</span><br><span class="line">        MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">        System.out.println(<span class="string">"name: "</span> + myAnnotation.name());</span><br><span class="line">        System.out.println(<span class="string">"value: "</span> + myAnnotation.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问特定方法注解信息："><a href="#访问特定方法注解信息：" class="headerlink" title="访问特定方法注解信息："></a>访问特定方法注解信息：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Method method = ... <span class="comment">// obtain method object</span></span><br><span class="line">Annotation annotation = method.getAnnotation(MyAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(annotation <span class="keyword">instanceof</span> MyAnnotation)&#123;</span><br><span class="line">    MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">    System.out.println(<span class="string">"name: "</span> + myAnnotation.name());</span><br><span class="line">    System.out.println(<span class="string">"value: "</span> + myAnnotation.value());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问参数注解信息："><a href="#访问参数注解信息：" class="headerlink" title="访问参数注解信息："></a>访问参数注解信息：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Method method = ... <span class="comment">//obtain method object</span></span><br><span class="line">Annotation[][] parameterAnnotations = method.getParameterAnnotations();</span><br><span class="line">Class[] parameterTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(Annotation[] annotations : parameterAnnotations)&#123;</span><br><span class="line">  Class parameterType = parameterTypes[i++];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(Annotation annotation : annotations)&#123;</span><br><span class="line">    <span class="keyword">if</span>(annotation <span class="keyword">instanceof</span> MyAnnotation)&#123;</span><br><span class="line">        MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">        System.out.println(<span class="string">"param: "</span> + parameterType.getName());</span><br><span class="line">        System.out.println(<span class="string">"name : "</span> + myAnnotation.name());</span><br><span class="line">        System.out.println(<span class="string">"value: "</span> + myAnnotation.value());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Method.getParameterAnnotations()方法返回的是一个二维的Annotation数组，其中包含每个方法参数的注解数组。</p><h2 id="访问类所有变量注解信息："><a href="#访问类所有变量注解信息：" class="headerlink" title="访问类所有变量注解信息："></a>访问类所有变量注解信息：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Field field = ... <span class="comment">//obtain field object</span></span><br><span class="line">Annotation[] annotations = field.getDeclaredAnnotations();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Annotation annotation : annotations)&#123;</span><br><span class="line">    <span class="keyword">if</span>(annotation <span class="keyword">instanceof</span> MyAnnotation)&#123;</span><br><span class="line">        MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">        System.out.println(<span class="string">"name: "</span> + myAnnotation.name());</span><br><span class="line">        System.out.println(<span class="string">"value: "</span> + myAnnotation.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问类某个特定变量的注解信息："><a href="#访问类某个特定变量的注解信息：" class="headerlink" title="访问类某个特定变量的注解信息："></a>访问类某个特定变量的注解信息：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Field field = ... <span class="comment">// obtain method object</span></span><br><span class="line">Annotation annotation = field.getAnnotation(MyAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(annotation <span class="keyword">instanceof</span> MyAnnotation)&#123;</span><br><span class="line">    MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">    System.out.println(<span class="string">"name: "</span> + myAnnotation.name());</span><br><span class="line">    System.out.println(<span class="string">"value: "</span> + myAnnotation.value());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取泛型信息"><a href="#获取泛型信息" class="headerlink" title="获取泛型信息"></a>获取泛型信息</h2><p>很多人认为java类在编译的时候会把泛型信息给擦除掉，所以在运行时是无法获取到泛型信息的。其实在某些情况下，还是可以通过反射在运行时获取到泛型信息的。</p><p>获取到java.lang.reflect.Method对象，就有可能获取到某个方法的泛型返回信息。</p><p>泛型方法返回类型<br>下面的类中定义了一个返回值中有泛型的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> List&lt;String&gt; stringList = ...;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getStringList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stringList;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的代码使用反射检测getStringList()方法返回的是List<String>而不是List</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Method method = MyClass.class.getMethod("getStringList", null);</span><br><span class="line"></span><br><span class="line">Type returnType = method.getGenericReturnType();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(returnType <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">    ParameterizedType type = (ParameterizedType) returnType;</span><br><span class="line">    Type[] typeArguments = type.getActualTypeArguments();</span><br><span class="line">    <span class="keyword">for</span>(Type typeArgument : typeArguments)&#123;</span><br><span class="line">        Class typeArgClass = (Class) typeArgument;</span><br><span class="line">        System.out.println(<span class="string">"typeArgClass = "</span> + typeArgClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码会打印：typeArgClass = java.lang.String</p><h2 id="泛型方法参数类型"><a href="#泛型方法参数类型" class="headerlink" title="泛型方法参数类型"></a>泛型方法参数类型</h2><p>下面的类定义了一个有泛型参数的方法setStringList():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> List&lt;String&gt; stringList = ...;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStringList</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.stringList = list;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Method类提供了getGenericParameterTypes()方法获取方法的泛型参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">method = Myclass.class.getMethod("setStringList", List.class);</span><br><span class="line"></span><br><span class="line">Type[] genericParameterTypes = method.getGenericParameterTypes();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Type genericParameterType : genericParameterTypes)&#123;</span><br><span class="line">    <span class="keyword">if</span>(genericParameterType <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">        ParameterizedType aType = (ParameterizedType) genericParameterType;</span><br><span class="line">        Type[] parameterArgTypes = aType.getActualTypeArguments();</span><br><span class="line">        <span class="keyword">for</span>(Type parameterArgType : parameterArgTypes)&#123;</span><br><span class="line">            Class parameterArgClass = (Class) parameterArgType;</span><br><span class="line">            System.out.println(<span class="string">"parameterArgClass = "</span> + parameterArgClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码会打印出parameterArgType = java.lang.String</p><h2 id="泛型变量类型"><a href="#泛型变量类型" class="headerlink" title="泛型变量类型"></a>泛型变量类型</h2><p>通过反射也可以获取到类的成员泛型变量信息——静态变量或实例变量。下面的类定义了一个泛型变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> List&lt;String&gt; stringList = ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反射的Filed对象获取到泛型变量的类型信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Field field = MyClass.class.getField("stringList");</span><br><span class="line"></span><br><span class="line">Type genericFieldType = field.getGenericType();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(genericFieldType <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">    ParameterizedType aType = (ParameterizedType) genericFieldType;</span><br><span class="line">    Type[] fieldArgTypes = aType.getActualTypeArguments();</span><br><span class="line">    <span class="keyword">for</span>(Type fieldArgType : fieldArgTypes)&#123;</span><br><span class="line">        Class fieldArgClass = (Class) fieldArgType;</span><br><span class="line">        System.out.println(<span class="string">"fieldArgClass = "</span> + fieldArgClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Field对象提供了getGenericType()方法获取到泛型变量。 上面的代码会打印出：fieldArgClass = java.lang.String</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li><p>性能问题</p><p> java反射的性能并不好，原因主要是编译器没法对反射相关的代码做优化。</p></li><li><p>安全问题</p><p> 我们知道单例模式的设计过程中，会强调将构造器设计为私有，因为这样可以防止从外部构造对象。但是反射可以获取类中的域、方法、构造器，修改访问权限。所以这样并不一定是安全的。</p></li></ol><h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot——Elasticsearch（二十八）</title>
      <link href="/2020/07/20/SpringBoot%E2%80%94%E2%80%94Elasticsearch%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AB%EF%BC%89/"/>
      <url>/2020/07/20/SpringBoot%E2%80%94%E2%80%94Elasticsearch%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="安装ES"><a href="#安装ES" class="headerlink" title="安装ES"></a>安装ES</h1><h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 添加 spring-data-elasticsearch的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span> org.springframework.boot <span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span> spring-boot-starter-data-elasticsearch <span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">l<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line"> <span class="attr">application</span>:<span class="string"></span></span><br><span class="line"> <span class="attr">name</span>: <span class="string">search</span></span><br><span class="line"> <span class="attr">data</span>:<span class="string"></span></span><br><span class="line"> <span class="attr">elasticsearch</span>:<span class="string"></span></span><br><span class="line"> <span class="meta">cluster-name</span>: <span class="string">my-cluster</span></span><br><span class="line"> <span class="meta">cluster-nodes</span>: <span class="string">localhost:9300</span></span><br></pre></td></tr></table></figure><p>也许，大家会疑惑，配置文件中明明写的端口是9200，为何这里配置文件中连接的时候写的端口是9300呢？</p><p>因为，配置9200是通过HTTP连接的端口，9300是TCP连接的端口</p><p>spring.data.elasticsearch.cluster-name：集群名称</p><p>spring.data.elasticsearch.cluster-nodes：集群节点地址列表，多个节点用英文逗号（,）分隔</p><h1 id="创建ES文档和映射"><a href="#创建ES文档和映射" class="headerlink" title="创建ES文档和映射"></a>创建ES文档和映射</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cjs.example.entity;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Id;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.annotations.Document;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Document</span>(indexName = <span class="string">"commodity"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Commodity</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String skuId;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String category;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> Integer stock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了Commodity实例，表示商品。在Elasticsearch 6.X 版本中，不建议使用type，而且在7.X版本中将会彻底废弃type，所以此处我只指定了indexName，没有指定type。这里，一个Commodity代表一个商品，同时代表一条索引记录。</p><h1 id="ElasticsearchRepository"><a href="#ElasticsearchRepository" class="headerlink" title="ElasticsearchRepository"></a>ElasticsearchRepository</h1><p>Spring提供的ES的Repository接口为ElasticsearchCrudRepository，所以我们就可以直接定义额新的接口，然后实现ElasticsearchCrudRepository即可，ElasticsearchRepository也提供了基本的增删改查接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cjs.example.dao;</span><br><span class="line"><span class="keyword">import</span> com.cjs.example.entity.Commodity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.repository.ElasticsearchRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommodityRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Commodity</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，定义service接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cjs.example.service;</span><br><span class="line"><span class="keyword">import</span> com.cjs.example.entity.Commodity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommodityService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Commodity <span class="title">save</span><span class="params">(Commodity commodity)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Commodity commodity)</span></span>;</span><br><span class="line">    <span class="function">Iterable&lt;Commodity&gt; <span class="title">getAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">List&lt;Commodity&gt; <span class="title">getByName</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function">Page&lt;Commodity&gt; <span class="title">pageQuery</span><span class="params">(Integer pageNo, Integer pageSize, String kw)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cjs.example.service.impl;</span><br><span class="line"><span class="keyword">import</span> com.cjs.example.entity.Commodity;</span><br><span class="line"><span class="keyword">import</span> com.cjs.example.dao.CommodityRepository;</span><br><span class="line"><span class="keyword">import</span> com.cjs.example.service.CommodityService;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.index.query.MatchQueryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.index.query.QueryBuilders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.PageRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.core.query.NativeSearchQueryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.core.query.SearchQuery;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommodityServiceImpl</span> <span class="keyword">implements</span> <span class="title">CommodityService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CommodityRepository commodityRepository;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> commodityRepository.count();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Commodity <span class="title">save</span><span class="params">(Commodity commodity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> commodityRepository.save(commodity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Commodity commodity)</span> </span>&#123;</span><br><span class="line">        commodityRepository.delete(commodity);</span><br><span class="line"><span class="comment">//        commodityRepository.deleteById(commodity.getSkuId());</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Commodity&gt; <span class="title">getAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> commodityRepository.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Commodity&gt; <span class="title">getByName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        List&lt;Commodity&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        MatchQueryBuilder matchQueryBuilder = <span class="keyword">new</span> MatchQueryBuilder(<span class="string">"name"</span>, name);</span><br><span class="line">        Iterable&lt;Commodity&gt; iterable = commodityRepository.search(matchQueryBuilder);</span><br><span class="line">        iterable.forEach(e-&gt;list.add(e));</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Page&lt;Commodity&gt; <span class="title">pageQuery</span><span class="params">(Integer pageNo, Integer pageSize, String kw)</span> </span>&#123;</span><br><span class="line">        SearchQuery searchQuery = <span class="keyword">new</span> NativeSearchQueryBuilder()</span><br><span class="line">                .withQuery(QueryBuilders.matchPhraseQuery(<span class="string">"name"</span>, kw))</span><br><span class="line">                .withPageable(PageRequest.of(pageNo, pageSize))</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> commodityRepository.search(searchQuery);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cjs.example;</span><br><span class="line"><span class="keyword">import</span> com.cjs.example.entity.Commodity;</span><br><span class="line"><span class="keyword">import</span> com.cjs.example.service.CommodityService;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">CjsElasticsearchExampleApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CommodityService commodityService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(commodityService.count());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Commodity commodity = <span class="keyword">new</span> Commodity();</span><br><span class="line">        commodity.setSkuId(<span class="string">"1501009001"</span>);</span><br><span class="line">        commodity.setName(<span class="string">"原味切片面包（10片装）"</span>);</span><br><span class="line">        commodity.setCategory(<span class="string">"101"</span>);</span><br><span class="line">        commodity.setPrice(<span class="number">880</span>);</span><br><span class="line">        commodity.setBrand(<span class="string">"良品铺子"</span>);</span><br><span class="line">        commodityService.save(commodity);</span><br><span class="line">        commodity = <span class="keyword">new</span> Commodity();</span><br><span class="line">        commodity.setSkuId(<span class="string">"1501009002"</span>);</span><br><span class="line">        commodity.setName(<span class="string">"原味切片面包（6片装）"</span>);</span><br><span class="line">        commodity.setCategory(<span class="string">"101"</span>);</span><br><span class="line">        commodity.setPrice(<span class="number">680</span>);</span><br><span class="line">        commodity.setBrand(<span class="string">"良品铺子"</span>);</span><br><span class="line">        commodityService.save(commodity);</span><br><span class="line">        commodity = <span class="keyword">new</span> Commodity();</span><br><span class="line">        commodity.setSkuId(<span class="string">"1501009004"</span>);</span><br><span class="line">        commodity.setName(<span class="string">"元气吐司850g"</span>);</span><br><span class="line">        commodity.setCategory(<span class="string">"101"</span>);</span><br><span class="line">        commodity.setPrice(<span class="number">120</span>);</span><br><span class="line">        commodity.setBrand(<span class="string">"百草味"</span>);</span><br><span class="line">        commodityService.save(commodity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Commodity commodity = <span class="keyword">new</span> Commodity();</span><br><span class="line">        commodity.setSkuId(<span class="string">"1501009002"</span>);</span><br><span class="line">        commodityService.delete(commodity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterable&lt;Commodity&gt; iterable = commodityService.getAll();</span><br><span class="line">        iterable.forEach(e-&gt;System.out.println(e.toString()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetByName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Commodity&gt; list = commodityService.getByName(<span class="string">"面包"</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Page&lt;Commodity&gt; page = commodityService.pageQuery(<span class="number">0</span>, <span class="number">10</span>, <span class="string">"切片"</span>);</span><br><span class="line">        System.out.println(page.getTotalPages());</span><br><span class="line">        System.out.println(page.getNumber());</span><br><span class="line">        System.out.println(page.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ElasticsearchTemplate"><a href="#ElasticsearchTemplate" class="headerlink" title="ElasticsearchTemplate"></a>ElasticsearchTemplate</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cjs.example;</span><br><span class="line"><span class="keyword">import</span> com.cjs.example.entity.Commodity;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.index.query.QueryBuilders;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.core.ElasticsearchTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.core.query.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ElasticsearchTemplateTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> ElasticsearchTemplate elasticsearchTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Commodity commodity = <span class="keyword">new</span> Commodity();</span><br><span class="line">        commodity.setSkuId(<span class="string">"1501009005"</span>);</span><br><span class="line">        commodity.setName(<span class="string">"葡萄吐司面包（10片装）"</span>);</span><br><span class="line">        commodity.setCategory(<span class="string">"101"</span>);</span><br><span class="line">        commodity.setPrice(<span class="number">160</span>);</span><br><span class="line">        commodity.setBrand(<span class="string">"良品铺子"</span>);</span><br><span class="line">        IndexQuery indexQuery = <span class="keyword">new</span> IndexQueryBuilder().withObject(commodity).build();</span><br><span class="line">        elasticsearchTemplate.index(indexQuery);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SearchQuery searchQuery = <span class="keyword">new</span> NativeSearchQueryBuilder()</span><br><span class="line">                .withQuery(QueryBuilders.matchQuery(<span class="string">"name"</span>, <span class="string">"吐司"</span>))</span><br><span class="line">                .build();</span><br><span class="line">        List&lt;Commodity&gt; list = elasticsearchTemplate.queryForList(searchQuery, Commodity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch——HTTP操作（六）</title>
      <link href="/2020/07/20/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticsearch%E2%80%94%E2%80%94HTTP%E6%93%8D%E4%BD%9C%EF%BC%88%E5%85%AD%EF%BC%89/"/>
      <url>/2020/07/20/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticsearch%E2%80%94%E2%80%94HTTP%E6%93%8D%E4%BD%9C%EF%BC%88%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Elasticsearch最终是通过HTTP的操作来完成搜索引擎的功能。</p><h1 id="新建和删除Index"><a href="#新建和删除Index" class="headerlink" title="新建和删除Index"></a>新建和删除Index</h1><p>新建 Index，可以直接向 Elastic 服务器发出 PUT 请求。下面的例子是新建一个名叫weather的 Index。</p><pre><code>$ curl -X PUT &apos;localhost:9200/weather&apos;</code></pre><p>服务器返回一个 JSON 对象，里面的acknowledged字段表示操作成功。</p><pre><code>{ &quot;acknowledged&quot;:true, &quot;shards_acknowledged&quot;:true }</code></pre><p>然后，我们发出 DELETE 请求，删除这个 Index。</p><pre><code>$ curl -X DELETE &apos;localhost:9200/weather&apos;</code></pre><h1 id="中文分词设置"><a href="#中文分词设置" class="headerlink" title="中文分词设置"></a>中文分词设置</h1><p>首先，安装中文分词插件。这里使用的是 ik，也可以考虑其他插件（比如 smartcn）。</p><pre><code>$ ./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v5.5.1/elasticsearch-analysis-ik-5.5.1.zip</code></pre><p>上面代码安装的是5.5.1版的插件，与 Elastic 5.5.1 配合使用。</p><p>接着，重新启动 Elastic，就会自动加载这个新安装的插件。</p><p>然后，新建一个 Index，指定需要分词的字段。这一步根据数据结构而异，下面的命令只针对本文。基本上，凡是需要搜索的中文字段，都要单独设置一下。</p><pre><code>$ curl -X PUT &apos;localhost:9200/accounts&apos; -d &apos;{&quot;mappings&quot;: {&quot;person&quot;: {&quot;properties&quot;: {&quot;user&quot;: {&quot;type&quot;: &quot;text&quot;,&quot;analyzer&quot;: &quot;ik_max_word&quot;,&quot;search_analyzer&quot;: &quot;ik_max_word&quot;},&quot;title&quot;: {&quot;type&quot;: &quot;text&quot;,&quot;analyzer&quot;: &quot;ik_max_word&quot;,&quot;search_analyzer&quot;: &quot;ik_max_word&quot;},&quot;desc&quot;: {&quot;type&quot;: &quot;text&quot;,&quot;analyzer&quot;: &quot;ik_max_word&quot;,&quot;search_analyzer&quot;: &quot;ik_max_word&quot;}}}}}&apos;</code></pre><p>面代码中，analyzer是字段文本的分词器，search_analyzer是搜索词的分词器。ik_max_word分词器是插件ik提供的，可以对文本进行最大数量的分词。</p><h1 id="新增记录"><a href="#新增记录" class="headerlink" title="新增记录"></a>新增记录</h1><p>向指定的 /Index/Type 发送 PUT 请求，就可以在 Index 里面新增一条记录。比如，向/accounts/person发送请求，就可以新增一条人员记录。</p><pre><code>$ curl -X PUT &apos;localhost:9200/accounts/person/1&apos; -d &apos;{&quot;user&quot;: &quot;张三&quot;,&quot;title&quot;: &quot;工程师&quot;,&quot;desc&quot;: &quot;数据库管理&quot;}&apos;</code></pre><p>服务器返回的 JSON 对象，会给出 Index、Type、Id、Version 等信息。</p><pre><code>{ &quot;_index&quot;:&quot;accounts&quot;, &quot;_type&quot;:&quot;person&quot;, &quot;_id&quot;:&quot;1&quot;, &quot;_version&quot;:1, &quot;result&quot;:&quot;created&quot;, &quot;_shards&quot;:{&quot;total&quot;:2,&quot;successful&quot;:1,&quot;failed&quot;:0}, &quot;created&quot;:true }</code></pre><p>如果你仔细看，会发现请求路径是/accounts/person/1，最后的1是该条记录的 Id。它不一定是数字，任意字符串（比如abc）都可以。</p><p>新增记录的时候，也可以不指定 Id，这时要改成 POST 请求。</p><pre><code>$ curl -X POST &apos;localhost:9200/accounts/person&apos; -d &apos;{&quot;user&quot;: &quot;李四&quot;,&quot;title&quot;: &quot;工程师&quot;,&quot;desc&quot;: &quot;系统管理&quot;}&apos;</code></pre><p>上面代码中，向/accounts/person发出一个 POST 请求，添加一个记录。这时，服务器返回的 JSON 对象里面，_id字段就是一个随机字符串。</p><pre><code>{ &quot;_index&quot;:&quot;accounts&quot;, &quot;_type&quot;:&quot;person&quot;, &quot;_id&quot;:&quot;AV3qGfrC6jMbsbXb6k1p&quot;, &quot;_version&quot;:1, &quot;result&quot;:&quot;created&quot;, &quot;_shards&quot;:{&quot;total&quot;:2,&quot;successful&quot;:1,&quot;failed&quot;:0}, &quot;created&quot;:true }</code></pre><p>注意，如果没有先创建 Index（这个例子是accounts），直接执行上面的命令，Elastic 也不会报错，而是直接生成指定的 Index。所以，打字的时候要小心，不要写错 Index 的名称。</p><h1 id="查看记录"><a href="#查看记录" class="headerlink" title="查看记录"></a>查看记录</h1><p>向/Index/Type/Id发出 GET 请求，就可以查看这条记录。</p><pre><code>$ curl &apos;localhost:9200/accounts/person/1?pretty=true&apos;</code></pre><p>上面代码请求查看/accounts/person/1这条记录，URL 的参数pretty=true表示以易读的格式返回。</p><p>返回的数据中，found字段表示查询成功，_source字段返回原始记录。</p><pre><code>{ &quot;_index&quot; : &quot;accounts&quot;, &quot;_type&quot; : &quot;person&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_version&quot; : 1, &quot;found&quot; : true, &quot;_source&quot; : { &quot;user&quot; : &quot;张三&quot;, &quot;title&quot; : &quot;工程师&quot;, &quot;desc&quot; : &quot;数据库管理&quot; } }</code></pre><p>如果 Id 不正确，就查不到数据，found字段就是false。</p><pre><code>$ curl &apos;localhost:9200/weather/beijing/abc?pretty=true&apos; { &quot;_index&quot; : &quot;accounts&quot;, &quot;_type&quot; : &quot;person&quot;, &quot;_id&quot; : &quot;abc&quot;, &quot;found&quot; : false }</code></pre><h1 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h1><p>删除记录就是发出 DELETE 请求。</p><pre><code>$ curl -X DELETE &apos;localhost:9200/accounts/person/1&apos;</code></pre><p>这里先不要删除这条记录，后面还要用到。</p><h1 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h1><p>更新记录就是使用 PUT 请求，重新发送一次数据。</p><pre><code>$ curl -X PUT &apos;localhost:9200/accounts/person/1&apos; -d &apos;{&quot;user&quot; : &quot;张三&quot;,&quot;title&quot; : &quot;工程师&quot;,&quot;desc&quot; : &quot;数据库管理，软件开发&quot;}&apos; { &quot;_index&quot;:&quot;accounts&quot;, &quot;_type&quot;:&quot;person&quot;, &quot;_id&quot;:&quot;1&quot;, &quot;_version&quot;:2, &quot;result&quot;:&quot;updated&quot;, &quot;_shards&quot;:{&quot;total&quot;:2,&quot;successful&quot;:1,&quot;failed&quot;:0}, &quot;created&quot;:false }</code></pre><p>上面代码中，我们将原始数据从”数据库管理”改成”数据库管理，软件开发”。 返回结果里面，有几个字段发生了变化。</p><pre><code>&quot;_version&quot; : 2, &quot;result&quot; : &quot;updated&quot;, &quot;created&quot; : false</code></pre><p>可以看到，记录的 Id 没变，但是版本（version）从1变成2，操作类型（result）从created变成updated，created字段变成false，因为这次不是新建记录。</p><h1 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h1><ol><li><p>返回所有记录</p><p> 使用 GET 方法，直接请求/Index/Type/_search，就会返回所有记录。</p><pre><code>$ curl &apos;localhost:9200/accounts/person/_search&apos; { &quot;took&quot;:2, &quot;timed_out&quot;:false, &quot;_shards&quot;:{&quot;total&quot;:5,&quot;successful&quot;:5,&quot;failed&quot;:0}, &quot;hits&quot;:{ &quot;total&quot;:2, &quot;max_score&quot;:1.0, &quot;hits&quot;:[ { &quot;_index&quot;:&quot;accounts&quot;, &quot;_type&quot;:&quot;person&quot;, &quot;_id&quot;:&quot;AV3qGfrC6jMbsbXb6k1p&quot;, &quot;_score&quot;:1.0, &quot;_source&quot;: { &quot;user&quot;: &quot;李四&quot;, &quot;title&quot;: &quot;工程师&quot;, &quot;desc&quot;: &quot;系统管理&quot; } }, { &quot;_index&quot;:&quot;accounts&quot;, &quot;_type&quot;:&quot;person&quot;, &quot;_id&quot;:&quot;1&quot;, &quot;_score&quot;:1.0, &quot;_source&quot;: { &quot;user&quot; : &quot;张三&quot;, &quot;title&quot; : &quot;工程师&quot;, &quot;desc&quot; : &quot;数据库管理，软件开发&quot; } } ] } }</code></pre><p> 上面代码中，返回结果的 took字段表示该操作的耗时（单位为毫秒），timed_out字段表示是否超时，hits字段表示命中的记录，里面子字段的含义如下。</p><ul><li><p>total：返回记录数，本例是2条。</p></li><li><p>max_score：最高的匹配程度，本例是1.0。</p></li><li><p>hits：返回的记录组成的数组。</p><p>返回的记录中，每条记录都有一个_score字段，表示匹配的程序，默认是按照这个字段降序排列。</p></li></ul></li><li><p>全文搜索</p><p> Elastic 的查询非常特别，使用自己的查询语法，要求 GET 请求带有数据体。</p><pre><code>$ curl &apos;localhost:9200/accounts/person/_search&apos; -d &apos;{&quot;query&quot; : { &quot;match&quot; : { &quot;desc&quot; : &quot;软件&quot; }}}&apos;</code></pre><p> 上面代码使用 Match 查询，指定的匹配条件是desc字段里面包含”软件”这个词。返回结果如下。</p><pre><code>{ &quot;took&quot;:3, &quot;timed_out&quot;:false, &quot;_shards&quot;:{&quot;total&quot;:5,&quot;successful&quot;:5,&quot;failed&quot;:0}, &quot;hits&quot;:{ &quot;total&quot;:1, &quot;max_score&quot;:0.28582606, &quot;hits&quot;:[ { &quot;_index&quot;:&quot;accounts&quot;, &quot;_type&quot;:&quot;person&quot;, &quot;_id&quot;:&quot;1&quot;, &quot;_score&quot;:0.28582606, &quot;_source&quot;: { &quot;user&quot; : &quot;张三&quot;, &quot;title&quot; : &quot;工程师&quot;, &quot;desc&quot; : &quot;数据库管理，软件开发&quot; } } ] } }</code></pre><p> Elastic 默认一次返回10条结果，可以通过size字段改变这个设置。</p><pre><code>$ curl &apos;localhost:9200/accounts/person/_search&apos; -d &apos;{&quot;query&quot; : { &quot;match&quot; : { &quot;desc&quot; : &quot;管理&quot; }},&quot;size&quot;: 1}&apos;</code></pre><p> 上面代码指定，每次只返回一条结果。</p><p> 还可以通过from字段，指定位移。</p><pre><code>$ curl &apos;localhost:9200/accounts/person/_search&apos; -d &apos;{&quot;query&quot; : { &quot;match&quot; : { &quot;desc&quot; : &quot;管理&quot; }},&quot;from&quot;: 1,&quot;size&quot;: 1}&apos;</code></pre><p> 上面代码指定，从位置1开始（默认是从位置0开始），只返回一条结果。</p></li></ol><h1 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h1><p>如果有多个搜索关键字， Elastic 认为它们是or关系。</p><pre><code>$ curl &apos;localhost:9200/accounts/person/_search&apos; -d &apos;{&quot;query&quot; : { &quot;match&quot; : { &quot;desc&quot; : &quot;软件 系统&quot; }}}&apos;</code></pre><p>上面代码搜索的是软件 or 系统。</p><p>如果要执行多个关键词的and搜索，必须使用布尔查询。</p><pre><code>$ curl &apos;localhost:9200/accounts/person/_search&apos; -d &apos;{&quot;query&quot;: {&quot;bool&quot;: {&quot;must&quot;: [{ &quot;match&quot;: { &quot;desc&quot;: &quot;软件&quot; } },{ &quot;match&quot;: { &quot;desc&quot;: &quot;系统&quot; } }]}}}&apos;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch HTTP操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch——分布式原理（三）</title>
      <link href="/2020/07/20/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticsearch%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2020/07/20/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticsearch%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ElastiSearch天生就是 分布式的 ，它知道如何通过管理多节点来提高扩容性和可用性。</p><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>一个运行中的 Elasticsearch 实例称为一个节点，而集群是由一个或者多个拥有相同 cluster.name 配置的节点组成， 它们共同承担数据和负载的压力。</p><p>当有节点加入集群中或者从集群中移除节点时，集群将会重新平均分布所有的数据。</p><ol><li><p>主节点（Master Node）</p><p>主节点负责创建索引、删除索引、分配分片、追踪集群中的节点状态等工作。Elasticsearch 中的主节点的工作量相对较轻。</p><p>用户的请求可以发往任何一个节点，并由该节点负责分发请求、收集结果等操作，而并不需要经过主节点转发。</p></li><li><p>数据节点</p><p> 数据节点，负责数据的存储和相关具体操作，比如索引数据的创建、修改、删除、搜索、聚合。</p></li><li><p>候选节点</p><p> 在 Elasticsearch 集群中只有候选节点才有选举权和被选举权。其他节点是不参与选举工作的。</p></li><li><p>协调节点</p><p> 是一种角色，而不是真实的 Elasticsearch 的节点，我们没有办法通过配置项来配置哪个节点为协调节点。集群中的任何节点都可以充当协调节点的角色。</p><p> 当一个节点 A 收到用户的查询请求后，会把查询语句分发到其他的节点，然后合并各个节点返回的查询结果，最好返回一个完整的数据集给用户。</p><p> 其实任何一个节点都可以完成这样的工作，单独增加这样的节点更多地是为了提高并发性。</p></li></ol><h1 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h1><p>Elasticsearch 会对索引数据进行切分，同时每一个分片会保存多个副本，其原因和 HDFS 是一样的，都是为了保证分布式环境下的高可用。</p><p>当一个节点因为网络或者其他原因宕机，其上的主分片和副本分片会丢失。</p><p>副本分片的丢失不会影响数据的读取，主分片的丢失则会有消息丢失的风险，此时需要从其他节点的主分片的副本分片选举一个作为主节点。</p><ol><li><p>主分片和副本分片</p><p> 一个分片可以是 主 分片或者 副本 分片。 索引内任意一个文档都归属于一个主分片，所以主分片的数目决定着索引能够保存的最大数据量。</p><p> 副本分片作为硬件故障时保护数据不丢失的冗余备份，并为搜索和返回文档等读操作提供服务。设及到数据的增减和修改在主分片上处理过后会转发给副本分篇</p></li><li><p>数据分布</p><p> Elasticsearch 如何知道一个文档应该存放到哪个分片中呢？当我们创建文档时，它如何决定这个文档应当被存储在分片 1 还是分片 2 中呢？这个过程是根据下面这个公式决定的：</p><p> shard = hash(routing) % number_of_primary_shards</p><p> routing 是一个可变值，默认是文档的 _id ，也可以设置成一个自定义的值。 routing 通过 hash 函数生成一个数字，然后这个数字再除以 number_of_primary_shards （主分片的数量）后得到 余数 。这个分布在 0 到 number_of_primary_shards-1 之间的余数，就是我们所寻求的文档所在分片的位置。</p><p> 所以我们要在创建索引的时候就确定好主分片的数量 并且永远不会改变这个数量：因为如果数量变化了，那么所有之前路由的值都会无效，文档也再也找不到了。</p></li></ol><h1 id="集群健康"><a href="#集群健康" class="headerlink" title="集群健康"></a>集群健康</h1><p>集群的状态有 Green、Yellow 和 Red 三种，如下所述：</p><ul><li><p>Green：绿色，健康。所有的主分片和副本分片都可正常工作，集群 100% 健康。</p></li><li><p>Yellow：黄色，预警。所有的主分片都可以正常工作，但至少有一个副本分片是不能正常工作的。此时集群可以正常工作，但是集群的高可用性在某种程度上被弱化。</p></li><li><p>Red：红色，集群不可正常使用。集群中至少有一个分片的主分片及它的全部副本分片都不可正常工作。</p></li></ul><h1 id="3C和脑裂"><a href="#3C和脑裂" class="headerlink" title="3C和脑裂"></a>3C和脑裂</h1><ol><li><p>共识性</p><p> 共识性是分布式系统中最基础也最主要的一个组件，在分布式系统中的所有节点必须对给定的数据或者节点的状态达成共识。</p><p> 但是 Elasticsearch 并没有使用它们，而是自己实现共识系统 zen discovery。</p><p> zen discovery 是 Elasticsearch 的一个核心的基础组件，zen discovery 不仅能够实现共识系统的选择工作，还能够很方便地监控集群的读写状态是否健康。当然，我们也不保证其后期会使用 Zookeeper 代替现在的 zen discovery”。</p><p> zen discovery 模块以 “八卦传播”（Gossip）的形式实现了单播（Unicat）：单播不同于多播（Multicast）和广播（Broadcast）。节点间的通信方式是一对一的。</p></li><li><p>并发</p><p> Elasticsearch 是一个分布式系统。写请求在发送到主分片时，同时会以并行的形式发送到备份分片，但是这些请求的送达时间可能是无序的。</p><p> 在这种情况下，Elasticsearch 用乐观并发控制（Optimistic Concurrency Control）来保证新版本的数据不会被旧版本的数据覆盖。</p><p> 乐观并发控制是一种乐观锁，另一种常用的乐观锁即多版本并发控制（Multi-Version Concurrency Control）。</p><p> 它们的主要区别如下：</p><ul><li>乐观并发控制（OCC）：是一种用来解决写 - 写冲突的无锁并发控制，认为事务间的竞争不激烈时，就先进行修改，在提交事务前检查数据有没有变化，如果没有就提交，如果有就放弃并重试。乐观并发控制类似于自选锁，适用于低数据竞争且写冲突比较少的环境。</li><li>多版本并发控制（MVCC）：是一种用来解决读 - 写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每一个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。</li></ul></li><li><p>一致性（Consistency）</p><p> Elasticsearch 集群保证写一致性的方式是在写入前先检查有多少个分片可供写入，如果达到写入条件，则进行写操作，否则，Elasticsearch 会等待更多的分片出现，默认为一分钟。</p><p> 有如下三种设置来判断是否允许写操作：</p><ul><li><p>One：只要主分片可用，就可以进行写操作。</p></li><li><p>All：只有当主分片和所有副本都可用时，才允许写操作。</p></li><li><p>Quorum（k-wu-wo/reng，法定人数）：是 Elasticsearch 的默认选项。当有大部分的分片可用时才允许写操作。其中，对 “大部分” 的计算公式为 int ((primary+number_of_replicas)/2)+1。</p><p>Elasticsearch 集群保证读写一致性的方式是，为了保证搜索请求的返回结果是最新版本的文档，备份可以被设置为 Sync（默认值），写操作在主分片和备份分片同时完成后才会返回写请求的结果。</p><p>这样，无论搜索请求至哪个分片都会返回最新的文档。但是如果我们的应用对写要求很高，就可以通过设置 replication=async 来提升写的效率，如果设置 replication=async，则只要主分片的写完成，就会返回写成功。</p></li></ul></li><li><p>脑裂</p><p> 在 Elasticsearch 集群中主节点通过 Ping 命令来检查集群中的其他节点是否处于可用状态，同时非主节点也会通过 Ping 来检查主节点是否处于可用状态。</p><p> 当集群网络不稳定时，有可能会发生一个节点 Ping 不通 Master 节点，则会认为 Master 节点发生了故障，然后重新选出一个 Master 节点，这就会导致在一个集群内出现多个 Master 节点。</p><p> 当在一个集群中有多个 Master 节点时，就有可能会导致数据丢失。我们称这种现象为脑裂。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch 分布式原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch——搜索引擎原理（一）</title>
      <link href="/2020/07/20/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticsearch%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/07/20/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticsearch%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>搜索引擎三大过程：爬取内容、进行分词、建立反向索引。</p><h1 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h1><p>很多搜索引擎是基于倒排索引，不过在倒排索引之前，我们先看看<code>正排索引</code>。</p><p>正排其实就是数据库表，他通过id和数据进行关联。我们可以通过搜索id，来获得相应的数据，也能删除数据。你买了一本书，书的目录其实也是正排搜索。</p><table><thead><tr><th>数据id</th><th align="left">数据内容</th></tr></thead><tbody><tr><td>1001</td><td align="left">苹果公司发布iPhone</td></tr><tr><td>1002</td><td align="left">地球引力起源于苹果</td></tr><tr><td>1003</td><td align="left">iPhone屏幕碎了</td></tr><tr><td>1004</td><td align="left">我在苹果商店维修屏幕</td></tr><tr><td>1005</td><td align="left">我刚刚吃了苹果</td></tr></tbody></table><p>但是我们如果通过具体数据内容<code>苹果</code>去搜索，就要去表中每一行的数据去匹配，如果数据量很大，很影响性能。</p><p>其次，这个时候我想搜索<code>苹果iPhone</code>，那么我们无法把这词汇拆开再到数据库去搜索。</p><ul><li><p>优点：使用起来方便，原理也简单，比较入门</p></li><li><p>缺点：检索效率低下，适合简单场景使用，比如传统项目，数据量较小的项目。不支持分词搜索。</p></li></ul><p><code>倒排索引</code>与正排索引正好相反，他会把文档内容进行分词，比如<code>苹果公司发布iPhone</code>是一个文档数据，当我们把他存入到搜索引擎中去的时候，会有一个文档id，这个文档id就类似于数据库主键。但是这文档存储的时候和数据库不一样，他会进行一个分词，参照上面的表格，分词后的结果如下：</p><table><thead><tr><th>文档数据</th><th>分词结果</th></tr></thead><tbody><tr><td>苹果公司发布iPhone</td><td>苹果，公司，发布，iPhone</td></tr><tr><td>地球引力起源于苹果</td><td>地球，引力，起源，于，苹果</td></tr><tr><td>iPhone屏幕碎了</td><td>iPhone，屏幕，碎了</td></tr><tr><td>我在苹果商店维修屏幕</td><td>我，在，苹果，商店，维修，屏幕</td></tr><tr><td>我刚刚吃了苹果</td><td>我，刚刚，吃了，苹果</td></tr></tbody></table><p>每一个词汇都会和文档id关联起来，可以根据词汇来找到所有出现的id列表，如下：</p><table><thead><tr><th>词汇</th><th>文档ids</th></tr></thead><tbody><tr><td>苹果</td><td>1001，1002，1004，1005</td></tr><tr><td>iPhone</td><td>1001，1003</td></tr><tr><td>屏幕</td><td>1003，1004</td></tr><tr><td>碎了</td><td>1003</td></tr><tr><td>我</td><td>1004，1005</td></tr><tr><td>在</td><td>1004</td></tr><tr><td>商店</td><td>1004</td></tr><tr><td>维修</td><td>1004</td></tr><tr><td>刚刚</td><td>1005</td></tr><tr><td>吃了</td><td>1005</td></tr><tr><td>····</td><td></td></tr></tbody></table><p>假设现在我要搜索<code>iPhone</code>，如果是数据库搜索，假设有1亿条数据，那么会匹配1亿次，全表扫描。最后再把数据返回出来。</p><p>如果是搜索引擎，那么有可能第一次就把所有文档数据给查出来，当然也有可能是第N次，当然他肯定要比数据库的搜索效率更高。如图中位置，他会直接把<code>1001，1003</code>两个文档返回。</p><p>而且搜索引擎是直接把关键字做匹配，相同当量的数据，效率肯定也是后者更快。</p><ul><li><p>优点：搜索更快，耗时短，用户体验高，精装度也高</p></li><li><p>缺点：维护成本高，索引新建后要修改，必须先删除，前期需要很好地规划</p></li></ul><h1 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h1><p>分词可以说是搜索引擎的基石，如果一个搜索引擎没有好的分词器那么这个搜索引擎必然是失败的。</p><p>搜索是以词作为最小单元，依靠分词器进行构建，最后会生成一个倒排索引。</p><p>分词器就负责拆分我们的语句。比如“my name is nijunyang”。分词的时候会处理掉一些区分度不高的词，英文中“is，are”，中文“的，是”这些之类。</p><p>通过分词之后结果再次指向原来的文档，通过value反向生成key（多个），这就是倒排索引。而我们以前的那些正向索引是先key-value，一般来说是一一对应，而且key也不是通过value去生成。</p><h1 id="爬取内容"><a href="#爬取内容" class="headerlink" title="爬取内容"></a>爬取内容</h1><p>搜索引擎蜘蛛通过跟踪链接访问网页，获得页面HTML代码存入数据库。</p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch 搜索引擎原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch——介绍与安装（二）</title>
      <link href="/2020/07/20/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticsearch%E2%80%94%E2%80%94%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/07/20/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticsearch%E2%80%94%E2%80%94%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>很多时候我们是搜索引擎的使用者，而不是自己去实现。业内已经有成熟的开源解决方案。</p><p>很早以前，业内有一个叫 <code>Lucene</code> 的库，用它我们可以很方便的建立倒排索引。但是 lucene 还是需要懂得搜索引擎的原理的人才能用好。</p><p>所以后来又有人基于 Lucene 进行封装，写出了 Elasticsearch。</p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ul><li>Elasticsearch将搜索引擎的封装都做成了RestFul的api,通过http请求就能对其进行操作。</li><li>同时对于海量数据，它还实现了分布式，是一个分布式搜索引擎。</li></ul><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ol><li><p>Node 与 Cluster</p><p> Elastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。</p><p> 单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。</p></li><li><p>索引</p><p>此索引并非上文中我们讲的索引，elasticsearch中的索引是存放数据的地方。相当于mysql的数据库。</p></li><li><p>类型</p><p>用来定义数据结构的，相当于数据库的一张表。</p></li><li><p>文档</p><p>文档是存放最终数据的地方，可以相当于表中的一行。</p></li></ol><p>比如一首诗，有诗题、作者、朝代、字数、诗内容等字段，那么首先，我们可以建立一个名叫 Poems 的索引，然后创建一个名叫 Poem 的类型，类型是通过 Mapping 来定义每个字段的类型。</p><p>比如诗题、作者、朝代都是 Keyword 类型，诗内容是 Text 类型，而字数是 Integer 类型，最后就是把数据组织成 Json 格式存放进去了。</p><p><img src="/images/Elasticsearch%E2%80%94%E2%80%94%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85%EF%BC%88%E4%BA%8C%EF%BC%89_2020-07-20-14-17-18.png" alt="Elasticsearch——介绍与安装（二）_2020-07-20-14-17-18.png"></p><p>注意：Keyword 类型是不会分词的，直接根据字符串内容建立反向索引，Text 类型在存入 Elasticsearch 的时候，会先分词，然后根据分词后的内容建立反向索引。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><a href="https://blog.csdn.net/weixin_44596128/article/details/103970665" target="_blank" rel="noopener">ubuntu 安装ES</a></p><p><a href="https://www.cnblogs.com/renxixao/archive/2019/09/05/11462754.html" target="_blank" rel="noopener">linux 安装ES</a></p><p><a href="https://www.cnblogs.com/merely/p/12594990.html" target="_blank" rel="noopener">linux 集群搭建</a></p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://www.cnblogs.com/kevingrace/p/6298022.html" target="_blank" rel="noopener">Elasticsearch 最佳运维实践 - 总结（一） </a></p><p><a href="https://www.cnblogs.com/kevingrace/p/10682264.html" target="_blank" rel="noopener">Elasticsearch 最佳运维实践 - 总结（二） </a></p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch 介绍与安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven——依赖冲突（九）</title>
      <link href="/2020/07/17/Maven%E2%80%94%E2%80%94%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
      <url>/2020/07/17/Maven%E2%80%94%E2%80%94%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81%EF%BC%88%E4%B9%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当我们使用 Maven 来构建我们的程序时，我们可以用几句配置来代替大量的 Jar 包，同时因为这种配置在我们交流代码时可以不用自己引入 Jar 包（避免了版本不一致而出错），只要更新 Maven，它就会在后台帮我们解决这一切。但是在我们享受这种方便的同时，我们也在为这种方便付出代价。通常都是版本不一致出现的依赖冲突。</p><h1 id="依赖冲突-例"><a href="#依赖冲突-例" class="headerlink" title="依赖冲突-例"></a>依赖冲突-例</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.3.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hibernate.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其依赖树如下：</p><p><img src="/images/Maven%E2%80%94%E2%80%94%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81%EF%BC%88%E4%B9%9D%EF%BC%89_2020-07-17-11-04-10.png" alt="Maven——依赖冲突（九）_2020-07-17-11-04-10.png"></p><p>我们可以清楚地看到 hibernate-core 所依赖的 jboss-logging 被省略了 （灰色的那一个依赖），因为 Maven ( 或者说是 Java 的 ClassLoader ) 先加载了 hibernate-validator 所依赖的 jboss-logging，就会忽略其他同名依赖。 一般情况来说, 这是不会出现问题的, 因为在你使用 Maven 时, 你已经不知不觉地通过这种方式多次使你的代码正确执行了, 但是一旦出现了错误, 你多半会被坑的死去活来 ~. ~</p><p>比如我举的这个例子, 当你初始化 SessionFactory 时, 你将会见到如下错误提醒：</p><pre><code>java.lang.NoSuchMethodError: org.hibernate.internal.CoreMessageLogger.debugf(Ljava/lang/String;II)V</code></pre><p>首先检查类或方法是否存在，如果找到类，却没有在该类及其父类中找到该方法，那么百分百就是版本错误。</p><p>最终确定是 jboss-logging 版本错误。</p><h1 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h1><ol><li>将重要的依赖放在前面</li></ol><p>因为 maven 会优先加载第一个遇到的版本，所以我们只需要将 hibernate-core 移到 hibernate-validator 的前面，这样 Maven 就会加载到 3.3.0 这个版本。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.3.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用 exclusions 标记排除依赖</li></ol><p>将干扰的依赖排除后就没有后顾之忧了，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.3.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jboss.logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jboss-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>使用 mvn dependency:tree 命令查看依赖树</li></ol><p>mvn dependency:tree 选项</p><ul><li><p>verbose 显示全部，不使用此选项则显示部分。当然了，这不是让你一次性显示所有依赖出来，因为太多了，显示出来的话阅读难度指数上升，有兴趣可亲身一试 ~. ~</p></li><li><p>includes 筛选出想要的的依赖，使用时只显示被加载的 jar 包，如果和 verbose 一起使用则可以查看被忽略的 jar 包，如下</p></li><li><p>excludes 这个就没什么好说的，includes 相反的作用</p><pre><code>mvn dependency:tree -Dverbose -Dincludes=org.jboss.logging:jboss-logging</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven 依赖冲突 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven——自动化部署（八）</title>
      <link href="/2020/07/17/Maven%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%EF%BC%88%E5%85%AB%EF%BC%89/"/>
      <url>/2020/07/17/Maven%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%EF%BC%88%E5%85%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通常我们发布项目，会经过以下步骤：</p><ol><li>打包本地项目，生成jar包/war包</li><li>将jar包/war包发布到公共库</li><li>从公共库下载最新版本到scp到liunx服务器</li></ol><p>现在用maven我们可以自动完成以上步骤。</p><h1 id="配置-linux-server-信息"><a href="#配置-linux-server-信息" class="headerlink" title="配置 linux server 信息"></a>配置 linux server 信息</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servers</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span>       </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>zhy-linux-server<span class="tag">&lt;/<span class="name">id</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">username</span>&gt;</span>zhy<span class="tag">&lt;/<span class="name">username</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">password</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="在pom-xml的build节点加入wagon-ssh的信息"><a href="#在pom-xml的build节点加入wagon-ssh的信息" class="headerlink" title="在pom.xml的build节点加入wagon-ssh的信息"></a>在pom.xml的build节点加入wagon-ssh的信息</h1><p><img src="/images/Maven%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%EF%BC%88%E5%85%AB%EF%BC%89_2020-07-17-10-47-49.png" alt="Maven——自动化部署（八）_2020-07-17-10-47-49.png"></p><h1 id="加入这个插件"><a href="#加入这个插件" class="headerlink" title="加入这个插件"></a>加入这个插件</h1><p><img src="/images/Maven%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%EF%BC%88%E5%85%AB%EF%BC%89_2020-07-17-10-48-46.png" alt="Maven——自动化部署（八）_2020-07-17-10-48-46.png"></p><h1 id="推到公共库"><a href="#推到公共库" class="headerlink" title="推到公共库"></a>推到公共库</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>centra<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8084/artifactory/list/local<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">uniqueVersion</span>&gt;</span>true<span class="tag">&lt;/<span class="name">uniqueVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><pre><code>mvn clean package</code></pre>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven 自动化部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven——引入外部依赖（七）</title>
      <link href="/2020/07/17/Maven%E2%80%94%E2%80%94%E5%BC%95%E5%85%A5%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96%EF%BC%88%E4%B8%83%EF%BC%89/"/>
      <url>/2020/07/17/Maven%E2%80%94%E2%80%94%E5%BC%95%E5%85%A5%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96%EF%BC%88%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>pom.xml 的 dependencies 列表列出了我们的项目需要构建的所有外部依赖项。<br>要添加依赖项，我们一般是先在 src 文件夹下添加 lib 文件夹，然后将你工程需要的 jar 文件复制到 lib 文件夹下。我们使用的是 ldapjdk.jar ，它是为 LDAP 操作的一个帮助库：</p><p>然后添加以下依赖到 pom.xml 文件中:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在这里添加你的依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ldapjdk<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  <span class="comment">&lt;!-- 库名称，也可以自定义 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ldapjdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="comment">&lt;!--库名称，也可以自定义--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!--版本号--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span> <span class="comment">&lt;!--作用域--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;basedir&#125;\src\lib\ldapjdk.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span> <span class="comment">&lt;!--项目根目录下的lib文件夹下--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven 引入外部依赖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven——命令构建项目（六）</title>
      <link href="/2020/07/17/Maven%E2%80%94%E2%80%94%E5%91%BD%E4%BB%A4%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%EF%BC%88%E5%85%AD%EF%BC%89/"/>
      <url>/2020/07/17/Maven%E2%80%94%E2%80%94%E5%91%BD%E4%BB%A4%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%EF%BC%88%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Maven 使用原型 archetype 插件创建项目</p><h1 id="简单java项目"><a href="#简单java项目" class="headerlink" title="简单java项目"></a>简单java项目</h1><p>要创建一个简单的 Java 应用，我们将使用 maven-archetype-quickstart 插件。</p><pre><code>mvn archetype:generate &quot;-DgroupId=com.companyname.bank&quot; &quot;-DartifactId=consumerBanking&quot; &quot;-DarchetypeArtifactId=maven-archetype-quickstart&quot; &quot;-DinteractiveMode=false&quot;</code></pre><p>参数说明：</p><ul><li>DgourpId: 组织名，公司网址的反写 + 项目名称</li><li>DartifactId: 项目名-模块名</li><li>DarchetypeArtifactId: 指定 ArchetypeId，maven-archetype-quickstart，创建一个简单的 Java 应用</li><li>DinteractiveMode: 是否使用交互模式</li></ul><h1 id="简单web项目"><a href="#简单web项目" class="headerlink" title="简单web项目"></a>简单web项目</h1><p>使用 maven-archetype-webapp 插件</p><pre><code>mvn archetype:generate -DgroupId=com.domain-DartifactId=webappdemo-Dpackage=com.domain.webappdemo-DarchetypeArtifactId=maven-archetype-webapp-Dversion=1.0 -DinteractiveMode=No</code></pre><h1 id="简单struts2-web项目"><a href="#简单struts2-web项目" class="headerlink" title="简单struts2 web项目"></a>简单struts2 web项目</h1><p>使用 struts2-archetype-convention 插件</p><pre><code>mvn archetype:generate -B -DgroupId=com.mycompany.mysystem-DartifactId=myWebApp-DarchetypeGroupId=org.apache.struts-DarchetypeArtifactId=struts2-archetype-convention-DarchetypeVersion=&lt;CURRENT_STRUTS_VERSION&gt;-DremoteRepositories=http://struts.apache.org</code></pre>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven 命令构建项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven——插件（五）</title>
      <link href="/2020/07/16/Maven%E2%80%94%E2%80%94%E6%8F%92%E4%BB%B6%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2020/07/16/Maven%E2%80%94%E2%80%94%E6%8F%92%E4%BB%B6%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上文我们讲述了maven的生命周期，每个生命周期中都包含着一系列的阶段(phase)。这些 phase 就相当于 Maven 提供的统一的接口，然后这些 phase 的实现由 Maven 的插件来完成。</p><p>我们在输入 mvn 命令的时候 比如 mvn clean，clean 对应的就是 Clean 生命周期中的 clean 阶段。但是 clean 的具体操作是由 maven-clean-plugin 来实现的。</p><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p>Maven 实际上是一个依赖插件执行的框架，每个任务实际上是由插件完成。Maven 插件通常被用来：</p><ul><li>创建 jar 文件</li><li>创建 war 文件</li><li>编译代码文件</li><li>代码单元测试</li><li>创建工程文档</li><li>创建工程报告</li></ul><h1 id="常用插件整理"><a href="#常用插件整理" class="headerlink" title="常用插件整理"></a>常用插件整理</h1><h2 id="maven内置变量"><a href="#maven内置变量" class="headerlink" title="maven内置变量"></a>maven内置变量</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">$&#123;basedir&#125;表示项目根目录,即包含pom.xml文件的目录;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">$&#123;version&#125;表示项目版本;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">$&#123;project.basedir&#125;同$&#123;basedir&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">$&#123;project.baseUri&#125;表示项目文件地址;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">$&#123;maven.build.timestamp&#125;表示项目构件开始时间;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">$&#123;maven.build.timestamp.format&#125;表示属性$&#123;maven.build.timestamp&#125;的展示格式,默认值为yyyyMMdd-HHmm,可自定义其格式,其类型可参考java.text.SimpleDateFormat。</span></span><br><span class="line"><span class="attr">　$&#123;project.build.directory&#125;表示主源码路径;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">　$&#123;project.build.sourceEncoding&#125;表示主源码的编码格式;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">　$&#123;project.build.sourceDirectory&#125;表示主源码路径;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">　$&#123;project.build.finalName&#125;表示输出文件名称;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">$&#123;project.version&#125;表示项目版本,与$&#123;version&#125;相同;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">$&#123;project.xxx&#125;</span> <span class="string">当前pom文件的任意节点的内容</span></span><br><span class="line"><span class="meta">$&#123;env.xxx&#125;</span> <span class="string">获取系统环境变量。</span></span><br><span class="line"><span class="meta">$&#123;settings.xxx&#125;</span> <span class="string">指代了settings.xml中对应元素的值。</span></span><br></pre></td></tr></table></figure><h2 id="maven-compiler-plugin"><a href="#maven-compiler-plugin" class="headerlink" title="maven-compiler-plugin"></a>maven-compiler-plugin</h2><p>设置maven编译的jdk版本，maven3默认用jdk1.5，maven2默认用jdk1.3</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span>                                          </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                                </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                              </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>                                                   </span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>       </span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span> <span class="comment">&lt;!-- 源代码使用的JDK版本 --&gt;</span>                            </span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span> <span class="comment">&lt;!-- 需要生成的目标class文件的编译版本 --&gt;</span>                    </span><br><span class="line">        <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span><span class="comment">&lt;!-- 字符集编码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">skipTests</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span><span class="comment">&lt;!-- 跳过测试 --&gt;</span>                           </span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="maven-jar-plugin"><a href="#maven-jar-plugin" class="headerlink" title="maven-jar-plugin"></a>maven-jar-plugin</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 打包jar文件时，配置manifest文件，加入lib包的jar依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">classesDirectory</span>&gt;</span>target/classes/<span class="tag">&lt;/<span class="name">classesDirectory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.alibaba.dubbo.container.Main<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 打包时 MANIFEST.MF文件不记录的时间戳版本 --&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--自动加载META-INF/spring目录下的所有Spring配置--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">useUniqueVersions</span>&gt;</span>false<span class="tag">&lt;/<span class="name">useUniqueVersions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">classpathPrefix</span>&gt;</span>lib/<span class="tag">&lt;/<span class="name">classpathPrefix</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Class-Path</span>&gt;</span>.<span class="tag">&lt;/<span class="name">Class-Path</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="maven-source-plugin"><a href="#maven-source-plugin" class="headerlink" title="maven-source-plugin"></a>maven-source-plugin</h2><p>提供项目自动将源码打包并发布的功能</p><p>注意：在多项目构建中，将source-plugin置于顶层或parent的pom中并不会发挥作用，必须置于具体项目的pom中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-source-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>attach-sources<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="maven-resource-plugin"><a href="#maven-resource-plugin" class="headerlink" title="maven-resource-plugin"></a>maven-resource-plugin</h2><p>该插件处理项目的资源文件拷贝到输出目录。可以分别处理main resources 和 test resources。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">id</span>&gt;</span>copy-resources<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">phase</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy-resources<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.outputDirectory&#125;<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                               <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources/$&#123;active.profile&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                               <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="maven-dependency-plugin"><a href="#maven-dependency-plugin" class="headerlink" title="maven-dependency-plugin"></a>maven-dependency-plugin</h2><p>自动拷贝jar包到target目录</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 依赖插件 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>copy-dependencies<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">phase</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy-dependencies<span class="tag">&lt;/<span class="name">goal</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">                <span class="comment">&lt;!-- $&#123;project.build.directory&#125;为Maven内置变量，缺省为target --&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/lib<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span>  </span><br><span class="line">                <span class="comment">&lt;!-- 表示是否不包含间接依赖的包 --&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">excludeTransitive</span>&gt;</span>false<span class="tag">&lt;/<span class="name">excludeTransitive</span>&gt;</span>  </span><br><span class="line">                <span class="comment">&lt;!-- 表示复制的jar文件去掉版本信息 --&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">stripVersion</span>&gt;</span>true<span class="tag">&lt;/<span class="name">stripVersion</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="maven-assembly-plugin"><a href="#maven-assembly-plugin" class="headerlink" title="maven-assembly-plugin"></a>maven-assembly-plugin</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>make-assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span> <span class="comment">&lt;!-- this is used for inheritance merges --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span> <span class="comment">&lt;!-- bind to the packaging phase --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="常用的pom配置"><a href="#常用的pom配置" class="headerlink" title="常用的pom配置"></a>常用的pom配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>www.JavaCoreTest<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>JavaCoreTest-javaTest<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>JavaCoreTest Maven Webapp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>4.1.3.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">quartz.version</span>&gt;</span>2.2.1<span class="tag">&lt;/<span class="name">quartz.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">activiti.version</span>&gt;</span>5.16.3<span class="tag">&lt;/<span class="name">activiti.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- JAR Maven 管理--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!-- 配置主程序 java -jar 默认Class --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">classpathPrefix</span>&gt;</span>lib/<span class="tag">&lt;/<span class="name">classpathPrefix</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>javacore.Test<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- maven 打包集成插件 --&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 将依赖一起打包到 JAR --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!-- 配置主程序 java -jar 默认Class --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">classpathPrefix</span>&gt;</span>lib/<span class="tag">&lt;/<span class="name">classpathPrefix</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>javacore.Test<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>JavaCoreTest<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.41<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven——构建生命周期（四）</title>
      <link href="/2020/07/16/Maven%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2020/07/16/Maven%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>项目构建是一个项目从编写源代码到编译，测试，运行，打包，部署，运行的过程。</p><p>Maven 构建生命周期定义了一个项目构建跟发布的过程。</p><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>Maven 有以下三个标准的生命周期：</p><ul><li>clean：项目清理的处理</li><li>default(或 build)：项目部署的处理</li><li>site：项目站点文档创建的处理</li></ul><h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><p>clean生命周期：清理项目，包含三个phase。</p><ol><li>pre-clean：执行清理前需要完成的工作</li><li>clean：清理上一次构建生成的文件</li><li>post-clean：执行清理后需要完成的工作</li></ol><h2 id="Default生命周期"><a href="#Default生命周期" class="headerlink" title="Default生命周期"></a>Default生命周期</h2><p>这是 Maven 的主要生命周期，重要的phase如下:</p><ol><li>validate：验证工程是否正确，所有需要的资源是否可用。</li><li>compile：编译项目的源代码。</li><li>test：使用合适的单元测试框架来测试已编译的源代码。这些测试不需要已打包和布署。</li><li>package：把已编译的代码打包成可发布的格式，比如jar。</li><li>integration-test：如有需要，将包处理和发布到一个能够进行集成测试的环境。</li><li>verify：运行所有检查，验证包是否有效且达到质量标准。</li><li>install：把包安装到maven本地仓库，可以被其他工程作为依赖来使用。</li><li>deploy：在集成或者发布环境下执行，将最终版本的包拷贝到远程的repository，使得其他的开发者或者工程可以共享。</li></ol><p>有一些与 Maven 生命周期相关的重要概念需要说明：</p><p>当一个阶段通过 Maven 命令调用时，例如 mvn compile，只有该阶段之前以及包括该阶段在内的所有阶段会被执行。 现在打开命令控制台，跳转到 pom.xml 所在目录，并执行以下 mvn 命令。 </p><pre><code>C:\MVN\project&gt;mvn compile</code></pre><p>Maven 将会开始处理并显示直到编译阶段的构建生命周期的各个阶段。 </p><p>在开发环境中，使用下面的命令去构建、安装工程到本地仓库 ：</p><pre><code>mvn install</code></pre><p>这个命令在执行 install 阶段前，按顺序执行了 default 生命周期的阶段 （validate，compile，package，等等），我们只需要调用最后一个阶段，如这里是 install。 </p><p>在构建环境中，使用下面的调用来纯净地构建和部署项目到共享仓库中 </p><pre><code>mvn clean deploy</code></pre><p>这行命令也可以用于多模块的情况下，即包含多个子项目的项目，Maven 会在每一个子项目执行 clean 命令，然后再执行 deploy 命令。 </p><h2 id="Site"><a href="#Site" class="headerlink" title="Site"></a>Site</h2><p>site生命周期：建立和发布项目站点，phase如下:</p><ol><li>pre-site：生成项目站点之前需要完成的工作</li><li>site：生成项目站点文档</li><li>post-site：生成项目站点之后需要完成的工作</li><li>site-deploy：将项目站点发布到服务器</li></ol>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven 构建生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven——仓库（三）</title>
      <link href="/2020/07/16/Maven%E2%80%94%E2%80%94%E4%BB%93%E5%BA%93%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2020/07/16/Maven%E2%80%94%E2%80%94%E4%BB%93%E5%BA%93%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 Maven 的术语中，仓库是一个位置（place）。</p><p>Maven 仓库是项目中依赖的第三方库，这个库所在的位置叫做仓库。<br>在 Maven 中，任何一个依赖、插件或者项目构建的输出，都可以称之为构件。 </p><p>Maven 仓库能帮助我们管理构件（主要是JAR），它就是放置所有JAR文件（WAR，ZIP，POM等等）的地方。</p><p>Maven 仓库有三种类型：</p><ul><li>本地（local）</li><li>中央（central）</li><li>远程（remote）</li></ul><h1 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h1><p>Maven 的本地仓库，在安装 Maven 后并不会创建，它是在第一次执行 maven 命令的时候才被创建。</p><p>运行 Maven 的时候，Maven 所需要的任何构件都是直接从本地仓库获取的。如果本地仓库没有，它会首先尝试从远程仓库下载构件至本地仓库，然后再使用本地仓库的构件。</p><p>默认情况下，不管Linux还是 Windows，每个用户在自己的用户目录下都有一个路径名为 .m2/respository/ 的仓库目录。</p><p>Maven 本地仓库默认被创建在 %USER_HOME% 目录下。要修改默认位置，在 %M2_HOME%\conf 目录中的 Maven 的 settings.xml 文件中定义另一个路径。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0 </span></span></span><br><span class="line"><span class="tag"><span class="string">   http://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>C:/MyLocalRepository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="中央仓库"><a href="#中央仓库" class="headerlink" title="中央仓库"></a>中央仓库</h1><p>Maven 中央仓库是由 Maven 社区提供的仓库，其中包含了大量常用的库。</p><p>中央仓库包含了绝大多数流行的开源Java构件，以及源码、作者信息、SCM、信息、许可证信息等。一般来说，简单的Java项目依赖的构件都可以在这里下载到。</p><p>1、从本地资源库中查找并获得依赖包，如果没有，执行第2步。 2、从Maven默认中央仓库中查找并获得依赖包（<a href="http://repo1.maven.org/maven2/）" target="_blank" rel="noopener">http://repo1.maven.org/maven2/）</a></p><p>国内访问maven社区网址有墙，所以我们通常使用阿里云的仓库。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*,!jeecg,!jeecg-snapshots<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><p>如果 Maven 在中央仓库中也找不到依赖的文件，它会停止构建过程并输出错误信息到控制台。为避免这种情况，Maven 提供了远程仓库的概念，它是开发人员自己定制仓库，包含了所需要的代码库或者其他工程中用到的 jar 文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.companyname.projectgroup<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.companyname.common-lib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>common-lib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">id</span>&gt;</span>companyname.lib1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://download.companyname.org/maven2/lib1<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">id</span>&gt;</span>companyname.lib2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://download.companyname.org/maven2/lib2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven 仓库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven——Pom（二）</title>
      <link href="/2020/07/16/Maven%E2%80%94%E2%80%94Pom%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/07/16/Maven%E2%80%94%E2%80%94Pom%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>POM( Project Object Model，项目对象模型 ) 是 Maven 工程的基本工作单元，是一个XML文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。</p><p>执行任务或目标时，Maven 会在项目根目录中查找 POM。它读取 POM，获取所需的配置信息，然后执行目标。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>POM 中可以指定以下配置：</p><ul><li>项目依赖</li><li>插件</li><li>执行目标</li><li>项目构建 profile</li><li>项目版本</li><li>项目开发者列表</li><li>相关邮件列表信息</li></ul><p>所有 POM 文件都需要 project 元素和三个必需字段：groupId，artifactId，version。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span> = <span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span> = <span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span> = <span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 模型版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.companyname.project-group<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 版本号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>父（Super）POM是 Maven 默认的 POM。所有的 POM 都继承自一个父 POM（无论是否显式定义了这个父 POM）。父 POM 包含了一些可以被继承的默认设置。</p><p>查看Super POM默认配置的一个简单方法是执行以下命令：</p><pre><code>mvn help:effective-pom</code></pre><h1 id="POM-标签大全详解"><a href="#POM-标签大全详解" class="headerlink" title="POM 标签大全详解"></a>POM 标签大全详解</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 </span></span><br><span class="line"><span class="comment">        version。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被继承的父项目的构件标识符 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被继承的父项目的全球唯一标识符 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被继承的父项目的版本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项 </span></span><br><span class="line"><span class="comment">            目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>asia.banseon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个 </span></span><br><span class="line"><span class="comment">        特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源 码，二进制发布和WARs等。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>banseon-maven2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的名称, Maven产生的文档用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon-maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目主页的URL, Maven产生的文档用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标 </span></span><br><span class="line"><span class="comment">        签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>A maven project to study maven.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--描述了这个项目构建环境中的前提条件。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prerequisites</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--构建该项目或使用该插件所需要的Maven的最低版本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">prerequisites</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">issueManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--问题管理系统（例如jira）的名字， --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">system</span>&gt;</span>jira<span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该项目使用的问题管理系统的URL --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://jira.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">issueManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目持续集成信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ciManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--持续集成系统的名字，例如continuum --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">system</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">notifiers</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">notifier</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--传送通知的途径 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--发生错误时是否通知 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnError</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建失败时是否通知 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnFailure</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建成功时是否通知 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnSuccess</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--发生警告时是否通知 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnWarning</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--不赞成使用。通知发送到哪里 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">address</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--扩展配置项 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">notifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">notifiers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ciManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">inceptionYear</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目相关邮件列表信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mailingLists</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mailingList</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--邮件的名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">post</span>&gt;</span>banseon@126.com<span class="tag">&lt;/<span class="name">post</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">subscribe</span>&gt;</span>banseon@126.com<span class="tag">&lt;/<span class="name">subscribe</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">unsubscribe</span>&gt;</span>banseon@126.com<span class="tag">&lt;/<span class="name">unsubscribe</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--你可以浏览邮件信息的URL --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">archive</span>&gt;</span>http:/hi.baidu.com/banseon/demo/dev/<span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mailingList</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mailingLists</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目开发者列表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">developers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--某个项目开发者的信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">developer</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--SCM里项目开发者的唯一标识符 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>HELLO WORLD<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者的全名 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者的email --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">email</span>&gt;</span>banseon@126.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者的主页的URL --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">roles</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">role</span>&gt;</span>Project Manager<span class="tag">&lt;/<span class="name">role</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">role</span>&gt;</span>Architect<span class="tag">&lt;/<span class="name">role</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">roles</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者所属组织 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">organization</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者所属组织的URL --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">organizationUrl</span>&gt;</span>http://hi.baidu.com/banseon<span class="tag">&lt;/<span class="name">organizationUrl</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者属性，如即时消息如何处理等 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dept</span>&gt;</span>No<span class="tag">&lt;/<span class="name">dept</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者所在时区， -11到12范围内的整数。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timezone</span>&gt;</span>-5<span class="tag">&lt;/<span class="name">timezone</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">developer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的其他贡献者列表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contributors</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--项目的其他贡献者。参见developers/developer元素 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">contributor</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">email</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">organization</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">organizationUrl</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">roles</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timezone</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">contributor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">contributors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">licenses</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">license</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--license用于法律上的名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Apache 2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--官方的license正文页面的URL --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.baidu.com/banseon/LICENSE-2.0.txt<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">distribution</span>&gt;</span>repo<span class="tag">&lt;/<span class="name">distribution</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--关于license的补充信息 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">comments</span>&gt;</span>A business-friendly OSS license<span class="tag">&lt;/<span class="name">comments</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">licenses</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scm</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">connection</span>&gt;</span></span><br><span class="line">            scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">connection</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">developerConnection</span>&gt;</span></span><br><span class="line">            scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk</span><br><span class="line">        <span class="tag">&lt;/<span class="name">developerConnection</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当前代码的标签，在开发阶段默认为HEAD --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tag</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://svn.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">scm</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--描述项目所属组织的各种属性。Maven产生的文档用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">organization</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--组织的全名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--组织主页的URL --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--构建项目需要的信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sourceDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scriptSourceDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">testSourceDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被编译过的应用程序class文件存放的目录。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">outputDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被编译过的测试class文件存放的目录。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">testOutputDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用来自该项目的一系列构建扩展 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">extensions</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--描述使用到的构建扩展。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">extension</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建扩展的groupId --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建扩展的artifactId --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建扩展的版本 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">defaultGoal</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--这个元素描述了项目相关或测试相关的所有资源路径 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。举个例 </span></span><br><span class="line"><span class="comment">                    子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--描述存放资源的目录，该路径相对POM路径 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--包含的模式列表，例如**/*.xml. --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--排除的模式列表，例如**/*.xml --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--构建产生的所有文件存放的目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当filtering开关打开时，使用到的过滤器属性文件列表 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filters</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--使用的插件列表 。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--plugin元素包含描述插件所需要的信息。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--插件在仓库里的group ID --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--插件在仓库里的artifact ID --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--被使用的插件的版本（或版本范围） --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--execution元素包含了插件执行需要的信息 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--配置的执行目标 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--配置是否被传播到子POM --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--作为DOM对象的配置 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--项目引入插件所需要的额外依赖 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                            ......</span><br><span class="line">                        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--任何配置是否被传播到子项目 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--作为DOM对象的配置 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用的插件列表 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        ......</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--在列的项目构建profile，如果被激活，会修改构建处理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--根据环境参数或命令行参数激活某个构建处理 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它 能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--profile默认是否激活的标志 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">activeByDefault</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">jdk</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的操作系统的名字 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Windows XP<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的操作系统所属家族(如 'windows') --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">family</span>&gt;</span>Windows<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的操作系统体系结构 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">arch</span>&gt;</span>x86<span class="tag">&lt;/<span class="name">arch</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的操作系统版本 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.2600<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile就会被激活。如果值 字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的属性的名称 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mavenVersion<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的属性的值 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>2.0.3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--如果指定的文件存在，则激活profile。 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exists</span>&gt;</span>/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">exists</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--如果指定的文件不存在，则激活profile。 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">missing</span>&gt;</span>/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">missing</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构建项目所需要的信息。参见build元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">defaultGoal</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">finalName</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filters</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                                <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                                    ......</span><br><span class="line">                                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                                ......</span><br><span class="line">                            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">modules</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--发现依赖和扩展的远程仓库列表。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--参见repositories/repository元素 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    ......</span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--不赞成使用. 现在Maven忽略该元素. --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">reports</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--该元素包括使用报表插件产生报表的规范。当用户执行"mvn site"，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span><br><span class="line">                ......</span><br><span class="line">            <span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见dependencyManagement元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        ......</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见distributionManagement元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">                ......</span><br><span class="line">            <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见properties元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--发现依赖和扩展的远程仓库列表。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--包含需要连接到远程仓库的信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--如何处理远程仓库里发布版本的下载 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的 </span></span><br><span class="line"><span class="comment">                策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-repository-proxy<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--远程仓库名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon-repository-proxy<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.1.169:9999/repository/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 </span></span><br><span class="line"><span class="comment">                而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">            ......</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖的group ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖的artifact ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-artifact<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， </span></span><br><span class="line"><span class="comment">                尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成 </span></span><br><span class="line"><span class="comment">                JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">classifier</span>&gt;</span><span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath </span></span><br><span class="line"><span class="comment">                - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 </span></span><br><span class="line"><span class="comment">                - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如$&#123;java.home&#125;。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span><span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--不赞成使用. 现在Maven忽略该元素. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">reports</span>&gt;</span><span class="tag">&lt;/<span class="name">reports</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--该元素描述使用报表插件产生报表的规范。当用户执行"mvn site"，这些报表就会运行。 在页面导航栏能看到所有报表的链接。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--true，则，网站不包括默认的报表。这包括"项目信息"菜单中的报表。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludeDefaults</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--所有产生的报表存放到哪里。默认值是$&#123;project.build.directory&#125;/site。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">outputDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用的报表插件和他们的配置。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--plugin元素包含描述报表插件需要的信息 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--报表插件在仓库里的group ID --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--报表插件在仓库里的artifact ID --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--被使用的报表插件的版本（或版本范围） --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--任何配置是否被传播到子项目 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--报表插件的配置 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">reportSets</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--表示报表的一个集合，以及产生该集合的配置 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">reportSet</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--报表集合的唯一标识符，POM继承时用到 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--产生报表集合时，被使用的报表的配置 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--配置是否被继承到子POMs --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--这个集合里使用到哪些报表 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">reports</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">reportSet</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">reportSets</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact </span></span><br><span class="line"><span class="comment">        ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                ......</span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--部署项目产生的构件到远程仓库需要的信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">uniqueVersion</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-maven2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon maven2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>file://$&#123;basedir&#125;/target/deploy<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">uniqueVersion</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-maven2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Banseon-maven2 Snapshot Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>scp://svn.baidu.com/banseon:/usr/local/maven-snapshot<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--部署项目的网站需要的信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">site</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-site<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--部署位置的名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>business api website<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--部署位置的URL，按protocol://hostname/path形式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span></span><br><span class="line">                scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web</span><br><span class="line">            <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">site</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">downloadUrl</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relocation</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构件新的group ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构件新的artifact ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构件新的版本号 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--显示给用户的，关于移动的额外信息，例如原因。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">message</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">relocation</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从 </span></span><br><span class="line"><span class="comment">            Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部 署），verified（被核实时正确的和最终的）。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">status</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven pom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven——概述（一）</title>
      <link href="/2020/07/16/Maven%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/07/16/Maven%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Maven 翻译为”专家”、”内行”，是 Apache 下的一个纯 Java 开发的开源项目。Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。</p><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p>Maven主要做了两件事：</p><ul><li>统一开发规范与工具</li><li>统一管理jar包</li></ul><h1 id="约定配置"><a href="#约定配置" class="headerlink" title="约定配置"></a>约定配置</h1><p>Maven 提倡使用一个共同的标准目录结构，Maven 使用约定优于配置的原则，大家尽可能的遵守这样的目录结构。如下所示：</p><ul><li>${basedir}<br>存放pom.xml和所有的子目录</li><li>${basedir}/src/main/java<br>项目的java源代码</li><li>${basedir}/src/main/resources<br>项目的资源，比如说property文件，springmvc.xml</li><li>${basedir}/src/test/java<br>项目的测试类，比如说Junit代码</li><li>${basedir}/src/test/resources<br>测试用的资源</li><li>${basedir}/src/main/webapp/WEB-INF<br>web应用文件目录，web项目的信息，比如存放web.xml、本地图片、jsp视图页面</li><li>${basedir}/target<br>打包输出目录</li><li>${basedir}/target/classes<br>编译输出目录</li><li>${basedir}/target/test-classes<br>测试编译输出目录</li><li>Test.java<br>Maven只会自动运行符合该命名规则的测试类</li><li>~/.m2/repository<br>Maven默认的本地仓库目录位置</li></ul><h1 id="安装-配置"><a href="#安装-配置" class="headerlink" title="安装/配置"></a>安装/配置</h1><p>Maven是个Java工具，所以你必须安装了Java才能继续。</p><p><a href="https://www.runoob.com/maven/maven-setup.html" target="_blank" rel="noopener">maven安装与配置</a></p><h1 id="Snapshot-版本与-Release-版本"><a href="#Snapshot-版本与-Release-版本" class="headerlink" title="Snapshot 版本与 Release 版本"></a>Snapshot 版本与 Release 版本</h1><ol><li>Snapshot 版本代表不稳定、尚处于开发中的版本。</li><li>Release 版本则代表稳定的版本。</li></ol><p>协同开发时，如果 A 依赖构件 B，由于 B 会更新，B 应该使用 SNAPSHOT 来标识自己。这种做法的必要性可以反证如下：</p><ol><li>如果 B 不用 SNAPSHOT，而是每次更新后都使用一个稳定的版本，那版本号就会升得太快，每天一升甚至每个小时一升，这就是对版本号的滥用。 </li><li>如果 B 不用 SNAPSHOT, 但一直使用一个单一的 Release 版本号，那当 B 更新后，A 可能并不会接受到更新。因为 A 所使用的 repository 一般不会频繁更新 release 版本的缓存（即本地 repository)，所以B以不换版本号的方式更新后，A在拿B时发现本地已有这个版本，就不会去远程Repository下载最新的 B</li></ol>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven 概述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件——pull和push</title>
      <link href="/2020/07/14/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94pull%E5%92%8Cpush/"/>
      <url>/2020/07/14/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94pull%E5%92%8Cpush/</url>
      
        <content type="html"><![CDATA[<h1 id="常用的消息中间件支持模型"><a href="#常用的消息中间件支持模型" class="headerlink" title="常用的消息中间件支持模型"></a>常用的消息中间件支持模型</h1><table><thead><tr><th>中间件</th><th align="center">push模型</th><th align="right">pull模型</th></tr></thead><tbody><tr><td>RabbitMQ</td><td align="center">支持</td><td align="right">支持</td></tr><tr><td>Kafka</td><td align="center">–</td><td align="right">支持（只有）</td></tr><tr><td>RocketMQ</td><td align="center">支持</td><td align="right">支持</td></tr></tbody></table><h1 id="两种模型优缺点对比"><a href="#两种模型优缺点对比" class="headerlink" title="两种模型优缺点对比"></a>两种模型优缺点对比</h1><ul><li>所谓 Push 模型，即当 Producer 发出的消息到达后，服务端马上将这条消息投递给 Consumer；</li><li>而 Pull 则是服务端收到这条消息后什么也不做，只是等着 Consumer 主动到自己这里来读，即 Consumer 这里有一个“拉取”的动作。</li></ul><h2 id="Push模型优缺点"><a href="#Push模型优缺点" class="headerlink" title="Push模型优缺点"></a>Push模型优缺点</h2><p>Push模型优点</p><p>实时（因为服务端Broker一旦收到消息，就会发送给消费者，不管消费这准备好没有，消费者是死是活，缓存到消费端的BlockingQueue中）</p><p>Push缺点</p><ol><li>消息保存在服务端broker，容易造成消息堆积。</li><li>服务端broker需要维护每次传输状态，遇到问题需要重试。</li><li>服务端broker需要依据订阅者消费能力做流控(流转机制)。</li></ol><h2 id="Pull模型优缺点"><a href="#Pull模型优缺点" class="headerlink" title="Pull模型优缺点"></a>Pull模型优缺点</h2><p>Pull模型优点<br> 保存在消费端，获取消息方便。（什么保存在消费端）<br>[2] 传输失败，不需要重试。（如何理解？）<br>[3] 消费端可以根据自身消费能力决定是否pull(流转机制) （这个好理解）</p><p>Pull缺点<br>默认的短轮询方式的实时性依赖于pull间隔时间，间隔越大，实时性越低，长轮询方式和push一致。（默认的端轮训指的是什么？ 指的当长时间没有消息时，消费端实现的间隔时间去服务端轮训消息的过程）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件——Kafka、RocketMQ、RabbitMQ的优劣势比较</title>
      <link href="/2020/07/13/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Kafka%E3%80%81RocketMQ%E3%80%81RabbitMQ%E7%9A%84%E4%BC%98%E5%8A%A3%E5%8A%BF%E6%AF%94%E8%BE%83/"/>
      <url>/2020/07/13/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Kafka%E3%80%81RocketMQ%E3%80%81RabbitMQ%E7%9A%84%E4%BC%98%E5%8A%A3%E5%8A%BF%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<h1 id="开发语言"><a href="#开发语言" class="headerlink" title="开发语言"></a>开发语言</h1><ul><li>Kafka：Scala </li><li>rabbitmq：Erlang </li><li>zeromq：c </li><li>rocketmq：java </li><li>activemq：java</li></ul><h1 id="支持的协议"><a href="#支持的协议" class="headerlink" title="支持的协议"></a>支持的协议</h1><ul><li>Kafka：自己定义的一套…（基于TCP） </li><li>rabbitmq：AMQP </li><li>zeromq：TCP、UDP </li><li>rocketmq：自己定义的一套… </li><li>activemq：AMQP</li></ul><h1 id="消息存储"><a href="#消息存储" class="headerlink" title="消息存储"></a>消息存储</h1><ol><li><p>Kafka：内存、磁盘、数据库。支持大量堆积。</p><p> kafka的最小存储单元是分区，一个topic包含多个分区，kafka创建主题时，这些分区会被分配在多个服务器上，通常一个broker一台服务器。 分区首领会均匀地分布在不同的服务器上，分区副本也会均匀的分布在不同的服务器上，确保负载均衡和高可用性，当新的broker加入集群的时候，部分副本会被移动到新的broker上。 根据配置文件中的目录清单，kafka会把新的分区分配给目录清单里分区数最少的目录。 默认情况下，分区器使用轮询算法把消息均衡地分布在同一个主题的不同分区中，对于发送时指定了key的情况，会根据key的hashcode取模后的值存到对应的分区中。</p></li><li><p>rabbitmq：内存、磁盘。支持少量堆积。<br> rabbitmq的消息分为持久化的消息和非持久化消息，不管是持久化的消息还是非持久化的消息都可以写入到磁盘。 持久化的消息在到达队列时就写入到磁盘，并且如果可以，持久化的消息也会在内存中保存一份备份，这样可以提高一定的性能，当内存吃紧的时候会从内存中清除。非持久化的消息一般只存在于内存中，在内存吃紧的时候会被换入到磁盘中，以节省内存。<br> 引入镜像队列机制，可将重要队列“复制”到集群中的其他broker上，保证这些队列的消息不会丢失。配置镜像的队列，都包含一个主节点master和多个从节点slave,如果master失效，加入时间最长的slave会被提升为新的master，除发送消息外的所有动作都向master发送，然后由master将命令执行结果广播给各个slave，rabbitmq会让master均匀地分布在不同的服务器上，而同一个队列的slave也会均匀地分布在不同的服务器上，保证负载均衡和高可用性。</p></li><li><p>zeromq：消息发送端的内存或者磁盘中。不支持持久化。</p></li><li><p>rocketmq：磁盘。支持大量堆积。<br> commitLog文件存放实际的消息数据，每个commitLog上限是1G，满了之后会自动新建一个commitLog文件保存数据。ConsumeQueue队列只存放offset、size、tagcode，非常小，分布在多个broker上。ConsumeQueue相当于CommitLog的索引文件，消费者消费时会从consumeQueue中查找消息在commitLog中的offset，再去commitLog中查找元数据。<br> ConsumeQueue存储格式的特性，保证了写过程的顺序写盘（写CommitLog文件），大量数据IO都在顺序写同一个commitLog，满1G了再写新的。加上rocketmq是累计4K才强制从PageCache中刷到磁盘（缓存），所以高并发写性能突出。</p></li><li><p>activemq：内存、磁盘、数据库。支持少量堆积。</p></li></ol><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><ul><li>Kafka：支持 </li><li>rabbitmq：支持。 客户端将信道设置为事务模式，只有当消息被rabbitMq接收，事务才能提交成功，否则在捕获异常后进行回滚。使用事务会使得性能有所下降 - zeromq：不支持 </li><li>rocketmq：支持 </li><li>activemq：支持</li></ul><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><ol><li><p>Kafka：支持负载均衡。</p><p> 一个broker通常就是一台服务器节点。对于同一个Topic的不同分区，Kafka会尽力将这些分区分布到不同的Broker服务器上，zookeeper保存了broker、主题和分区的元数据信息。分区首领会处理来自客户端的生产请求，kafka分区首领会被分配到不同的broker服务器上，让不同的broker服务器共同分担任务。<br> 每一个broker都缓存了元数据信息，客户端可以从任意一个broker获取元数据信息并缓存起来，根据元数据信息知道要往哪里发送请求。</p><p> kafka的消费者组订阅同一个topic，会尽可能地使得每一个消费者分配到相同数量的分区，分摊负载。</p><p> 当消费者加入或者退出消费者组的时候，还会触发再均衡，为每一个消费者重新分配分区，分摊负载。<br> kafka的负载均衡大部分是自动完成的，分区的创建也是kafka完成的，隐藏了很多细节，避免了繁琐的配置和人为疏忽造成的负载问题。</p><p> 发送端由topic和key来决定消息发往哪个分区，如果key为null，那么会使用轮询算法将消息均衡地发送到同一个topic的不同分区中。如果key不为null，那么会根据key的hashcode取模计算出要发往的分区。</p></li><li><p>rabbitmq：对负载均衡的支持不好。</p><p> 消息被投递到哪个队列是由交换器和key决定的，交换器、路由键、队列都需要手动创建。<br> rabbitmq客户端发送消息要和broker建立连接，需要事先知道broker上有哪些交换器，有哪些队列。通常要声明要发送的目标队列，如果没有目标队列，会在broker上创建一个队列，如果有，就什么都不处理，接着往这个队列发送消息。假设大部分繁重任务的队列都创建在同一个broker上，那么这个broker的负载就会过大。（可以在上线前预先创建队列，无需声明要发送的队列，但是发送时不会尝试创建队列，可能出现找不到队列的问题，rabbitmq的备份交换器会把找不到队列的消息保存到一个专门的队列中，以便以后查询使用）<br> 使用镜像队列机制建立rabbitmq集群可以解决这个问题，形成master-slave的架构，master节点会均匀分布在不同的服务器上，让每一台服务器分摊负载。slave节点只是负责转发，在master失效时会选择加入时间最长的slave成为master。<br> 当新节点加入镜像队列的时候，队列中的消息不会同步到新的slave中，除非调用同步命令，但是调用命令后，队列会阻塞，不能在生产环境中调用同步命令。</p><p> 当rabbitmq队列拥有多个消费者的时候，队列收到的消息将以轮询的分发方式发送给消费者。每条消息只会发送给订阅列表里的一个消费者，不会重复。<br> 这种方式非常适合扩展，而且是专门为并发程序设计的。<br> 如果某些消费者的任务比较繁重，那么可以设置basicQos限制信道上消费者能保持的最大未确认消息的数量，在达到上限时，rabbitmq不再向这个消费者发送任何消息。</p><p> 对于rabbitmq而言，客户端与集群建立的TCP连接不是与集群中所有的节点建立连接，而是挑选其中一个节点建立连接。<br> 但是rabbitmq集群可以借助HAProxy、LVS技术，或者在客户端使用算法实现负载均衡，引入负载均衡之后，各个客户端的连接可以分摊到集群的各个节点之中。</p></li></ol><h1 id="客户端均衡算法"><a href="#客户端均衡算法" class="headerlink" title="客户端均衡算法"></a>客户端均衡算法</h1><ol><li><p>轮询法。按顺序返回下一个服务器的连接地址。</p></li><li><p>加权轮询法。给配置高、负载低的机器配置更高的权重，让其处理更多的请求；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载。</p></li><li><p>随机法。随机选取一个服务器的连接地址。</p></li><li><p>加权随机法。按照概率随机选取连接地址。</p></li><li><p>源地址哈希法。通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算。</p></li><li><p>最小连接数法。动态选择当前连接数最少的一台服务器的连接地址。</p></li></ol><h1 id="负载均衡-1"><a href="#负载均衡-1" class="headerlink" title="负载均衡"></a>负载均衡</h1><ol><li><p>zeromq：去中心化，不支持负载均衡。本身只是一个多线程网络库。</p></li><li><p>rocketmq：支持负载均衡。<br> 一个broker通常是一个服务器节点，broker分为master和slave,master和slave存储的数据一样，slave从master同步数据。</p><p> nameserver与每个集群成员保持心跳，保存着Topic-Broker路由信息，同一个topic的队列会分布在不同的服务器上。</p><p> 发送消息通过轮询队列的方式发送，每个队列接收平均的消息量。发送消息指定topic、tags、keys，无法指定投递到哪个队列（没有意义，集群消费和广播消费跟消息存放在哪个队列没有关系）。<br> tags选填，类似于 Gmail 为每封邮件设置的标签，方便服务器过滤使用。目前只支 持每个消息设置一个 tag，所以也可以类比为 Notify 的 MessageType 概念。<br> keys选填，代表这条消息的业务关键词，服务器会根据 keys 创建哈希索引，设置后， 可以在 Console 系统根据 Topic、Keys 来查询消息，由于是哈希索引，请尽可能 保证 key 唯一，例如订单号，商品 Id 等。</p><p> rocketmq的负载均衡策略规定：Consumer数量应该小于等于Queue数量，如果Consumer超过Queue数量，那么多余的Consumer 将不能消费消息。这一点和kafka是一致的，rocketmq会尽可能地为每一个Consumer分配相同数量的队列，分摊负载。</p></li><li><p>activemq：支持负载均衡。可以基于zookeeper实现负载均衡。</p></li></ol><h1 id="集群方式"><a href="#集群方式" class="headerlink" title="集群方式"></a>集群方式</h1><ol><li><p>Kafka：天然的‘Leader-Slave’无状态集群，每台服务器既是Master也是Slave。</p><p> 分区首领均匀地分布在不同的kafka服务器上，分区副本也均匀地分布在不同的kafka服务器上，所以每一台kafka服务器既含有分区首领，同时又含有分区副本，每一台kafka服务器是某一台kafka服务器的Slave，同时也是某一台kafka服务器的leader。</p><p> kafka的集群依赖于zookeeper，zookeeper支持热扩展，所有的broker、消费者、分区都可以动态加入移除，而无需关闭服务，与不依靠zookeeper集群的mq相比，这是最大的优势。</p></li><li><p>rabbitmq：支持简单集群，’复制’模式，对高级集群模式支持不好。</p><p> rabbitmq的每一个节点，不管是单一节点系统或者是集群中的一部分，要么是内存节点，要么是磁盘节点，集群中至少要有一个是磁盘节点。</p><p> 在rabbitmq集群中创建队列，集群只会在单个节点创建队列进程和完整的队列信息（元数据、状态、内容），而不是在所有节点上创建。</p><p> 引入镜像队列，可以避免单点故障，确保服务的可用性，但是需要人为地为某些重要的队列配置镜像。</p></li><li><p>zeromq：去中心化，不支持集群。</p></li><li><p>rocketmq：常用 多对’Master-Slave’ 模式，开源版本需手动切换Slave变成Master</p><p> Name Server是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。</p><p> Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave的对应关系通过指定相同的BrokerName，不同的BrokerId来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与Name Server集群中的所有节点建立长连接，定时注册Topic信息到所有Name Server。</p><p> Producer与Name Server集群中的其中一个节点（随机选择）建立长连接，定期从Name Server取Topic路由信息，并向提供Topic服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。</p><p> Consumer与Name Server集群中的其中一个节点（随机选择）建立长连接，定期从Name Server取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，订阅规则由Broker配置决定。客户端先找到NameServer, 然后通过NameServer再找到 Broker。</p><p> 一个topic有多个队列，这些队列会均匀地分布在不同的broker服务器上。rocketmq队列的概念和kafka的分区概念是基本一致的，kafka同一个topic的分区尽可能地分布在不同的broker上，分区副本也会分布在不同的broker上。</p><p> rocketmq集群的slave会从master拉取数据备份，master分布在不同的broker上。</p></li><li><p>activemq：支持简单集群模式，比如’主-备’，对高级集群模式支持不好。</p></li></ol><h1 id="管理界面"><a href="#管理界面" class="headerlink" title="管理界面"></a>管理界面</h1><ol><li>Kafka：一般 rabbitmq：好 zeromq：无 rocketmq：无 activemq：一般</li></ol><h1 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h1><p>Kafka：非常高（分布式） rabbitmq：高（主从） zeromq：高。 rocketmq：非常高（分布式） activemq：高（主从）</p><h1 id="消息重复"><a href="#消息重复" class="headerlink" title="消息重复"></a>消息重复</h1><ul><li>Kafka：支持at least once、at most once</li><li>rabbitmq：支持at least once、at most once</li><li>zeromq：只有重传机制，但是没有持久化，消息丢了重传也没有用。既不是at least once、也不是at most once、更不是exactly only once</li><li>rocketmq：支持at least once</li><li>activemq：支持at least once</li></ul><h1 id="吞吐量TPS"><a href="#吞吐量TPS" class="headerlink" title="吞吐量TPS"></a>吞吐量TPS</h1><ul><li>Kafka：极大 Kafka按批次发送消息和消费消息。发送端将多个小消息合并，批量发向Broker，消费端每次取出一个批次的消息批量处理。 </li><li>rabbitmq：比较大 </li><li>zeromq：极大 </li><li>rocketmq：大 rocketMQ接收端可以批量消费消息，可以配置每次消费的消息数，但是发送端不是批量发送。 </li><li>activemq：比较大</li></ul><h1 id="订阅形式和消息分发"><a href="#订阅形式和消息分发" class="headerlink" title="订阅形式和消息分发"></a>订阅形式和消息分发</h1><ol><li>Kafka：基于topic以及按照topic进行正则匹配的发布订阅模式。</li></ol><pre><code>发送端由topic和key来决定消息发往哪个分区，如果key为null，那么会使用轮询算法将消息均衡地发送到同一个topic的不同分区中。如果key不为null，那么会根据key的hashcode取模计算出要发往的分区。consumer向群组协调器broker发送心跳来维持他们和群组的从属关系以及他们对分区的所有权关系，所有权关系一旦被分配就不会改变除非发生再均衡(比如有一个consumer加入或者离开consumer group)，consumer只会从对应的分区读取消息。kafka限制consumer个数要少于分区个数,每个消息只会被同一个 Consumer Group的一个consumer消费（非广播）。kafka的 Consumer Group订阅同一个topic，会尽可能地使得每一个consumer分配到相同数量的分区，不同 Consumer Group订阅同一个主题相互独立，同一个消息会被不同的 Consumer Group处理。</code></pre><ol start="2"><li><p>rabbitmq：提供了4种：direct, topic ,Headers和fanout。</p><p> 先要声明一个队列，这个队列会被创建或者已经被创建，队列是基本存储单元。由exchange和key决定消息存储在哪个队列。</p><p> direct&gt;发送到和bindingKey完全匹配的队列。</p><p> topic&gt;路由key是含有”.”的字符串，会发送到含有“*”、“#”进行模糊匹配的bingKey对应的队列。</p><p> fanout&gt;与key无关，会发送到所有和exchange绑定的队列</p><p> headers&gt;与key无关，消息内容的headers属性（一个键值对）和绑定键值对完全匹配时，会发送到此队列。此方式性能低一般不用</p><p> rabbitmq的队列是基本存储单元，不再被分区或者分片，对于我们已经创建了的队列，消费端要指定从哪一个队列接收消息。</p><p> 当rabbitmq队列拥有多个消费者的时候，队列收到的消息将以轮询的分发方式发送给消费者。每条消息只会发送给订阅列表里的一个消费者，不会重复。</p><p> 这种方式非常适合扩展，而且是专门为并发程序设计的。如果某些消费者的任务比较繁重，那么可以设置basicQos限制信道上消费者能保持的最大未确认消息的数量，在达到上限时，rabbitmq不再向这个消费者发送任何消息。</p></li><li><p>zeromq：点对点(p2p)</p></li><li><p>rocketmq：基于topic/messageTag以及按照消息类型、属性进行正则匹配的发布订阅模式</p><p> 发送消息通过轮询队列的方式发送，每个队列接收平均的消息量。发送消息指定topic、tags、keys，无法指定投递到哪个队列（没有意义，集群消费和广播消费跟消息存放在哪个队列没有关系）。</p><p> tags选填，类似于 Gmail 为每封邮件设置的标签，方便服务器过滤使用。目前只支 持每个消息设置一个 tag，所以也可以类比为 Notify 的 MessageType 概念。</p><p> keys选填，代表这条消息的业务关键词，服务器会根据 keys 创建哈希索引，设置后， 可以在 Console 系统根据 Topic、Keys 来查询消息，由于是哈希索引，请尽可能 保证 key 唯一，例如订单号，商品 Id 等。</p><p> 1&gt;广播消费。一条消息被多个Consumer消费，即使Consumer属于同一个ConsumerGroup，消息也会被ConsumerGroup中的每个Consumer都消费一次。</p><p> 2&gt;集群消费。一个 Consumer Group中的Consumer实例平均分摊消费消息。例如某个Topic有 9 条消息，其中一个Consumer Group有3个实例，那么每个实例只消费其中的 3 条消息。即每一个队列都把消息轮流分发给每个consumer。</p></li><li><p>activemq：点对点(p2p)、广播（发布-订阅）</p><p> 点对点模式，每个消息只有1个消费者；发布/订阅模式，每个消息可以有多个消费者。</p><p> 点对点模式：先要指定一个队列，这个队列会被创建或者已经被创建。</p><p> 发布/订阅模式：先要指定一个topic，这个topic会被创建或者已经被创建。</p><p> 点对点模式：对于已经创建了的队列，消费端要指定从哪一个队列接收消息。</p><p> 发布/订阅模式：对于已经创建了的topic，消费端要指定订阅哪一个topic的消息。</p></li></ol><h1 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h1><ol><li><p>Kafka：支持。</p><p> 设置生产者的max.in.flight.requests.per.connection为1，可以保证消息是按照发送顺序写入服务器的，即使发生了重试。</p><p> kafka保证同一个分区里的消息是有序的，但是这种有序分两种情况</p><p> 1&gt;key为null，消息逐个被写入不同主机的分区中，但是对于每个分区依然是有序的</p><p> 2&gt;key不为null , 消息被写入到同一个分区，这个分区的消息都是有序。</p></li><li><p>rabbitmq：不支持</p></li><li><p>zeromq：不支持</p></li><li><p>rocketmq：支持</p></li><li><p>activemq：不支持</p></li></ol><h1 id="消息确认"><a href="#消息确认" class="headerlink" title="消息确认"></a>消息确认</h1><ol><li><p>Kafka：支持。</p><p> 发送方确认机制<br> ack=0，不管消息是否成功写入分区<br> ack=1，消息成功写入首领分区后，返回成功<br> ack=all，消息成功写入所有分区后，返回成功。</p><p> 接收方确认机制</p><p> 自动或者手动提交分区偏移量，早期版本的kafka偏移量是提交给Zookeeper的，这样使得zookeeper的压力比较大，更新版本的kafka的偏移量是提交给kafka服务器的，不再依赖于zookeeper群组，集群的性能更加稳定。</p></li><li><p>rabbitmq：支持。</p><p> 1&gt;发送方确认机制，消息被投递到所有匹配的队列后，返回成功。如果消息和队列是可持久化的，那么在写入磁盘后，返回成功。支持批量确认和异步确认。</p><p> 2&gt;接收方确认机制，设置autoAck为false，需要显式确认，设置autoAck为true，自动确认。<br> 当autoAck为false的时候，rabbitmq队列会分成两部分，一部分是等待投递给consumer的消息，一部分是已经投递但是没收到确认的消息。如果一直没有收到确认信号，并且consumer已经断开连接，rabbitmq会安排这个消息重新进入队列，投递给原来的消费者或者下一个消费者。<br> 未确认的消息不会有过期时间，如果一直没有确认，并且没有断开连接，rabbitmq会一直等待，rabbitmq允许一条消息处理的时间可以很久很久。</p></li><li><p>zeromq：支持。</p></li><li><p>rocketmq：支持。</p></li><li><p>activemq：支持。</p></li></ol><h1 id="消息回溯"><a href="#消息回溯" class="headerlink" title="消息回溯"></a>消息回溯</h1><ul><li>Kafka：支持指定分区offset位置的回溯。 </li><li>rabbitmq：不支持 </li><li>zeromq：不支持 </li><li>rocketmq：支持指定时间点的回溯。 </li><li>activemq：不支持</li></ul><h1 id="消息重试"><a href="#消息重试" class="headerlink" title="消息重试"></a>消息重试</h1><ul><li>Kafka：不支持，但是可以实现。kafka支持指定分区offset位置的回溯，可以实现消息重试。</li><li>rabbitmq：不支持，但是可以利用消息确认机制实现。</li><li>rabbitmq接收方确认机制，设置autoAck为false。<br>当autoAck为false的时候，rabbitmq队列会分成两部分，一部分是等待投递给consumer的消息，一部分是已经投递但是没收到确认的消息。如果一直没有收到确认信号，并且consumer已经断开连接，rabbitmq会安排这个消息重新进入队列，投递给原来的消费者或者下一个消费者。</li><li>zeromq：不支持，</li><li>rocketmq：支持。</li><li>activemq：不支持</li></ul><h1 id="并发度"><a href="#并发度" class="headerlink" title="并发度"></a>并发度</h1><ol><li>Kafka：高</li><li>rabbitmq：极高</li><li>zeromq：高</li><li>rocketmq：高</li><li>activemq：高</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot——定时任务（二十七）</title>
      <link href="/2020/07/13/SpringBoot%E2%80%94%E2%80%94%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89/"/>
      <url>/2020/07/13/SpringBoot%E2%80%94%E2%80%94%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>定时任务实现的几种方式：<br>Timer：这是java自带的java.util.Timer类，这个类允许你调度一个java.util.TimerTask任务。使用这种方式可以让你的程序按照某一个频度执行，但不能在指定时间运行。一般用的较少。<br>ScheduledExecutorService：也jdk自带的一个类；是基于线程池设计的定时任务类,每个调度任务都会分配到线程池中的一个线程去执行,也就是说,任务是并发执行,互不影响。<br>Spring Task：Spring3.0以后自带的task，可以将它看成一个轻量级的Quartz，而且使用起来比Quartz简单许多。<br>Quartz：这是一个功能比较强大的的调度器，可以让你的程序在指定时间执行，也可以按照某一个频度执行，配置起来稍显复杂。</p><h1 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTimer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TimerTask timerTask = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"task  run:"</span>+ <span class="keyword">new</span> Date());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        <span class="comment">//安排指定的任务在指定的时间开始进行重复的固定延迟执行。这里是每3秒执行一次</span></span><br><span class="line">        timer.schedule(timerTask,<span class="number">10</span>,<span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestScheduledExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">        <span class="comment">// 参数：1、任务体 2、首次执行的延时时间</span></span><br><span class="line">        <span class="comment">//      3、任务执行间隔 4、间隔时间单位</span></span><br><span class="line">        service.scheduleAtFixedRate(()-&gt;System.out.println(<span class="string">"task ScheduledExecutorService "</span>+<span class="keyword">new</span> Date()), <span class="number">0</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring-Task"><a href="#Spring-Task" class="headerlink" title="Spring Task"></a>Spring Task</h1><h2 id="简单定时任务"><a href="#简单定时任务" class="headerlink" title="简单定时任务"></a>简单定时任务</h2><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.CommandLineRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.ServletComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableAsync;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ServletComponentScan</span> 扫描Servlet, Filter, Listener 添加到容器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.qn.mapper"</span>) <span class="comment">//扫描的mapper</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootDemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommandLineRunner <span class="title">commandLineRunner</span><span class="params">(ApplicationContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args -&gt; &#123;</span><br><span class="line">            <span class="comment">// 开始检查spring boot 提供的 beans</span></span><br><span class="line">            System.out.println(<span class="string">"Let's inspect the beans provided by Spring Boot:"</span>);</span><br><span class="line">            String[] beanNames = ctx.getBeanDefinitionNames();</span><br><span class="line">            Arrays.sort(beanNames);</span><br><span class="line">            <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">                System.out.println(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"0/5 * * * * *"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduled</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=====&gt;&gt;&gt;&gt;&gt;使用cron  &#123;&#125;"</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedRate = <span class="number">5000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduled1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=====&gt;&gt;&gt;&gt;&gt;使用fixedRate&#123;&#125;"</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedDelay = <span class="number">5000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduled2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=====&gt;&gt;&gt;&gt;&gt;fixedDelay&#123;&#125;"</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多线程执行"><a href="#多线程执行" class="headerlink" title="多线程执行"></a>多线程执行</h2><p>确认开启异步，创建线程池配置，详情见上文</p><p>然后在定时任务的类或者方法上添加@Async 。最后重启项目，每一个任务都是在不同的线程中。</p><h1 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h1><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="任务类"><a href="#任务类" class="headerlink" title="任务类"></a>任务类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestQuartz</span> <span class="keyword">extends</span> <span class="title">QuartzJobBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行定时任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jobExecutionContext</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> JobExecutionException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeInternal</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"quartz task "</span>+<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JobDetail <span class="title">teatQuartzDetail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        return JobBuilder.newJob(TestQuartz.class).withIdentity("testQuartz").storeDurably().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Trigger <span class="title">testQuartzTrigger</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SimpleScheduleBuilder scheduleBuilder = SimpleScheduleBuilder.simpleSchedule()</span><br><span class="line">                .withIntervalInSeconds(<span class="number">10</span>)  <span class="comment">//设置时间周期单位秒</span></span><br><span class="line">                .repeatForever();</span><br><span class="line">        <span class="keyword">return</span> TriggerBuilder.newTrigger().forJob(teatQuartzDetail())</span><br><span class="line">                .withIdentity(<span class="string">"testQuartz"</span>)</span><br><span class="line">                .withSchedule(scheduleBuilder)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot——异步（二十六）</title>
      <link href="/2020/07/13/SpringBoot%E2%80%94%E2%80%94%E5%BC%82%E6%AD%A5%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AD%EF%BC%89/"/>
      <url>/2020/07/13/SpringBoot%E2%80%94%E2%80%94%E5%BC%82%E6%AD%A5%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在SpringBoot中使用异步调用是很简单的，只需要使用@Async注解即可实现方法的异步调用。</p><h1 id="简单异步"><a href="#简单异步" class="headerlink" title="简单异步"></a>简单异步</h1><h2 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.CommandLineRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.ServletComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableAsync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ServletComponentScan</span> 扫描Servlet, Filter, Listener 添加到容器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.qn.mapper"</span>) <span class="comment">//扫描的mapper</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootDemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommandLineRunner <span class="title">commandLineRunner</span><span class="params">(ApplicationContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args -&gt; &#123;</span><br><span class="line">            <span class="comment">// 开始检查spring boot 提供的 beans</span></span><br><span class="line">            System.out.println(<span class="string">"Let's inspect the beans provided by Spring Boot:"</span>);</span><br><span class="line">            String[] beanNames = ctx.getBeanDefinitionNames();</span><br><span class="line">            Arrays.sort(beanNames);</span><br><span class="line">            <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">                System.out.println(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncEvent</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//休眠1s</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//log.info("异步方法输出：&#123;&#125;!", System.currentTimeMillis());</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncEvent</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//log.info("同步方法输出：&#123;&#125;!", System.currentTimeMillis());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdbc测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">AccountServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        accountService.getAll().forEach(account -&gt; System.out.println(account.toString()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>在默认情况下，未设置TaskExecutor时，默认是使用SimpleAsyncTaskExecutor这个线程池，但此线程不是真正意义上的线程池，因为线程不重用，每次调用都会创建一个新的线程。可通过控制台日志输出可以看出，每次输出线程名都是递增的。</p><p>调用的异步方法，不能为同一个类的方法，简单来说，因为Spring在启动扫描时会为其创建一个代理类，而同类调用时，还是调用本身的代理类的，所以和平常调用是一样的。其他的注解如@Cache等也是一样的道理，说白了，就是Spring的代理机制造成的。</p><h1 id="异步线程池"><a href="#异步线程池" class="headerlink" title="异步线程池"></a>异步线程池</h1><h2 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.config.AsnycConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringBootConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskExecutorConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"asyncPoolTaskExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title">getAsyncThreadPoolTaskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor taskExecutor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        taskExecutor.setCorePoolSize(<span class="number">20</span>);</span><br><span class="line">        taskExecutor.setMaxPoolSize(<span class="number">200</span>);</span><br><span class="line">        taskExecutor.setQueueCapacity(<span class="number">25</span>);</span><br><span class="line">        taskExecutor.setKeepAliveSeconds(<span class="number">200</span>);</span><br><span class="line">        taskExecutor.setThreadNamePrefix(<span class="string">"oKong-"</span>);</span><br><span class="line">        <span class="comment">// 线程池对拒绝任务（无线程可用）的处理策略，目前只支持AbortPolicy、CallerRunsPolicy；默认为后者</span></span><br><span class="line">        taskExecutor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        <span class="comment">//调度器shutdown被调用时等待当前被调度的任务完成</span></span><br><span class="line">        taskExecutor.setWaitForTasksToCompleteOnShutdown(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//等待时长</span></span><br><span class="line">        taskExecutor.setAwaitTerminationSeconds(<span class="number">60</span>);</span><br><span class="line">        taskExecutor.initialize();</span><br><span class="line">        <span class="keyword">return</span> taskExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.AsyncResult;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTaskService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span>(<span class="string">"asyncPoolTaskExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;String&gt; <span class="title">asyncEvent</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="comment">//休眠1s</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">"异步方法内部线程名称：&#123;&#125;!"</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;&gt;(<span class="string">"异步方法返回值"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncEvent</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//log.info("同步方法输出：&#123;&#125;!", System.currentTimeMillis());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Test-1"><a href="#Test-1" class="headerlink" title="Test"></a>Test</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">AsyncTaskServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AsyncTaskService asyncTaskService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doAsync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"方法执行开始：&#123;&#125;"</span> + start);</span><br><span class="line">        <span class="comment">//调用同步方法</span></span><br><span class="line">        asyncTaskService.syncEvent();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> syncTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"同步方法用时：&#123;&#125;"</span> + (syncTime - start));</span><br><span class="line">        <span class="comment">//调用异步方法</span></span><br><span class="line">        Future&lt;String&gt; doFutrue = asyncTaskService.asyncEvent();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//判断异步任务是否完成</span></span><br><span class="line">            <span class="keyword">if</span>(doFutrue.isDone()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> asyncTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"异步方法用时：&#123;&#125;"</span> + (asyncTime - syncTime));</span><br><span class="line">        System.out.println(<span class="string">"方法执行完成：&#123;&#125;!"</span> + asyncTime);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"async!!!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h1><p>对于一些需要异步回调的函数，不能无期限的等待下去，所以一般上需要设置超时时间，超时后可将线程释放，而不至于一直堵塞而占用资源。</p><p>配置future超时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/get方法会一直堵塞，直到等待执行完成才返回</span><br><span class="line"><span class="comment">//get(long timeout, TimeUnit unit) 在设置时间类未返回结果，会直接排除异常TimeoutException，messages为null</span></span><br><span class="line">String result = doFutrue.get(<span class="number">60</span>, TimeUnit.SECONDS);<span class="comment">//60s</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot——RabittMQ（二十四）</title>
      <link href="/2020/07/10/SpringBoot%E2%80%94%E2%80%94RabittMQ%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
      <url>/2020/07/10/SpringBoot%E2%80%94%E2%80%94RabittMQ%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="pom"><a href="#pom" class="headerlink" title="pom"></a>pom</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--mq--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rabbitmq</span></span><br><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">guest</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">guest</span></span><br><span class="line"><span class="comment"># 开启confirms回调 P -&gt; Exchange</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-confirms</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 开启returnedMessage回调 Exchange -&gt; Queue</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-returns</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 设置手动确认(ack) Queue -&gt; C</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.acknowledge-mode</span>=<span class="string">manual</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.prefetch</span>=<span class="string">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mail</span></span><br><span class="line"><span class="meta">spring.mail.host</span>=<span class="string">smtp.163.com</span></span><br><span class="line"><span class="meta">spring.mail.username</span>=<span class="string">18621142249@163.com</span></span><br><span class="line"><span class="meta">spring.mail.password</span>=<span class="string">123456wangzai</span></span><br><span class="line"><span class="meta">spring.mail.from</span>=<span class="string">18621142249@163.com</span></span><br><span class="line"><span class="meta">spring.mail.properties.mail.smtp.auth</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.mail.properties.mail.smtp.starttls.enable</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.mail.properties.mail.smtp.starttls.required</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><h1 id="RabbitConfig"><a href="#RabbitConfig" class="headerlink" title="RabbitConfig"></a>RabbitConfig</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CachingConnectionFactory connectionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MsgLogService msgLogService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">rabbitTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate(connectionFactory);</span><br><span class="line">        rabbitTemplate.setMessageConverter(converter());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消息是否成功发送到Exchange</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">                log.info(<span class="string">"消息成功发送到Exchange"</span>);</span><br><span class="line">                String msgId = correlationData.getId();</span><br><span class="line">                msgLogService.updateStatus(msgId, Constant.MsgLogStatus.DELIVER_SUCCESS);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(<span class="string">"消息发送到Exchange失败, &#123;&#125;, cause: &#123;&#125;"</span>, correlationData, cause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发setReturnCallback回调必须设置mandatory=true, 否则Exchange没有找到Queue就会丢弃掉消息, 而不会触发回调</span></span><br><span class="line">        rabbitTemplate.setMandatory(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 消息是否从Exchange路由到Queue, 注意: 这是一个失败回调, 只有消息从Exchange路由到Queue失败才会回调这个方法</span></span><br><span class="line">        rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">"消息从Exchange路由到Queue失败: exchange: &#123;&#125;, route: &#123;&#125;, replyCode: &#123;&#125;, replyText: &#123;&#125;, message: &#123;&#125;"</span>, exchange, routingKey, replyCode, replyText, message);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Jackson2JsonMessageConverter <span class="title">converter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Jackson2JsonMessageConverter();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送邮件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAIL_QUEUE_NAME = <span class="string">"mail.queue"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAIL_EXCHANGE_NAME = <span class="string">"mail.exchange"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAIL_ROUTING_KEY_NAME = <span class="string">"mail.routing.key"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">mailQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(MAIL_QUEUE_NAME, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">mailExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(MAIL_EXCHANGE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">mailBinding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(mailQueue()).to(mailExchange()).with(MAIL_ROUTING_KEY_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="MailUtil"><a href="#MailUtil" class="headerlink" title="MailUtil"></a>MailUtil</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.mail.from&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaMailSender mailSender;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送简单邮件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mail</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">send</span><span class="params">(Mail mail)</span> </span>&#123;</span><br><span class="line">        String to = mail.getTo();<span class="comment">// 目标邮箱</span></span><br><span class="line">        String title = mail.getTitle();<span class="comment">// 邮件标题</span></span><br><span class="line">        String content = mail.getContent();<span class="comment">// 邮件正文</span></span><br><span class="line"></span><br><span class="line">        SimpleMailMessage message = <span class="keyword">new</span> SimpleMailMessage();</span><br><span class="line">        message.setFrom(from);</span><br><span class="line">        message.setTo(to);</span><br><span class="line">        message.setSubject(title);</span><br><span class="line">        message.setText(content);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mailSender.send(message);</span><br><span class="line">            log.info(<span class="string">"邮件发送成功"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MailException e) &#123;</span><br><span class="line">            log.error(<span class="string">"邮件发送失败, to: &#123;&#125;, title: &#123;&#125;"</span>, to, title, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> <span class="keyword">implements</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MsgLogMapper msgLogMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerResponse <span class="title">send</span><span class="params">(Mail mail)</span> </span>&#123;</span><br><span class="line">        String msgId = RandomUtil.UUID32();</span><br><span class="line">        mail.setMsgId(msgId);</span><br><span class="line"></span><br><span class="line">        MsgLog msgLog = <span class="keyword">new</span> MsgLog(msgId, mail, RabbitConfig.MAIL_EXCHANGE_NAME, RabbitConfig.MAIL_ROUTING_KEY_NAME);</span><br><span class="line">        msgLogMapper.insert(msgLog);<span class="comment">// 消息入库</span></span><br><span class="line"></span><br><span class="line">        CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(msgId);</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitConfig.MAIL_EXCHANGE_NAME, RabbitConfig.MAIL_ROUTING_KEY_NAME, MessageHelper.objToMsg(mail), correlationData);<span class="comment">// 发送消息</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ServerResponse.success(ResponseCode.MAIL_SEND_SUCCESS.getMsg());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MsgLogService msgLogService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MailUtil mailUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = RabbitConfig.MAIL_QUEUE_NAME)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Mail mail = MessageHelper.msgToObj(message, Mail<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        log.info(<span class="string">"收到消息: &#123;&#125;"</span>, mail.toString());</span><br><span class="line"></span><br><span class="line">        String msgId = mail.getMsgId();</span><br><span class="line"></span><br><span class="line">        MsgLog msgLog = msgLogService.selectByMsgId(msgId);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == msgLog || msgLog.getStatus().equals(Constant.MsgLogStatus.CONSUMED_SUCCESS)) &#123;<span class="comment">// 消费幂等性</span></span><br><span class="line">            log.info(<span class="string">"重复消费, msgId: &#123;&#125;"</span>, msgId);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MessageProperties properties = message.getMessageProperties();</span><br><span class="line">        <span class="keyword">long</span> tag = properties.getDeliveryTag();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> success = mailUtil.send(mail);</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            msgLogService.updateStatus(msgId, Constant.MsgLogStatus.CONSUMED_SUCCESS);</span><br><span class="line">            channel.basicAck(tag, <span class="keyword">false</span>);<span class="comment">// 消费确认</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.basicNack(tag, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ResendMsg定时任务重新投递发送失败的消息"><a href="#ResendMsg定时任务重新投递发送失败的消息" class="headerlink" title="ResendMsg定时任务重新投递发送失败的消息"></a>ResendMsg定时任务重新投递发送失败的消息</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResendMsg</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MsgLogService msgLogService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大投递次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_TRY_COUNT = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每30s拉取投递失败的消息, 重新投递</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"0/30 * * * * ?"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"开始执行定时任务(重新投递消息)"</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;MsgLog&gt; msgLogs = msgLogService.selectTimeoutMsg();</span><br><span class="line">        msgLogs.forEach(msgLog -&gt; &#123;</span><br><span class="line">            String msgId = msgLog.getMsgId();</span><br><span class="line">            <span class="keyword">if</span> (msgLog.getTryCount() &gt;= MAX_TRY_COUNT) &#123;</span><br><span class="line">                msgLogService.updateStatus(msgId, Constant.MsgLogStatus.DELIVER_FAIL);</span><br><span class="line">                log.info(<span class="string">"超过最大重试次数, 消息投递失败, msgId: &#123;&#125;"</span>, msgId);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                msgLogService.updateTryCount(msgId, msgLog.getNextTryTime());<span class="comment">// 投递次数+1</span></span><br><span class="line"></span><br><span class="line">                CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(msgId);</span><br><span class="line">                rabbitTemplate.convertAndSend(msgLog.getExchange(), msgLog.getRoutingKey(), MessageHelper.objToMsg(msgLog.getMsg()), correlationData);<span class="comment">// 重新投递</span></span><br><span class="line"></span><br><span class="line">                log.info(<span class="string">"第 "</span> + (msgLog.getTryCount() + <span class="number">1</span>) + <span class="string">" 次重新投递消息"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"定时任务执行结束(重新投递消息)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件——RabbitMQ—延时消息队列（七）</title>
      <link href="/2020/07/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E2%80%94%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88%E4%B8%83%EF%BC%89/"/>
      <url>/2020/07/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E2%80%94%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用RabbitMQ来实现延迟任务必须先了解RabbitMQ的两个概念：消息的TTL和死信Exchange，通过这两者的组合来实现上述需求。</p><h1 id="消息的TTL（Time-To-Live）"><a href="#消息的TTL（Time-To-Live）" class="headerlink" title="消息的TTL（Time To Live）"></a>消息的TTL（Time To Live）</h1><p>消息的TTL就是消息的存活时间。RabbitMQ可以对队列和消息分别设置TTL。对队列设置就是队列没有消费者连着的保留时间，也可以对每一个单独的消息做单独的设置。超过了这个时间，我们认为这个消息就死了，称之为死信。如果队列设置了，消息也设置了，那么会取小的。所以一个消息如果被路由到不同的队列中，这个消息死亡的时间有可能不一样（不同的队列设置）。</p><p>这里单讲单个消息的TTL，因为它才是实现延迟任务的关键。</p><p>可以通过设置消息的expiration字段或者x-message-ttl属性来设置时间，两者是一样的效果。只是expiration字段是字符串参数，所以要写个int类型的字符串：</p><p><img src="/images/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E2%80%94%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88%E4%B8%83%EF%BC%89_2020-07-10-16-00-18.png" alt="消息中间件——RabbitMQ—延时消息队列（七）_2020-07-10-16-00-18.png"></p><p>当上面的消息扔到队列中后，过了3分钟，如果没有被消费，它就死了。不会被消费者消费到。这个消息后面的，没有“死掉”的消息对顶上来，被消费者消费。死信在队列中并不会被删除和释放，它会被统计到队列的消息数中去。单靠死信还不能实现延迟任务，还要靠Dead Letter Exchange。</p><h1 id="Dead-Letter-Exchanges"><a href="#Dead-Letter-Exchanges" class="headerlink" title="Dead Letter Exchanges"></a>Dead Letter Exchanges</h1><p>一个消息在满足如下条件下，会进死信路由，记住这里是路由而不是队列，一个路由可以对应很多队列。</p><ol><li>一个消息被Consumer拒收了，并且reject方法的参数里requeue是false。也就是说不会被再次放在队列里，被其他消费者使用。</li><li>上面的消息的TTL到了，消息过期了。</li><li>队列的长度限制满了。排在前面的消息会被丢弃或者扔到死信路由上。</li></ol><p>Dead Letter Exchange其实就是一种普通的exchange，和创建其他exchange没有两样。只是在某一个设置Dead Letter Exchange的队列中有消息过期了，会自动触发消息的转发，发送到Dead Letter Exchange中去。</p><h1 id="实现延迟队列"><a href="#实现延迟队列" class="headerlink" title="实现延迟队列"></a>实现延迟队列</h1><p>延迟任务通过消息的TTL和Dead Letter Exchange来实现。我们需要建立2个队列，一个用于发送消息，一个用于消息过期后的转发目标队列。</p><p>生产者输出消息到Queue1，并且这个消息是设置有有效时间的，比如3分钟。消息会在Queue1中等待3分钟，如果没有消费者收掉的话，它就是被转发到Queue2，Queue2有消费者，收到，处理延迟任务。</p><p><a href="https://www.cnblogs.com/yinfengjiujian/p/9204600.html" target="_blank" rel="noopener">实现延时队列</a></p>]]></content>
      
      
      <categories>
          
          <category> 消息中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息中间件 RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件——RabbitMQ—无消息丢失和幂等性（五）</title>
      <link href="/2020/07/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E2%80%94%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E5%92%8C%E5%B9%82%E7%AD%89%E6%80%A7%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2020/07/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E2%80%94%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E5%92%8C%E5%B9%82%E7%AD%89%E6%80%A7%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="消息无丢失？"><a href="#消息无丢失？" class="headerlink" title="消息无丢失？"></a>消息无丢失？</h1><h2 id="生产者丢失？"><a href="#生产者丢失？" class="headerlink" title="生产者丢失？"></a>生产者丢失？</h2><p>RabbitMQ使⽤发送⽅确认模式，确保消息正确地发送到RabbitMQ。</p><p>发送⽅确认模式：将信道设置成confirm模式（发送⽅确认模式），则所有在信道上发布的消息</p><p>都会被指派⼀个唯⼀的ID。⼀旦消息被投递到⽬的队列后，或者消息被写⼊磁盘后（可持久化</p><p>的消息），信道会发送⼀个确认给⽣产者（包含消息唯⼀ID）。</p><p>如果RabbitMQ发⽣内部错误，从⽽导致消息丢失，会发送⼀条nack（not acknowledged，未确认）消息。</p><p>发送⽅确认模式是异步的，⽣产者应⽤程序在等待确认的同时，可以继续发送消息。当确认消息到达⽣产者应⽤程序，⽣产者应⽤程序的回调⽅法就会被触发来处理确认消息。</p><h2 id="消费者丢失？"><a href="#消费者丢失？" class="headerlink" title="消费者丢失？"></a>消费者丢失？</h2><p>接收⽅消息确认机制：消费者接收每一条消息后都必须进行确认（ack确认机制）。只有消费者确认了消息，RabbitMQ才能安全地把消息从队列中删除。</p><p>这⾥并没有⽤到超时机制，RabbitMQ仅通过Consumer的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，RabbitMQ给了Consumer⾜够⻓的时间来处理消息。</p><p>特殊情况：</p><ul><li>如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ会认为消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要根据bizId去重）</li><li>如果消费者接收到消息却没有确认消息，连接也未断开，则RabbitMQ认为该消费者繁忙，将不会给该消费者分发更多的消息。</li></ul><p>ack确认机制：</p><p>多个消费者同时收取消息，比如消息接收到一半的时候，一个消费者死掉了(逻辑复杂时间太长，超时了或者消费被停机或者网络断开链接)，如何保证消息不丢？<br>这个使用就要使用Message acknowledgment 机制，就是消费端消费完成要通知服务端，服务端才把消息从内存删除。<br>这样就解决了，及时一个消费者出了问题，没有同步消息给服务端，还有其他的消费端去消费，保证了消息不丢的case。</p><h2 id="RabbitMQ内部丢失？"><a href="#RabbitMQ内部丢失？" class="headerlink" title="RabbitMQ内部丢失？"></a>RabbitMQ内部丢失？</h2><ol><li>镜像队列集群</li><li>消息持久化</li></ol><h1 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h1><p>上面我们在保证无消息丢失的情况下，难免造成了重复消费的情况。</p><h2 id="生产者幂等"><a href="#生产者幂等" class="headerlink" title="生产者幂等"></a>生产者幂等</h2><p>在消息⽣产时，MQ内部针对每条⽣产者发送的消息⽣成⼀个inner-msg-id，作为去重和幂等的依据（消息投递失败并重传），避免重复的消息进⼊队列；</p><h2 id="消费者幂等"><a href="#消费者幂等" class="headerlink" title="消费者幂等"></a>消费者幂等</h2><p>在消息消费时，要求消息体中必须要有⼀个bizId（对于同⼀业务全局唯⼀，如⽀付ID、订单ID、帖⼦ID等）作为去重和幂等的依据，避免同⼀条消息被重复消费。</p><h1 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h1><h1 id="ACK确认机制"><a href="#ACK确认机制" class="headerlink" title="ACK确认机制"></a>ACK确认机制</h1><h1 id="设置集群镜像模式"><a href="#设置集群镜像模式" class="headerlink" title="设置集群镜像模式"></a>设置集群镜像模式</h1><h1 id="消息补偿机制"><a href="#消息补偿机制" class="headerlink" title="消息补偿机制"></a>消息补偿机制</h1><p>为什么还要消息补偿机制呢？难道消息还会丢失，没错，系统是在一个复杂的环境，不要想的太简单了，虽然以上的三种方案，基本可以保证消息的高可用不丢失的问题，<br>但是作为有追求的程序员来讲，要绝对保证我的系统的稳定性，有一种危机意识。</p><p>比如：持久化的消息，保存到硬盘过程中，当前队列节点挂了，存储节点硬盘又坏了，消息丢了，怎么办？</p><p>产线网络环境太复杂，所以不知数太多，消息补偿机制需要建立在消息要写入DB日志，发送日志，接受日志，两者的状态必须记录。</p><p>然后根据DB日志记录check 消息发送消费是否成功，不成功，进行消息补偿措施，重新发送消息处理。</p><h1 id="消息确认"><a href="#消息确认" class="headerlink" title="消息确认"></a>消息确认</h1><p>消息的确认做有很多法，其中包括事务机制、批量确认、异步确认等。</p><ol><li><p>事务机制：我们在channel对象中可以看到 txSelect(),txCommit(),txrollback() 这些方法，分别对应着开启事务，提交事务，回滚。由于使用事务会造成生产者与Broker交互次数增加，造成性能资源的浪费，而且事务机制是阻塞的，在发送一条消息后需要等待RabbitMq回应，之后才能发送下一条，因此事务机制不提倡，大家在网上也很少看到RabbitMq使用事务进行消息确认的。</p></li><li><p>批量确认：批量其实是一个节约资源的操作，但是在RabbitMq中我们使用批量操作会造成消息重复消费，原因是批量操作是使客户端程序定期或者消息达到一定量，来调用方法等待Broker返回，这样其实是一个提高效率的做法，但是如果出现消息重发的情况，当前这批次的消息都需要重发，这就造成了重复消费，因此批量确认的操作性能没有提高反而下降。</p></li><li><p>异步确认：异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都没得说，他是利用回调函数来达到消息可靠性传递的，笔者接触过RocketMq，这个中间件也是通过函数回调来保证是否投递成功，下面就让我们来详细讲解异步确认是怎么实现的。</p></li></ol><p>我们大概分为两大类，发送方确认和接收方确认，其中发送方确认又分为生产者到交换器到确认和交换器到队列的确认。</p><h2 id="发布者确认"><a href="#发布者确认" class="headerlink" title="发布者确认"></a>发布者确认</h2><p>ConfirmCallback</p><p>是一个回调接口，消息发送到 Broker 后触发回调，确认消息是否到达 Broker 服务器，也就是只确认是否正确到达 Exchange 中。</p><p>我们需要在生产者的配置中添加下面配置，表示开启发布者确认</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.rabbitmq.publisher-confirms=true</span></span><br></pre></td></tr></table></figure><p>然后在生产者的Java配置类实现该接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitTemplateConfig</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initRabbitTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置生产者消息确认</span></span><br><span class="line"></span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 消息发送到 Broker 后触发回调，确认消息是否到达 Broker 服务器，也就是只确认是否正确到达 Exchange 中</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> correlationData</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(@Nullable CorrelationData correlationData, <span class="keyword">boolean</span> b, @Nullable String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"ack：[&#123;&#125;]"</span> + b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (b) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"消息到达rabbitmq服务器"</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"消息可能未到达rabbitmq服务器"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ReturnCallback</p><p>通过实现 ReturnCallback 接口，启动消息失败返回，此接口是在交换器路由不到队列时触发回调，该方法可以不使用，因为交换器和队列是在代码里绑定的，如果消息成功投递到Broker后几乎不存在绑定队列失败，除非你代码写错了。</p><p>使用此接口需要在生产者配置中加入一下配置，表示发布者返回</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.rabbitmq.publisher-returns=true</span></span><br></pre></td></tr></table></figure><p>然后基于刚才的生产者Java配置里实现接口ReturnCallback</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Componentpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitTemplateConfig</span> <span class="keyword">implements</span>  <span class="title">RabbitTemplate</span>.<span class="title">ReturnCallback</span> </span>&#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;     <span class="meta">@PostConstruct</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initRabbitTemplate</span><span class="params">()</span> </span>&#123;               rabbitTemplate.setReturnCallback(<span class="keyword">this</span>);    &#125;     <span class="comment">/**     * 启动消息失败返回，比如路由不到队列时触发回调     *     * <span class="doctag">@param</span> message     * <span class="doctag">@param</span> i     * <span class="doctag">@param</span> s     * <span class="doctag">@param</span> s1     * <span class="doctag">@param</span> s2     */</span>    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> i, String s, String s1, String s2)</span> </span>&#123;        System.out.println(<span class="string">"消息主体 message : "</span> + message);        System.out.println(<span class="string">"消息主体 replyCode : "</span> + i);        System.out.println(<span class="string">"描述 replyText："</span> + s);        System.out.println(<span class="string">"消息使用的交换器 exchange : "</span> + s1);        System.out.println(<span class="string">"消息使用的路由键 routing : "</span> + s2);    &#125;&#125;</span><br></pre></td></tr></table></figure><p>以上两段Java配置可以写在一个类里。</p><p>到此，我们完成了生产者的异步确认，我们可以在回调函数中对当前失败的消息进行补偿，这样保证了我们没有发送成功的数据也被观察到了，比如某某条数据需要发送到消费者消费，但是没有发送成功，这就需要你在此做一些其他操作喽，根据你具体业务来。</p><h2 id="消息消费确认"><a href="#消息消费确认" class="headerlink" title="消息消费确认"></a>消息消费确认</h2><p>消费者确认发生在监听队列的消费者处理业务失败，如，发生了异常，不符合要求的数据……，这些场景我们就需要手动处理，比如重新发送或者丢弃。</p><p>我们知道ACK是默认是自动的，自动确认会在消息发送给消费者后立即确认，但存在丢失消息的可能，如果消费端消费逻辑抛出异常，加入你用回滚了也只是保证了数据的一致性，但是消息还是丢了，也就是消费端没有处理成功这条消息，那么就相当于丢失了消息。</p><p>消息确认模式有：</p><p>AcknowledgeMode.NONE：自动确认<br>AcknowledgeMode.AUTO：根据情况确认<br>AcknowledgeMode.MANUAL：手动确认</p><p>需要在消费者的配置里加手动 ack（确认）则需要修改确认模式为 manual，手动确认的方式有很多，可以在RabbitListenerContainerFactory类进行设置。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.rabbitmq.listener.direct.acknowledge-mode=MANUAL</span></span><br></pre></td></tr></table></figure><p>消费者类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncConfirmConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"confirm_queue"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncConfirm</span><span class="params">(Order order, Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"消费消息："</span> + order.getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">//            int a = 1 / 0;</span></span><br><span class="line"></span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"消费消息确认"</span> + message.getMessageProperties().getConsumerQueue() + <span class="string">"，接收到了回调方法"</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//重新回到队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, true);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            System.out.println("尝试重发：" + message.getMessageProperties().getConsumerQueue());</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//requeue =true 重回队列，false 丢弃</span></span><br><span class="line"></span><br><span class="line">            channel.basicReject(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// TODO 该消息已经导致异常，重发无意义，自己实现补偿机制</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ 无消息丢失 幂等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件——RabbitMQ—持久化（四）</title>
      <link href="/2020/07/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E2%80%94%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2020/07/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E2%80%94%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>所谓持久化，就是RabbitMQ会将内存中的数据(Exchange 交换器，Queue 队列，Message 消息)固化到磁盘，以防异常情况发生时，数据丢失。</p><p>其中，RabblitMQ的持久化分为三个部分：</p><ol><li>交换器(Exchange)的持久化</li><li>队列(Queue)的持久化</li><li>消息(Message)的持久化</li></ol><h1 id="交换器-Exchange-的持久化"><a href="#交换器-Exchange-的持久化" class="headerlink" title="交换器(Exchange)的持久化"></a>交换器(Exchange)的持久化</h1><p>在上篇博客中，我们声明Exchange的代码是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"normal-confirm-exchange"</span>;</span><br><span class="line"><span class="comment">// 创建一个Exchange</span></span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"direct"</span>);</span><br></pre></td></tr></table></figure><p>这种情况下声明的Exchange是非持久化的，在RabbitMQ出现异常情况（重启，宕机）时，该Exchange会丢失，会影响后续的消息写入该Exchange。</p><p>那么如何设置Exchange为持久化的呢？答案是设置durable参数。</p><p>durable：设置是否持久化。durable设置为true表示持久化，反之是非持久化。<br>持久化可以将交换器存盘，在服务器重启的时候不会丢失相关信息。</p><p>设置Exchange持久化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"direct"</span>, <span class="keyword">true</span>);</span><br><span class="line">此时调用的重载方法为：</span><br><span class="line"><span class="function"><span class="keyword">public</span> DeclareOk <span class="title">exchangeDeclare</span><span class="params">(String exchange, String type, <span class="keyword">boolean</span> durable)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.exchangeDeclare(exchange, (String)type, durable, <span class="keyword">false</span>, (Map)<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了能更好的理解，我们新建个生产类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwwhnly.springbootaction.rabbitmq.durable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DurableProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"durable-exchange"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"durable-queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">// 设置 RabbitMQ 的主机名</span></span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        <span class="comment">// 创建一个连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">// 创建一个通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 创建一个Exchange</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"direct"</span>);</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        String message = <span class="string">"durable exchange test"</span>;</span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">""</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭频道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="队列-Queue-的持久化"><a href="#队列-Queue-的持久化" class="headerlink" title="队列(Queue)的持久化"></a>队列(Queue)的持久化</h1><p>细心的网友可能会发现，虽然现在重启RabbitMQ服务后，Exchange不丢失了，但是队列和消息丢失了。</p><p>那么如何解决队列不丢失呢？答案也是设置durable参数。</p><p>durable：设置是否持久化。为true则设置队列为持久化。</p><p>持久化的队列会存盘，在服务器重启的时候可以保证不丢失相关信息。<br>简单修改下上面声明Queue的代码，将durable参数设置为true：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">此时调用的重载方法如下：</span><br><span class="line"><span class="keyword">public</span> com.rabbitmq.client.impl.AMQImpl.Queue.<span class="function">DeclareOk <span class="title">queueDeclare</span><span class="params">(String queue, <span class="keyword">boolean</span> durable, <span class="keyword">boolean</span> exclusive, <span class="keyword">boolean</span> autoDelete, Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    validateQueueNameLength(queue);</span><br><span class="line">    <span class="keyword">return</span> (com.rabbitmq.client.impl.AMQImpl.Queue.DeclareOk)<span class="keyword">this</span>.exnWrappingRpc((<span class="keyword">new</span> com.rabbitmq.client.AMQP.Queue.Declare.Builder()).queue(queue).durable(durable).exclusive(exclusive).autoDelete(autoDelete).arguments(arguments).build()).getMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="消息-Message-的持久化"><a href="#消息-Message-的持久化" class="headerlink" title="消息(Message)的持久化"></a>消息(Message)的持久化</h1><p>虽然现在RabbitMQ重启后，Exchange和Queue都不丢失了，但是存储在Queue里的消息却仍然会丢失。</p><p>那么如何保证消息不丢失呢？答案是设置消息的投递模式为2，即代表持久化。</p><p>修改发送消息的代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line">String message = <span class="string">"durable exchange test"</span>;</span><br><span class="line">AMQP.BasicProperties props = <span class="keyword">new</span> AMQP.BasicProperties().builder().deliveryMode(<span class="number">2</span>).build();</span><br><span class="line">channel.basicPublish(EXCHANGE_NAME, <span class="string">""</span>, props, message.getBytes());</span><br><span class="line">调用的重载方法为：</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicPublish</span><span class="params">(String exchange, String routingKey, BasicProperties props, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.basicPublish(exchange, routingKey, <span class="keyword">false</span>, props, body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们完美的解决了RabbitMQ重启后，消息丢失的问题。<br>最终的代码如下，你也可以通过文末的源码链接下载本文用到的所有源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zwwhnly.springbootaction.rabbitmq.durable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.AMQP;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DurableProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"durable-exchange"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"durable-queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">// 设置 RabbitMQ 的主机名</span></span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        <span class="comment">// 创建一个连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">// 创建一个通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 创建一个Exchange</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"direct"</span>, <span class="keyword">true</span>);</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        String message = <span class="string">"durable exchange test"</span>;</span><br><span class="line">        AMQP.BasicProperties props = <span class="keyword">new</span> AMQP.BasicProperties().builder().deliveryMode(<span class="number">2</span>).build();</span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">""</span>, props, message.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭频道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li>理论上可以将所有的消息都设置为持久化，但是这样会严重影响RabbitMQ的性能。因为写入磁盘的速度比写入内存的速度慢得不止一点点。对于可靠性不是那么高的消息可以不采用持久化处理以提高整体的吞吐量。在选择是否要将消息持久化时，需要在可靠性和吞吐量之间做一个权衡。</li><li>将交换器、队列、消息都设置了持久化之后仍然不能百分之百保证数据不丢失，因为当持久化的消息正确存入RabbitMQ之后，还需要一段时间（虽然很短，但是不可忽视）才能存入磁盘之中。如果在这段时间内RabbitMQ服务节点发生了宕机、重启等异常情况，消息还没来得及落盘，那么这些消息将会丢失。</li><li>单单只设置队列持久化，重启之后消息会丢失；单单只设置消息的持久化，重启之后队列消失，继而消息也丢失。单单设置消息持久化而不设置队列的持久化显得毫无意义。</li></ol>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ 持久化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件——RabbitMQ—集群（三）</title>
      <link href="/2020/07/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E2%80%94%E9%9B%86%E7%BE%A4%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2020/07/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E2%80%94%E9%9B%86%E7%BE%A4%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用的。</p><h1 id="集群节点类型"><a href="#集群节点类型" class="headerlink" title="集群节点类型"></a>集群节点类型</h1><p>节点的存储类型分为两种：</p><ul><li>磁盘节点</li><li>内存节点</li></ul><p>磁盘节点就是配置信息和元信息存储在磁盘上，内存节点把这些信息存储在内存中，当然内次节点的性能是大大超越磁盘节点的。</p><p>单节点系统必须是磁盘节点，否则每次你重启RabbitMQ之后所有的系统配置信息都会丢失。</p><p>RabbitMQ要求集群中至少有一个磁盘节点，当节点加入和离开集群时，必须通知磁盘节点。</p><p>如果集群中的唯一一个磁盘节点，结果这个磁盘节点还崩溃了，那会发生什么情况？</p><p>如果唯一磁盘的磁盘节点崩溃了，不能进行如下操作：</p><ul><li>不能创建队列</li><li>不能创建交换器</li><li>不能创建绑定</li><li>不能添加用户</li><li>不能更改权限</li><li>不能添加和删除集群几点</li></ul><p>总结：如果唯一磁盘的磁盘节点崩溃，集群是可以保持运行的，但你不能更改任何东西。</p><p>解决方案： 在集群中设置两个磁盘节点，只要一个可以，你就能正常操作。</p><h1 id="集群类型"><a href="#集群类型" class="headerlink" title="集群类型"></a>集群类型</h1><p>RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。</p><ol><li><p>单机模式</p><p> 单机模式,生产几乎不用。</p></li><li><p>普通集群模式（无高可用性）</p><p> 普通集群模式，有服务器ABC，在服务器ABC上分别启动RabbitMQ实例，生产者生产消息1，随机发给某一实例A，实例BC上记录消息1的原数据信息（比如消息1具体信息在示例A上）,消费者消费消息，随机连接某个示例B，消费消息1，实例B根据原数据发现消息1在实例A上，则实例B去实例A拉取消息返回给消费者。</p><p> 优点：</p><p> 提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。</p><p> 缺点：</p><p> 消费者每次随机连接一个实例然后拉取数据，要么固定连接那个 queue 所在实例消费数据，前者有数据拉取的开销，后者导致单实例性能瓶颈。</p><p> 如果那个放 queue 的实例宕机了，会导致接下来其他实例就无法从那个实例拉取。</p><p> 如果你开启了消息持久化，让 RabbitMQ 落地存储消息的话，消息不一定会丢，得等这个实例恢复了，然后才可以继续从这个 queue 拉取数据。</p></li><li><p>镜像集群模式（高可用性）</p><p> 这种模式，才是所谓的 RabbitMQ 的高可用模式。</p><p> 跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，其元数据还是 queue 里的消息都会存在于一个或多个从队列拷贝，一旦主节点不可用，最老的从队列将被选举为新的主队列。</p><p> 为什么不在所有节点都完整拷贝一套数据？</p><p> 如果镜像队列数量过多，加之大量的消息进入，集群内部的网络带宽将会被这种同步通讯大大消耗掉。</p><p> 那么如何开启这个镜像集群模式呢？</p><p> 其实很简单，RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ 集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件——RabbitMQ—基础（二）</title>
      <link href="/2020/07/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E2%80%94%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/07/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E2%80%94%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><ol><li><p>Connection</p><p> Connection是RabbitMQ内部对象之一，用于管理每个到RabbitMQ的TCP网络连接。</p></li><li><p>Producer与Consumer</p><p> 生产者与消费者相对于RabbitMQ服务器来说，都是RabbitMQ服务器的客户端。</p><p> 生产者(Producer)：连到RabbitMQ服务器，将消息发送到RabbitMQ服务器的队列，是消息的发送方。</p><p> 消费者(Consumer)：连接到RabbitMQ则是为了消费队列中的消息，是消息的接收方。</p><p> 生产者与消费者一般由我们的应用程序充当。</p></li><li><p>Channel</p><p> Channel是我们与RabbitMQ打交道的最重要的一个接口，我们大部分的业务操作是在Channel这个接口中完成的，包括定义Queue、定义Exchange、绑定Queue与Exchange、发布消息等</p></li><li><p>Exchnage</p><p> 消息交换机，作用是接收来自生产者的消息，并根据路由键转发消息到所绑定的队列。</p><p> 生产者发送上的消息，就是先通过Exchnage按照绑定(binding)规则转发到队列的。</p><p> 交换机类型(Exchange Type)有四种：fanout、direct、topic，headers，其中headers并不常用。</p><ul><li><p>fanout：这种类型不处理路由键(RoutingKey)，很像子网广播，每台子网内的主机都获得了一份复制的消息，发布/订阅模式就是指使用fanout交换机类型，fanout类型交换机转发消息是最快的。</p></li><li><p>direct：模式处理路由键，需要路由键完全匹配的队列才能收到消息，路由模式使用的是direct类型的交换机。</p></li><li><p>topic：将路由键和某模式进行匹配。主题模式使用的是topic类型的交换机。</p><p>路由模式，发布订阅模式，主题模式，这些工作模式我们下面会讲。</p></li></ul></li><li><p>Queue</p><p> Queue，即队列，RabbitMQ内部用于存储消息的对象，是真正用存储消息的结构，在生产端，生产者的消息最终发送到指定队列，而消费者也是通过订阅某个队列，达到获取消息的目的。</p></li><li><p>RoutingKey（路由键）</p><p> 用于把生成者的数据分配到交换器上；</p></li><li><p>BindingKey（绑定键）</p><p> 用于把交换器的消息绑定到队列上；</p></li><li><p>Virtual Host</p><p> Virutal host也叫虚拟主机，一个VirtualHost下面有一组不同Exchnage与Queue，不同的Virtual host的Exchnage与Queue之间互相不影响。</p><p> 应用隔离与权限划分，Virtual host是RabbitMQ中最小颗粒的权限单位划分。</p><p> 如果要类比的话，我们可以把Virtual host比作MySQL中的数据库，通常我们在使用MySQL时，会为不同的项目指定不同的数据库，同样的，在使用RabbitMQ时，我们可以为不同的应用程序指定不同的Virtual host。</p></li></ol><h1 id="消息传递过程"><a href="#消息传递过程" class="headerlink" title="消息传递过程"></a>消息传递过程</h1><p>首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息，客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码），你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。</p><p>为什么不直接通过TCP协议？</p><p>因为其代价高昂，如果有成千上万个请求，是否要建立成千上万个TCP连接？</p><ol><li><p>发送消息</p><ul><li>生产者和Broker建立TCP连接。</li><li>生产者和Broker建立通道。</li><li>生产者通过通道消息发送给Broker，由Exchange将消息进行转发。</li><li>Exchange将消息转发到指定的Queue（队列）</li></ul></li><li><p>接受消息</p><ul><li>消费者和Broker建立TCP连接</li><li>消费者和Broker建立通道</li><li>消费者监听指定的Queue（队列）</li><li>当有消息到达Queue时Broker默认将消息推送给消费者。</li></ul></li></ol><h1 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h1><ol><li><p>简单(simple)模式</p><p> simple模式，是RabbitMQ几种模式中最简单的一种模式，其结构如下图所示：</p><p> <img src="/images/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E2%80%94%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89_2020-07-10-14-53-52.png" alt="消息中间件——RabbitMQ—工作模式（三）_2020-07-10-14-53-52.png"></p><p> 从上面的示意图，我们可以看出simple模式有以下几个特征：</p><ul><li>只有一个生产者、一个消费者和一个队列。</li><li>生产者和消费者在发送和接收消息时，只需要指定队列名，而不需要指定发送到哪个Exchange，RabbitMQ服务器会自动使用Virtual host的默认的Exchange，默认Exchange的type为direct。</li></ul></li><li><p>工作(work)模式</p><p> 在simple模式下只有一个生产者和消费者，当生产者生产消息的速度大于消费者的消费速度时，我们可以添加一个或多个消费者来加快消费速度，这种在simple模式下增加消费者的模式，称为work模式，如下图所示：</p><p> <img src="/images/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E2%80%94%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89_2020-07-10-14-54-11.png" alt="消息中间件——RabbitMQ—工作模式（三）_2020-07-10-14-54-11.png"></p><p> work模式有以下两个特征：</p><ul><li>可以有多个消费者，但一条消息只能被一个消费者获取。</li><li>发送到队列中的消息，由服务器平均分配给不同消费者进行消费。</li></ul></li><li><p>发布/订阅(pub/sub)模式</p><p> work模式可以将消息转到多个消费者，但每条消息只能由一个消费者获取，如果我们想一条消息可以同时给多个消费者消费呢？</p><p> 这时候就需要发布/订阅模式，其示意图如下所示：</p><p> <img src="/images/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E2%80%94%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89_2020-07-10-14-54-28.png" alt="消息中间件——RabbitMQ—工作模式（三）_2020-07-10-14-54-28.png"></p><p> 从上面的示意图我们可以看出来，在发布/订阅模式下，需要指定发送到哪个Exchange中，上面图中的X表示Exchange。<br> 发布/订阅模式中，Echange的type为fanout。</p><ul><li>生产者发送消息时，不需要指定具体的队列名，Exchange会将收到的消息转发到所绑定的队列。</li><li>消息被Exchange转到多个队列，一条消息可以被多个消费者获取。</li></ul></li><li><p>路由(routing)模式</p><p> 前面几种模式，消息的目标队列无法由生产者指定，而在路由模式下，消息的目标队列，可以由生产者指定，其示意图如下所示：</p><p> 从上面示意图，我们可以看出路由模式有以下特征：</p><p> <img src="/images/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E2%80%94%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89_2020-07-10-14-54-44.png" alt="消息中间件——RabbitMQ—工作模式（三）_2020-07-10-14-54-44.png"></p><ul><li><p>路由模式下Exchange的type为direct。</p></li><li><p>消息的目标队列可以由生产者按照routingKey规则指定。</p></li><li><p>一条消息队可以被多个消息者获取。只有RoutingKey与BidingKey相匹配的队列才会收到消息。</p><p>RoutingKey用于生产者指定Exchange最终将消息路由到哪个队列，BindingKey用于消费者绑定到某个队列。</p></li></ul></li><li><p>主题(topic)模式</p><p> 主题模式是在路由模式的基础上，将路由键和某模式进行匹配。其中#表示匹配多个词，*表示匹配一个词，消费者可以通过某种模式的BindKey来达到订阅某个主题消息的目的，如示意图如下所示：</p><p> <img src="/images/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E2%80%94%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89_2020-07-10-14-55-00.png" alt="消息中间件——RabbitMQ—工作模式（三）_2020-07-10-14-55-00.png"></p><ul><li>主题模式Exchange的type取值为topic。</li><li>一条消息可以被多个消费者获取。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件——RabbitMQ—介绍与安装（一）</title>
      <link href="/2020/07/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E2%80%94%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/07/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E2%80%94%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是RabbitMQ"><a href="#什么是RabbitMQ" class="headerlink" title="什么是RabbitMQ"></a>什么是RabbitMQ</h1><p>RabbitMQ是用Erlang语言开发的一个实现了AMQP协议的消息队列服务器。</p><p>相比其他同类型的消息队列，最大的特点在保证可观的单机吞吐量的同时，延时方面非常出色。</p><p>为什么要选择RabbitMQ？</p><ul><li>除了Qpid，RabbitMQ是唯一一个实现了AMQP标准的消息服务器；</li><li>可靠性，RabbitMQ的持久化支持，保证了消息的稳定性；</li><li>高并发，RabbitMQ使用了Erlang开发语言，Erlang是为电话交换机开发的语言，天生自带高并发光环，和高可用特性；</li><li>集群部署简单，正是因为Erlang使得RabbitMQ集群部署变得超级简单；</li><li>社区活跃度高，根据网上资料来看，RabbitMQ也是首选；</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="centos7"><a href="#centos7" class="headerlink" title="centos7"></a>centos7</h2><p>基础依赖安装:</p><p>如果你的操作系统是Linux的最小安装包，那么应该有很多基础的依赖包没有安装，在安装RabbitMQ之前，需要安装好这些基础依赖包，可以运行如下命令：</p><pre><code>$ sudo yum install openssql openssl-devel make gcc gcc-c++ kernel-devel</code></pre><p>安装Socat:</p><p>RabbitMQ依赖于Socat，因此在安装RabbitMQ前要安装Socat，如下：</p><pre><code>$ sudo yum install -y socat</code></pre><p>安装Erlang：</p><p>因为RabbitMQ是用Erlang语言开发，所以在安装RabbitMQ前，要先安装Erlang运行环境，我们使用Erlang语言的rpm<br>安装包。</p><pre><code># 下载$ wget https://github.com/rabbitmq/erlang-rpm/releases/download/v22.3/erlang-22.3-1.el7.x86_64.rpm# 安装$ rpm -ivh erlang-22.3-1.el7.x86_64.rpm</code></pre><p>安装RabbitMQ：</p><p>上面所说的依赖安装完成后，最后我们可以运行下面的命令安装RabbitMQ：</p><pre><code># 下载$ wget https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.3/rabbitmq-server-3.8.3-1.el7.noarch.rpm# 安装$ rpm -ivh rabbitmq-server-3.8.3-1.el7.noarch.rpm</code></pre><p>启动与关闭：</p><p>安装完成之后，可以使用rabbitmq-server命令启动服务器，如下：</p><pre><code># 直接启动$ sudo rabbitmq-server# -detached为可选参数，表示后台开启$ sudo rabbitmq-server -detached</code></pre><p>启动成功，输出如下：</p><p><img src="/images/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E2%80%94%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85%EF%BC%88%E4%B8%80%EF%BC%89_2020-07-10-13-34-58.png" alt="消息中间件——RabbitMQ—介绍与安装（一）_2020-07-10-13-34-58.png"></p><p>如果要关闭，则可以使用下面的命令：</p><pre><code>#关闭RabbitMQ服务：  $ sudo rabbitmqctl stop</code></pre><p>插件管理：</p><p>上面我们使用rabbitmq-server启动服务器，也可以使用rabbitmqctl命令管理服务器，包括创建交换机、队列、用户管理等操作，除了命令管理工具，RabbitMQ还提供了Web管理工具，而Web管理工具作为RabbitMQ的插件，如果要开启，可以使用下面的命令 ：</p><pre><code>rabbitmq-plugins是RabbitMQ管理插件的命令。$ sudo rabbitmq-plugins enable rabbitmq_management</code></pre><p>启动插件后，我们再启动服务器，最后一行显示运行了3个插件，如下：</p><p><img src="/images/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E2%80%94%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85%EF%BC%88%E4%B8%80%EF%BC%89_2020-07-10-13-37-49.png" alt="消息中间件——RabbitMQ—介绍与安装（一）_2020-07-10-13-37-49.png"></p><p>重新启动服务器后，可以打开浏览器访问RabbitMQ的Web管理界面，Web管理程序的端口号是15672，在浏览器中输入<a href="http://localhost:15672，即可以访问。" target="_blank" rel="noopener">http://localhost:15672，即可以访问。</a></p><p><img src="/images/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E2%80%94%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85%EF%BC%88%E4%B8%80%EF%BC%89_2020-07-10-13-39-03.png" alt="消息中间件——RabbitMQ—介绍与安装（一）_2020-07-10-13-39-03.png"></p><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><pre><code># 拉取镜像包docker pull rabbitmq:3.8.3-management# 启动镜像`docker run -d --name rabbitmq -p 5672:5672 -p 15672:15672 -v `pwd`/data:/var/lib/rabbitmq --hostname myRabbit -e RABBITMQ_DEFAULT_VHOST=my_vhost  -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin rabbitmq3.8.3-management</code></pre>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ 安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis——一对一、一对多、多对多（十一）</title>
      <link href="/2020/07/09/Mybatis%E2%80%94%E2%80%94%E4%B8%80%E5%AF%B9%E4%B8%80%E3%80%81%E4%B8%80%E5%AF%B9%E5%A4%9A%E3%80%81%E5%A4%9A%E5%AF%B9%E5%A4%9A%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/"/>
      <url>/2020/07/09/Mybatis%E2%80%94%E2%80%94%E4%B8%80%E5%AF%B9%E4%B8%80%E3%80%81%E4%B8%80%E5%AF%B9%E5%A4%9A%E3%80%81%E5%A4%9A%E5%AF%B9%E5%A4%9A%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>利用Mybatis实现一对一、一对多、多对多的数据模型。</p><h1 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h1><h2 id="statement"><a href="#statement" class="headerlink" title="statement"></a>statement</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 查询订单关联查询用户信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findOrdersUserResultMap"</span> <span class="attr">resultMap</span>=<span class="string">"OrdersUserResultMap"</span>&gt;</span></span><br><span class="line">    SELECT</span><br><span class="line">    orders.*,</span><br><span class="line">    user.username,</span><br><span class="line">    user.sex,</span><br><span class="line">    user.address</span><br><span class="line">    FROM</span><br><span class="line">    orders,</span><br><span class="line">    user</span><br><span class="line">    WHERE orders.user_id = user.id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 订单查询关联用户的resultMap</span></span><br><span class="line"><span class="comment">将整个查询的结果映射到com.iot.mybatis.po.Orders中</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.iot.mybatis.po.Orders"</span> <span class="attr">id</span>=<span class="string">"OrdersUserResultMap"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置映射的订单信息 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- id：指定查询列中的唯一标识，订单信息的中的唯 一标识，如果有多个列组成唯一标识，配置多个id</span></span><br><span class="line"><span class="comment">        column：订单信息的唯一标识列</span></span><br><span class="line"><span class="comment">        property：订单信息的唯一标识列所映射到Orders中哪个属性</span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"user_id"</span> <span class="attr">property</span>=<span class="string">"userId"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"number"</span> <span class="attr">property</span>=<span class="string">"number"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"createtime"</span> <span class="attr">property</span>=<span class="string">"createtime"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"note"</span> <span class="attr">property</span>=<span class="string">"note"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置映射的关联的用户信息 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- association：用于映射关联查询单个对象的信息</span></span><br><span class="line"><span class="comment">    property：要将关联查询的用户信息映射到Orders中哪个属性</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"user"</span>  <span class="attr">javaType</span>=<span class="string">"com.iot.mybatis.po.User"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- id：关联查询用户的唯 一标识</span></span><br><span class="line"><span class="comment">        column：指定唯 一标识用户信息的列</span></span><br><span class="line"><span class="comment">        javaType：映射到user的哪个属性</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"user_id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"username"</span> <span class="attr">property</span>=<span class="string">"username"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"sex"</span> <span class="attr">property</span>=<span class="string">"sex"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"address"</span> <span class="attr">property</span>=<span class="string">"address"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="pojo"><a href="#pojo" class="headerlink" title="pojo"></a>pojo</h2><p>在orders类中添加User属性</p><h2 id="mapper-java"><a href="#mapper-java" class="headerlink" title="mapper.java"></a>mapper.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询订单关联查询用户使用resultMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Orders&gt; <span class="title">findOrdersUserResultMap</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><h1 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h1><h2 id="statement-1"><a href="#statement-1" class="headerlink" title="statement"></a>statement</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 查询订单关联查询用户及订单明细，使用resultmap --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findOrdersAndOrderDetailResultMap"</span> <span class="attr">resultMap</span>=<span class="string">"OrdersAndOrderDetailResultMap"</span>&gt;</span></span><br><span class="line">   SELECT</span><br><span class="line">      orders.*,</span><br><span class="line">      user.username,</span><br><span class="line">      user.sex,</span><br><span class="line">      user.address,</span><br><span class="line">      orderdetail.id orderdetail_id,</span><br><span class="line">      orderdetail.items_id,</span><br><span class="line">      orderdetail.items_num,</span><br><span class="line">      orderdetail.orders_id</span><br><span class="line">    FROM</span><br><span class="line">      orders,</span><br><span class="line">      user,</span><br><span class="line">      orderdetail</span><br><span class="line">    WHERE orders.user_id = user.id AND orderdetail.orders_id=orders.id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="resultMap-1"><a href="#resultMap-1" class="headerlink" title="resultMap"></a>resultMap</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 订单及订单明细的resultMap</span></span><br><span class="line"><span class="comment">使用extends继承，不用在中配置订单信息和用户信息的映射</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.iot.mybatis.po.Orders"</span> <span class="attr">id</span>=<span class="string">"OrdersAndOrderDetailResultMap"</span> <span class="attr">extends</span>=<span class="string">"OrdersUserResultMap"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 订单信息 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 用户信息 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用extends继承，不用在中配置订单信息和用户信息的映射 --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 订单明细信息</span></span><br><span class="line"><span class="comment">    一个订单关联查询出了多条明细，要使用collection进行映射</span></span><br><span class="line"><span class="comment">    collection：对关联查询到多条记录映射到集合对象中</span></span><br><span class="line"><span class="comment">    property：将关联查询到多条记录映射到com.iot.mybatis.po.Orders哪个属性</span></span><br><span class="line"><span class="comment">    ofType：指定映射到list集合属性中pojo的类型</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"orderdetails"</span> <span class="attr">ofType</span>=<span class="string">"com.iot.mybatis.po.Orderdetail"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- id：订单明细唯 一标识</span></span><br><span class="line"><span class="comment">        property:要将订单明细的唯 一标识 映射到com.iot.mybatis.po.Orderdetail的哪个属性</span></span><br><span class="line"><span class="comment">          --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"orderdetail_id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"items_id"</span> <span class="attr">property</span>=<span class="string">"itemsId"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"items_num"</span> <span class="attr">property</span>=<span class="string">"itemsNum"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"orders_id"</span> <span class="attr">property</span>=<span class="string">"ordersId"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="pojo-1"><a href="#pojo-1" class="headerlink" title="pojo"></a>pojo</h1><p>在orders中添加list订单明细属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//订单明细</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Orderdetail&gt; orderdetails;</span><br></pre></td></tr></table></figure><h1 id="mapper-java-1"><a href="#mapper-java-1" class="headerlink" title="mapper.java"></a>mapper.java</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询订单(关联用户)及订单明细</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Orders&gt;  <span class="title">findOrdersAndOrderDetailResultMap</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><h1 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h1><h2 id="statement-2"><a href="#statement-2" class="headerlink" title="statement"></a>statement</h2><!-- 查询用户及购买的商品信息，使用resultmap --><select id="findUserAndItemsResultMap" resultMap="UserAndItemsResultMap">   SELECT      orders.*,      user.username,      user.sex,      user.address,      orderdetail.id orderdetail_id,      orderdetail.items_id,      orderdetail.items_num,      orderdetail.orders_id,      items.name items_name,      items.detail items_detail,      items.price items_price    FROM      orders,      user,      orderdetail,      items    WHERE orders.user_id = user.id AND orderdetail.orders_id=orders.id AND orderdetail.items_id = items.id</select><h2 id="映射思路"><a href="#映射思路" class="headerlink" title="映射思路"></a>映射思路</h2><p>在user类中添加订单列表属性List<Orders> orderslist，将用户创建的订单映射到orderslist</p><p>在Orders中添加订单明细列表属性List<OrderDetail>orderdetials，将订单的明细映射到orderdetials</p><p>在OrderDetail中添加Items属性，将订单明细所对应的商品映射到Items</p><h2 id="resultMap-2"><a href="#resultMap-2" class="headerlink" title="resultMap"></a>resultMap</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 查询用户及购买的商品 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.iot.mybatis.po.User"</span> <span class="attr">id</span>=<span class="string">"UserAndItemsResultMap"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 用户信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"user_id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"username"</span> <span class="attr">property</span>=<span class="string">"username"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"sex"</span> <span class="attr">property</span>=<span class="string">"sex"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"address"</span> <span class="attr">property</span>=<span class="string">"address"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 订单信息</span></span><br><span class="line"><span class="comment">    一个用户对应多个订单，使用collection映射</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"ordersList"</span> <span class="attr">ofType</span>=<span class="string">"com.iot.mybatis.po.Orders"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"user_id"</span> <span class="attr">property</span>=<span class="string">"userId"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"number"</span> <span class="attr">property</span>=<span class="string">"number"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"createtime"</span> <span class="attr">property</span>=<span class="string">"createtime"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"note"</span> <span class="attr">property</span>=<span class="string">"note"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 订单明细</span></span><br><span class="line"><span class="comment">         一个订单包括 多个明细</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"orderdetails"</span> <span class="attr">ofType</span>=<span class="string">"com.iot.mybatis.po.Orderdetail"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"orderdetail_id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"items_id"</span> <span class="attr">property</span>=<span class="string">"itemsId"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"items_num"</span> <span class="attr">property</span>=<span class="string">"itemsNum"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"orders_id"</span> <span class="attr">property</span>=<span class="string">"ordersId"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 商品信息</span></span><br><span class="line"><span class="comment">             一个订单明细对应一个商品</span></span><br><span class="line"><span class="comment">             --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"items"</span> <span class="attr">javaType</span>=<span class="string">"com.iot.mybatis.po.Items"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"items_id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"items_name"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"items_detail"</span> <span class="attr">property</span>=<span class="string">"detail"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"items_price"</span> <span class="attr">property</span>=<span class="string">"price"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="mapper-java-2"><a href="#mapper-java-2" class="headerlink" title="mapper.java"></a>mapper.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询用户购买商品信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt;  <span class="title">findUserAndItemsResultMap</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis 数据模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis——整合Encache（十）</title>
      <link href="/2020/07/09/Mybatis%E2%80%94%E2%80%94%E6%95%B4%E5%90%88Encache%EF%BC%88%E5%8D%81%EF%BC%89/"/>
      <url>/2020/07/09/Mybatis%E2%80%94%E2%80%94%E6%95%B4%E5%90%88Encache%EF%BC%88%E5%8D%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Mybatis无法实现分布式缓存，需要与其他分布式框架进行整合。如 Enchache</p><h1 id="开启二级缓存"><a href="#开启二级缓存" class="headerlink" title="开启二级缓存"></a>开启二级缓存</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 全局配置参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启二级缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="导入相关jar包"><a href="#导入相关jar包" class="headerlink" title="导入相关jar包"></a>导入相关jar包</h1><p><img src="/images/Mybatis%E2%80%94%E2%80%94%E6%95%B4%E5%90%88Encache%EF%BC%88%E5%8D%81%EF%BC%89_2020-07-09-16-03-41.png" alt="Mybatis——整合Encache（十）_2020-07-09-16-03-41.png"></p><h1 id="mapper-xml-配置encache"><a href="#mapper-xml-配置encache" class="headerlink" title="mapper.xml 配置encache"></a>mapper.xml 配置encache</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  开启本mapper的namespace下的二级缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">"org.mybatis.caches.ehcache.EhcacheCache"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h1 id="在classpath下加入ehcache-xml配置文件"><a href="#在classpath下加入ehcache-xml配置文件" class="headerlink" title="在classpath下加入ehcache.xml配置文件"></a>在classpath下加入ehcache.xml配置文件</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">"../config/ehcache.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">"F:\develop\ehcache"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">maxElementsInMemory</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">maxElementsOnDisk</span>=<span class="string">"10000000"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">eternal</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">overflowToDisk</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">timeToIdleSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">timeToLiveSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">"LRU"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis Encache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis——缓存（九）</title>
      <link href="/2020/07/09/Mybatis%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
      <url>/2020/07/09/Mybatis%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98%EF%BC%88%E4%B9%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>mybatis提供查询缓存，用于减轻数据压力，提高数据库性能。<br>mybaits提供一级缓存，和二级缓存。</p><h1 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h1><p>一级缓存默认开启。</p><p>一级缓存是SqlSession级别的缓存。在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构（HashMap）用于存储缓存数据。不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的。</p><h1 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h1><p>首先开启mybatis的二级缓存.</p><ol><li><p>在核心配置文件SqlMapConfig.xml中加入<setting name="cacheEnabled" value="true"/></p></li><li><p>在UserMapper.xml中开启二缓存，UserMapper.xml下的sql执行完成会存储到它的缓存区域（HashMap</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.iot.mybatis.mapper.UserMapper"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启本mapper的namespace下的二级缓存--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。</p><p>每一个namespace的mapper都有一个二缓存区域。</p><h1 id="局限性和分布式问题"><a href="#局限性和分布式问题" class="headerlink" title="局限性和分布式问题"></a>局限性和分布式问题</h1><ol><li><p>局限性</p><p> mybatis二级缓存对细粒度的数据级别的缓存实现不好。</p><p> 比如如下需求：对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次都能查询最新的商品信息，此时如果使用mybatis的二级缓存就无法实现当一个商品变化时只刷新该商品的缓存信息而不刷新其它商品的信息，因为mybaits的二级缓存区域以mapper为单位划分，当一个商品信息变化会将所有商品信息的缓存数据全部清空。解决此类问题需要在业务层根据需求对数据有针对性缓存。</p></li><li><p>分布式问题</p><p> 无论是一级缓存还是二级缓存，都是本地缓存，对分布式来说，都很难保持一致性，所以分布式环境下，最好不使用Mybatis的缓存，或者使用EnChache等分布式缓存框架，搭建分布式缓存。</p><p> 一级缓存默认打开，且截至目前我们无法关闭，我们可以有两种方式解决这个问题：</p><ul><li>可以设置Mybatis一级缓存为STATEMENT级别，因为在查询方法执行的最后，会判断一级缓存级别是否是STATEMENT级别，如果是的话，就清空缓存。</li><li>select标签里面设置flushCache=”true”即可</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis——延迟加载（八）</title>
      <link href="/2020/07/09/Mybatis%E2%80%94%E2%80%94%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%88%E5%85%AB%EF%BC%89/"/>
      <url>/2020/07/09/Mybatis%E2%80%94%E2%80%94%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%88%E5%85%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>resultMap可以实现高级映射（使用association、collection实现一对一及一对多映射），association、collection具备延迟加载功能。</p><p>延迟加载：先从单表查询、需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速度要快。</p><h1 id="使用association实现延迟加载"><a href="#使用association实现延迟加载" class="headerlink" title="使用association实现延迟加载"></a>使用association实现延迟加载</h1><p>mybatis默认没有开启延迟加载，需要在SqlMapConfig.xml中setting配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 打开延迟加载 的开关 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将积极加载改为消极加载即按需要加载 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"aggressiveLazyLoading"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启二级缓存 --&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- &lt;setting name="cacheEnabled" value="true"/&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>1.只查询订单信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findOrdersUserLazyLoading"</span> <span class="attr">resultMap</span>=<span class="string">"OrdersUserLazyLoadingResultMap"</span>&gt;</span></span><br><span class="line">    SELECT * FROM orders</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span>1234</span><br></pre></td></tr></table></figure><p>2.关联查询用户信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"com.iot.mybatis.po.User"</span>&gt;</span></span><br><span class="line">    SELECT * FROM  user  WHERE id=#&#123;value&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上边先去执行findOrdersUserLazyLoading，当需要去查询用户的时候再去执行findUserById，通过resultMap的定义将延迟加载执行配置起来。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 延迟加载的resultMap --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.iot.mybatis.po.Orders"</span> <span class="attr">id</span>=<span class="string">"OrdersUserLazyLoadingResultMap"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--对订单信息进行映射配置  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"user_id"</span> <span class="attr">property</span>=<span class="string">"userId"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"number"</span> <span class="attr">property</span>=<span class="string">"number"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"createtime"</span> <span class="attr">property</span>=<span class="string">"createtime"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"note"</span> <span class="attr">property</span>=<span class="string">"note"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 实现对用户信息进行延迟加载</span></span><br><span class="line"><span class="comment">    select：指定延迟加载需要执行的statement的id（是根据user_id查询用户信息的statement）</span></span><br><span class="line"><span class="comment">    要使用userMapper.xml中findUserById完成根据用户id(user_id)用户信息的查询，如果findUserById不在本mapper中需要前边加namespace</span></span><br><span class="line"><span class="comment">    column：订单信息中关联用户信息查询的列，是user_id</span></span><br><span class="line"><span class="comment">    关联查询的sql理解为：</span></span><br><span class="line"><span class="comment">    SELECT orders.*,</span></span><br><span class="line"><span class="comment">    (SELECT username FROM USER WHERE orders.user_id = user.id)username,</span></span><br><span class="line"><span class="comment">    (SELECT sex FROM USER WHERE orders.user_id = user.id)sex</span></span><br><span class="line"><span class="comment">     FROM orders</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"user"</span>  <span class="attr">javaType</span>=<span class="string">"com.iot.mybatis.po.User"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">select</span>=<span class="string">"com.iot.mybatis.mapper.UserMapper.findUserById"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">column</span>=<span class="string">"user_id"</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 实现对用户信息进行延迟加载 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>mapper.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询订单关联查询用户，用户信息是延迟加载</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Orders&gt; <span class="title">findOrdersUserLazyLoading</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><p>Order类里封装User信息。</p><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询订单关联查询用户，用户信息使用延迟加载</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindOrdersUserLazyLoading</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();<span class="comment">// 创建代理对象</span></span><br><span class="line">    OrdersMapperCustom ordersMapperCustom = sqlSession</span><br><span class="line">            .getMapper(OrdersMapperCustom<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 查询订单信息（单表）</span></span><br><span class="line">    List&lt;Orders&gt; list = ordersMapperCustom.findOrdersUserLazyLoading();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历上边的订单列表</span></span><br><span class="line">    <span class="keyword">for</span> (Orders orders : list) &#123;</span><br><span class="line">        <span class="comment">// 执行getUser()去查询用户信息，这里实现按需加载</span></span><br><span class="line">        User user = orders.getUser();</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis 延迟加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis——动态sql（七）</title>
      <link href="/2020/07/09/Mybatis%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81sql%EF%BC%88%E4%B8%83%EF%BC%89/"/>
      <url>/2020/07/09/Mybatis%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81sql%EF%BC%88%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>动态sql:</p><ul><li>if判断</li><li>sql片段重点</li><li>foreach标签</li></ul><h1 id="if-判断"><a href="#if-判断" class="headerlink" title="if 判断"></a>if 判断</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 用户信息综合查询</span></span><br><span class="line"><span class="comment">    #&#123;userCustom.sex&#125;:取出pojo包装对象中性别值</span></span><br><span class="line"><span class="comment">    $&#123;userCustom.username&#125;：取出pojo包装对象中用户名称</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserList"</span> <span class="attr">parameterType</span>=<span class="string">"com.iot.mybatis.po.UserQueryVo"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">resultType</span>=<span class="string">"com.iot.mybatis.po.UserCustom"</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    <span class="comment">&lt;!--  where 可以自动去掉条件中的第一个and --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userCustom!=null"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userCustom.sex!=null and userCustom.sex != '' "</span>&gt;</span></span><br><span class="line">               AND user.sex=#&#123;userCustom.sex&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userCustom.username!=null and userCustom.username != '' "</span>&gt;</span></span><br><span class="line">               AND user.username LIKE '%$&#123;userCustom.username&#125;%'</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用户信息综合查询总数</span></span><br><span class="line"><span class="comment">    parameterType：指定输入类型和findUserList一样</span></span><br><span class="line"><span class="comment">    resultType：输出结果类型</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserCount"</span> <span class="attr">parameterType</span>=<span class="string">"com.iot.mybatis.po.UserQueryVo"</span> <span class="attr">resultType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">    SELECT count(*) FROM user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userCustom!=null"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userCustom.sex!=null and userCustom.sex != '' "</span>&gt;</span></span><br><span class="line">                AND user.sex=#&#123;userCustom.sex&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userCustom.username!=null and userCustom.username != '' "</span>&gt;</span></span><br><span class="line">                AND user.username LIKE '%$&#123;userCustom.username&#125;%'</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="sql片段-重点"><a href="#sql片段-重点" class="headerlink" title="sql片段(重点)"></a>sql片段(重点)</h1><p>将上边实现的动态sql判断代码块抽取出来，组成一个sql片段。其它的statement中就可以引用sql片段。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义sql片段</span></span><br><span class="line"><span class="comment">id：sql片段的唯 一标识</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">经验：是基于单表来定义sql片段，这样话这个sql片段可重用性才高</span></span><br><span class="line"><span class="comment">在sql片段中不要包括 where</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"query_user_where"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userCustom!=null"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userCustom.sex!=null and userCustom.sex!=''"</span>&gt;</span></span><br><span class="line">            AND user.sex = #&#123;userCustom.sex&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userCustom.username!=null and userCustom.username!=''"</span>&gt;</span></span><br><span class="line">            AND user.username LIKE '%$&#123;userCustom.username&#125;%'</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引用sql片段：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 用户信息综合查询</span></span><br><span class="line"><span class="comment">    #&#123;userCustom.sex&#125;:取出pojo包装对象中性别值</span></span><br><span class="line"><span class="comment">    $&#123;userCustom.username&#125;：取出pojo包装对象中用户名称</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserList"</span> <span class="attr">parameterType</span>=<span class="string">"com.iot.mybatis.po.UserQueryVo"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">resultType</span>=<span class="string">"com.iot.mybatis.po.UserCustom"</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    <span class="comment">&lt;!--  where 可以自动去掉条件中的第一个and --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 引用sql片段 的id，如果refid指定的id不在本mapper文件中，需要前边加namespace --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"query_user_where"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 在这里还要引用其它的sql片段  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="foreach标签"><a href="#foreach标签" class="headerlink" title="foreach标签"></a>foreach标签</h2><p>向sql传递数组或List，mybatis使用foreach解析</p><p>在用户查询列表和查询总数的statement中增加多个id输入查询。两种方法，sql语句如下：</p><pre><code>SELECT * FROM USER WHERE id=1 OR id=10 OR id=16SELECT * FROM USER WHERE id IN(1,10,16)</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">if</span> test=<span class="string">"ids!=null"</span>&gt;</span><br><span class="line">    &lt;!-- 使用 foreach遍历传入ids</span><br><span class="line">    collection：指定输入 对象中集合属性</span><br><span class="line">    item：每个遍历生成对象中</span><br><span class="line">    open：开始遍历时拼接的串</span><br><span class="line">    close：结束遍历时拼接的串</span><br><span class="line">    separator：遍历的两个对象中需要拼接的串</span><br><span class="line">     --&gt;</span><br><span class="line">    &lt;!-- 使用实现下边的sql拼接：</span><br><span class="line">     AND (id=<span class="number">1</span> OR id=<span class="number">10</span> OR id=<span class="number">16</span>)</span><br><span class="line">     --&gt;</span><br><span class="line">    &lt;foreach collection=<span class="string">"ids"</span> item=<span class="string">"user_id"</span> open=<span class="string">"AND ("</span> close=<span class="string">")"</span> separator=<span class="string">"or"</span>&gt;</span><br><span class="line">        &lt;!-- 每个遍历需要拼接的串 --&gt;</span><br><span class="line">        id=#&#123;user_id&#125;</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 实现  “ <span class="function">and id <span class="title">IN</span><span class="params">(<span class="number">1</span>,<span class="number">10</span>,<span class="number">16</span>)</span>”拼接 --&gt;</span></span><br><span class="line"><span class="function">    &lt;!-- &lt;foreach collection</span>=<span class="string">"ids"</span> item=<span class="string">"user_id"</span> open=<span class="string">"and id IN("</span> close=<span class="string">")"</span> separator=<span class="string">","</span>&gt;</span><br><span class="line">        每个遍历需要拼接的串</span><br><span class="line">        #&#123;user_id&#125;</span><br><span class="line">    &lt;/foreach&gt; --&gt;</span><br><span class="line">&lt;/if&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis 动态sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis——映射（六）</title>
      <link href="/2020/07/09/Mybatis%E2%80%94%E2%80%94%E6%98%A0%E5%B0%84%EF%BC%88%E5%85%AD%EF%BC%89/"/>
      <url>/2020/07/09/Mybatis%E2%80%94%E2%80%94%E6%98%A0%E5%B0%84%EF%BC%88%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>映射主要是指定输入输出类型，类型可以是</p><ul><li>简单类型</li><li>hashmap</li><li>pojo的包装类型</li></ul><h1 id="输入映射"><a href="#输入映射" class="headerlink" title="输入映射"></a>输入映射</h1><p>主要介绍pojo包装对象</p><p>查询条件可能是综合的查询条件，不仅包括用户查询条件还包括其它的查询条件（比如查询用户信息的时候，将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。</p><h2 id="包装类型pojo"><a href="#包装类型pojo" class="headerlink" title="包装类型pojo"></a>包装类型pojo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iot.mybatis.po;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Brian on 2016/2/24.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryVo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在这里包装所需要的查询条件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用户查询条件</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以包装其它的查询条件，订单、商品</span></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sql语句"><a href="#sql语句" class="headerlink" title="sql语句"></a>sql语句</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryUserByQueryVo"</span> <span class="attr">parameterType</span>=<span class="string">"QueryVo"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">resultType</span>=<span class="string">"com.wisedu.mybatis.pojo.User"</span>&gt;</span></span><br><span class="line">    SELECT * FROM `user` WHERE username LIKE "%"#&#123;user.username&#125;"%" <span class="comment">&lt;!-- user对象被封装在QueryVo中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="mapper接口"><a href="#mapper接口" class="headerlink" title="mapper接口"></a>mapper接口</h2><p>public List<User> queryUserByQueryVo(QueryVo vo);</p><h1 id="输出映射"><a href="#输出映射" class="headerlink" title="输出映射"></a>输出映射</h1><p>输出映射有两种方式：</p><ul><li>resultType</li><li>resultMap</li></ul><h2 id="resultType"><a href="#resultType" class="headerlink" title="resultType"></a>resultType</h2><p>输出pojo对象和pojo列表:</p><p>不管是输出的pojo单个对象还是一个列表（list中包括pojo），在mapper.xml中resultType指定的类型是一样的。</p><p>在mapper.java指定的方法返回值类型不一样：</p><p>输出单个pojo对象，方法返回值是单个对象类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据id查询用户信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception</span>;<span class="number">12</span></span><br></pre></td></tr></table></figure><p>输出pojo对象list，方法返回值是List</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据用户名列查询用户列表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUserByName</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><h2 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h2><p>如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap对列名和pojo属性名之间作一个映射关系。</p><ol><li>定义reusltMap</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义resultMap</span></span><br><span class="line"><span class="comment">    将SELECT id id_,username username_ FROM USER 和User类中的属性作一个映射关系</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    type：resultMap最终映射的java对象类型,可以使用别名</span></span><br><span class="line"><span class="comment">    id：对resultMap的唯一标识</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"user"</span> <span class="attr">id</span>=<span class="string">"userResultMap"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- id表示查询结果集中唯一标识 </span></span><br><span class="line"><span class="comment">        column：查询出来的列名</span></span><br><span class="line"><span class="comment">        property：type指定的pojo类型中的属性名</span></span><br><span class="line"><span class="comment">        最终resultMap对column和property作一个映射关系 （对应关系）</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id_"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">        result：对普通名映射定义</span></span><br><span class="line"><span class="comment">        column：查询出来的列名</span></span><br><span class="line"><span class="comment">        property：type指定的pojo类型中的属性名</span></span><br><span class="line"><span class="comment">        最终resultMap对column和property作一个映射关系 （对应关系）</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"username_"</span> <span class="attr">property</span>=<span class="string">"username"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用resultMap作为statement的输出映射类型</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用resultMap进行输出映射</span></span><br><span class="line"><span class="comment">        resultMap：指定定义的resultMap的id，如果这个resultMap在其它的mapper文件，前边需要加namespace</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserByIdResultMap"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"userResultMap"</span>&gt;</span></span><br><span class="line">        SELECT id id_,username username_ FROM USER WHERE id=#&#123;value&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用resultType进行输出映射，只有查询出来的列名和pojo中的属性名一致，该列才可以映射成功。</p><p>如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap对列名和pojo属性名之间作一个映射关系。</p><p>resultMap可以实现懒加载。</p>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis 映射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis——配置（五）</title>
      <link href="/2020/07/09/Mybatis%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2020/07/09/Mybatis%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>SqlMapConfig.xml中配置的内容和顺序如下</p><ul><li>properties（属性）</li><li>settings（全局配置参数）</li><li>typeAliases（类型别名）</li><li>typeHandlers（类型处理器）</li><li>objectFactory（对象工厂）</li><li>plugins（插件）</li><li>environments（环境集合属性对象） </li><li>environment（环境子属性对象） </li><li>transactionManager（事务管理）</li><li>dataSource（数据源）</li><li>mappers（映射器）</li></ul><h1 id="properties-属性"><a href="#properties-属性" class="headerlink" title="properties(属性)"></a>properties(属性)</h1><p>将数据库连接参数单独配置在db.properties中，只需要在SqlMapConfig.xml中加载db.properties的属性值。在SqlMapConfig.xml中就不需要对数据库连接参数硬编码。</p><h1 id="settings-全局参数配置"><a href="#settings-全局参数配置" class="headerlink" title="settings(全局参数配置)"></a>settings(全局参数配置)</h1><p>mybatis框架在运行时可以调整一些运行参数,比如：开启二级缓存、开启延迟加载…</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"multipleResultSetsEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"useColumnLabel"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"useGeneratedKeys"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"autoMappingBehavior"</span> <span class="attr">value</span>=<span class="string">"PARTIAL"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"autoMappingUnknownColumnBehavior"</span> <span class="attr">value</span>=<span class="string">"WARNING"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"defaultExecutorType"</span> <span class="attr">value</span>=<span class="string">"SIMPLE"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"defaultStatementTimeout"</span> <span class="attr">value</span>=<span class="string">"25"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"defaultFetchSize"</span> <span class="attr">value</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"safeRowBoundsEnabled"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"mapUnderscoreToCamelCase"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"localCacheScope"</span> <span class="attr">value</span>=<span class="string">"SESSION"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"jdbcTypeForNull"</span> <span class="attr">value</span>=<span class="string">"OTHER"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadTriggerMethods"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">value</span>=<span class="string">"equals,clone,hashCode,toString"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="typeAliases-类型别名"><a href="#typeAliases-类型别名" class="headerlink" title="typeAliases(类型别名)"></a>typeAliases(类型别名)</h1><p>如果在指定类型时输入类型全路径，不方便进行开发，可以针对parameterType或resultType指定的类型定义一些别名，在mapper.xml中通过别名定义，方便开发。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 别名定义 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 针对单个别名定义</span></span><br><span class="line"><span class="comment">    type：类型的路径</span></span><br><span class="line"><span class="comment">    alias：别名</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;typeAlias type="cn.itcast.mybatis.po.User" alias="user"/&gt; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 批量别名定义</span></span><br><span class="line"><span class="comment">    指定包名，mybatis自动扫描包中的po类，自动定义别名，别名就是类名（首字母大写或小写都可以）</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.iot.mybatis.po"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="typeHandlers-类型处理器"><a href="#typeHandlers-类型处理器" class="headerlink" title="typeHandlers(类型处理器)"></a>typeHandlers(类型处理器)</h1><p>mybatis中通过typeHandlers完成jdbc类型和java类型的转换。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">        select * from user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>mybatis自带的类型处理器基本上满足日常需求，不需要单独定义。</p><h1 id="mappers-映射配置"><a href="#mappers-映射配置" class="headerlink" title="mappers(映射配置)"></a>mappers(映射配置)</h1><p>通过resource加载单个映射文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--通过resource方法一次加载一个映射文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"mapper/UserMapper.xml"</span>/&gt;</span>12</span><br></pre></td></tr></table></figure><p>通过mapper接口加载单个mapper</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过mapper接口加载单个 映射文件</span></span><br><span class="line"><span class="comment">        遵循一些规范：需要将mapper接口类名和mapper.xml映射文件名称保持一致，且在一个目录中</span></span><br><span class="line"><span class="comment">        上边规范的前提是：使用的是mapper代理方法</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"com.iot.mybatis.mapper.UserMapper"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>批量加载mapper(推荐使用)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 批量加载mapper</span></span><br><span class="line"><span class="comment">        指定mapper接口的包名，mybatis自动扫描包下边所有mapper接口进行加载</span></span><br><span class="line"><span class="comment">        遵循一些规范：需要将mapper接口类名和mapper.xml映射文件名称保持一致，且在一个目录 中</span></span><br><span class="line"><span class="comment">        上边规范的前提是：使用的是mapper代理方法</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.iot.mybatis.mapper"</span>/&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis——mapper代理方法（三）</title>
      <link href="/2020/07/09/Mybatis%E2%80%94%E2%80%94mapper%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2020/07/09/Mybatis%E2%80%94%E2%80%94mapper%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>程序员只需要编写mapper.xml映射文件，编写mapper接口（相当 于dao接口），程序员编写mapper接口需要遵循一些开发规范，mybatis可以自动生成mapper接口实现类代理对象。</p><h1 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h1><p>在mapper.xml中namespace等于mapper接口地址</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> namespace 命名空间，作用就是对sql进行分类化管理,理解为sql隔离</span></span><br><span class="line"><span class="comment"> 注意：使用mapper代理方法开发，namespace有特殊重要的作用,namespace等于mapper接口地址</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.iot.mybatis.mapper.UserMapper"</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>mapper.java接口中的方法名和mapper.xml中statement的id一致</li><li>mapper.java接口中的方法输入参数类型和mapper.xml中statement的parameterType指定的类型一致。</li><li>mapper.java接口中的方法返回值类型和mapper.xml中statement的resultType指定的类型一致。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"com.iot.mybatis.po.User"</span>&gt;</span></span><br><span class="line">    SELECT * FROM  user  WHERE id=#&#123;value&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span>123</span><br></pre></td></tr></table></figure><pre><code>//根据id查询用户信息public User findUserById(int id) throws Exception;12</code></pre><p>总结：以上开发规范主要是对下边的代码进行统一生成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User user = sqlSession.selectOne(<span class="string">"test.findUserById"</span>, id);</span><br><span class="line">sqlSession.insert(<span class="string">"test.insertUser"</span>, user);</span><br></pre></td></tr></table></figure><h1 id="mapper-xml"><a href="#mapper-xml" class="headerlink" title="mapper.xml"></a>mapper.xml</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> namespace 命名空间，作用就是对sql进行分类化管理,理解为sql隔离</span></span><br><span class="line"><span class="comment"> 注意：使用mapper代理方法开发，namespace有特殊重要的作用</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.iot.mybatis.mapper.UserMapper"</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 在映射文件中配置很多sql语句 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--需求:通过id查询用户表的记录 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过select执行数据库查询</span></span><br><span class="line"><span class="comment">     id:标识映射文件中的sql，称为statement的id</span></span><br><span class="line"><span class="comment">     将sql语句封装到mappedStatement对象中，所以将id称为statement的id</span></span><br><span class="line"><span class="comment">     parameterType:指定输入参数的类型</span></span><br><span class="line"><span class="comment">     #&#123;&#125;标示一个占位符,</span></span><br><span class="line"><span class="comment">     #&#123;value&#125;其中value表示接收输入参数的名称，如果输入参数是简单类型，那么#&#123;&#125;中的值可以任意。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     resultType：指定sql输出结果的映射的java对象类型，select指定resultType表示将单条记录映射成java对象</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"com.iot.mybatis.po.User"</span>&gt;</span></span><br><span class="line">        SELECT * FROM  user  WHERE id=#&#123;value&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 根据用户名称模糊查询用户信息，可能返回多条</span></span><br><span class="line"><span class="comment">    resultType：指定就是单条记录所映射的java对象类型</span></span><br><span class="line"><span class="comment">    $&#123;&#125;:表示拼接sql串，将接收到参数的内容不加任何修饰拼接在sql中。</span></span><br><span class="line"><span class="comment">    使用$&#123;&#125;拼接sql，引起 sql注入</span></span><br><span class="line"><span class="comment">    $&#123;value&#125;：接收输入参数的内容，如果传入类型是简单类型，$&#123;&#125;中只能使用value</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserByName"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.String"</span> <span class="attr">resultType</span>=<span class="string">"com.iot.mybatis.po.User"</span>&gt;</span></span><br><span class="line">        SELECT * FROM user WHERE username LIKE '%$&#123;value&#125;%'</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 添加用户</span></span><br><span class="line"><span class="comment">        parameterType：指定输入 参数类型是pojo（包括 用户信息）</span></span><br><span class="line"><span class="comment">        #&#123;&#125;中指定pojo的属性名，接收到pojo对象的属性值，mybatis通过OGNL获取对象的属性值</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertUser"</span> <span class="attr">parameterType</span>=<span class="string">"com.iot.mybatis.po.User"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">         将插入数据的主键返回，返回到user对象中</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         SELECT LAST_INSERT_ID()：得到刚insert进去记录的主键值，只适用与自增主键</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         keyProperty：将查询到主键值设置到parameterType指定的对象的哪个属性</span></span><br><span class="line"><span class="comment">         order：SELECT LAST_INSERT_ID()执行顺序，相对于insert语句来说它的执行顺序</span></span><br><span class="line"><span class="comment">         resultType：指定SELECT LAST_INSERT_ID()的结果类型</span></span><br><span class="line"><span class="comment">          --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">order</span>=<span class="string">"AFTER"</span> <span class="attr">resultType</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></span><br><span class="line">          SELECT LAST_INSERT_ID()</span><br><span class="line">        <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">        INSERT INTO user (username,birthday,sex,address)values (#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)</span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            使用mysql的uuid（）生成主键</span></span><br><span class="line"><span class="comment">            执行过程：</span></span><br><span class="line"><span class="comment">            首先通过uuid()得到主键，将主键设置到user对象的id属性中</span></span><br><span class="line"><span class="comment">            其次在insert执行时，从user对象中取出id属性值</span></span><br><span class="line"><span class="comment">             --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  &lt;selectKey keyProperty="id" order="BEFORE" resultType="java.lang.String"&gt;</span></span><br><span class="line"><span class="comment">            SELECT uuid()</span></span><br><span class="line"><span class="comment">        &lt;/selectKey&gt;</span></span><br><span class="line"><span class="comment">        insert into user(id,username,birthday,sex,address) value(#&#123;id&#125;,#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;) --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 删除 用户</span></span><br><span class="line"><span class="comment">        根据id删除用户，需要输入 id值</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteUser"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></span><br><span class="line">        delete from user where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 根据id更新用户</span></span><br><span class="line"><span class="comment">    分析：</span></span><br><span class="line"><span class="comment">    需要传入用户的id</span></span><br><span class="line"><span class="comment">    需要传入用户的更新信息</span></span><br><span class="line"><span class="comment">    parameterType指定user对象，包括 id和更新信息，注意：id必须存在</span></span><br><span class="line"><span class="comment">    #&#123;id&#125;：从输入 user对象中获取id属性值</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateUser"</span> <span class="attr">parameterType</span>=<span class="string">"com.iot.mybatis.po.User"</span>&gt;</span></span><br><span class="line">        update user set username=#&#123;username&#125;,birthday=#&#123;birthday&#125;,sex=#&#123;sex&#125;,address=#&#123;address&#125;</span><br><span class="line">        where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="SqlMapConfig-xml"><a href="#SqlMapConfig-xml" class="headerlink" title="SqlMapConfig.xml"></a>SqlMapConfig.xml</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"mapper/UserMapper.xml"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="UserMapper-java"><a href="#UserMapper-java" class="headerlink" title="UserMapper.java"></a>UserMapper.java</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据id查询用户信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据用户名列查询用户列表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUserByName</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加用户信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除用户信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新用户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(User user)</span><span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperTest</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//注解Before是在执行本类所有测试方法之前先调用这个方法  </span></span><br><span class="line">    <span class="meta">@Before</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;  </span><br><span class="line">        <span class="comment">//创建SqlSessionFactory  </span></span><br><span class="line">        String resource=<span class="string">"SqlMapConfig.xml"</span>;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//将配置文件加载成流  </span></span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);  </span><br><span class="line">        <span class="comment">//创建会话工厂，传入mybatis配置文件的信息  </span></span><br><span class="line">        sqlSessionFactory=<span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindUserById</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;  </span><br><span class="line"></span><br><span class="line">        SqlSession sqlSession=sqlSessionFactory.openSession();  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建UserMapper代理对象  </span></span><br><span class="line">        UserMapper userMapper=sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用userMapper的方法  </span></span><br><span class="line">        User user=userMapper.findUserById(<span class="number">1</span>);  </span><br><span class="line"></span><br><span class="line">        System.out.println(user.getUsername());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Myabatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis mapper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis——开发Dao方法（二）</title>
      <link href="/2020/07/08/Mybatis%E2%80%94%E2%80%94%E5%BC%80%E5%8F%91Dao%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/07/08/Mybatis%E2%80%94%E2%80%94%E5%BC%80%E5%8F%91Dao%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>原始dao开发方法，程序员需要写dao接口和dao实现类。</p><h1 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h1><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://120.25.162.238:3306/mybatis001?characterEncoding=utf-8</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">123</span></span><br></pre></td></tr></table></figure><h1 id="SqlMapConfig-xml"><a href="#SqlMapConfig-xml" class="headerlink" title="SqlMapConfig.xml"></a>SqlMapConfig.xml</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"db.properties"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--properties中还可以配置一些属性名和属性值  --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;property name="jdbc.driver" value=""/&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 和spring整合后 environments配置将废除--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 使用jdbc事务管理，事务控制由mybatis--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 数据库连接池,由mybatis管理--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 加载映射文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"sqlmap/User.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="sqlmap-User-xml"><a href="#sqlmap-User-xml" class="headerlink" title="sqlmap/User.xml"></a>sqlmap/User.xml</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- namespace 命名空间，作用就是对sql进行分类化管理,理解为sql隔离</span></span><br><span class="line"><span class="comment"> 注意：使用mapper代理方法开发，namespace有特殊重要的作用</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在映射文件中配置很多sql语句 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--需求:通过id查询用户表的记录 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过select执行数据库查询</span></span><br><span class="line"><span class="comment">     id:标识映射文件中的sql，称为statement的id</span></span><br><span class="line"><span class="comment">     将sql语句封装到mappedStatement对象中，所以将id称为statement的id</span></span><br><span class="line"><span class="comment">     parameterType:指定输入参数的类型</span></span><br><span class="line"><span class="comment">     #&#123;&#125;标示一个占位符,</span></span><br><span class="line"><span class="comment">     #&#123;value&#125;其中value表示接收输入参数的名称，如果输入参数是简单类型，那么#&#123;&#125;中的值可以任意。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     resultType：指定sql输出结果的映射的java对象类型，select指定resultType表示将单条记录映射成java对象</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"com.iot.mybatis.po.User"</span>&gt;</span></span><br><span class="line">        SELECT * FROM  user  WHERE id=#&#123;value&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 根据用户名称模糊查询用户信息，可能返回多条</span></span><br><span class="line"><span class="comment">    resultType：指定就是单条记录所映射的java对象类型</span></span><br><span class="line"><span class="comment">    $&#123;&#125;:表示拼接sql串，将接收到参数的内容不加任何修饰拼接在sql中。</span></span><br><span class="line"><span class="comment">    使用$&#123;&#125;拼接sql，引起 sql注入</span></span><br><span class="line"><span class="comment">    $&#123;value&#125;：接收输入参数的内容，如果传入类型是简单类型，$&#123;&#125;中只能使用value</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserByName"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.String"</span> <span class="attr">resultType</span>=<span class="string">"com.iot.mybatis.po.User"</span>&gt;</span></span><br><span class="line">        SELECT * FROM user WHERE username LIKE '%$&#123;value&#125;%'</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 添加用户</span></span><br><span class="line"><span class="comment">        parameterType：指定输入 参数类型是pojo（包括 用户信息）</span></span><br><span class="line"><span class="comment">        #&#123;&#125;中指定pojo的属性名，接收到pojo对象的属性值，mybatis通过OGNL获取对象的属性值</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertUser"</span> <span class="attr">parameterType</span>=<span class="string">"com.iot.mybatis.po.User"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">         将插入数据的主键返回，返回到user对象中</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         SELECT LAST_INSERT_ID()：得到刚insert进去记录的主键值，只适用与自增主键</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         keyProperty：将查询到主键值设置到parameterType指定的对象的哪个属性</span></span><br><span class="line"><span class="comment">         order：SELECT LAST_INSERT_ID()执行顺序，相对于insert语句来说它的执行顺序</span></span><br><span class="line"><span class="comment">         resultType：指定SELECT LAST_INSERT_ID()的结果类型</span></span><br><span class="line"><span class="comment">          --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">order</span>=<span class="string">"AFTER"</span> <span class="attr">resultType</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></span><br><span class="line">          SELECT LAST_INSERT_ID()</span><br><span class="line">        <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">        INSERT INTO user (username,birthday,sex,address)values (#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)</span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            使用mysql的uuid（）生成主键</span></span><br><span class="line"><span class="comment">            执行过程：</span></span><br><span class="line"><span class="comment">            首先通过uuid()得到主键，将主键设置到user对象的id属性中</span></span><br><span class="line"><span class="comment">            其次在insert执行时，从user对象中取出id属性值</span></span><br><span class="line"><span class="comment">             --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  &lt;selectKey keyProperty="id" order="BEFORE" resultType="java.lang.String"&gt;</span></span><br><span class="line"><span class="comment">            SELECT uuid()</span></span><br><span class="line"><span class="comment">        &lt;/selectKey&gt;</span></span><br><span class="line"><span class="comment">        insert into user(id,username,birthday,sex,address) value(#&#123;id&#125;,#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;) --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 删除 用户</span></span><br><span class="line"><span class="comment">        根据id删除用户，需要输入 id值</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteUser"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></span><br><span class="line">        delete from user where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 根据id更新用户</span></span><br><span class="line"><span class="comment">    分析：</span></span><br><span class="line"><span class="comment">    需要传入用户的id</span></span><br><span class="line"><span class="comment">    需要传入用户的更新信息</span></span><br><span class="line"><span class="comment">    parameterType指定user对象，包括 id和更新信息，注意：id必须存在</span></span><br><span class="line"><span class="comment">    #&#123;id&#125;：从输入 user对象中获取id属性值</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateUser"</span> <span class="attr">parameterType</span>=<span class="string">"com.iot.mybatis.po.User"</span>&gt;</span></span><br><span class="line">        update user set username=#&#123;username&#125;,birthday=#&#123;birthday&#125;,sex=#&#123;sex&#125;,address=#&#123;address&#125;</span><br><span class="line">        where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="dao接口"><a href="#dao接口" class="headerlink" title="dao接口"></a>dao接口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据id查询用户信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据用户名列查询用户列表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUserByName</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加用户信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除用户信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="dao接口实现类"><a href="#dao接口实现类" class="headerlink" title="dao接口实现类"></a>dao接口实现类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iot.mybatis.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.iot.mybatis.po.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Brian on 2016/2/24.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    <span class="comment">// 需要向dao实现类中注入SqlSessionFactory</span></span><br><span class="line">    <span class="comment">// 这里通过构造方法注入</span></span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDaoImpl</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        User user = sqlSession.selectOne(<span class="string">"test.findUserById"</span>,id);</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUserByName</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; list = sqlSession.selectList(<span class="string">"test.findUserByName"</span>, name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">//执行插入操作</span></span><br><span class="line">        sqlSession.insert(<span class="string">"test.insertUser"</span>, user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交事务</span></span><br><span class="line">        sqlSession.commit();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行插入操作</span></span><br><span class="line">        sqlSession.delete(<span class="string">"test.deleteUser"</span>, id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交事务</span></span><br><span class="line">        sqlSession.commit();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iot.mybatis.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.iot.mybatis.po.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImplTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此方法是在执行testFindUserById之前执行</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建sqlSessionFactory</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// mybatis配置文件</span></span><br><span class="line">        String resource = <span class="string">"SqlMapConfig.xml"</span>;</span><br><span class="line">        <span class="comment">// 得到配置文件流</span></span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建会话工厂，传入mybatis的配置文件信息</span></span><br><span class="line">        sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder()</span><br><span class="line">                .build(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindUserById</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建UserDao的对象</span></span><br><span class="line">        UserDao userDao = <span class="keyword">new</span> UserDaoImpl(sqlSessionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用UserDao的方法</span></span><br><span class="line">        User user = userDao.findUserById(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结原始dao开发问题"><a href="#总结原始dao开发问题" class="headerlink" title="总结原始dao开发问题"></a>总结原始dao开发问题</h1><ol><li><p>dao接口实现类方法中存在大量模板方法，设想能否将这些代码提取出来，大大减轻程序员的工作量。</p></li><li><p>调用sqlsession方法时将statement的id硬编码了</p></li><li><p>调用sqlsession方法时传入的变量，由于sqlsession方法使用泛型，即使变量类型传入错误，在编译阶段也不报错，不利于程序员开发。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis Dao </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis——概述（一）</title>
      <link href="/2020/07/08/Mybatis%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/07/08/Mybatis%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>mybatis是一个持久层的框架，是apache下的顶级项目。托管到github下(<a href="https://github.com/mybatis/mybatis-3/releases)。" target="_blank" rel="noopener">https://github.com/mybatis/mybatis-3/releases)。</a></p><p>mybatis让程序将主要精力放在sql上，通过mybatis提供的映射方式，自由灵活生成（半自动化，大部分需要程序员编写sql）满足需要sql语句。</p><p>mybatis可以将向 preparedStatement中的输入参数自动进行输入映射，将查询结果集灵活映射成java对象。（输出映射）</p><h1 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h1><p>SqlSessionFactoryBuilder</p><p>通过SqlSessionFactoryBuilder创建会话工厂SqlSessionFactory将SqlSessionFactoryBuilder当成一个工具类使用即可，不需要使用单例管理SqlSessionFactoryBuilder。在需要创建SqlSessionFactory时候，只需要new一次SqlSessionFactoryBuilder即可。</p><p>SqlSessionFactory</p><p>通过SqlSessionFactory创建SqlSession，使用单例模式管理sqlSessionFactory（工厂一旦创建，使用一个实例）。将来mybatis和spring整合后，使用单例模式管理sqlSessionFactory。</p><p>SqlSession</p><p>SqlSession是一个面向用户（程序员）的接口。SqlSession中提供了很多操作数据库的方法：如：selectOne(返回单个对象)、selectList（返回单个或多个对象）。</p><p>SqlSession是线程不安全的，在SqlSesion实现类中除了有接口中的方法（操作数据库的方法）还有数据域属性。</p><p>SqlSession最佳应用场合在方法体内，定义成局部变量使用。</p><h1 id="框架原理"><a href="#框架原理" class="headerlink" title="框架原理"></a>框架原理</h1><p>mybatis框架执行过程</p><ol><li>配置mybatis的配置文件，SqlMapConfig.xml（名称不固定）</li><li>通过配置文件，加载mybatis运行环境，创建SqlSessionFactory会话工厂(SqlSessionFactory在实际使用时按单例方式)</li><li>通过SqlSessionFactory创建SqlSession。SqlSession是一个面向用户接口（提供操作数据库方法），实现对象是线程不安全的，建议sqlSession应用场合在方法体内。</li><li>调用sqlSession的方法去操作数据。如果需要提交事务，需要执行SqlSession的commit()方法。</li><li>释放资源，关闭SqlSession</li></ol><h1 id="mybatis开发dao的方法"><a href="#mybatis开发dao的方法" class="headerlink" title="mybatis开发dao的方法"></a>mybatis开发dao的方法</h1><p>1.原始dao 的方法</p><p>需要程序员编写dao接口和实现类<br>需要在dao实现类中注入一个SqlSessionFactory工厂</p><p>2.mapper代理开发方法（建议使用）</p><p>只需要程序员编写mapper接口（就是dao接口）。<br>程序员在编写mapper.xml(映射文件)和mapper.java需要遵循一个</p><h1 id="开发规范："><a href="#开发规范：" class="headerlink" title="开发规范："></a>开发规范：</h1><p>mapper.xml中namespace就是mapper.java的类全路径。<br>mapper.xml中statement的id和mapper.java中方法名一致。<br>mapper.xml中statement的parameterType指定输入参数的类型和mapper.java的方法输入参数类型一致<br>mapper.xml中statement的resultType指定输出结果的类型和mapper.java的方法返回值类型一致。<br>SqlMapConfig.xml配置文件：可以配置properties属性、别名、mapper加载。</p><h1 id="输入映射和输出映射"><a href="#输入映射和输出映射" class="headerlink" title="输入映射和输出映射"></a>输入映射和输出映射</h1><p>输入映射：</p><p>parameterType：指定输入参数类型可以简单类型、pojo、hashmap。</p><p>对于综合查询，建议parameterType使用包装的pojo，有利于系统 扩展。</p><p>输出映射：</p><p>resultType：查询到的列名和resultType指定的pojo的属性名一致，才能映射成功。</p><p>reusltMap：可以通过resultMap 完成一些高级映射。如果查询到的列名和映射的pojo的属性名不一致时，通过resultMap设置列名和属性名之间的对应关系（映射关系）。可以完成映射。</p><p>高级映射：</p><p>将关联查询的列映射到一个pojo属性中。（一对一）<br>将关联查询的列映射到一个List中。（一对多）</p><h1 id="动态sql"><a href="#动态sql" class="headerlink" title="动态sql"></a>动态sql</h1><p>动态sql：（重点）<br>if判断（掌握）<br>where<br>foreach<br>sql片段（掌握）</p><h1 id="mybatis和hibernate本质区别和应用场景"><a href="#mybatis和hibernate本质区别和应用场景" class="headerlink" title="mybatis和hibernate本质区别和应用场景"></a>mybatis和hibernate本质区别和应用场景</h1><p>hibernate</p><p>是一个标准ORM框架（对象关系映射）。入门门槛较高的，不需要程序写sql，sql语句自动生成了。对sql语句进行优化、修改比较困难的。</p><p>应用场景：适用与需求变化不多的中小型项目，比如：后台管理系统，erp、orm、oa。。</p><p>mybatis</p><p>专注是sql本身，需要程序员自己编写sql语句，sql修改、优化比较方便。mybatis是一个不完全的ORM框架，虽然程序员自己写sql，mybatis也可以实现映射（输入映射、输出映射）。</p><p>应用场景：适用与需求变化较多的项目，比如：互联网项目。</p><p>企业进行技术选型，以低成本高回报作为技术选型的原则，根据项目组的技术力量进行选择。</p>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis 概述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件——Redis—缓存五大问题的解决方案（二十四）</title>
      <link href="/2020/06/29/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Redis%E2%80%94%E7%BC%93%E5%AD%98%E4%BA%94%E5%A4%A7%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%88%E5%85%AB%EF%BC%89/"/>
      <url>/2020/06/29/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Redis%E2%80%94%E7%BC%93%E5%AD%98%E4%BA%94%E5%A4%A7%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%88%E5%85%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><p>缓存雪崩是指某一时刻发生了大规模的缓存失效，比如发生了 Redis 服务器宕机、缓存数据同时到期被删除这种情况，此时大量的请求直接转发到数据库，数据库一旦撑不住就会导致整个服务瘫痪。</p><ol><li><p>过期时间错峰：</p><p> 分析用户行为，制定策略为 key 设置不同的过期时间，尽量让缓存失效的时间均匀分布</p></li><li><p>高可用</p><p> 采用主从架构 + Sentinel 或者 Redis Cluster 实现HA，避免 Redis 单点故障</p></li><li><p>缓存降级</p><p> 设置本地缓存(ehcache) + 限流(hystrix)。如果某个目标服务调用慢或者有大量超时，此时，熔断该服务的调用，对于后续调用请求，不再继续调用目标服务，直接返回，快速释放资源。如果目标服务情况好转则恢复调用。服务降级的最终目的是保证核心服务可用</p></li><li><p>备份和恢复</p><p> 开启 Redis 持久化机制，服务重启后快速恢复缓存数据</p></li></ol><h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><p>对于一些设置了过期时间的热点 key，需要考虑缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里是针对某个 key 的缓存，前者则是很多 key。</p><ol><li><p>使用互斥锁（mutex key）：</p><p> 让一个线程构建 Redis 缓存，其他线程等待构建缓存的线程执行完，然后直接从缓存获取数据</p></li><li><p>设置 key 永不过期</p><p> 永不过期既要保证 key 一直持有在缓存中，又要能对 key 的 value 进行及时的更新。实现的方式是不为 key 设置物理过期时间，即不通过redis.expire(key, timeout) 命令设置过期时间；但是要设置一个逻辑的过期时间，可以把 key 的过期时间拼接到 value 中，程序访问缓存时，从 value 中解析出过期时间并根据规则判定 key 是否需要更新</p></li></ol><p>两种方案对比：</p><table><thead><tr><th>方案</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>使用互斥锁</td><td>保证一致性</td><td>程序复杂度高，存在死锁和线程阻塞的风险</td></tr><tr><td>设置key永不过期</td><td>异步构建缓存缓存，线程不会阻塞</td><td>无法保证一致性，代码复杂度增加，每个 key 占用的空间增加</td></tr></tbody></table><h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p>缓存穿透是指查询一个一定不存在的数据。出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义，也很容易被攻击者作为系统漏洞进行攻击。</p><ol><li>key校验，key设定一定的规则，不符合规则的倍屏蔽。</li><li>接口层增加校验，如用户鉴权校验，id 做基础校验，id&lt;=0 的直接拦截</li><li>即便存储层查不到这个数据，也将返回的空对象设置到缓存里。下次再请求的时候，直接从缓存取到空对象返回，这种情况一般会将空对象设置一个较短的过期时间，这样可以防止攻击者反复用同一个 id 暴力攻击。</li></ol><h1 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h1><p>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统，避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis 缓存五大问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件——Redis—分布式Session共享（十）</title>
      <link href="/2020/06/29/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Redis%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8FSession%E5%85%B1%E4%BA%AB%EF%BC%88%E5%8D%81%EF%BC%89/"/>
      <url>/2020/06/29/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Redis%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8FSession%E5%85%B1%E4%BA%AB%EF%BC%88%E5%8D%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当项目使用分布式时，session问题就显得比较突出了，因为有不同服务器的缘故，如果你安照一般方式存储session，那么你的session会保存在某一台服务器上，如果你的下一个请求并不是访问这台服务器，那么会发生读取不到session的情况。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="session-replication-和-session-sticky"><a href="#session-replication-和-session-sticky" class="headerlink" title="session replication 和 session sticky"></a>session replication 和 session sticky</h2><p>session replication 策略是复制会话，即bai一个用户访问了一次就把session复制到所有的服务器或这一部分服务器。这样的好处是如果正访问的服务器down了用户可以自动被转到别的服务器session不丢失。缺点当然是效率低。</p><p>session sticky策略则是不复制，一个用户访问了一次后，同一个session周期内，所有的请求都定向到这个服务器，down了session就丢了</p><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>不过这种方式是十分不可取了，先不说session数据放到客户端那边造成的安全问题，这样会造成带宽消耗，而且会强烈影响性能，而且cookie自身也有长度限制。</p><h2 id="集中化处理"><a href="#集中化处理" class="headerlink" title="集中化处理"></a>集中化处理</h2><p>你可以存在数据库中，也可以采用其他分布式存储系统，这里session的储存引入了网络操作，所以可能会有数据延迟，而且当session储存设备挂了，会造成所有session丢失</p><h1 id="redis储存方案"><a href="#redis储存方案" class="headerlink" title="redis储存方案"></a>redis储存方案</h1><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p>一般都是通过容器插件来实现，例如基于Tomcat的tomcat-redis-session-manager，基于Jetty的jetty-session-redis等等。好处是对项目来说是透明的，无需更改代码，但是目前还不支持Tomcat8。个人觉得由于过于依赖容器，，一旦更换容器或者容器升级，那又得重新来过。而且代码并不在项目中，对于开发者的维护也是个麻烦。</p><p><a href="https://zhuanlan.zhihu.com/p/25189495" target="_blank" rel="noopener">使用容器拓展实现session redis存储</a></p><h1 id="自定义工具类"><a href="#自定义工具类" class="headerlink" title="自定义工具类"></a>自定义工具类</h1><p>第二种是自定义会话管理的工具类，这样的话灵活性很大，可以根据自身需求来实现，但是需要额外的开发时间</p><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p><a href="https://zhuanlan.zhihu.com/p/25010950" target="_blank" rel="noopener">Spring Session + Redis实现分布式Session共享</a></p><p><a href="https://zhuanlan.zhihu.com/p/148503037" target="_blank" rel="noopener">SpringBoot 一个依赖搞定 session 共享，没有比这更简单的方案了！</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis 分布式session </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件——Redis—实战学习（十一）</title>
      <link href="/2020/06/29/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Redis%E2%80%94%E5%AE%9E%E6%88%98%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/"/>
      <url>/2020/06/29/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Redis%E2%80%94%E5%AE%9E%E6%88%98%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="redis实战之使用redis实现排行榜"><a href="#redis实战之使用redis实现排行榜" class="headerlink" title="redis实战之使用redis实现排行榜"></a>redis实战之使用redis实现排行榜</h1><p><a href="https://www.jianshu.com/p/9fc142aaa466" target="_blank" rel="noopener">SpringBoot应用篇之借助Redis实现排行榜功能</a></p><h1 id="redis实现点赞取消点赞"><a href="#redis实现点赞取消点赞" class="headerlink" title="redis实现点赞取消点赞"></a>redis实现点赞取消点赞</h1><p><a href="https://www.jianshu.com/p/d70ecd83214c" target="_blank" rel="noopener">Redis是如何实现点赞、取消点赞的？</a></p><h1 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h1><p><a href="https://blog.csdn.net/qq_35375529/article/details/90295311" target="_blank" rel="noopener">java秒杀之redis限流操作</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot——redis分布式锁实现（二十三）</title>
      <link href="/2020/06/29/SpringBoot%E2%80%94%E2%80%94redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%89%EF%BC%89/"/>
      <url>/2020/06/29/SpringBoot%E2%80%94%E2%80%94redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">cluster</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">nodes</span>:<span class="string"></span></span><br><span class="line">        <span class="meta">-</span> <span class="string">192.168.43.32:7001</span></span><br><span class="line">        <span class="meta">-</span> <span class="string">192.168.43.32:7002</span></span><br><span class="line">        <span class="meta">-</span> <span class="string">192.168.43.32:7003</span></span><br><span class="line">        <span class="meta">-</span> <span class="string">192.168.43.32:7004</span></span><br><span class="line">        <span class="meta">-</span> <span class="string">192.168.43.32:7005</span></span><br><span class="line">        <span class="meta">-</span> <span class="string">192.168.43.32:7006</span></span><br><span class="line">      <span class="meta">max-redirects</span>: <span class="string">3</span></span><br><span class="line">    <span class="attr">lettuce</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">pool</span>:<span class="string"></span></span><br><span class="line">        <span class="meta">max-idle</span>: <span class="string">8</span></span><br><span class="line">        <span class="meta">max-wait</span>: <span class="string">-1</span></span><br><span class="line">        <span class="meta">max-active</span>: <span class="string">8</span></span><br><span class="line">        <span class="meta">min-idle</span>: <span class="string">0</span></span><br></pre></td></tr></table></figure><h1 id="RedissionConfig"><a href="#RedissionConfig" class="headerlink" title="RedissionConfig"></a>RedissionConfig</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.rojao.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.redisson.config.Config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * redisson配置</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;spring.redis.clusters&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>  String cluster;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;spring.redis.password&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedissonClient <span class="title">getRedisson</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">String[] nodes = cluster.split(<span class="string">","</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//redisson版本是3.5，集群的ip前面要加上“redis://”，不然会报错，3.2版本可不加</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nodes.length;i++)&#123;</span><br><span class="line"></span><br><span class="line">nodes[i] = <span class="string">"redis://"</span>+nodes[i];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RedissonClient redisson = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">Config config = <span class="keyword">new</span> Config();</span><br><span class="line"></span><br><span class="line">config.useClusterServers() <span class="comment">//这是用的集群server</span></span><br><span class="line"></span><br><span class="line">.setScanInterval(<span class="number">2000</span>) <span class="comment">//设置集群状态扫描时间</span></span><br><span class="line"></span><br><span class="line">.addNodeAddress(nodes).setRetryAttempts(<span class="number">5</span>).setTimeout(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(StringUtils.isNotEmpty(password))&#123;</span><br><span class="line"></span><br><span class="line">config.useClusterServers().setPassword(password);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">redisson = Redisson.create(config);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//可通过打印redisson.getConfig().toJSON().toString()来检测是否配置成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//try &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println(redisson.getConfig().toJSON().toString());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#125; catch (IOException e) &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//e.printStackTrace();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> redisson;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="DistributedRedisLock"><a href="#DistributedRedisLock" class="headerlink" title="DistributedRedisLock"></a>DistributedRedisLock</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot_redis.redis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RLock;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分布式Redis锁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/19 15:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedRedisLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">lock</span><span class="params">(String lockName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (redissonClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">                log.info(<span class="string">"DistributedRedisLock redissonClient is null"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            RLock lock = redissonClient.getLock(lockName);</span><br><span class="line">            <span class="comment">// 锁10秒后自动释放，防止死锁</span></span><br><span class="line">            lock.lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">            log.info(<span class="string">"Thread [&#123;&#125;] DistributedRedisLock lock [&#123;&#125;] success"</span>, Thread.currentThread().getName(), lockName);</span><br><span class="line">            <span class="comment">// 加锁成功</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"DistributedRedisLock lock [&#123;&#125;] Exception:"</span>, lockName, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">unlock</span><span class="params">(String lockName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (redissonClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">                log.info(<span class="string">"DistributedRedisLock redissonClient is null"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            RLock lock = redissonClient.getLock(lockName);</span><br><span class="line">            lock.unlock();</span><br><span class="line">            log.info(<span class="string">"Thread [&#123;&#125;] DistributedRedisLock unlock [&#123;&#125;] success"</span>, Thread.currentThread().getName(), lockName);</span><br><span class="line">            <span class="comment">// 释放锁成功</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"DistributedRedisLock unlock [&#123;&#125;] Exception:"</span>, lockName, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LockTestController"><a href="#LockTestController" class="headerlink" title="LockTestController"></a>LockTestController</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot_redis.contoller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.springboot_redis.redis.DistributedRedisLock;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分布式Redis锁测试controller</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/19 17:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/lock"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DistributedRedisLock distributedRedisLock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试分布式锁</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/testLock"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Boolean lockFlag = distributedRedisLock.lock(<span class="string">"LOCK"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件——Redis—分布式锁（二十）</title>
      <link href="/2020/06/24/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Redis%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
      <url>/2020/06/24/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Redis%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%88%E4%B9%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要用分布式锁？"><a href="#为什么要用分布式锁？" class="headerlink" title="为什么要用分布式锁？"></a>为什么要用分布式锁？</h1><p>比如我们用redis做秒杀活动，客户端请求，首先查看库存，库存足够，则下订单，更新库存。然而当并发下，可能会出现库存数据不一致的情形，造成库存超卖。</p><p>如果是单台机器：</p><p>我们使用java的锁将一系列操作变成原子操作，能够避免并发下的线程安全问题。</p><p>如果是多台机器：</p><p>单机上的锁只能锁住进程，多个进程之间是无效的，我们需要保证多台机器加的锁是同一把锁。</p><p>分布式锁的思路是：在整个系统提供一个全局、唯一的获取锁的“东西”，然后每个系统在需要加锁时，都去问这个“东西”拿到一把锁，这样不同的系统拿到的就可以认为是同一把锁。</p><p>至于这个“东西”，可以是 Redis、Zookeeper，也可以是数据库。</p><h1 id="setnx"><a href="#setnx" class="headerlink" title="setnx"></a>setnx</h1><p>在 Redis 中设置一个值表示加了锁，然后释放锁的时候就把这个 Key 删除。</p><p>其实目前通常所说的setnx命令，并非单指redis的setnx key value这条命令。</p><p>一般代指redis中对set命令加上nx参数进行使用， set这个命令，目前已经支持这么多参数可选：</p><pre><code>SET key value [EX seconds|PX milliseconds] [NX|XX] [KEEPTTL]</code></pre><p><img src="/images/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Redis%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89_2020-06-24-15-58-07.png" alt="消息中间件——Redis—分布式锁（二十）_2020-06-24-15-58-07.png"></p><ol><li>那么为什么要使用PX 30000去设置一个超时时间？</li></ol><p>如果进程A崩了，直接原地把锁带走了，导致系统中谁也拿不到锁。</p><ol start="2"><li>为什么要设置唯一value哪？</li></ol><p>如果进程A操作锁内资源超过笔者设置的超时时间，那么就会导致其他进程拿到锁，等进程A回来了，回手就是把其他进程的锁删了。</p><p>当解锁的时候，先获取value判断是否是当前进程加的锁，再去删除。伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String uuid = xxxx;</span><br><span class="line"><span class="comment">// 伪代码，具体实现看项目中用的连接工具</span></span><br><span class="line"><span class="comment">// 有的提供的方法名为set 有的叫setIfAbsent</span></span><br><span class="line">set Test uuid NX PX <span class="number">3000</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// biz handle....</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// unlock</span></span><br><span class="line">    <span class="keyword">if</span>(uuid.equals(redisTool.get(<span class="string">'Test'</span>))&#123;</span><br><span class="line">        redisTool.del(<span class="string">'Test'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在finally代码块中，get和del并非原子操作，还是有进程安全问题。</p><p>删除锁的正确姿势之一，就是可以使用lua脚本，通过redis的eval/evalsha命令来运行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- lua删除锁：</span><br><span class="line">-- KEYS和ARGV分别是以集合方式传入的参数，对应上文的Test和uuid。</span><br><span class="line">-- 如果对应的value等于传入的uuid。</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">'get'</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] </span><br><span class="line">    then </span><br><span class="line">-- 执行删除操作</span><br><span class="line">        <span class="keyword">return</span> redis.call(<span class="string">'del'</span>, KEYS[<span class="number">1</span>]) </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">-- 不成功，返回<span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>命令执行脚本，其他客户端是看不到的。</p><h1 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h1><p>Redisson 是 Java 的 Redis 客户端之一，提供了一些 API 方便操作 Redis。</p><p>Redisson 帮我们搞了分布式的版本，对主从，哨兵，集群等模式都支持，当然了，单节点模式肯定是支持的。</p><ol><li>Redisson 普通的锁实现源码主要是 RedissonLock 这个类</li><li>源码中加锁/释放锁操作都是用 Lua 脚本完成的</li></ol><p>我们回想以下上一步设置的超时时间是 30s，假如我超过 30s 都还没有完成业务逻辑的情况下，Key 会过期，其他线程有可能会获取到锁。</p><p>我们是通过设置唯一value去避免线程安全问题。</p><p>我们来看一下Redisson怎么实现？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Config config = <span class="keyword">new</span> Config(); </span><br><span class="line">config.useClusterServers() </span><br><span class="line">.addNodeAddress(<span class="string">"redis://192.168.31.101:7001"</span>) </span><br><span class="line">.addNodeAddress(<span class="string">"redis://192.168.31.101:7002"</span>) </span><br><span class="line">.addNodeAddress(<span class="string">"redis://192.168.31.101:7003"</span>) </span><br><span class="line">.addNodeAddress(<span class="string">"redis://192.168.31.102:7001"</span>) </span><br><span class="line">.addNodeAddress(<span class="string">"redis://192.168.31.102:7002"</span>) </span><br><span class="line">.addNodeAddress(<span class="string">"redis://192.168.31.102:7003"</span>); </span><br><span class="line"> </span><br><span class="line">RedissonClient redisson = Redisson.create(config); </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">RLock lock = redisson.getLock(<span class="string">"anyLock"</span>); </span><br><span class="line">lock.lock(); </span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure><p>就是这么简单，我们只需要通过它的 API 中的 Lock 和 Unlock 即可完成分布式锁，他帮我们考虑了很多细节：</p><ol><li>Redisson 所有指令都通过 Lua 脚本执行，Redis 支持 Lua 脚本原子性执行。</li><li>Redisson 设置一个 Key 的默认过期时间为 30s，如果某个客户端持有一个锁超过了 30s 怎么办？</li><li>Redisson 中有一个 Watchdog 的概念，翻译过来就是看门狗，它会在你获取锁之后，每隔 10s 帮你把 Key 的超时时间设为 30s</li><li>帮我们解决了锁的可重入性问题。</li></ol><p>另外，Redission还提供了对RedLock的支持。</p><h1 id="RedLock"><a href="#RedLock" class="headerlink" title="RedLock"></a>RedLock</h1><p>Redlock是Redis的作者 Antirez 提出的集群模式分布式锁，基于N个完全独立的Redis节点实现分布式锁的高可用。</p><ol><li>获取当前Unix时间，以毫秒为单位。</li><li>依次尝试从5个实例，使用相同的key和具有唯一性的value获取锁<br>当向Redis请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间，这样可以避免客户端死等。</li><li>客户端使用当前时间减去开始获取锁时间就得到获取锁使用的时间。当且仅当从半数以上的Redis节点取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。</li><li>如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间，这个很重要。</li><li>如果因为某些原因，获取锁失败（没有在半数以上实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁，无论Redis实例是否加锁成功，因为可能服务端响应消息丢失了但是实际成功了，毕竟多释放一次也不会有问题。</li></ol><h1 id="redis作为分布式锁面临的问题"><a href="#redis作为分布式锁面临的问题" class="headerlink" title="redis作为分布式锁面临的问题"></a>redis作为分布式锁面临的问题</h1><ol><li><p>锁需要具有唯一性</p><p> 为了保证同一变量不被多个线程同时访问，确保锁在多线程甚至多进程间访问需要具有唯一性。</p></li><li><p>锁需要有超时时间,防止死锁</p><p> redis释放锁需要客户端的操作,如果此时客户端突然挂了,就没有释放锁的操作了,也意味着其他客户端想要重新加锁,却加不了的问题.</p><p> 所以,为了避免客户端挂掉或者说是客户端不能正常释放锁的问题,需要在加锁的同时,给锁加上超时时间.</p></li><li><p>锁的创建和设置锁超时时间需要具备原子性</p><p> 加锁和设置锁超时必须是原子操作，否则加锁时客户端挂了，此时还未设置超时时间，锁依然得不到释放。</p></li><li><p>锁的超时问题</p><p> 虽然上面给锁加上了超时时间,但是客户端并不能一定在超时时间之内完成定时任务,所以,即使当前客户端没有完成任务,此时又会有其他的客户端设置锁成功,此时同一资源将会面临多个客户端同时操作的问题.</p><p> 客户端可以在锁设置成功之后,进行定时任务,在锁超时之前使用lua脚本删除锁并重新设置锁和超时时间. </p><p> Redisson 中有一个 Watchdog 的概念，翻译过来就是看门狗，它会在你获取锁之后，每隔 10s 帮你把 Key 的超时时间设为 30s</p></li><li><p>锁的可重入性</p><p> 通常情况下，redis实现的分布式锁不具有可重入性，遇到可重入问题会产生死锁，不过我们可以通过使用threadlocal存储持有锁的信息。</p><p> 当然一般情况下不需要我们去实现可重入锁，Redission已经帮我们实现了。</p></li><li><p>集群下分布式锁的问题</p><p> 如果在多个客户端获取锁的过程中，redis 挂了怎么办呢？</p><ol><li><p>客户端1在Redis的master节点上拿到了锁</p></li><li><p>Master宕机了，存储锁的key还没有来得及同步到Slave上</p></li><li><p>master故障，发生故障转移，slave节点升级为master节点</p></li><li><p>客户端2从新的Master获取到了对应同一个资源的锁</p><p>RedLock方案以牺牲性能的代价解决了这个问题。Redission也提供了RedLock的支持。不过这是极端情况下的考虑。</p></li></ol></li></ol><h1 id="Redis作为分布式锁有以下缺点"><a href="#Redis作为分布式锁有以下缺点" class="headerlink" title="Redis作为分布式锁有以下缺点"></a>Redis作为分布式锁有以下缺点</h1><ul><li>它获取锁的方式简单粗暴，获取不到锁直接不断尝试获取锁，比较消耗性能。</li><li>另外来说的话，Redis 的设计定位决定了它的数据并不是强一致性的，在某些极端情况下，可能会出现问题。锁的模型不够健壮。</li><li>即便使用 Redlock 算法来实现，在某些复杂场景下，也无法保证其实现 100% 没有问题，关于 Redlock 的讨论可以看 How to do distributed locking。</li></ul><p>对于 ZK 分布式锁而言:</p><ul><li>ZK 天生设计定位就是分布式协调，强一致性。锁的模型健壮、简单易用、适合做分布式锁。</li><li>如果获取不到锁，只需要添加一个监听器就可以了，不用一直轮询，性能消耗较小。</li></ul><p>但是 ZK 也有其缺点：如果有较多的客户端频繁的申请加锁、释放锁，对于 ZK 集群的压力会比较大。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot——redis消息队列list（二十二）</title>
      <link href="/2020/06/24/SpringBoot%E2%80%94%E2%80%94redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97list%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/06/24/SpringBoot%E2%80%94%E2%80%94redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97list%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>redis的lpush和rpop很适合作为一种轻量级的消息队列实现，这与redis的list列表有关，详情见</p><h1 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisProducerImpl</span> <span class="keyword">implements</span> <span class="title">RedisProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResponse <span class="title">produce</span><span class="params">(String key, String msg)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = Maps.newHashMap();</span><br><span class="line">        map.put(<span class="string">"fileId"</span>, msg);</span><br><span class="line">        redisTemplate.opsForList().leftPush(key, map);</span><br><span class="line">        <span class="keyword">return</span> JsonResponse.ok();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processOrderImport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Object object = redisTemplate.opsForList().rightPop(RedisKey.orderImportKey, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == object) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                String msg = JSON.toJSONString(object);</span><br><span class="line">                executorService.execute(*******);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot——redis发布与订阅（二十一）</title>
      <link href="/2020/06/24/SpringBoot%E2%80%94%E2%80%94redis%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89/"/>
      <url>/2020/06/24/SpringBoot%E2%80%94%E2%80%94redis%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="配置RedisTemplate"><a href="#配置RedisTemplate" class="headerlink" title="配置RedisTemplate"></a>配置RedisTemplate</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">// 设置Key使用String序列化</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="订阅监听类"><a href="#订阅监听类" class="headerlink" title="订阅监听类"></a>订阅监听类</h1><p>订阅者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscribeListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订阅接收发布者的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, <span class="keyword">byte</span>[] pattern)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 缓存消息是序列化的，需要反序列化。然而new String()可以反序列化，但静态方法valueOf()不可以</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(pattern) + <span class="string">"主题发布："</span> + <span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发布者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PublishService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发布方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 消息发布订阅 主题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 消息信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">(String channel, Object message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 该方法封装的 connection.publish(rawChannel, rawMessage);</span></span><br><span class="line">        redisTemplate.convertAndSend(channel, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="添加监听主题"><a href="#添加监听主题" class="headerlink" title="添加监听主题"></a>添加监听主题</h1><p>在RedisConfig中配置监听test-topic主题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> RedisMessageListenerContainer <span class="title">redisMessageListenerContainer</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">       RedisMessageListenerContainer container = <span class="keyword">new</span> RedisMessageListenerContainer();</span><br><span class="line">       container.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">       <span class="comment">// 添加订阅者监听类，数量不限.PatternTopic定义监听主题,这里监听test-topic主题</span></span><br><span class="line">       container.addMessageListener(<span class="keyword">new</span> SubscribeListener(), <span class="keyword">new</span> PatternTopic(<span class="string">"test-topic"</span>));</span><br><span class="line">       <span class="keyword">return</span> container;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="发布订阅测试"><a href="#发布订阅测试" class="headerlink" title="发布订阅测试"></a>发布订阅测试</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">RedisMqPsApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PublishService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            service.publish(<span class="string">"test-topic"</span>, <span class="string">"hello~~~"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件——Redis—阻塞分析（五）</title>
      <link href="/2020/06/22/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Redis%E2%80%94%E9%98%BB%E5%A1%9E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2020/06/22/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Redis%E2%80%94%E9%98%BB%E5%A1%9E%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Redis是典型的单线程架构，所有的读写操作都是在一条主线程中完成的。当Redis用于高并发场景时，这条线程就变成了它的生命线。如果出现阻塞，哪怕是很短时间，对于应用来说都是噩梦。</p><h1 id="导致阻塞问题的原因"><a href="#导致阻塞问题的原因" class="headerlink" title="导致阻塞问题的原因"></a>导致阻塞问题的原因</h1><p>内在原因：不合理地使用API或数据结构、CPU饱和、持久化阻塞等<br>外在原因：CPU竞争、内存交换、网络问题等</p><h1 id="发现阻塞"><a href="#发现阻塞" class="headerlink" title="发现阻塞"></a>发现阻塞</h1><ul><li>应用方加入异常监控，如日志系统，比如Java语言中的logback或log4j</li><li>Redis监控系统，如CacheCloud</li></ul><h1 id="内在原因"><a href="#内在原因" class="headerlink" title="内在原因"></a>内在原因</h1><h2 id="API或数据结构使用不合理"><a href="#API或数据结构使用不合理" class="headerlink" title="API或数据结构使用不合理"></a>API或数据结构使用不合理</h2><p>对于高并发的场景应该尽量避免在大对象上执行算法复杂度超过O(n)的命令。</p><h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><p>Redis原生提供慢查询统计功能，执行slowlog get{n}命令可以获取最近的n条慢查询命令，默认对于执行超过10毫秒的命令都会记录到一个定长队列中，线上实例建议设置为1毫秒便于及时发现毫秒级以上的命令。</p><p>发现慢查询后如何调整:</p><ul><li>修改为低算法复杂度的命令</li></ul><h3 id="大对象"><a href="#大对象" class="headerlink" title="大对象"></a>大对象</h3><p>Redis本身提供发现大对象的工具。具体命令：<br>redis-cli -h {ip}  -p {port} –bigkeys</p><p>内部原理采用分段进行scan操作，把历史扫描过的最大对象统计出来便于分析优化。</p><p>发现大对象如何调整：</p><ul><li>调整大对象：缩减大对象数据或把大对象拆分为多个小对象，防止一次命令操作过多的数据。</li></ul><h2 id="CPU饱和"><a href="#CPU饱和" class="headerlink" title="CPU饱和"></a>CPU饱和</h2><p>单线程的Redis处理命令时只能使用一个CPU。而CPU饱和是指Redis把单核CPU使用率跑到接近100%。CPU饱和是非常危险的，将导致Redis无法处理更多的命令，严重影响吞吐量和应用方的稳定性。</p><p>对于这种情况，首先判断当前Redis的并发量是否达到极限，建议使用统计命令redis-cli -h {ip} -p {port} –stat获取当前Redis使用情况</p><h2 id="持久化阻塞"><a href="#持久化阻塞" class="headerlink" title="持久化阻塞"></a>持久化阻塞</h2><p>对于开启了持久化功能的Redis节点，需要排查是否是持久化导致的阻塞。</p><p>fork阻塞：fork操作发生在RDB和AOF重写时，Redis主线程调用fork操作产生共享内存的子进程，由子进程完成持久化文件重写工作。如果fork操作本身耗时过长，必然会导致主线程的阻塞。</p><p>AOF刷盘阻塞：当我们开启AOF持久化功能时，文件刷盘的方式一般采用每秒一次，后台线程每秒对AOF文件做fsync操作。当硬盘压力过大时，fsync操作需要等待，直到写入完成。如果主线程发现距离上一次的fsync成功超过2秒，为了数据安全性它会阻塞直到后台线程执行fsync操作完成。这种阻塞行为主要是硬盘压力引起。</p><p>HugePage写操作阻塞：子进程在执行重写期间利用Linux写时复制技术降低内存开销，因此只有写操作时Redis才复制要修改的内存页。对于开启Transparent HugePages的操作系统，每次写命令引起的复制内存页单位由4K变为2MB，放大了512倍，会拖慢写操作的执行时间，导致大量写操作慢查询。</p><h1 id="外在原因"><a href="#外在原因" class="headerlink" title="外在原因"></a>外在原因</h1><h2 id="CPU竞争"><a href="#CPU竞争" class="headerlink" title="CPU竞争"></a>CPU竞争</h2><p>进程竞争：Redis是典型的CPU密集型应用，不建议和其他多核CPU密集型服务部署在一起。当其他进程过度消耗CPU时，将严重影响Redis吞吐量。可以通过top、sar等命令定位到CPU消耗的时间点和具体进程，这个问题比较容易发现，需要调整服务之间部署结构。</p><p>绑定CPU：部署Redis时为了充分利用多核CPU，通常一台机器部署多个实例。常见的一种优化是把Redis进程绑定到CPU上，用于降低CPU频繁上下文切换的开销。这个优化技巧正常情况下没有问题，但是存在例外情况，当Redis父进程创建子进程进行RDB/AOF重写时，如果做了CPU绑定，会与父进程共享使用一个CPU。子进程重写时对单核CPU使用率通常在90%以上，父进程与子进程将产生激烈CPU竞争，极大影响Redis稳定性。因此对于开启了持久化或参与复制的主节点不建议绑定CPU。</p><h2 id="内存交换"><a href="#内存交换" class="headerlink" title="内存交换"></a>内存交换</h2><p>内存交换（swap）对于Redis来说是非常致命的，Redis保证高性能的一个重要前提是所有的数据在内存中。如果操作系统把Redis使用的部分内存换出到硬盘，由于内存与硬盘读写速度差几个数量级，会导致发生交换后的Redis性能急剧下降。</p><p>预防内存交换：</p><ul><li>保证机器充足的可用内存。</li><li>确保所有Redis实例设置最大可用内存（maxmemory），防止极端情况下Redis内存不可控的增长。</li><li>降低系统使用swap优先级。</li></ul><h2 id="网络问题"><a href="#网络问题" class="headerlink" title="网络问题"></a>网络问题</h2><h3 id="连接拒绝"><a href="#连接拒绝" class="headerlink" title="连接拒绝"></a>连接拒绝</h3><ul><li>网络闪断（网络割接或者带宽耗尽）</li><li>Redis连接拒绝（超过客户端最大连接数）</li><li>连接溢出（进程限制或backlog队列溢出）</li></ul><h3 id="网络延迟"><a href="#网络延迟" class="headerlink" title="网络延迟"></a>网络延迟</h3><p>网络延迟取决于客户端到Redis服务器之间的网络环境。主要包括它们之间的物理拓扑和带宽占用情况。常见的物理拓扑按网络延迟由快到慢可分为：同物理机&gt;同机架&gt;跨机架&gt;同机房&gt;同城机房&gt;异地机房。但它们容灾性正好相反，同物理机容灾性最低而异地机房容灾性最高。</p><p>网络延迟问题经常出现在跨机房的部署结构上，对于机房之间延迟比较严重的场景需要调整拓扑结构，如把客户端和Redis部署在同机房或同城机房等。</p><p>带宽瓶颈通常出现在以下几个方面：</p><ul><li>机器网卡带宽。</li><li>机架交换机带宽。</li><li>机房之间专线带宽。</li></ul><h3 id="网卡软中断"><a href="#网卡软中断" class="headerlink" title="网卡软中断"></a>网卡软中断</h3><p>网卡软中断是指由于单个网卡队列只能使用一个CPU，高并发下网卡数据交互都集中在同一个CPU，导致无法充分利用多核CPU的情况。网卡软中断瓶颈一般出现在网络高流量吞吐的场景。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis 阻塞分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件——Redis—内存淘汰策略（六）</title>
      <link href="/2020/06/19/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Redis%E2%80%94%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%EF%BC%88%E5%85%AD%EF%BC%89/"/>
      <url>/2020/06/19/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Redis%E2%80%94%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%EF%BC%88%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>长期将Redis作为缓存使用，难免会遇到内存空间存储瓶颈，当Redis内存超出物理内存限制时，内存数据就会与磁盘产生频繁交换，使Redis性能急剧下降。此时如何淘汰无用数据释放空间，存储新数据就变得尤为重要了。</p><p>Redis在生产环境中，采用配置参数 maxmemory 的方式来限制内存大小。当实际存储内存超出maxmemory 参数值时，开发者们可以通过这几种方法——Redis内存淘汰策略，来决定如何腾出新空间继续支持读写工作。</p><p>有个问题？</p><p>Redis的数据已经设置了TTL，不是过期就已经删除了吗？为什么还存在所谓的淘汰策略呢？这个原因我们需要从redis的过期策略聊起。</p><h1 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h1><ol><li><p>定期删除</p><p> redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，以后会定期遍历这个字典来删除到期的 key。</p><p> Redis 默认会每秒进行十次过期扫描（100ms一次），过期扫描不会遍历过期字典中所有的 key，而是采用了一种简单的贪心策略。</p><ol><li>从过期字典中随机 20 个 key；</li><li>删除这 20 个 key 中已经过期的 key；</li><li>如果过期的 key 比率超过 1/4，那就重复步骤 1；</li></ol></li></ol><p>redis默认是每隔 100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载。</p><ol start="2"><li><p>惰性删除</p><p> 所谓惰性策略就是在客户端访问这个key的时候，redis对key的过期时间进行检查，如果过期了就立即删除，不会给你返回任何东西。</p><p> 定期删除可能会导致很多过期key到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，即当你主动去查过期的key时,如果发现key过期了,就立即进行删除,不返回任何东西.</p><p> 总结：定期删除是集中处理，惰性删除是零散处理。</p></li></ol><h1 id="为什么需要淘汰策略"><a href="#为什么需要淘汰策略" class="headerlink" title="为什么需要淘汰策略"></a>为什么需要淘汰策略</h1><p>有了以上过期策略的说明后，就很容易理解为什么需要淘汰策略了，因为不管是定期采样删除还是惰性删除都不是一种完全精准的删除，就还是会存在key没有被删除掉的场景，所以就需要内存淘汰策略进行补充。</p><h1 id="淘汰机制"><a href="#淘汰机制" class="headerlink" title="淘汰机制"></a>淘汰机制</h1><p>区分不同的淘汰策略选择不同的key，Redis淘汰策略主要分为LRU淘汰、TTL淘汰、随机淘汰三种机制。</p><ol><li>LRU淘汰</li></ol><p>LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</p><p>在服务器配置中保存了 lru 计数器 server.lrulock，会定时（redis 定时程序 serverCorn()）更新，server.lrulock 的值是根据 server.unixtime 计算出来进行排序的，然后选择最近使用时间最久的数据进行删除。另外，从 struct redisObject 中可以发现，每一个 redis 对象都会设置相应的 lru。每一次访问数据，会更新对应redisObject.lru。</p><p>在Redis中，LRU算法是一个近似算法，默认情况下，Redis会随机挑选5个键，并从中选择一个最久未使用的key进行淘汰。在配置文件中，按maxmemory-samples选项进行配置，选项配置越大，消耗时间就越长，但结构也就越精准。</p><ol start="2"><li><p>TTL淘汰</p><p> Redis 数据集数据结构中保存了键值对过期时间的表，即 redisDb.expires。与 LRU 数据淘汰机制类似，TTL 数据淘汰机制中会先从过期时间的表中随机挑选几个键值对，取出其中 ttl 最大的键值对淘汰。同样，TTL淘汰策略并不是面向所有过期时间的表中最快过期的键值对，而只是随机挑选的几个键值对。</p></li></ol><p>3.# 随机淘汰</p><pre><code>在随机淘汰的场景下获取待删除的键值对，随机找hash桶再次hash指定位置的dictEntry即可。Redis中的淘汰机制都是几近于算法实现的，主要从性能和可靠性上做平衡，所以并不是完全可靠，所以开发者们在充分了解Redis淘汰策略之后还应在平时多主动设置或更新key的expire时间，主动删除没有价值的数据，提升Redis整体性能和空间。</code></pre><h1 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h1><p>根据以上三种淘汰机制，以及是否专注于淘汰过期数据时间集，又分为六种淘汰策略。</p><ol><li>volatile-lru：从设置过期时间的数据集（server.db[i].expires）中挑选出最近最少使用的数据淘汰。没有设置过期时间的key不会被淘汰，这样就可以在增加内存空间的同时保证需要持久化的数据不会丢失。</li><li>volatile-ttl：除了淘汰机制采用LRU，策略基本上与volatile-lru相似，从设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰，ttl值越大越优先被淘汰。</li><li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰。当内存达到限制无法写入非过期时间的数据集时，可以通过该淘汰策略在主键空间中随机移除某个key。</li><li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰，该策略要淘汰的key面向的是全体key集合，而非过期的key集合。</li><li>allkeys-random：从数据集(server.db[i].dict）中选择任意数据淘汰。</li><li>no-enviction：禁止驱逐数据，也就是当内存不足以容纳新入数据时，新写入操作就会报错，请求可以继续进行，线上任务也不能持续进行，采用no-enviction策略可以保证数据不被丢失，这也是系统默认的一种淘汰策略。</li></ol><h1 id="淘汰策略的选择"><a href="#淘汰策略的选择" class="headerlink" title="淘汰策略的选择"></a>淘汰策略的选择</h1><ol><li>在Redis中，数据有一部分访问频率较高，其余部分访问频率较低，或者无法预测数据的使用频率时，设置allkeys-lru是比较合适的。</li><li>如果所有数据访问概率大致相等时，可以选择allkeys-random。</li><li>如果研发者需要通过设置不同的ttl来判断数据过期的先后顺序，此时可以选择volatile-ttl策略。</li><li>如果希望一些数据能长期被保存，而一些数据可以被淘汰掉时，选择volatile-lru或volatile-random都是比较不错的。</li><li>由于设置expire会消耗额外的内存，如果计划避免Redis内存在此项上的浪费，可以选用allkeys-lru 策略，这样就可以不再设置过期时间，高效利用内存了。</li></ol><p>Redis缓存功能，是由edis.c文件中的freeMemoryIfNeeded函数实现的。如果maxmemory被设置，那么每次在执行命令钱，该函数都会被调用来判断内存是否够用、释放内存、返回错误。如果没有足够的内存程序主逻辑将会阻止设置了REDIS_COM_DENYOOM flag的命令执行，对其返回command not allowed when used memory &gt; ‘maxmemory’的错误消息。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis 淘汰策略 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件——Redis—事务（七）</title>
      <link href="/2020/06/12/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Redis%E2%80%94%E4%BA%8B%E5%8A%A1%EF%BC%88%E4%B8%83%EF%BC%89/"/>
      <url>/2020/06/12/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Redis%E2%80%94%E4%BA%8B%E5%8A%A1%EF%BC%88%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>和众多其它数据库一样，Redis 作为 NoSQL 数据库也同样提供了事务机制。在 Redis 中，MULTI/EXEC/DISCARD/WATCH 这四个命令是我们实现事务的基石。</p><h1 id="Redis-中事务的实现特征"><a href="#Redis-中事务的实现特征" class="headerlink" title="Redis 中事务的实现特征"></a>Redis 中事务的实现特征</h1><ol><li>在事务中的所有命令都将会被串行化的顺序执行</li><li>和关系型数据库中的事务相比，在 Redis 事务中如果有某一条命令执行失败，其后的命令仍然会<br>被继续执行。 </li><li>我们可以通过MULTI命令开启一个事务，有关系型数据库开发经验的人可以将其理解为”BEGIN TRANSACTION”语句。在该语句之后执行的命令都将被视为事务之内的操作，最后我们可以通过执行EXEC/DISCARD 命令来提交/回滚该事务内的所有操作。这两个 Redis 命令可被视为等同于关系型数据库中的 COMMIT/ROLLBACK语句。 </li><li>在事务开启之前，出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行 EXEC 命令之后，那么该事务中的所有命令都会被服务器执行。 </li><li>当使用 Append-Only 模式时，Redis 会通过调用系统函数write 将该事务内的所有写操作在本次调用中全部写入磁盘。    然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。Redis 服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，我们就要充分利用 Redis工具包中提供的redis-check-aof 工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动 Redis 服务器了。</li></ol><h1 id="相关命令列表"><a href="#相关命令列表" class="headerlink" title="相关命令列表"></a>相关命令列表</h1><ol><li><p>MULTI</p><p> 用于标记事务的开始，其后执行的命令都将被存入命令队列，直<br> 到执行 EXEC 时，这些命令才会被原子的执行。 </p></li><li><p>EXEC</p><p> 执行在一个事务内命令队列中的所有命令，同时将当前连接的状<br> 态恢复为正常状态，即非事务状态。如果在事务中执行了<br> WATCH 命令，那么只有当WATCH 所监控的 Keys 没有被修<br> 改的前提下，EXEC 命令才能执行事务队列中的所有命令，否则<br> EXEC 将放弃当前事务中的所有命令。 </p></li><li><p>DISCARD</p><p> 回滚事务队列中的所有命令，同时再将当前连接的状态恢复为正<br> 常状态，即非事务状态。如果 WATCH 命令被使用，该命令将<br> UNWATCH 所有的 Keys。 </p></li><li><p>WATCH</p><p> 在 MULTI 命令执行之前，可以指定待监控的 Keys，然而在执<br> 行 EXEC 之前，如果被监控的 Keys 发生修改，EXEC 将放弃执<br> 行该事务队列中的所有命令。 </p></li><li><p>UNWATCH</p><p> 取消当前事务中指定监控的 Keys，如果执行了 EXEC 或<br> DISCARD 命令，则无需再手工执行该命令了，因为在此之后，<br> 事务中所有被监控的 Keys 都将自动取消。</p></li></ol><h1 id="Redis的事务是原子性的吗？"><a href="#Redis的事务是原子性的吗？" class="headerlink" title="Redis的事务是原子性的吗？"></a>Redis的事务是原子性的吗？</h1><p>原子性：</p><p>数据库中的某个事务A中要更新t1表、t2表的某条记录，当事务提交，t1、t2两个表都被更新，若其中一个表操作失败，事务将回滚。</p><p>非原子性：</p><p>数据库中的某个事务A中要更新t1表、t2表的某条记录，当事务提交，t1、t2两个表都被更新，若其中一个表操作失败，另一个表操作继续，事务不会回滚。（当然对于关系型数据库不会出现非原子性）</p><p>至于Redis的事务是否为原子性，我们通过一些例子进行观察。</p><ol><li>事务正常执行</li></ol><p>给k1、k2分别赋值，在事务中修改k1、k2，执行事务后，查看k1、k2值都被修改。   </p><pre><code>127.0.0.1:6379&gt; set k1 v1OK127.0.0.1:6379&gt; set k2 v2OK127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; set k1 11QUEUED127.0.0.1:6379&gt; set k2 22QUEUED127.0.0.1:6379&gt; EXEC  1) OK  2) OK127.0.0.1:6379&gt; get k1&quot;11&quot;127.0.0.1:6379&gt; get k2&quot;22&quot;127.0.0.1:6379&gt;</code></pre><ol start="2"><li>事务失败处理（语法错误）</li></ol><p>语法错误（编译器错误），在开启事务后，修改k1值为11，k2值为22，但k2语法错误，最终导致事务提交失败，k1、k2保留原值。</p><pre><code>127.0.0.1:6379&gt; set k1 v1OK127.0.0.1:6379&gt; set k2 v2OK127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; set k1 11QUEUED127.0.0.1:6379&gt; sets k2 22(error) ERR unknown command `sets`, with args beginning with: `k2`, `22`, 127.0.0.1:6379&gt; exec(error) EXECABORT Transaction discarded because of previous errors.127.0.0.1:6379&gt; get k1&quot;v1&quot;127.0.0.1:6379&gt; get k2&quot;v2&quot;127.0.0.1:6379&gt;</code></pre><p>看到这里，可以确定Redis的事务是原子性的吗？</p><ol start="3"><li>事务失败处理（运行时错误）</li></ol><p>Redis类型错误（运行时错误），在开启事务后，修改k1值为11，k2值为22，但将k2的类型作为List，在运行时检测类型错误，最终导致事务提交失败，此时事务并没有回滚，而是跳过错误命令继续执行， 结果k1值改变、k2保留原值。</p><pre><code>127.0.0.1:6379&gt; set k1 v1OK127.0.0.1:6379&gt; set k1 v2OK127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; set k1 11QUEUED127.0.0.1:6379&gt; lpush k2 22QUEUED127.0.0.1:6379&gt; EXEC  1) OK  2) (error) WRONGTYPE Operation against a key holding the wrong kind of value127.0.0.1:6379&gt; get k1&quot;11&quot;127.0.0.1:6379&gt; get k2&quot;v2&quot;127.0.0.1:6379&gt;</code></pre><p>为啥语法错误就回滚，类型错误就不回滚？</p><p>因为前者是在入队之前就监测到的，后者是在执行过程中报错，redis为了性能而采取简单的事务。</p><p>严格来说Redis的命令是原子性的，事务并不是原子性的，我们要让Redis事务完全具有事务回滚的能力，需要借助于命令WATCH来实现。</p><h1 id="WATCH"><a href="#WATCH" class="headerlink" title="WATCH"></a>WATCH</h1><p>WATCH提供CAS功能，使用WATCH来监控某些键值对，然后使用MULTI命令来开启事务，执行对数据结构操作的各种命令，此时这些命令入队列。</p><p>当使用EXEC执行事务时，首先会比对WATCH所监控的键值对，如果没发生改变，它会执行事务队列中的命令，提交事务；如果发生变化，将不会执行事务中的任何命令，同时事务回滚。当然无论是否回滚，Redis都会取消执行事务前的WATCH命令。</p><pre><code>127.0.0.1:6379&gt; set k1 v1OK127.0.0.1:6379&gt; set k2 v2OK127.0.0.1:6379&gt; WATCH k1OK127.0.0.1:6379&gt; set k1 11OK127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; set k1 12QUEUED127.0.0.1:6379&gt; set k2 22QUEUED127.0.0.1:6379&gt; EXEC(nil)127.0.0.1:6379&gt; get k1&quot;11&quot;127.0.0.1:6379&gt; get k2&quot;v2&quot;127.0.0.1:6379&gt;</code></pre><h1 id="DISCARD"><a href="#DISCARD" class="headerlink" title="DISCARD"></a>DISCARD</h1><p>不是用EXEC结束事务，而是用DISCARD取消事务，则命令都不会执行。</p><pre><code>redis 127.0.0.1:6379&gt; set t2 tt OK redis 127.0.0.1:6379&gt; multi OK redis 127.0.0.1:6379&gt; set t2 ttnew QUEUED redis 127.0.0.1:6379&gt; discard OK redis 127.0.0.1:6379&gt; get t2 &quot;tt&quot; </code></pre>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件——Redis—持久化（十）</title>
      <link href="/2020/06/11/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Redis%E2%80%94%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2020/06/11/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Redis%E2%80%94%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通常 Redis 将数据存储在内存中或虚拟内存中，它是通过以下两种方式实现对数据的持久化。</p><h1 id="RDB-快照方式（默认持久化方式）"><a href="#RDB-快照方式（默认持久化方式）" class="headerlink" title="RDB 快照方式（默认持久化方式）"></a>RDB 快照方式（默认持久化方式）</h1><p>这种方式就是将内存中数据以快照的方式写入到二进制文件中 ，默认的文件名为dump.rdb。</p><ol><li><p>手动触发</p><p> 客户端可以使用 save 或者 bgsave 命令通知 redis 做一次快照持久化。</p><p> save 操作是在主线程中保存快照的，由于 redis 是用一个主线程来处理所有客户端的请求，这种方式会阻塞所有客户端请求。所以不推荐使用。</p><p> bgsave 操作时Redis主进程会fork一个子进程来完成RDB的过程，完成后自动结束（操作系统的多进程Copy On Write机制，简称COW）。所以Redis主进程阻塞时间只有fork阶段的那一下。相对于save，阻塞时间很短。</p><p> 另一点需要注意的是，每次快照持久化都是将内存数据完整写入到磁盘一次，并不是增量的只同步增量数据。如果数据量大的话，写操作会比较多，必然会引起大量的磁盘 IO 操作，可能会严重影响性能。</p><p> 注意：由于快照方式是在一定间隔时间做一次的，所以如果 redis 意外当机的话，就会丢失最后一次快照后的所有数据修改。</p></li><li><p>自动触发</p><p> 场景一：配置redis.conf，触发规则，自动执行：</p><pre><code># 当在规定的时间内，Redis发生了写操作的个数满足条件，会触发发生BGSAVE命令。# save &lt;seconds&gt; &lt;changes&gt;# 当用户设置了多个save的选项配置，只要其中任一条满足，Redis都会触发一次BGSAVE操作save 900 1 save 300 10 save 60 10000# 以上配置的含义：900秒之内至少一次写操作、300秒之内至少发生10次写操作、# 60秒之内发生至少10000次写操作，只要满足任一条件，均会触发bgsave</code></pre><p> 场景二：执行shutdown命令关闭服务器时，如果没有开启AOF持久化功能，那么会自动执行一次bgsave</p><p> 场景三：主从同步（slave和master建立同步机制） </p></li><li><p>RDB 执行过程</p><p> Redis 使用操作系统的多进程 cow(Copy On Write) 机制来实现RDB快照持久化</p><ul><li><p>执行bgsave命令的时候，Redis主进程会检查是否有子进程在执行RDB/AOF持久化任务，如果有的话，直接返回</p></li><li><p>Redis主进程会fork一个子进程来执行执行RDB操作，fork操作会对主进程造成阻塞（影响Redis的读写），fork操作完成后会发消息给主进程，从而不再阻塞主进程。（阻塞仅指主进程fork子进程的过程，后续子进程执行操作时不会阻塞）</p></li><li><p>RDB子进程会根据Redis主进程的内存生成临时的快照文件，持久化完成后会使用临时快照文件替换掉原来的RDB文件。（该过程中主进程的读写不受影响，但Redis的写操作不会同步到主进程的主内存中，而是会写到一个临时的内存区域作为一个副本）</p></li><li><p>子进程完成RDB持久化后会发消息给主进程，通知RDB持久化完成（将上阶段内存副本中的增量写数据同步到主内存）</p></li></ul></li><li><p>RDB的优缺点</p><p> 优点</p><ul><li><p>RDB文件小，非常适合定时备份，用于灾难恢复</p></li><li><p>Redis加载RDB文件的速度比AOF快很多，因为RDB文件中直接存储的是内存数据，而AOF文件中存储的是一条条命令，需要重演命令。</p><p>缺点：</p></li><li><p>RDB无法做到实时持久化，若在两次bgsave间宕机，则会丢失区间（分钟级）的增量数据，不适用于实时性要求较高的场景</p></li><li><p>RDB的cow机制中，fork子进程属于重量级操作，并且会阻塞redis主进程</p></li><li><p>存在老版本的Redis不兼容新版本RDB格式文件的问题</p></li></ul></li></ol><h1 id="AOF-增量持久化"><a href="#AOF-增量持久化" class="headerlink" title="AOF 增量持久化"></a>AOF 增量持久化</h1><p>AOF日志是持续增量的备份，是基于写命令存储的可读的文本文件。</p><p>AOF日志会在持续运行中持续增大，由于Redis重启过程需要优先加载AOF日志进行指令重放以恢复数据，恢复时间会无比漫长。</p><p>所以需要定期进行AOF重写，对AOF日志进行瘦身。目前AOF是Redis持久化的主流方式。</p><ol><li><p>开启方式</p><p> AOF默认是关闭的，通过redis.conf配置文件进行开启</p><pre><code>## 只有在“yes”下，aof重写/文件同步等特性才会生效  appendonly yes  ## 指定aof文件名称  appendfilename appendonly.aof  ## 指定aof操作中文件同步策略，有三个合法值：always everysec no,默认为everysec  appendfsync everysec  ## 在aof-rewrite期间，appendfsync是否暂缓文件同步，&quot;no&quot;表示“不暂缓”，“yes”表示“暂缓”，默认为“no”  no-appendfsync-on-rewrite no  ## aof文件rewrite触发的最小文件尺寸(mb,gb),只有大于此aof文件大于此尺寸是才会触发rewrite，默认“64mb”，建议“512mb”  auto-aof-rewrite-min-size 64mb  ## 相对于“上一次”rewrite，本次rewrite触发时aof文件应该增长的百分比  ## 每一次rewrite之后，redis都会记录下此时“新aof”文件的大小(例如A)## aof文件增长到A*(1 + p)之后，触发下一次rewrite，每一次aof记录的添加，都会检测当前aof文件的尺寸。  auto-aof-rewrite-percentage 100</code></pre><p> AOF是文件操作，对于变更操作比较密集的server，那么将造成磁盘IO的负荷加重。</p><p> 此外linux对文件操作采取了“延迟写入”手段，即并非每次write操作都会触发实际磁盘操作，而是进入了buffer中，当buffer数据达到阀值时触发实际写入(也有其他时机)，这是linux对文件系统的优化。<strong>这样的持久化还是有可能会丢失部分修改</strong>。</p><p> 所以Linux 的glibc提供了fsync(int fd)函数可以将指定文件的内容强制从内核缓存刷到磁盘。只要 Redis 进程实时调用 fsync 函数就可以保证 aof 日志不丢失。</p><p> 但是 fsync 是一个磁盘 IO 操作，它很慢！如果 Redis 执行一条指令就要 fsync 一次，那么 Redis 高性能的地位就不保了。</p><p> 因此在上述配置文件中，可观察到Redis中提供了3中AOF记录同步选项：</p><ul><li>always：每一条AOF记录都立即同步到文件，性能很低，但较为安全。</li><li>everysec：每秒同步一次，性能和安全都比较中庸的方式，也是redis推荐的方式。如果遇到物理服务器故障，可能导致最多1秒的AOF记录丢失。</li><li>no：Redis永不直接调用文件同步，而是让操作系统来决定何时同步磁盘。性能较好，但很不安全。</li></ul></li><li><p>重写机制</p><p> 日志追加方式同时带来了另一个问题。持久化文件会变的越来越大。此时就需要对AOF进行重写，瘦身。</p><p> AOF Rewrite 虽然是“压缩”AOF文件的过程，但并非采用“基于原AOF文件”来重写或压缩，而是采取了类似RDB快照的方式：基于Copy On Write，全量遍历内存中数据，然后逐个序列到AOF文件中。因此AOF rewrite能够正确反应当前内存数据的状态。</p><p> AOF重写（bgrewriteaof）和RDB快照写入（bgsave）过程类似，二者都消耗磁盘IO。Redis采取了“schedule”策略：无论是“人工干预”还是系统触发，快照和重写需要逐个被执行。</p><p> 重写过程中，对于新的变更操作将仍然被写入到原AOF文件中，同时这些新的变更操作也会被Redis收集起来。当内存中的数据被全部写入到新的AOF文件之后，收集的新的变更操作也将被一并追加到新的AOF文件中。然后将新AOF文件重命名为appendonly.aof，使用新AOF文件替换老文件，此后所有的操作都将被写入新的AOF文件。</p><p> AOF重写默认大小64m太小 可改5g以上 避免重写频繁，在4.0之前会将相同的操作进行合并（比如连续使用set进行了三次，重写会将这三次合并成一次命令存到文件中，这样文件就会变小），在 4.0之后是混合持久化。</p></li><li><p>重写触发机制</p><p> 和RDB类似，AOF触发机制也分为：手动触发和自动触发 </p><p> 手动触发 </p><p> 直接调用bgrewriteaof命令</p><blockquote><p>redis-cli -h ip -p port bgrewriteaof</p></blockquote><p> 自动触发 </p><p> 根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数确定自动触发时机</p><blockquote><p>auto-aof-rewrite-min-size:表示运行AOF重写时文件最小体积，默认为64MB（我们线上是512MB）。<br>auto-aof-rewrite-percentage:代表当前AOF文件空间（aof_current_size）和上一次重写后AOF文件空间（aof_base_size）的值</p></blockquote><p> 其中aof_current_size和aof_base_size可以在info Persistence统计信息中查看。</p></li><li><p>AOF 优缺点</p><p> 优点 </p><ul><li><p>AOF只是追加写日志文件，对服务器性能影响较小，速度比RDB要快，消耗的内存较少</p><p>缺点 </p></li><li><p>AOF方式生成的日志文件太大，需要不断AOF重写，进行瘦身。<br>即使经过AOF重写瘦身，由于文件是文本文件，文件体积较大（相比于RDB的二进制文件）。 </p></li><li><p>AOF重演命令式的恢复数据，速度显然比RDB要慢。</p></li></ul></li></ol><h1 id="Redis-4-0-混合持久化"><a href="#Redis-4-0-混合持久化" class="headerlink" title="Redis 4.0 混合持久化"></a>Redis 4.0 混合持久化</h1><ul><li>仅使用RDB快照方式恢复数据，由于快照时间粒度较大，会丢失大量数据。</li><li>仅使用AOF重放方式恢复数据，日志性能相对 rdb 来说要慢。在 Redis 实例很大的情况下，启动需要花费很长的时间。</li></ul><p>Redis 4.0 为了解决这个问题，带来了一个新的持久化选项——混合持久化。将 rdb 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是自持久化开始到持久化结束的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小。</p><p>混合持久化同样也是通过bgrewriteaof完成的，不同的是当开启混合持久化时，fork出的子进程先将共享的内存副本全量的以RDB方式写入aof文件，然后在将重写缓冲区的增量命令以AOF方式写入到文件，写入完成后通知主进程更新统计信息，并将新的含有RDB格式和AOF格式的AOF文件替换旧的的AOF文件。简单的说：新的AOF文件前半段是RDB格式的全量数据后半段是AOF格式的增量数据。</p><p>大量数据使用粗粒度（时间上）的rdb快照方式，性能高，恢复时间快。增量数据使用细粒度（时间上）的AOF日志方式，尽量保证数据的不丢失。</p><p>开启混合持久化</p><p>4.0版本的混合持久化默认关闭的，通过aof-use-rdb-preamble配置参数控制，yes则表示开启，no表示禁用，默认是禁用的，可通过config set修改。</p><p>在 Redis 重启的时候，可以先加载 rdb 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升。</p><h1 id="持久化设置"><a href="#持久化设置" class="headerlink" title="持久化设置"></a>持久化设置</h1><ol><li>RBD和AOF建议同时打开（Redis4.0之后支持）</li><li>RDB做冷备，AOF做数据恢复（数据更可靠）</li><li>RDB采取默认配置即可，AOF推荐采取everysec每秒策</li></ol><h1 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h1><p>我们需要定时备份rdb文件来做冷备，为什么？</p><p>不是有aof和rbd了吗为什么还要单独写定时任务去备份？</p><p>因为Redis的aof和rdb是仅仅有一个最新的，比如谁手贱再Redis宕机的时候执行rm -rf aof/rdb了，那不就GG了吗？或者rdb/aof文件损坏了等不可预期的情况。所以我们需要单独备份rdb文件以防万一。</p><h1 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h1><ol><li><p>redis挂了</p><p> 如果仅仅是redis进程挂了，那么直接重启redis进程即可，Redis会按照持久化配置直接基于持久化文件进行恢复数据。</p><p> 如果有AOF则按照AOF，AOF和RDB一起开的话也走AOF。</p></li><li><p>持久化文件丢了</p><p> 如果持久化文件（rdb/aof）损坏了，或者直接丢失了。那么就要采取我们上面所做的rdb备份来进行恢复了。</p><p> 方案一：直接把备份的rdb扔到redis持久化目录下然后重启redis</p><p> 不行的原因在于：redis是按照先aof后rdb进行恢复的，所以都是开启aof的，redis启动后会重新生成新的aof文件，里面是空的。所以不会进行任何数据恢复，也就是说虽然你把rdb丢给redis了，但是redis会按照aof来恢复，而aof是redis启动的时候新生成的空文件，所以不会有任何数据进行恢复。</p><p> 方案二：那么我们把rdb文件丢给redis后，先将redis的aof关闭再启动redis进程不就能按照rdb来进行恢复了吗？</p><p> 是这样的，没毛病！但是新的问题来了，我们aof肯定要开的，aof对数据保障更可靠。那什么我们按照rdb文件恢复完后再修改redis配置文件开启aof然后重启redis进程不就得了嘛？大哥…你打开aof然后重启redis，这时候redis又会生成一个空的aof文件，这时候恢复的时候又是啥数据都没了。</p><p> 可行方案：我不管你是持久化文件丢了还是坏了，我都先rm -rf * 给他删了。</p><ul><li>停止redis进程</li><li>删除坏掉的rdb和aof持久化文件。</li><li>修改配置文件关闭redis的aof持久化。</li><li>找到最新备份的rdb文件扔到redis的持久化目录里。（这里最新的肯定是按照小时备份的最后一个）</li><li>启动Redis进程</li><li>执行set appendonly yes动态打开aof持久化。</li><li>等aof文件生成后再修改redis配置文件打开aof。</li><li>重启redis进程。</li></ul></li></ol><h1 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h1><ol><li><p>scan+MIGRATE</p><p> 先scan出key，然后使用redis自带命令MIGRATE执行建的迁移。<br> 说明：MIGRATE命令在redis&gt;=2.6.0版本才有，Redis3.06版本之后支持迁移多个键。</p></li><li><p>dump</p><p> 现在源redis执行dump命令，该redis的所有数据会序列化成rdb文件；然后把rdb文件拷贝到目标redis，重启目标redis。<br> 说明：这种方式优点是操作简单，不需要研发再另外写程序迁移。缺点是：需要运维手动操作。</p></li><li><p>scan+hset/set</p><p> 先scan出key，然后判断这个key属于哪种类型，执行对应的写命令hset、set等。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis 持久化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件——Redis—主从、哨兵、集群（六）</title>
      <link href="/2020/06/11/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Redis%E2%80%94%E4%B8%BB%E4%BB%8E%E3%80%81%E5%93%A8%E5%85%B5%E3%80%81%E9%9B%86%E7%BE%A4%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2020/06/11/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Redis%E2%80%94%E4%B8%BB%E4%BB%8E%E3%80%81%E5%93%A8%E5%85%B5%E3%80%81%E9%9B%86%E7%BE%A4%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果在实际生产中，如果redis只部署一个节点，当机器故障时，整个服务都不能提供服务了。这就是我们常说的单点故障。</p><p>如果redis部署了多台，当一台或几台故障时，整个系统依然可以对外提供服务，这样就提高了服务的可用性。</p><p>redis高可用的三种模式：主从模式，哨兵模式，集群模式。</p><h1 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h1><p>Redis提供了复制(replication)功能，当一台redis数据库中的数据发生了变化，这个变化会被自动的同步到其他的redis机器上去。</p><p>redis多机器部署时，这些机器节点会被分成两类，一类是主节点（master节点），一类是从节点（slave节点）。一般主节点可以进行读、写操作，而从节点只能进行读操作。同时由于主节点可以写，数据会发生变化，当主节点的数据发生变化时，会将变化的数据同步给从节点，这样从节点的数据就可以和主节点的数据保持一致了。一个主节点可以有多个从节点，但是一个从节点会只会有一个主节点，也就是所谓的一主多从结构。</p><ol><li><p>主从复制机制</p><p> 从数据库连接主数据库，发送SYNC命令;</p><p> 主数据库接收到SYNC命令后，可以执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令;</p><p> 主数据库BGSAVE执行完后，向所有从数据库发送快照文件，并在发送期间继续记录被执行的写命令;</p><p> 从数据库收到快照文件后丢弃所有旧数据，载入收到的快照;</p><p> 主数据库快照发送完毕后开始向从数据库发送缓冲区中的写命令;</p><p> 从数据库完成对快照的载入，开始接受命令请求，并执行来自主数据库缓冲区的写命令;(从数据库初始化完成)</p><p> 主数据库每执行一个写命令就会向从数据库发送相同的写命令，从数据库接收并执行收到的写命令(从数据库初始化完成后的操作)</p><p> 出现断开重连后，2.8之后的版本会将断线期间的命令传给从数据库，增量复制。</p><p> 主从刚刚连接的时候，进行全量同步;全同步结束后，进行增量同步。当然，如果有需要，slave在任何时候都可以发起全量同步。Redis的策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</p></li><li><p>手动重置master</p><p> 系统运行时，如果master挂掉了，可以在一个从库（如slave1）上手动执行命令slaveof no one，将slave1变成新的master；在slave2和slave3上分别执行slaveof 192.168.1.11 6379 将这两个机器的主节点指向的这个新的master；同时，挂掉的原master启动后作为新的slave也指向新的master上。</p><p> 执行命令slaveof no one命令，可以关闭从服务器的复制功能。同时原来同步的所得的数据集都不会被丢弃。</p></li><li><p>优缺点<br>优点：</p><p>读写分离、异步复制</p><p>缺点：</p><p>可用性低，主机从机的宕机都会造成部分读写失败。<br>主机宕机，宕机前有部分数据未同步，会造成数据丢失<br>多个从机掉线，一起启动，全部全复制，可能导致master IO剧增而宕机<br>难以扩容<br>主节点和从节点数据一样，降低内存可用性。</p></li></ol><h1 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h1><p>主从模式下，当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这种方式并不推荐，实际生产中，我们优先考虑哨兵模式。这种模式下，master宕机，哨兵会自动选举master并将其他的slave指向新的master。</p><p>在主从模式下，redis同时提供了哨兵命令redis-sentinel，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵进程向所有的redis机器发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</p><p>哨兵可以有多个，一般为了便于决策选举，使用奇数个哨兵。哨兵可以和redis机器部署在一起，也可以部署在其他的机器上。多个哨兵构成一个哨兵集群，哨兵直接也会相互通信，检查哨兵是否正常运行，同时发现master宕机哨兵之间会进行决策选举新的master</p><ol><li><p>哨兵模式的作用</p><ul><li><p>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器;</p></li><li><p>当哨兵监测到master宕机，会自动将slave切换到master，然后通过发布订阅模式通过其他的从服务器，修改配置文件，让它们切换主机;</p></li><li><p>然而一个哨兵进程对Redis服务器进行监控，也可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p></li></ul></li><li><p>哨兵模式的工作</p><p>假设master宕机，sentinel 1先检测到这个结果，系统并不会马上进行 failover(故障转移)选出新的master，仅仅是sentinel 1主观的认为master不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时（配置参数值），那么哨兵之间就会进行一次投票，投票的结果由sentinel 1发起，进行 failover 操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。这样对于客户端而言，一切都是透明的。</p></li><li><p>优缺点</p><p> 优点：</p><p> 主从可以自动切换，系统更健壮，可用性更高。</p><p> 缺点：</p><p> 具有主从模式的缺点，每台机器上的数据是一样的，内存的可用性较低。</p><p> Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。</p></li></ol><h1 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h1><p>Redis 的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存，所以在redis3.0上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，对数据进行分片，也就是说每台 Redis 节点上存储不同的内容；</p><p>集群中redis两两之间并不是独立的，每个节点都会通过集群总线(cluster bus)，与其他的节点进行通信。通讯时使用特殊的端口号，即对外服务端口号加10000。例如如果某个node的端口号是6379，那么它与其它nodes通信的端口号是16379。nodes之间的通信采用特殊的二进制协议。</p><p>对客户端来说，整个cluster被看做是一个整体，客户端可以连接任意一个node进行操作，就像操作单一Redis实例一样，当客户端操作的key没有分配到该node上时，Redis会返回转向指令，指向正确的node，这有点儿像浏览器页面的302 redirect跳转。</p><p>为了保证其高可用性，当一台机器宕机其上的数据也会丢失，采用了先前将的主从复制模式，一个master节点有n个从节点。</p><ol><li><p>数据分片</p><p> 为了使得集群能够水平扩展，首要解决的问题就是如何将整个数据集按照一定的规则分配到多个节点上，常用的数据分片的方法有：范围分片，哈希分片，一致性哈希算法，哈希槽等。</p><p> 范围分片假设数据集是有序，将顺序相临近的数据放在一起，可以很好的支持遍历操作。范围分片的缺点是面对顺序写时，会存在热点。比如日志类型的写入，一般日志的顺序都是和时间相关的，时间是单调递增的，因此写入的热点永远在最后一个分片。对于关系型的数据库，因为经常性的需要表扫描或者索引扫描，基本上都会使用范围的分片策略。</p><p> 我们为了将不同的 key 分散放置到不同的 redis 节点，通常的做法是获取 key 的哈希值，然后根据节点数来求模，但这种做法有其明显的弊端，当我们需要增加或减少一个节点时，会造成大量的 key 无法命中，这种比例是相当高的，所以就有人提出了一致性哈希的概念。</p><p> <a href="https://mp.weixin.qq.com/s?__biz=MzI2MTk1NDY0Mw==&mid=2247483768&idx=1&sn=fee0eda48ea283de79d787387ae5d89e&chksm=ea53cc44dd24455248ce8ce49aefa2d707b61041a221322dcba86bdeeb4295f0c61be2c40f70&scene=21" target="_blank" rel="noopener">一致性哈希算法</a></p><p> 一致性哈希有四个重要特征：</p><ul><li>均衡性：也有人把它定义为平衡性，是指哈希的结果能够尽可能分布到所有的节点中去，这样可以有效的利用每个节点上的资源。</li><li>单调性：当节点数量变化时哈希的结果应尽可能的保护已分配的内容不会被重新分派到新的节点。</li><li>分散性和负载：这两个其实是差不多的意思，就是要求一致性哈希算法对 key 哈希应尽可能的避免重复。</li></ul></li><li><p>哈希槽</p><p> Redis 集群没有使用一致性hash, 而是引入了哈希槽的概念。</p><p> Redis Cluster 采用虚拟哈希槽分区，所有的键根据哈希函数映射到 0 ~ 16383 整数槽内，每个key通过CRC16校验后对16384取模来决定放置哪个槽(Slot)，每一个节点负责维护一部分槽以及槽所映射的键值数据。</p><p> 计算公式：slot = CRC16(key) &amp; 16383。</p><p> 这种结构很容易添加或者删除节点，并且无论是添加删除或者修改某一个节点，都不会造成集群不可用的状态。使用哈希槽的好处就在于可以方便的添加或移除节点。</p><p> 当需要增加节点时，只需要把其他节点的某些哈希槽挪到新节点就可以了；<br> 当需要移除节点时，只需要把移除节点上的哈希槽挪到其他节点就行了。</p><p> 当持有槽的主节点下线时，从故障发现到自动完成转移期间整个集群是不可用状态，对于大多数业务无法忍受这情况，因此建议将参数 cluster-require-full-coverage 配置为 no ，当主节点故障时只影响它负责槽的相关命令执行，不会影响其他主节点的可用性。</p><p> 为什么RedisCluster会设计成16384个槽呢?</p><p> 从网络带宽、节点数量、压缩率考虑。</p></li><li><p>集群扩缩容</p><p> 扩容时，先使用redis-tri.rb add-node将新的机器加到集群中，这是新机器虽然已经在集群中了，但是没有分配slots，依然是不起做用的。在使用  redis-tri.rb reshard进行分片重哈希（数据迁移），将旧节点上的slots分配到新节点上后，新节点才能起作用。</p><p> 缩容时，先要使用  redis-tri.rb reshard移除的机器上的slots，然后使用redis-tri.rb add-del移除机器。</p></li><li><p>优缺点</p><p> 优点：</p><p> 采用去中心化思想，数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布;</p><p> 可扩展性：可线性扩展到 1000 多个节点，节点可动态添加或删除;</p><p> 高可用性：部分节点不可用时，集群仍可用。通过增加 Slave 做 standby 数据副本，能够实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave 到 Master 的角色提升;</p><p> 降低运维成本，提高系统的扩展性和可用性。</p><p> 缺点：</p><p> Redis Cluster是无中心节点的集群架构，依靠Goss协议(谣言传播)协同自动化修复集群的状态，但 GosSIp有消息延时和消息冗余的问题，在集群节点数量过多的时候，节点之间需要不断进行 PING/PANG通讯，不必须要的流量占用了大量的网络资源。虽然Reds4.0对此进行了优化，但这个问题仍然存在。</p><p> Redis Cluster可以进行节点的动态扩容缩容，这一过程，在目前实现中，还处于半自动状态，需要人工介入。在扩缩容的时候，需要进行数据迁移。</p><p> 而 Redis为了保证迁移的一致性，迁移所有操作都是同步操作，执行迁移时，两端的 Redis均会进入时长不等的阻塞状态，对于小Key，该时间可以忽略不计，但如果一旦Key的内存使用过大，严重的时候会接触发集群内的故障转移，造成不必要的切换。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis 主从、哨兵、集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件——Redis—入门（二）</title>
      <link href="/2020/06/09/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Redis%E2%80%94%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/06/09/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Redis%E2%80%94%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Redis 是 C 语言开发的一个开源的高性能键值对（key-value）的NoSQL内存数据库，可以用作数据库、缓存、消息中间件等。</p><p>优点：</p><p>速度快（每秒10万次读写）、多种数据结构、支持多种客户端语言、功能丰富、支持集群分布式。</p><p>缺点：</p><p>成本高昂（消耗cpu、内存）、持久化影响性能。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><ol><li>缓存系统</li></ol><p>缓存是Redis最常见的应用场景，之所有这么使用，主要是因为Redis读写性能优异。而且逐渐有取代memcached，成为首选服务端缓存的组件。而且，Redis内部是支持事务的，在使用时候能有效保证数据的一致性。 </p><ol start="2"><li>丰富的数据格式性能更高，应用场景丰富</li></ol><p>Redis相比其他缓存，有一个非常大的优势，就是支持多种数据类型。</p><ul><li>string——适合最简单的k-v存储，类似于memcached的存储结构，短信验证码，配置信息等，就用这种类型来存储。</li><li>hash——一般key为ID或者唯一标示，value对应的就是详情了。如商品详情，个人信息详情，新闻详情等。</li><li>list——因为list是有序的，比较适合存储一些有序且数据相对固定的数据。如省市区表、字典表等。因为list是有序的，适合根据写入的时间来排序，如：最新的***，消息队列等。</li><li>set——可以简单的理解为ID-List的模式，如微博中一个人有哪些好友，set最牛的地方在于，可以对两个set提供交集、并集、差集操作。例如：查找两个人共同的好友等。</li><li>Sorted Set——是set的增强版本，增加了一个score参数，自动会根据score的值进行排序。比较适合类似于top 10等不根据插入的时间来排序的数据。</li></ul><ol start="3"><li>作为分布式锁</li></ol><p>redis支持setnx操作（即key不存在的情况下设置value），这种特性常用来做分布式锁的实现。</p><ol start="4"><li>过期时间设置</li></ol><p>最常见的就是：短信验证码、具有时间性的商品展示等。无需像数据库还要去查时间进行对比。因为使用比较简单，就不赘述了。</p><h1 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h1><ol><li><p>TCP协议</p><p> Redis底层网络通信协议其实是通过TCP来完成的。</p></li><li><p>RESP协议。</p><p>Redis客户端和服务器端使用的序列化协议，它是特意为Redis设计的，同时也可以用于其他软件工程。</p><p>RESP可以序列化多种不同的数据类型，比如：整型、字符串、数组。错误是一种特定的类型。Redis客户端把参数用数组来表示。回复的是一种特殊的数据格式。</p></li><li><p>pipeline管道</p><p> pipeline管道就是解决执行大量命令时、会产生大量数据来回次数而导致延迟的技术。其实原理比较简单，pipeline是把所有的命令一次发过去，避免频繁的发送、接收带来的网络开销，redis在打包接收到一堆命令后，依次执行，然后把结果再打包返回给客户端。</p></li><li><p>单线程</p><p> redis虽然是单线程，却是直接操作内存，同时使用了IO多路复用，异步非阻塞，效率依然可观。</p></li></ol><h1 id="请求处理过程"><a href="#请求处理过程" class="headerlink" title="请求处理过程"></a>请求处理过程</h1><p><img src="/images/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Redis%E2%80%94%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89_2020-10-29-13-54-02.png" alt="消息中间件——Redis—基础（二）_2020-10-29-13-54-02.png"></p><p>可以看到整个请求过程操作都离不开文本事件处理器</p><ol><li><p>当Redis启动时，在所监听的 socket 上 创建文件事件处理器，监听 socket 建立连接的事件。</p></li><li><p>当用户在客户端中键入一个命令请求时， 客户端会将这个命令请求转换成协议格式（RESP）， 然后建立到服务器的socket，建立client,注册socket读取事件处理器，将协议格式的命令请求发送给服务器（读取事件处理器）。</p></li><li><p>服务器端读取套接字中协议格式的命令请求， 并将其保存到客户端状态的输入缓冲区里面。</p></li><li><p>对输入缓冲区中的命令请求进行分析， 提取出命令请求中包含的命令参数， 以及命令参数的个数， 然后分别将参数和参数个数保存到客户端状态的 argv 属性和 argc 属性里面。</p></li><li><p>调用命令执行器， 执行客户端指定的命令，命令实现函数会将命令回复保存到客户端的输出缓冲区里面。</p></li><li><p>注册socket写入事件处理器，从输入缓冲区写回数据到socket,关闭client,清空缓冲区。</p></li></ol><h1 id="IO多路复用模型"><a href="#IO多路复用模型" class="headerlink" title="IO多路复用模型"></a>IO多路复用模型</h1><p>多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</p><p>在 I/O 多路复用模型中，最重要的函数调用就是 select，该方法的能够同时监控多个文件描述符的可读可写情况，当其中的某些文件描述符可读或者可写时，select 方法就会返回可读以及可写的文件描述符个数。</p><p>Redis 服务采用 Reactor 的方式来实现文件事件处理器（每一个网络连接其实都对应一个文件描述符）</p><p><img src="/images/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Redis%E2%80%94%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89_2020-10-29-14-09-01.png" alt="消息中间件——Redis—基础（二）_2020-10-29-14-09-01.png"></p><p>文件事件处理器使用 I/O 多路复用模块同时监听多个 FD，当 accept、read、write 和 close 文件事件产生时，文件事件处理器就会回调 FD 绑定的事件处理器。</p><p>虽然整个文件事件处理器是在单线程上运行的，但是通过 I/O 多路复用模块的引入，实现了同时对多个 FD 读写的监控，提高了网络通信模型的性能，同时也可以保证整个 Redis 服务实现的简单。</p><h1 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h1><p>redis提供了多种数据结构，我们主要了解其中五种基础数据结构：String、Hash、List、Set、Sorted Set。</p><p>Redis 的 key 是字符串类型，但是 key 中不能包括边界字符，由于 key 不是 binary safe<br>的字符串，所以像”my key”和”mykey\n”这样包含空格和换行的 key 是不允许的。</p><p>首先redis内部使用一个redisObject对象来表示所有的key和value.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123; </span><br><span class="line"> unsigned [type] <span class="number">4</span>; </span><br><span class="line"> unsigned [encoding] <span class="number">4</span>; </span><br><span class="line"> unsigned [lru] REDIS_LRU_BITS; </span><br><span class="line"> <span class="keyword">int</span> refcount; </span><br><span class="line"> <span class="keyword">void</span> *ptr; </span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>简单介绍一下这几个字段：</p><ul><li>type：数据类型，就是我们熟悉的string、hash、list等。</li><li>encoding：内部编码，其实就是本文要介绍的数据结构。指的是当前这个value底层是用的什么数据结构。因为同一个数据类型底层也有多种数据结构的实现，所以这里需要指定数据结构。</li><li>REDIS_LRU_BITS：当前对象可以保留的时长。这个我们在后面讲键的过期策略的时候讲。</li><li>refcount：对象引用计数，用于GC。</li><li>ptr：指针，指向以encoding的方式实现这个对象的实际地址。</li></ul><ol><li><p>String（字符串）</p><p>应用场景：</p><p>存储key-value键值对，这个比较简单不细说了</p></li><li><p>list(列表)</p><p>应用场景：</p><p> 由于list它是一个按照插入顺序排序的列表，所以应用场景相对还较多的，例如：</p><ul><li>消息队列：lpop和rpush（或者反过来，lpush和rpop）能实现队列的功能</li><li>朋友圈的点赞列表、评论列表、排行榜：lpush命令和lrange命令能实现最新列表的功能，每次通过lpush命令往列表里插入新的元素，然后通过lrange命令读取最新的元素列表。</li></ul></li><li><p>hash （字典）</p><p>应用场景：</p><ul><li>购物车：hset [key] [field] [value] 命令， 可以实现以用户Id，商品Id为field，商品数量为value，恰好构成了购物车的3个要素。</li><li>存储对象：hash类型的(key, field, value)的结构与对象的(对象id, 属性, 值)的结构相似，也可以用来存储对象。</li></ul></li><li><p>set(集合)</p><p>应用场景：</p><ul><li>好友、关注、粉丝、感兴趣的人集合： </li><li>首页展示随机：美团首页有很多推荐商家，但是并不能全部展示，set类型适合存放所有需要展示的内容，而srandmember命令则可以从中随机获取几个。</li><li>存储某活动中中奖的用户ID ，因为有去重功能，可以保证同一个用户不会中奖两次。</li></ul></li><li><p>zset(有序集合)</p><p>应用场景：</p><ul><li>zset 可以用做排行榜，但是和list不同的是zset它能够实现动态的排序，例如： 可以用来存储粉丝列表，value 值是粉丝的用户 ID，score 是关注时间，我们可以对粉丝列表按关注时间进行排序。</li><li>zset 还可以用来存储学生的成绩， value 值是学生的 ID, score 是他的考试成绩。 我们对成绩按分数进行排序就可以得到他的名次。</li></ul></li></ol><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>目前主流的客户端有三种，Jedis、Lettuce、Redisson,我们从几个方面比较以下它们。</p><ol><li><p>性能</p><p> Jedis的性能比lettuce和Redisson都要差一点，三者的主要差异在于以下:</p><ul><li><p>Jedis使用同步和阻塞IO的方式，不支持异步；lettuce和Redisson支持异步，底层是基于netty框架的事件驱动作为通信层。</p></li><li><p>Jedis设计上就是基于线程不安全来设计，一个连接只能被一个线程使用，但是可以结合连接池来提高其性能；lettuce和Redis基于线程安全来设计的，一个连接是被共享使用的，但是也提供了连接池，主要用于事务以及阻塞操作的命令。</p></li><li><p>lettuce和Redisson支持异步流的方式。</p></li></ul></li><li><p>功能</p><ul><li><p>Jedis: 提供比较全面的redis原生指令的支持，上层封装比较弱，集群特性支持度非常低，高级特性几乎没有。</p></li><li><p>lettuce: 高级redis客户端，支持各种模式的redis连接和操作，高级特性几乎没有。</p></li><li><p>Redisson: 高级redis客户端，支持各种模式的redis连接和操作，同时提供一大堆的实用功能。</p></li></ul></li><li><p>Redisson</p><p> Redisson支持了很多高级功能：分布式锁、事务、RPC、分布式任务调度等；</p><p> 实际上单是使用Redisson作为Spring的客户端就足够了。但是Redisson实际上对字符串操作支持性差。</p><p> 个人倾向lettuce，如果需要分布式锁、分布式集合等分布式高级特性可以结合 Redisson 使用。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件——Kafka—持久化、高性能（四）</title>
      <link href="/2020/06/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Kafka%E2%80%94%E6%8C%81%E4%B9%85%E5%8C%96%E3%80%81%E9%AB%98%E6%80%A7%E8%83%BD%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2020/06/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Kafka%E2%80%94%E6%8C%81%E4%B9%85%E5%8C%96%E3%80%81%E9%AB%98%E6%80%A7%E8%83%BD%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="储存模型"><a href="#储存模型" class="headerlink" title="储存模型"></a>储存模型</h1><p>Kafka节点上，一个Partition的每个副本对应一个磁盘目录，新的日志，都是直接append到文件末尾，所以不管文件多大，写入总是O(1)的时间复杂度。但如果文件很大，顺序查找的效率也会很低。kafka通过两种方式解决：分段、索引。</p><h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><p>比如有100条 Message，它们的offset是从0到99。假设将数据文件分成5段，第一段为0-19，第二段为20-39，以此类推，每段放在一个单独的数据文 件里面，数据文件以该段中最小的offset命名。这样在查找指定offset的Message的时候，用二分查找就可以定位到该Message在哪个段 中。</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>数据文件分段使得可以在一个较小的数据文件中查找对应offset的 Message了，但是这依然需要顺序扫描才能找到对应offset的Message。为了进一步提高查找的效率，Kafka为每个分段后的数据文件建立 了索引文件，文件名与数据文件的名字是一样的，只是文件扩展名为.index。</p><p>索引文件中包含若干个索引条目，每个条目表示数据文件中一条Message的索引。索引包含两个部分（均为4个字节的数字），分别为相对offset和position。</p><p>注: index文件中并没有为数据文件中的每条Message建立索引，而是采用了 稀疏存储 的方式，每隔一定字节的数据建立一条索引。这样避免了索引文件占用过多的空间，从而可以将索引文件保留在内存中。但缺点是没有建立索引的 Message也不能一次定位到其在数据文件的位置，从而需要做一次顺序扫描，但是这次顺序扫描的范围就很小了。</p><h1 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h1><h2 id="顺序读写"><a href="#顺序读写" class="headerlink" title="顺序读写"></a>顺序读写</h2><p>kafka采用的磁盘的顺序读写比无序快了太多，这是由操作系统决定的，即使是普通的机械磁盘，顺序访问速率也接近了内存的随机访问速率。</p><p>即使是顺序读写，过于频繁的大量小IO操作一样会造成磁盘的瓶颈，此时又变成了随机读写。Kafka的策略是把消息集合在一起，批量发送，尽可能减少对磁盘的访问。所以，Kafka的Topic和Partition数量不宜过多，超过64个Topic/Partition以后，Kafka性能会急剧下降。</p><h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>Kafka中存在大量的网络数据持久化到磁盘（Producer到Broker）和磁盘文件通过网络发送（Broker到Consumer）的过程。这一过程的性能直接影响Kafka的整体吞吐量。</p><p>Linux 2.4+内核通过sendfile系统调用，提供了零拷贝。数据通过DMA拷贝到内核态Buffer后，直接通过DMA拷贝到NIC Buffer，无需CPU拷贝。这也是零拷贝这一说法的来源。除了减少数据拷贝外，因为整个读文件-网络发送由一个sendfile调用完成，整个过程只有两次上下文切换，因此大大提高了性能。</p><p>Kafka的数据传输通过TransportLayer来完成，其子类PlaintextTransportLayer通过Java NIO的FileChannel的transferTo和transferFrom方法实现零拷贝。</p><h2 id="页缓存"><a href="#页缓存" class="headerlink" title="页缓存"></a>页缓存</h2><p>Kafka并不太依赖JVM内存大小，而是主要利用Page Cache，如果使用应用层缓存（JVM堆内存），会增加GC负担，增加停顿时间和延迟，创建对象的开销也会比较高。</p><p>读取操作可以直接在Page Cache上进行，如果消费和生产速度相当，甚至不需要通过物理磁盘直接交换数据，这是Kafka高吞吐量的一个重要原因。</p><p>这么做还有一个优势，如果Kafka重启，JVM内的Cache会失效，Page Cache依然可用。</p>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka 持久化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件——Kafka—无消息丢失和幂等性（三）</title>
      <link href="/2020/06/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Kafka%E2%80%94%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E4%B8%8E%E5%B9%82%E7%AD%89%E6%80%A7%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2020/06/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Kafka%E2%80%94%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E4%B8%8E%E5%B9%82%E7%AD%89%E6%80%A7%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="无消息丢失"><a href="#无消息丢失" class="headerlink" title="无消息丢失"></a>无消息丢失</h1><p>首先要先清楚大部分情况下消息丢失是在什么情况下发生的。</p><h2 id="生产者丢失"><a href="#生产者丢失" class="headerlink" title="生产者丢失"></a>生产者丢失</h2><p>producer客户端有一个acks的配置:</p><ul><li>这个配置为0的时候，producer是发送之后不管的，这个时候就很有可能因为网络等原因造成数据丢失，所以应该尽量避免。</li><li>但是将ack设置为1就没问题了吗，那也不一定，因为有可能在leader副本接收到数据，但还没同步给其他副本的时候就挂掉了，这时候数据也是丢失了。</li><li>要达到最严格的无消息丢失配置，应该是要将acks的参数设置为-1（也就是all），并且将 <code>min.insync.replicas</code> 配置项调高到大于1（最小ISR个数）。</li></ul><p>当然生产者还需要以异步获取发送结果的方式发送数据，min.insync.replicas,而当数据发送丢失的时候，就可以进行手动重发或其他操作，从而确保生产者发送成功。</p><h2 id="kafka内部丢失"><a href="#kafka内部丢失" class="headerlink" title="kafka内部丢失"></a>kafka内部丢失</h2><ol><li><p>副本数量</p><p> replication.factor配置参数代表副本数量，默认为1。实际上我们需要将其设置为大于1，防止磁盘损坏，数据丢失。</p></li><li><p>leader选举</p><p><code>unclean.leader.election.enable</code> 参数，这个参数是在主副本挂掉，然后在ISR集合中没有副本可以成为leader的时候，要不要让进度比较慢的副本成为leader的。</p><p>不用多说，让进度比较慢的副本成为leader，肯定是要丢数据的。虽然可能会提高一些可用性，但如果你的业务场景丢失数据更加不能忍受，那还是将unclean.leader.election.enable设置为false吧。</p></li></ol><h2 id="消费者丢失"><a href="#消费者丢失" class="headerlink" title="消费者丢失"></a>消费者丢失</h2><p>消费者丢失的问题主要跟 offset 处理不当有关。</p><p>消费者位移提交有一个参数，enable.auto.commit，默认是true，决定是否要让消费者自动提交位移。如果开启，那么consumer每次都是先提交位移，再进行消费，这样处理的话，好处是简单，坏处就是漏消费数据。</p><p>如果设置为false，改为手动提交位移，在每次消费完之后再手动提交位移信息。又会造成重复消费的问题。</p><h2 id="无消息丢失配置总结"><a href="#无消息丢失配置总结" class="headerlink" title="无消息丢失配置总结"></a>无消息丢失配置总结</h2><ul><li>producer的acks设置位-1，同时min.insync.replicas设置大于1。并且使用带有回调的producer api发生消息。</li><li>默认副本数replication.factor设置为大于1，或者创建topic的时候指定大于1的副本数。</li><li>unclean.leader.election.enable 设置为false，防止定期副本leader重选举</li><li>消费者端，自动提交位移enable.auto.commit设置为false。在消费完后手动提交位移。</li></ul><h2 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h2><p>幂等这个词最早起源于函数式编程，意思是一个函数无论执行多少次都会返回一样的结果。比如说让一个数加1就不是幂等的，而让一个数取整就是幂等的。因为这个特性所以幂等的函数适用于并发的场景下。</p><p>在kafka中，幂等性意味着一个消息无论重复多少次，都会被当作一个消息来持久化处理。及 精确一次（exactly once）。要实现 exactly once，就不得不提到至多一次（at most once）和至少一次（at least once）。</p><p>最多一次就是保证一条消息只发送一次，这个其实最简单，异步发送一次然后不管就可以，缺点是容易丢数据，所以一般不采用。至少一次语义是kafka默认提供的语义，它保证每条消息都能至少接收并处理一次，缺点是可能有重复数据。</p><p>前面有介绍过acks机制，当设置producer客户端的acks是1的时候，broker接收到消息就会跟producer确认。但producer发送一条消息后，可能因为网络原因消息超时未达，这时候producer客户端会选择重发，broker回应接收到消息，但很可能最开始发送的消息延迟到达，就会造成消息重复接收。</p><h2 id="幂等的生产者"><a href="#幂等的生产者" class="headerlink" title="幂等的生产者"></a>幂等的生产者</h2><p>kafka的producer默认是支持最少一次语义，也就是说不是幂等的，这样在一些比如支付等要求精确数据的场景会出现问题。</p><p>在0.11.0后，kafka提供了让producer支持幂等的配置操作。即：</p><blockquote><p>props.put(“enable.idempotence”, ture)</p></blockquote><p>在创建producer客户端的时候，添加这一行配置，producer就变成幂等的了。注意开启幂等性的时候，acks就自动是“all”了，如果这时候手动将ackss设置为0，那么会报错。其底层实现其实也很简单，就是对每条消息生成一个id值，broker会根据这个id值进行去重，从而实现幂等，这样一来就能够实现精确一次的语义了。</p><p>注意：单纯的设置将acks设置为all是没用的，重试次数 retries&gt;0（为防止消息丢失）的话还是会有重复消息出现。</p><p>但是！幂等的producery也并非万能。有两个主要是缺陷：</p><ul><li>幂等性的producer仅做到单分区上的幂等性，即单分区消息不重复，多分区无法保证幂等性。</li><li>只能保持单会话的幂等性，无法实现跨会话的幂等性，也就是说如果producer挂掉再重启，无法保证两个会话间的幂等（新会话可能会重发）。因为broker端无法获取之前的状态信息，所以无法实现跨会话的幂等。</li></ul><p>所以需要事务producer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化事务</span></span><br><span class="line">producer.initTransactions();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//开启一个事务</span></span><br><span class="line">    producer.beginTransaction();</span><br><span class="line">    producer.send(record1);</span><br><span class="line">    producer.send(record2);</span><br><span class="line">    <span class="comment">//提交</span></span><br><span class="line">    producer.commitTransaction();</span><br><span class="line">&#125; <span class="keyword">catch</span> (KafkaException e) &#123;</span><br><span class="line">    <span class="comment">//出现异常的时候，终止事务</span></span><br><span class="line">    producer.abortTransaction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但无论开启幂等还是事务的特性，都会对性能有一定影响，这是必然的。</p><h2 id="消费者的幂等性"><a href="#消费者的幂等性" class="headerlink" title="消费者的幂等性"></a>消费者的幂等性</h2><p>如果确实需要保证consumer的幂等，可以对每条消息维持一个全局的id，每次消费进行去重，当然耗费这么多的资源来实现exactly once的消费到底值不值，那就得看具体业务了。</p>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka 无消息丢失和幂等性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件——Kafka—生产者与消费者（二）</title>
      <link href="/2020/06/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Kafka%E2%80%94%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/06/08/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Kafka%E2%80%94%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h1><h2 id="生产者消息写入过程"><a href="#生产者消息写入过程" class="headerlink" title="生产者消息写入过程"></a>生产者消息写入过程</h2><ol><li><p>序列化 ProducerRecord</p><p>每个消息是一个 ProducerRecord 对象，必须指定消息所属的 Topic 和消息值 Value，此外还可以指定消息所属的 分区 以及消息的 Key。</p></li><li><p>推送到分区</p><p>推送到分区kafka有三种策略：随机策略、轮询策略、key的hash策略。默认为轮询策略。</p><p>当然如果该消息指定了 key，则 partitioner（分区器）会根据 key 的哈希值来选择目标分区，将具有相同 key 的所有消息都路由到相同的分区中；若该消息未指定 key，则 partitioner 使用轮询的方式确认目标分区。</p></li><li><p>找到分区副本 leader</p><p>producer 先从 zookeeper 的 “/brokers/…/state”节点找到该 partition 的 leader，将消息发送给该 leader。</p><p>leader将消息追加到本地log, followers 副本从 leader 拉取消息，追加到各自的本地log,后向 leader 发送 ACK</p><p>leader 收到所有 ISR 中的 replication 的 ACK 后，增加 HW（high watermark，最后 commit 的 offset）并向 producer 发送 ACK。</p></li></ol><h2 id="生产者消息发送方式"><a href="#生产者消息发送方式" class="headerlink" title="生产者消息发送方式"></a>生产者消息发送方式</h2><ol><li><p>批量发送</p><p>消息写入到目标分区的一块内存缓冲池中。而 producer 的另一个工作线程(I/O 发送线程，也称 Sender 线程)则负责实时地从该缓冲区中提取准备就绪的消息封装进一个批次(batch),统一发送给对应的 broker。</p></li><li><p>同步异步发送</p><p>Kafka producer 发送消息的主方法是 send 方法，producer 在底层完全实现了异步化发送，并且通过 Java 提供的 Future 同时实现了同步发送和异步发送+回调(Callback)(默认异步)两种发送方式。最后 producer 程序结束时需要关闭 producer。</p></li></ol><h2 id="asks-参数"><a href="#asks-参数" class="headerlink" title="asks 参数"></a>asks 参数</h2><ul><li>acks 设置为 0，表示 producer 不会等待 broker 的响应；所以 producer 无法知道消息是否发送成功，这样有可能会导致数据丢失，但同时，acks 值为 0 会得到最大的系统吞吐量。</li><li>若 acks 设置为 1，表示 producer 会在 leader partition 收到消息时得到 broker 的一个确认，这样会有更好的可靠性，因为客户端会等待直到 broker 确认收到消息。</li><li>若设置为-1，producer 会在所有备份的 partition 收到消息时得到 broker 的确认，这个设置可以得到最高的可靠性保证。</li></ul><h1 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h1><h2 id="消费消息过程"><a href="#消费消息过程" class="headerlink" title="消费消息过程"></a>消费消息过程</h2><ol><li><p>Consumer 端使用 zookeeper 用来注册 consumer 信息,其中包括 consumer 消费的 partition 列表等,同时也用来发现 broker 列表,并和 partition leader 建立 socket 连接,并获取消息。</p></li><li><p>订阅 topic 后，当 consumer 调用 pull(拉取模型)时，会自动加入相应的 Consumer Group；只要 consumer 持续 pull，consumer 将持续的从分配给他的 topic partitions 接收消息；</p></li><li><p>提交偏移量</p><p>消费者通过往一个叫作 <code>＿consumer_offset</code> 的特殊主题发送消息，消息里包含每个分区的偏移量。 如果消费者一直处于运行状态，那么偏移量就没有什么用处。不过，如果有消费者退出或者新分区加入，此时就会触发再均衡。完成再均衡之后，每个消费者可能分配到新的分区，而不是之前处理的那个。为了能够继续之前的工作，消费者需要读取每个分区最后一次提交的偏移量，然后从偏移量指定的地方继续处理。 因为这个原因，所以如果不能正确提交偏移量，就可能会导致数据丢失或者重复出现消费</p></li><li><p>consumer 会在后台持续向服务发送心跳，如果 consumer 进程崩溃或者在 session.timeout.ms 期间没有发送心跳，这个 consumer 将会被认为已经死掉了，他的分区将会被重新分配。</p></li></ol><h2 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h2><ol><li><p>enable.auto.commit</p><p> 将以配置项 auto.commit.interval.ms 指定的频率自动提交 offset</p></li><li><p>auto.commit.interval.ms</p><p> 提交 offset 的频率</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文简单介绍了生成与消费过程，不过我们在过程中可能会出现消息丢失与重复消费的问题。</p>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka 生产者 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot——redis、SpringCache（二十）</title>
      <link href="/2020/06/04/SpringBoot%E2%80%94%E2%80%94redis%E3%80%81SpringCache%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89/"/>
      <url>/2020/06/04/SpringBoot%E2%80%94%E2%80%94redis%E3%80%81SpringCache%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="依赖、配置"><a href="#依赖、配置" class="headerlink" title="依赖、配置"></a>依赖、配置</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>redis请见<a href="/2020/06/03/SpringBoot%E2%80%94%E2%80%94redis%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89/" title="SpringBoot——redis（十九）">SpringBoot——redis（十九）</a></p><h1 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.config.redisConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.support.json.JSONUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringBootConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.interceptor.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheWriter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableCaching</span><span class="comment">//开启缓存</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LettuceRedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redisTemplate配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connectionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Serializable&gt; <span class="title">redisTemplate</span><span class="params">(LettuceConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);</span></span><br><span class="line"><span class="comment">        //解决查询缓存转换异常的问题</span></span><br><span class="line"><span class="comment">        ObjectMapper objectMapper = new ObjectMapper();</span></span><br><span class="line"><span class="comment">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span></span><br><span class="line"><span class="comment">        objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance,ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);</span></span><br><span class="line"><span class="comment">        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);*/</span></span><br><span class="line">        RedisTemplate&lt;String, Serializable&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        redisTemplate.setValueSerializer(<span class="keyword">new</span> GenericJackson2JsonRedisSerializer());</span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        redisTemplate.setHashValueSerializer(<span class="keyword">new</span> GenericJackson2JsonRedisSerializer());</span><br><span class="line">        redisTemplate.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * reis缓存配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redisTemplate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returnd</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisCacheManager <span class="title">cacheManager</span><span class="params">(RedisTemplate redisTemplate)</span> </span>&#123;</span><br><span class="line">        RedisCacheWriter redisCacheWriter = RedisCacheWriter.nonLockingRedisCacheWriter(redisTemplate.getConnectionFactory());</span><br><span class="line">        RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(redisTemplate.getValueSerializer()))</span><br><span class="line">                .disableCachingNullValues()</span><br><span class="line">                <span class="comment">// 缓存数据保存1小时</span></span><br><span class="line">                .entryTtl(Duration.ofHours(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedisCacheManager(redisCacheWriter, redisCacheConfiguration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存key自定义</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyGenerator <span class="title">cacheKeyGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (target, method, params) -&gt; &#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(target.getClass().getName());</span><br><span class="line">        sb.append(method.getName());</span><br><span class="line">        <span class="keyword">for</span> (Object obj : params) &#123;</span><br><span class="line">            <span class="comment">// 由于参数可能不同, hashCode肯定不一样, 缓存的key也需要不一样</span></span><br><span class="line">            sb.append(JSONUtils.toJSONString(obj).hashCode());</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是开启缓存使用及配置自定义缓存key</p><h1 id="业务操作类"><a href="#业务操作类" class="headerlink" title="业务操作类"></a>业务操作类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.qn.eneity.User;</span><br><span class="line"><span class="keyword">import</span> com.qn.dao.boot.UserMapperAnocation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.Cacheable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解使用mybatis业务类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceAnocation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapperAnocation userMapperAnocation;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable</span>(value = <span class="string">"user"</span>, key = <span class="string">"#id"</span>,unless=<span class="string">"#result == null||#result.size()&lt;1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date().toString());</span><br><span class="line">        <span class="keyword">return</span> userMapperAnocation.getUserById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable</span>(value = <span class="string">"user"</span>, keyGenerator = <span class="string">"cacheKeyGenerator"</span>,unless=<span class="string">"#result == null||#result.size()&lt;1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getAllUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date().toString());</span><br><span class="line">        <span class="keyword">return</span> userMapperAnocation.getAllUsers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先查询redis,redis不存在，查询数据库，并将值根据key存入redis库。</p>]]></content>
      
      
      <categories>
          
          <category> Springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot——redis（十九）</title>
      <link href="/2020/06/03/SpringBoot%E2%80%94%E2%80%94redis%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89/"/>
      <url>/2020/06/03/SpringBoot%E2%80%94%E2%80%94redis%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="Lettuce-与-Jedis-比较"><a href="#Lettuce-与-Jedis-比较" class="headerlink" title="Lettuce 与 Jedis 比较"></a>Lettuce 与 Jedis 比较</h1><p>Lettuce 和 Jedis 的都是连接 Redis Server的客户端。</p><p>Jedis 在实现上是直连 redis server，多线程环境下非线程安全，除非使用连接池，为每个 redis实例增加物理连接。</p><p>Lettuce 是 一种可伸缩，线程安全，完全非阻塞的Redis客户端，多个线程可以共享一个RedisConnection,它利用Netty NIO 框架来高效地管理多个连接，从而提供了异步和同步数据访问方式，用于构建非阻塞的反应性应用程序。</p><p>在2.x版本中，默认是使用lettuce；1.x版本的时候，默认使用的就是Jedis；</p><p>下面主介绍Lettuce集成Redis服务</p><h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line"><span class="attr">redis</span>:<span class="string"></span></span><br><span class="line"><span class="attr">cluster</span>:<span class="string"></span></span><br><span class="line"><span class="attr">nodes</span>:<span class="string"></span></span><br><span class="line"><span class="meta">-</span> <span class="string">192.168.43.32:7001</span></span><br><span class="line"><span class="meta">-</span> <span class="string">192.168.43.32:7002</span></span><br><span class="line"><span class="meta">-</span> <span class="string">192.168.43.32:7003</span></span><br><span class="line"><span class="meta">-</span> <span class="string">192.168.43.32:7004</span></span><br><span class="line"><span class="meta">-</span> <span class="string">192.168.43.32:7005</span></span><br><span class="line"><span class="meta">-</span> <span class="string">192.168.43.32:7006</span></span><br><span class="line"><span class="meta">max-redirects</span>: <span class="string">3</span></span><br><span class="line"><span class="attr">lettuce</span>:<span class="string"></span></span><br><span class="line"><span class="attr">pool</span>:<span class="string"></span></span><br><span class="line"><span class="meta">max-idle</span>: <span class="string">8</span></span><br><span class="line"><span class="meta">max-wait</span>: <span class="string">-1</span></span><br><span class="line"><span class="meta">max-active</span>: <span class="string">8</span></span><br><span class="line"><span class="meta">min-idle</span>: <span class="string">0</span></span><br></pre></td></tr></table></figure><h1 id="自定义-RedisTemplate"><a href="#自定义-RedisTemplate" class="headerlink" title="自定义 RedisTemplate"></a>自定义 RedisTemplate</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.config.redisConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringBootConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LettuceRedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Serializable&gt; <span class="title">redisTemplate</span><span class="params">(LettuceConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Serializable&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        redisTemplate.setValueSerializer(<span class="keyword">new</span> GenericJackson2JsonRedisSerializer());</span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试实体序列化类"><a href="#测试实体序列化类" class="headerlink" title="测试实体序列化类"></a>测试实体序列化类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.eneity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserEntity</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">41408631575559586L</span>;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String userSex;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userSex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserSex</span><span class="params">(String userSex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userSex = userSex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"UserEntity&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", userName='"</span> + userName + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", userSex='"</span> + userSex + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.qn.eneity.UserEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String,String&gt; strRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Serializable&gt; serializableRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">(String key,String value)</span></span>&#123;</span><br><span class="line">        strRedisTemplate.opsForValue().set(key,value);</span><br><span class="line">        <span class="keyword">return</span> strRedisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserEntity <span class="title">testSerializable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserEntity user=<span class="keyword">new</span> UserEntity();</span><br><span class="line">        user.setId(<span class="number">1L</span>);</span><br><span class="line">        user.setUserName(<span class="string">"朝雾轻寒"</span>);</span><br><span class="line">        user.setUserSex(<span class="string">"男"</span>);</span><br><span class="line">        serializableRedisTemplate.opsForValue().set(<span class="string">"user"</span>, user);</span><br><span class="line">        <span class="keyword">return</span> (UserEntity) serializableRedisTemplate.opsForValue().get(<span class="string">"user"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">RedisServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"获取数据： "</span>+redisService.getValue(<span class="string">"sex"</span>,<span class="string">"nan"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testSerializable</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(redisService.testSerializable().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h1><p>测试跑测试类会报错:ClassNotFoundException: org.apache.commons.pool2.impl.GenericObjectPoolConfig</p><p>此时需要引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://juejin.im/post/5da2728251882528e8363676" target="_blank" rel="noopener">sprngboot集成redis集群</a></p>]]></content>
      
      
      <categories>
          
          <category> Springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件——Redis——安装（一）</title>
      <link href="/2020/06/03/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Redis%E2%80%94%E5%AE%89%E8%A3%85%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/06/03/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Redis%E2%80%94%E5%AE%89%E8%A3%85%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我是在win10子系统ubuntu安装的redis集群，当然linux上的安装只需要用yum进行安装。</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ol><li><p>首先我们要安装c语言的编译环境，我们要安装redis。首先安装gcc g++：</p><ul><li><p>apt-get install   gcc </p></li><li><p>apt-get install   gcc</p><p>或者</p></li><li><p>apt-get install  build-essential</p></li></ul></li></ol><ol start="2"><li><p>在make时可能出现错误” error: jemalloc/jemalloc.h: No such file or directory”，通过如下命令解决：</p><ul><li>make MALLOC=libc</li></ul></li><li><p>安装ruby环境</p><ul><li>apt-get install ruby</li><li>gem install redis</li></ul></li></ol><h1 id="下载redis编译安装"><a href="#下载redis编译安装" class="headerlink" title="下载redis编译安装"></a>下载redis编译安装</h1><ul><li>wget <a href="http://download.redis.io/releases/redis-4.0.8.tar.gz" target="_blank" rel="noopener">http://download.redis.io/releases/redis-4.0.8.tar.gz</a></li><li>tar xzf redis-4.0.8.tar.gz</li><li>cd redis-4.0.8</li><li>make</li><li>make install</li></ul><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>接下来我们创建6个目录，路径为/usr/sofe/redis/redis-cluster下创建6个文件夹代表6个实例</p><p><img src="/images/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Linux%EF%BC%88ubuntu%EF%BC%89%E5%AE%89%E8%A3%85redis%E9%9B%86%E7%BE%A4_2020-06-03-14-37-44.png" alt="消息中间件——Linux（ubuntu）安装redis集群_2020-06-03-14-37-44.png"></p><p>进去安装redis的目录分别将redis.config配置文件cp到这6个目录。</p><p><img src="/images/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Linux%EF%BC%88ubuntu%EF%BC%89%E5%AE%89%E8%A3%85redis%E9%9B%86%E7%BE%A4_2020-06-03-14-38-28.png" alt="消息中间件——Linux（ubuntu）安装redis集群_2020-06-03-14-38-28.png"></p><p>进入一个目录的配置文件修改该配置文件：如7001文件</p><ul><li>cd /usr/sofe/redis/redis-cluster/7001</li><li>vim redis.config    (没有安装vim的可以用vi或者 安装vim)</li></ul><p>配置修改如下：</p><p>daemonize  yes //后台启动</p><p>port 7001 //修改端口号对应目录的端口号</p><p>bing 192.168.43.32 //绑定本机ip</p><p>dir /usr/sofe/redis/redis-cluster/7001 //数据位置</p><p>cluster-enabled yes //开启集群</p><p>cluster-config-file nodes-7001.conf //配置文件</p><p>appendonly yes //持久化</p><p>6个配置文件都如上述方式修改</p><h1 id="启动redis"><a href="#启动redis" class="headerlink" title="启动redis"></a>启动redis</h1><p>进入redis的src目录启动redis,6个都要启动</p><p><img src="/images/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Linux%EF%BC%88ubuntu%EF%BC%89%E5%AE%89%E8%A3%85redis%E9%9B%86%E7%BE%A4_2020-06-03-14-54-04.png" alt="消息中间件——Linux（ubuntu）安装redis集群_2020-06-03-14-54-04.png"></p><p><img src="/images/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Linux%EF%BC%88ubuntu%EF%BC%89%E5%AE%89%E8%A3%85redis%E9%9B%86%E7%BE%A4_2020-06-03-14-55-23.png" alt="消息中间件——Linux（ubuntu）安装redis集群_2020-06-03-14-55-23.png"></p><h1 id="创建redis集群"><a href="#创建redis集群" class="headerlink" title="创建redis集群"></a>创建redis集群</h1><p>redis的src目录执行以下命令：</p><ul><li>./redis-trib.rb create –replicas 1 192.168.43.32:7001 192.168.43.32:7002 192.168.43.32:7003 192.168.43.32:7004 192.168.43.32:7005 192.168.43.32:7006</li></ul><p><img src="/images/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Linux%EF%BC%88ubuntu%EF%BC%89%E5%AE%89%E8%A3%85redis%E9%9B%86%E7%BE%A4_2020-06-03-14-58-48.png" alt="消息中间件——Linux（ubuntu）安装redis集群_2020-06-03-14-58-48.png"></p><h1 id="连接集群测试"><a href="#连接集群测试" class="headerlink" title="连接集群测试"></a>连接集群测试</h1><p><img src="/images/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Linux%EF%BC%88ubuntu%EF%BC%89%E5%AE%89%E8%A3%85redis%E9%9B%86%E7%BE%A4_2020-06-03-15-02-20.png" alt="消息中间件——Linux（ubuntu）安装redis集群_2020-06-03-15-02-20.png"></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>Redis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf<br>你可以通过 CONFIG 命令查看或设置配置项。</p><ol><li>查看配置</li></ol><p>//查询单个配置</p><blockquote><p>redis 127.0.0.1:6379&gt; CONFIG GET loglevel1</p></blockquote><p>//查询所有配置<br>redis 127.0.0.1:6379&gt; CONFIG GET *</p><ol start="2"><li><p>修改配置</p><blockquote><p>redis 127.0.0.1:6379&gt; CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE</p></blockquote></li><li><p>参数说明</p></li></ol><table><thead><tr><th align="center">序号</th><th align="center">配置</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">daemonize no</td><td align="center">Redis 默认不是以守护进程的方式运行，可以通过该配置项修改，使用 yes 启用守护进程（Windows 不支持守护线程的配置为 no ）</td></tr><tr><td align="center">2</td><td align="center">pidfile /var/run/redis.pid</td><td align="center">当 Redis 以守护进程方式运行时，Redis 默认会把 pid 写入 /var/run/redis.pid 文件，可以通过 pidfile 指定</td></tr><tr><td align="center">3</td><td align="center">port 6379</td><td align="center">指定 Redis 监听端口，默认端口为 6379，作者在自己的一篇博文中解释了为什么选用 6379 作为默认端口，因为 6379 在手机按键上 MERZ 对应的号码，而 MERZ 取自意大利歌女 Alessia Merz 的名字</td></tr><tr><td align="center">4</td><td align="center">bind 127.0.0.1</td><td align="center">绑定的主机地址</td></tr><tr><td align="center">5</td><td align="center">timeout 300</td><td align="center">当客户端闲置多长时间后关闭连接，如果指定为 0，表示关闭该功能</td></tr><tr><td align="center">6</td><td align="center">loglevel notice</td><td align="center">指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice</td></tr><tr><td align="center">7</td><td align="center">logfile stdout</td><td align="center">日志记录方式，默认为标准输出，如果配置 Redis 为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给 /dev/null</td></tr><tr><td align="center">8</td><td align="center">databases 16</td><td align="center">设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id</td></tr><tr><td align="center">9</td><td align="center">save <seconds> <changes> Redis 默认配置文件中提供了三个条件：save 900 1 save 300 10 save 60 10000 分别表示 900 秒（15 分钟）内有 1 个更改，300 秒（5 分钟）内有 10 个更改以及 60 秒内有 10000 个更改。</td><td align="center">指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</td></tr><tr><td align="center">10</td><td align="center">rdbcompression yes</td><td align="center">指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大</td></tr><tr><td align="center">11</td><td align="center">dbfilename dump.rdb</td><td align="center">指定本地数据库文件名，默认值为 dump.rdb</td></tr><tr><td align="center">12</td><td align="center">dir ./</td><td align="center">指定本地数据库存放目录</td></tr><tr><td align="center">13</td><td align="center">slaveof <masterip> <masterport></td><td align="center">设置当本机为 slav 服务时，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步</td></tr><tr><td align="center">14</td><td align="center">masterauth <master-password></td><td align="center">当 master 服务设置了密码保护时，slav 服务连接 master 的密码</td></tr><tr><td align="center">15</td><td align="center">requirepass foobared</td><td align="center">设置 Redis 连接密码，如果配置了连接密码，客户端在连接 Redis 时需要通过 AUTH <password> 命令提供密码，默认关闭</td></tr><tr><td align="center">16</td><td align="center">maxclients 128</td><td align="center">设置同一时间最大客户端连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息</td></tr><tr><td align="center">17</td><td align="center">maxmemory <bytes></td><td align="center">指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区</td></tr><tr><td align="center">18</td><td align="center">appendonly no</td><td align="center">指定是否在每次更新操作后进行日志记录，Redis 在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis 本身同步数据文件是按上面 save 条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为 no</td></tr><tr><td align="center">19</td><td align="center">appendfilename appendonly.aof</td><td align="center">指定更新日志文件名，默认为 appendonly.aof</td></tr><tr><td align="center">20</td><td align="center">appendfsync everysec</td><td align="center">指定更新日志条件，共有 3 个可选值no：表示等操作系统进行数据缓存同步到磁盘（快）always：表示每次更新操作后手动调用 fsync() 将数据写到磁盘（慢，安全）everysec：表示每秒同步一次（折中，默认值）</td></tr><tr><td align="center">21</td><td align="center">vm-enabled no</td><td align="center">指定是否启用虚拟内存机制，默认值为 no，简单的介绍一下，VM 机制将数据分页存放，由 Redis 将访问量较少的页即冷数据 swap 到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析 Redis 的 VM 机制）</td></tr><tr><td align="center">22</td><td align="center">vm-swap-file /tmp/redis.swap</td><td align="center">虚拟内存文件路径，默认值为 /tmp/redis.swap，不可多个 Redis 实例共享</td></tr><tr><td align="center">23</td><td align="center">vm-max-memory 0</td><td align="center">将所有大于 vm-max-memory 的数据存入虚拟内存，无论 vm-max-memory 设置多小，所有索引数据都是内存存储的(Redis 的索引数据 就是 keys)，也就是说，当 vm-max-memory 设置为 0 的时候，其实是所有 value 都存在于磁盘。默认值为 0</td></tr><tr><td align="center">24</td><td align="center">vm-page-size 32</td><td align="center">Redis swap 文件分成了很多的 page，一个对象可以保存在多个 page 上面，但一个 page 上不能被多个对象共享，vm-page-size 是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page 大小最好设置为 32 或者 64bytes；如果存储很大大对象，则可以使用更大的 page，如果不确定，就使用默认值</td></tr><tr><td align="center">25</td><td align="center">vm-pages 134217728</td><td align="center">设置 swap 文件中的 page 数量，由于页表（一种表示页面空闲或使用的 bitmap）是在放在内存中的，，在磁盘上每 8 个 pages 将消耗 1byte 的内存。</td></tr><tr><td align="center">26</td><td align="center">vm-max-threads 4</td><td align="center">设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</td></tr><tr><td align="center">27</td><td align="center">glueoutputbuf yes</td><td align="center">设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</td></tr><tr><td align="center">28</td><td align="center">hash-max-zipmap-entries 64hash-max-zipmap-value 512</td><td align="center">指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种                                                                                                               特殊的哈希算法</td></tr><tr><td align="center">29</td><td align="center">activerehashing yes</td><td align="center">指定是否激活重置哈希，默认为开启（后面在介绍 Redis 的哈希算法时具体介绍）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis 安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker——centos容器安装</title>
      <link href="/2020/05/27/%E6%9C%8D%E5%8A%A1%E5%99%A8docker%E2%80%94%E2%80%94centos%E5%AE%B9%E5%99%A8%E5%AE%89%E8%A3%85/"/>
      <url>/2020/05/27/%E6%9C%8D%E5%8A%A1%E5%99%A8docker%E2%80%94%E2%80%94centos%E5%AE%B9%E5%99%A8%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="查询镜像"><a href="#查询镜像" class="headerlink" title="查询镜像"></a>查询镜像</h1><p>dokcer search centos</p><h1 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h1><p>docker pull centos</p><h1 id="查看本地镜像"><a href="#查看本地镜像" class="headerlink" title="查看本地镜像"></a>查看本地镜像</h1><p>docker images</p><p><img src="/images/docker%E2%80%94%E2%80%94centos%E5%AE%B9%E5%99%A8%E5%AE%89%E8%A3%85_2020-05-27-18-46-23.png" alt="docker——centos容器安装_2020-05-27-18-46-23.png"></p><h1 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h1><p>docker run -itd -p 8088:8044 -p 8089:8077 –name mycentos centos</p><h1 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h1><p>docker exec -it mycentos /bin/bash</p><p><img src="/images/docker%E2%80%94%E2%80%94centos%E5%AE%B9%E5%99%A8%E5%AE%89%E8%A3%85_2020-05-27-18-49-11.png" alt="docker——centos容器安装_2020-05-27-18-49-11.png"></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker——springboot、centos、mysql部署</title>
      <link href="/2020/05/27/%E6%9C%8D%E5%8A%A1%E5%99%A8docker%E2%80%94%E2%80%94springboot%E3%80%81centos%E3%80%81mysql%E9%83%A8%E7%BD%B2/"/>
      <url>/2020/05/27/%E6%9C%8D%E5%8A%A1%E5%99%A8docker%E2%80%94%E2%80%94springboot%E3%80%81centos%E3%80%81mysql%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="springbootdemo"><a href="#springbootdemo" class="headerlink" title="springbootdemo"></a>springbootdemo</h1><p><a href="https://github.com/qn101630/study.git" target="_blank" rel="noopener">github地址</a></p><h1 id="mysql容器安装"><a href="#mysql容器安装" class="headerlink" title="mysql容器安装"></a>mysql容器安装</h1><h1 id="centos容器安装"><a href="#centos容器安装" class="headerlink" title="centos容器安装"></a>centos容器安装</h1><h1 id="centos安装JDK"><a href="#centos安装JDK" class="headerlink" title="centos安装JDK"></a>centos安装JDK</h1><p>yum search java|grep jdk//查询所有版本</p><p>yum install -y java-1.8.0-openjdk java-1.8.0-openjdk-devel//选择版本安装</p><p>java -version//验证是否安装成功</p><h1 id="springboot打包、copy"><a href="#springboot打包、copy" class="headerlink" title="springboot打包、copy"></a>springboot打包、copy</h1><p>此时要注意 mysql的配置连接的url要改为镜像的虚拟机地址：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">datasource</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">boot</span>:<span class="string"></span></span><br><span class="line">      <span class="meta">driver-class-name</span>: <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url</span>: <span class="string">jdbc:mysql://172.17.0.4:3306/boot</span></span><br><span class="line">      <span class="attr">username</span>: <span class="string">qinnan</span></span><br><span class="line">      <span class="attr">password</span>: <span class="string">123456</span></span><br><span class="line">      <span class="attr">type</span>: <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br></pre></td></tr></table></figure><p>172.17.0.4这个ip可以通过以下命令查看：</p><p>docker inspect mymysql</p><p><img src="/images/docker%E2%80%94%E2%80%94springboot%E3%80%81centos%E3%80%81mysql%E9%83%A8%E7%BD%B2_2020-05-27-19-02-14.png" alt="docker——springboot、centos、mysql部署_2020-05-27-19-02-14.png"></p><p>拷贝到centos容器：</p><p>docker cp D:\resposity\com\qn\springboot-demo\0.0.1-SNAPSHOT\springboot-demo-0.0.1-SNAPSHOT.jar bootcentos:/usr/local/</p><p>进入容器，启动springboot</p><p>docker exec -it bootcentos /bin/bash</p><p>cd usr/local</p><p>nohup java -jar springboot-demo-0.0.1-SNAPSHOT.jar &amp;</p><p>启动完成，可以在 nohup.out查看启动日志：</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p><img src="/images/docker%E2%80%94%E2%80%94springboot%E3%80%81centos%E3%80%81mysql%E9%83%A8%E7%BD%B2_2020-05-27-19-07-35.png" alt="docker——springboot、centos、mysql部署_2020-05-27-19-07-35.png"></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot——spring cache（十八）</title>
      <link href="/2020/05/22/SpringBoot%E2%80%94%E2%80%94spring%20cache%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89/"/>
      <url>/2020/05/22/SpringBoot%E2%80%94%E2%80%94spring%20cache%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在我们不使用其他第三方缓存依赖的时候，springboot自动采用ConcurrenMapCacheManager作为缓存管理器。</p><h1 id="缓存注解"><a href="#缓存注解" class="headerlink" title="缓存注解"></a>缓存注解</h1><p>对于缓存声明，spring的缓存提供了一组java注解:</p><ul><li>@Cacheable:触发缓存写入。</li><li>@CacheEvict:触发缓存清除。</li><li>@CachePut:更新缓存(不会影响到方法的运行)。</li><li>@Caching:重新组合要应用于方法的多个缓存操作。</li><li>@CacheConfig:设置类级别上共享的一些常见缓存设置。</li></ul><h2 id="Cacheable注解"><a href="#Cacheable注解" class="headerlink" title="@Cacheable注解"></a>@Cacheable注解</h2><p>可以用来进行缓存的写入，将结果存储在缓存中，以便于在后续调用的时候可以直接返回缓存中的值，而不必再执行实际的方法。 </p><p>最简单的使用方式,注解名称=缓存名称,使用例子如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="meta">@Cacheable</span>(<span class="string">"books"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Book <span class="title">findBook</span><span class="params">(ISBN isbn)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>一个方法可以对应两个缓存名称，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cacheable</span>(&#123;<span class="string">"books"</span>, <span class="string">"isbns"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Book <span class="title">findBook</span><span class="params">(ISBN isbn)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>缓存名称是可以配置动态参数的，比如选择传入的参数:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cacheable</span>(cacheNames=<span class="string">"books"</span>, key=<span class="string">"#isbn"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Book <span class="title">findBook</span><span class="params">(ISBN isbn, <span class="keyword">boolean</span> checkWarehouse, <span class="keyword">boolean</span> includeUsed)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">@<span class="title">Cacheable</span><span class="params">(cacheNames=<span class="string">"books"</span>, key=<span class="string">"#isbn.rawNumber"</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Book <span class="title">findBook</span><span class="params">(ISBN isbn, <span class="keyword">boolean</span> checkWarehouse, <span class="keyword">boolean</span> includeUsed)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">@<span class="title">Cacheable</span><span class="params">(cacheNames=<span class="string">"books"</span>, key=<span class="string">"T(someType).hash(#isbn)"</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Book <span class="title">findBook</span><span class="params">(ISBN isbn, <span class="keyword">boolean</span> checkWarehouse, <span class="keyword">boolean</span> includeUsed)</span></span></span><br></pre></td></tr></table></figure><p>还可以设置根据条件判断是否需要缓存 condition:取决于给定的参数是否满足条件; unless:取决于返回值是否满足条件。</p><p>以下是一个简单的例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cacheable</span>(cacheNames=<span class="string">"book"</span>, condition=<span class="string">"#name.length() &lt; 32"</span>) </span><br><span class="line"><span class="function"><span class="keyword">public</span> Book <span class="title">findBook</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">@<span class="title">Cacheable</span><span class="params">(cacheNames=<span class="string">"book"</span>, condition=<span class="string">"#name.length() &lt; 32"</span>, unless=<span class="string">"#result.hardback"</span>)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Book <span class="title">findBook</span><span class="params">(String name)</span></span></span><br></pre></td></tr></table></figure><p>还可以设置:keyGenerator(指定key自动生成方法),cacheManager(指定使用的缓存管理),cacheResolver(指定使用缓存的解析器)等,这些参数比较适合全局设置，这里就不多做介绍了。</p><h2 id="CachePut注解"><a href="#CachePut注解" class="headerlink" title="@CachePut注解"></a>@CachePut注解</h2><p>始终执行该方法，并将结果放入缓存，注解参数与@Cacheable相同。 </p><h2 id="CacheEvict注解"><a href="#CacheEvict注解" class="headerlink" title="CacheEvict注解"></a>CacheEvict注解</h2><p>删除缓存的注解,这对删除旧的数据和无用的数据是非常有用的。</p><p>这里还多了一个参数(allEntries),设置allEntries=true时，可以对整个条目进行批量删除。 </p><p>以下是个简单的例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheEvict</span>(cacheNames=<span class="string">"books"</span>) </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBooks</span><span class="params">(InputStream batch)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//对cacheNames进行批量删除</span></span></span><br><span class="line"><span class="function">@<span class="title">CacheEvict</span><span class="params">(cacheNames=<span class="string">"books"</span>, allEntries=<span class="keyword">true</span>)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBooks</span><span class="params">(InputStream batch)</span></span></span><br></pre></td></tr></table></figure><h2 id="Caching注解"><a href="#Caching注解" class="headerlink" title="@Caching注解"></a>@Caching注解</h2><p>在使用缓存的时候，有可能会同时进行更新和删除，会出现同时使用多个注解的情况.而@Caching可以实现。 </p><p>以下是个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Caching</span>(evict = &#123; <span class="meta">@CacheEvict</span>(<span class="string">"primary"</span>), <span class="meta">@CacheEvict</span>(cacheNames=<span class="string">"secondary"</span>, key=<span class="string">"#p0"</span>) &#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Book <span class="title">importBooks</span><span class="params">(String deposit, Date date)</span></span></span><br></pre></td></tr></table></figure><h1 id="CacheConfig注解"><a href="#CacheConfig注解" class="headerlink" title="@CacheConfig注解"></a>@CacheConfig注解</h1><p>缓存提供了许多的注解选项，但是有一些公用的操作，我们可以使用@CacheConfig在类上进行全局设置。 </p><p>以下是个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheConfig</span>(<span class="string">"books"</span>) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">BookRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Book <span class="title">findBook</span><span class="params">(ISBN isbn)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="开启缓存支持"><a href="#开启缓存支持" class="headerlink" title="开启缓存支持"></a>开启缓存支持</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.CommandLineRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.ServletComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ServletComponentScan</span> 扫描Servlet, Filter, Listener 添加到容器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.qn.mapper"</span>) <span class="comment">//扫描的mapper</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootDemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommandLineRunner <span class="title">commandLineRunner</span><span class="params">(ApplicationContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args -&gt; &#123;</span><br><span class="line">            <span class="comment">// 开始检查spring boot 提供的 beans</span></span><br><span class="line">            System.out.println(<span class="string">"Let's inspect the beans provided by Spring Boot:"</span>);</span><br><span class="line">            String[] beanNames = ctx.getBeanDefinitionNames();</span><br><span class="line">            Arrays.sort(beanNames);</span><br><span class="line">            <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">                System.out.println(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="缓存操作"><a href="#缓存操作" class="headerlink" title="缓存操作"></a>缓存操作</h1><p>数据库上几章已经应用，这里直接在数据库操作的地方加入缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.qn.eneity.User;</span><br><span class="line"><span class="keyword">import</span> com.qn.dao.boot.UserMapperAnocation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.Cacheable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解使用mybatis业务类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceAnocation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapperAnocation userMapperAnocation;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable</span>(<span class="string">"user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getAllUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date().toString());</span><br><span class="line">        <span class="keyword">return</span> userMapperAnocation.getAllUsers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">UserServiceAnocationTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserServiceAnocation userServiceAnocation;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getAllUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            userServiceAnocation.getAllUsers()</span><br><span class="line">                    .forEach(user -&gt; System.out.println(user.toString()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>![SpringBoot——spring cache（十八）_2020-05-22-15-33-32.png](/images/SpringBoot——spring cache（十八）_2020-05-22-15-33-32.png)</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot——多数据源-mybatis（十七）</title>
      <link href="/2020/05/21/SpringBoot%E2%80%94%E2%80%94%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90-mybatis%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89/"/>
      <url>/2020/05/21/SpringBoot%E2%80%94%E2%80%94%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90-mybatis%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>与jpa多数据源相同</p><h1 id="boot数据源配置类"><a href="#boot数据源配置类" class="headerlink" title="boot数据源配置类"></a>boot数据源配置类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.config.DataSourceConfig.mybatis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.SqlSessionFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.SqlSessionTemplate;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringBootConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Primary;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PathMatchingResourcePatternResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DataSourceTransactionManager;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages = &#123;<span class="string">"com.qn.dao.boot"</span>, <span class="string">"com.qn.mapper"</span>&#125;, sqlSessionTemplateRef = <span class="string">"sqlSessionTemplateBoot"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootMybatisConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"bootDataSource"</span>)</span><br><span class="line">    <span class="keyword">private</span> DruidDataSource bootDataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function">SqlSessionFactory <span class="title">sqlSessionFactoryBoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SqlSessionFactoryBean factoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">            factoryBean.setDataSource(bootDataSource);</span><br><span class="line">            factoryBean.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver().getResources(<span class="string">"classpath:mapping/*Mapper.xml"</span>));</span><br><span class="line">            sqlSessionFactory = factoryBean.getObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function">SqlSessionTemplate <span class="title">sqlSessionTemplateBoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactoryBoot());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置事务管理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function">DataSourceTransactionManager <span class="title">transactionManagerBootMybatis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(bootDataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="app数据源配置类"><a href="#app数据源配置类" class="headerlink" title="app数据源配置类"></a>app数据源配置类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.config.DataSourceConfig.mybatis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.SqlSessionFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.SqlSessionTemplate;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringBootConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DataSourceTransactionManager;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages = <span class="string">"com.qn.dao.app"</span>, sqlSessionTemplateRef = <span class="string">"sqlSessionTemplateApp"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppMybatisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"appDataSource"</span>)</span><br><span class="line">    <span class="keyword">private</span> DruidDataSource appDataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">SqlSessionFactory <span class="title">sqlSessionFactoryApp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SqlSessionFactoryBean factoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">            factoryBean.setDataSource(appDataSource);</span><br><span class="line">            sqlSessionFactory = factoryBean.getObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">SqlSessionTemplate <span class="title">sqlSessionTemplateApp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactoryApp());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置事务管理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">DataSourceTransactionManager <span class="title">transactionManagerAppMybatis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(appDataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Mapper接口"><a href="#Mapper接口" class="headerlink" title="Mapper接口"></a>Mapper接口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.dao.boot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.qn.eneity.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mapper注解映射类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapperAnocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"SELECT * FROM user"</span>)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getAllUsers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.dao.app;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.qn.eneity.Person;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonMapperAnocation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"SELECT * FROM person"</span>)</span><br><span class="line">    <span class="function">List&lt;Person&gt; <span class="title">getAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="业务类"><a href="#业务类" class="headerlink" title="业务类"></a>业务类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.qn.eneity.User;</span><br><span class="line"><span class="keyword">import</span> com.qn.dao.boot.UserMapperAnocation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解使用mybatis业务类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceAnocation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapperAnocation userMapperAnocation;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getAllUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapperAnocation.getAllUsers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.qn.dao.app.PersonMapperAnocation;</span><br><span class="line"><span class="keyword">import</span> com.qn.eneity.Person;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceAnocation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    PersonMapperAnocation personMapperAnocation;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Person&gt; <span class="title">getAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> personMapperAnocation.getAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">UserServiceAnocationTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserServiceAnocation userServiceAnocation;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getAllUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userServiceAnocation.getAllUsers()</span><br><span class="line">                .forEach(user -&gt; System.out.println(user.toString()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">PersonServiceAnocationTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    PersonServiceAnocation personServiceAnocation;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        personServiceAnocation.getAll().forEach(</span><br><span class="line">                person -&gt; System.out.println(person.toString())</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sprinboot 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot——多数据源-JPA（十六）</title>
      <link href="/2020/05/21/SpringBoot%E2%80%94%E2%80%94%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90-JPA%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89/"/>
      <url>/2020/05/21/SpringBoot%E2%80%94%E2%80%94%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90-JPA%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">datasource</span>:<span class="string"></span></span><br><span class="line"><span class="comment">  # boot数据库</span></span><br><span class="line">    <span class="attr">boot</span>:<span class="string"></span></span><br><span class="line">      <span class="meta">driver-class-name</span>: <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url</span>: <span class="string">jdbc:mysql://localhost:3306/boot</span></span><br><span class="line">      <span class="attr">username</span>: <span class="string">qinnan</span></span><br><span class="line">      <span class="attr">password</span>: <span class="string">123456</span></span><br><span class="line">      <span class="attr">type</span>: <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">initialSize</span>: <span class="string">5</span></span><br><span class="line">      <span class="attr">minIdle</span>: <span class="string">5</span></span><br><span class="line">      <span class="attr">maxActive</span>: <span class="string">20</span></span><br><span class="line">      <span class="attr">maxWait</span>: <span class="string">60000</span></span><br><span class="line">      <span class="attr">timeBetweenEvictionRunsMillis</span>: <span class="string">60000</span></span><br><span class="line">      <span class="attr">minEvictableIdleTimeMillis</span>: <span class="string">300000</span></span><br><span class="line">      <span class="attr">validationQuery</span>: <span class="string">SELECT 1 FROM DUAL</span></span><br><span class="line">      <span class="attr">testWhileIdle</span>: <span class="string">true</span></span><br><span class="line">      <span class="attr">testOnBorrow</span>: <span class="string">false</span></span><br><span class="line">      <span class="attr">testOnReturn</span>: <span class="string">false</span></span><br><span class="line">      <span class="attr">poolPreparedStatements</span>: <span class="string">true</span></span><br><span class="line"><span class="comment">      #   配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙</span></span><br><span class="line">      <span class="attr">filters</span>: <span class="string">stat</span></span><br><span class="line">      <span class="attr">maxPoolPreparedStatementPerConnectionSize</span>: <span class="string">20</span></span><br><span class="line">      <span class="attr">useGlobalDataSourceStat</span>: <span class="string">true</span></span><br><span class="line">      <span class="attr">connectionProperties</span>: <span class="string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">  # app数据库</span></span><br><span class="line">    <span class="attr">app</span>:<span class="string"></span></span><br><span class="line">      <span class="meta">driver-class-name</span>: <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url</span>: <span class="string">jdbc:mysql://localhost:3306/app</span></span><br><span class="line">      <span class="attr">username</span>: <span class="string">qinnan</span></span><br><span class="line">      <span class="attr">password</span>: <span class="string">123456</span></span><br><span class="line">      <span class="attr">type</span>: <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">initialSize</span>: <span class="string">5</span></span><br><span class="line">      <span class="attr">minIdle</span>: <span class="string">5</span></span><br><span class="line">      <span class="attr">maxActive</span>: <span class="string">20</span></span><br><span class="line">      <span class="attr">maxWait</span>: <span class="string">60000</span></span><br><span class="line">      <span class="attr">timeBetweenEvictionRunsMillis</span>: <span class="string">60000</span></span><br><span class="line">      <span class="attr">minEvictableIdleTimeMillis</span>: <span class="string">300000</span></span><br><span class="line">      <span class="attr">validationQuery</span>: <span class="string">SELECT 1 FROM DUAL</span></span><br><span class="line">      <span class="attr">testWhileIdle</span>: <span class="string">true</span></span><br><span class="line">      <span class="attr">testOnBorrow</span>: <span class="string">false</span></span><br><span class="line">      <span class="attr">testOnReturn</span>: <span class="string">false</span></span><br><span class="line">      <span class="attr">poolPreparedStatements</span>: <span class="string">true</span></span><br><span class="line"><span class="comment">      #   配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙</span></span><br><span class="line">      <span class="attr">filters</span>: <span class="string">stat</span></span><br><span class="line">      <span class="attr">maxPoolPreparedStatementPerConnectionSize</span>: <span class="string">20</span></span><br><span class="line">      <span class="attr">useGlobalDataSourceStat</span>: <span class="string">true</span></span><br><span class="line">      <span class="attr">connectionProperties</span>: <span class="string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">  # jpa配置</span></span><br><span class="line">  <span class="attr">jpa</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">database-platform</span>: <span class="string">org.hibernate.dialect.MySQL5Dialect</span></span><br><span class="line">    <span class="meta">show-sql</span>: <span class="string">true</span></span><br><span class="line">    <span class="attr">hibernate</span>:<span class="string"></span></span><br><span class="line">      <span class="meta">ddl-auto</span>: <span class="string">update # create 每次都重新创建表，update，表若存在则不重建</span></span><br></pre></td></tr></table></figure><h1 id="多数据源配置类"><a href="#多数据源配置类" class="headerlink" title="多数据源配置类"></a>多数据源配置类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.config.DataSourceConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.support.http.StatViewServlet;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.support.http.WebStatFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringBootConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.ServletRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Primary;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多数据源的配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置绑定boot</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name =<span class="string">"bootDataSource"</span>)</span><br><span class="line">    <span class="meta">@Primary</span> <span class="comment">//主数据源</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"bootDataSource"</span>)</span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource.boot"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DruidDataSource <span class="title">bootDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置绑定app</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name =<span class="string">"appDataSource"</span>)</span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"appDataSource"</span>)</span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource.app"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DruidDataSource <span class="title">appDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Druid的servlet</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">statViewServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServletRegistrationBean bean = <span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> StatViewServlet());</span><br><span class="line">        Map&lt;String, String&gt; initParams = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        initParams.put(<span class="string">"loginUsername"</span>, <span class="string">"admin"</span>);</span><br><span class="line">        initParams.put(<span class="string">"loginPassword"</span>, <span class="string">"123"</span>);</span><br><span class="line">        initParams.put(<span class="string">"allow"</span>, <span class="string">"127.0.0.1"</span>);</span><br><span class="line">        bean.setInitParameters(initParams);</span><br><span class="line">        bean.setUrlMappings(Arrays.asList(<span class="string">"/druid/*"</span>));</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Druid的filter</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">webStatFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FilterRegistrationBean&lt;WebStatFilter&gt; bean = <span class="keyword">new</span> FilterRegistrationBean&lt;&gt;(<span class="keyword">new</span> WebStatFilter());</span><br><span class="line">        HashMap&lt;String, String&gt; initParams = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        initParams.put(<span class="string">"exclusions"</span>, <span class="string">"/css,/druid/*"</span>);</span><br><span class="line">        bean.setInitParameters(initParams);</span><br><span class="line">        bean.setUrlPatterns(Arrays.asList(<span class="string">"/*"</span>));</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="boot数据源配置类"><a href="#boot数据源配置类" class="headerlink" title="boot数据源配置类"></a>boot数据源配置类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.config.DataSourceConfig.jpa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringBootConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.orm.jpa.HibernateProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.orm.jpa.HibernateSettings;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Primary;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.config.EnableJpaRepositories;</span><br><span class="line"><span class="keyword">import</span> org.springframework.orm.jpa.JpaTransactionManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.PlatformTransactionManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.EnableTransactionManagement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityManager;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * boot数据源配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories</span>(</span><br><span class="line">        entityManagerFactoryRef = <span class="string">"entityManagerFactoryBoot"</span>,</span><br><span class="line">        transactionManagerRef = <span class="string">"transactionManagerBoot"</span>,</span><br><span class="line">        basePackages = &#123;<span class="string">"com.qn.dao.boot"</span>&#125;) <span class="comment">//设置Repository所在位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootJpaConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JpaProperties jpaProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"bootDataSource"</span>)</span><br><span class="line">    <span class="keyword">private</span> DruidDataSource bootDataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HibernateProperties hibernateProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"entityManagerBoot"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> EntityManager <span class="title">entityManager</span><span class="params">(EntityManagerFactoryBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> entityManagerFactoryPrimary(builder).getObject().createEntityManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"entityManagerFactoryBoot"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title">entityManagerFactoryPrimary</span><span class="params">(EntityManagerFactoryBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder</span><br><span class="line">                .dataSource(bootDataSource)</span><br><span class="line">                .properties(hibernateProperties.determineHibernateProperties(jpaProperties.getProperties(), <span class="keyword">new</span> HibernateSettings()))</span><br><span class="line">                .packages(<span class="string">"com.qn.eneity"</span>) <span class="comment">//设置实体类所在位置</span></span><br><span class="line">                .persistenceUnit(<span class="string">"primaryPersistenceUnit"</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"transactionManagerBoot"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManagerPrimary</span><span class="params">(EntityManagerFactoryBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JpaTransactionManager(entityManagerFactoryPrimary(builder).getObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="app数据源配置类"><a href="#app数据源配置类" class="headerlink" title="app数据源配置类"></a>app数据源配置类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.config.DataSourceConfig.jpa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringBootConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.orm.jpa.HibernateProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.orm.jpa.HibernateSettings;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.config.EnableJpaRepositories;</span><br><span class="line"><span class="keyword">import</span> org.springframework.orm.jpa.JpaTransactionManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.PlatformTransactionManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.EnableTransactionManagement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityManager;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * app数据源配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories</span>(</span><br><span class="line">        entityManagerFactoryRef = <span class="string">"entityManagerFactoryApp"</span>,</span><br><span class="line">        transactionManagerRef = <span class="string">"transactionManagerApp"</span>,</span><br><span class="line">        basePackages = &#123;<span class="string">"com.qn.dao.app"</span>&#125;) <span class="comment">//设置Repository所在位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppJpaConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JpaProperties jpaProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"appDataSource"</span>)</span><br><span class="line">    <span class="keyword">private</span> DruidDataSource appDataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HibernateProperties hibernateProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"entityManagerApp"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> EntityManager <span class="title">entityManager</span><span class="params">(EntityManagerFactoryBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> entityManagerFactoryPrimary(builder).getObject().createEntityManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"entityManagerFactoryApp"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title">entityManagerFactoryPrimary</span><span class="params">(EntityManagerFactoryBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder</span><br><span class="line">                .dataSource(appDataSource)</span><br><span class="line">                .properties(hibernateProperties.determineHibernateProperties(jpaProperties.getProperties(), <span class="keyword">new</span> HibernateSettings()))</span><br><span class="line">                .packages(<span class="string">"com.qn.eneity"</span>) <span class="comment">//设置实体类所在位置</span></span><br><span class="line">                .persistenceUnit(<span class="string">"primaryPersistenceUnit"</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"transactionManagerApp"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManagerPrimary</span><span class="params">(EntityManagerFactoryBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JpaTransactionManager(entityManagerFactoryPrimary(builder).getObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="主从库dao类"><a href="#主从库dao类" class="headerlink" title="主从库dao类"></a>主从库dao类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.dao.app;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.qn.eneity.Person;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppPersonRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Person</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.dao.boot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.qn.eneity.Account;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BootAccountRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Account</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="entity"><a href="#entity" class="headerlink" title="entity"></a>entity</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.eneity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.Column;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Table;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"account"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@Column</span>(nullable = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> money;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Account&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", money="</span> + money +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.eneity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.Column;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Table;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@Column</span>(nullable = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> user_id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String user_name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"user_id="</span> + user_id +</span><br><span class="line">                <span class="string">", user_name='"</span> + user_name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", password='"</span> + password + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", phone='"</span> + phone + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUser_id</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user_id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser_id</span><span class="params">(<span class="keyword">int</span> user_id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user_id = user_id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUser_name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user_name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser_name</span><span class="params">(String user_name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user_name = user_name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPhone</span><span class="params">(String phone)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.dao.app;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">AppPersonRepositoryTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AppPersonRepository appPersonRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getAllPersons</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        appPersonRepository.findAll().forEach(</span><br><span class="line">                person -&gt; System.out.println(person.toString())</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.dao.boot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">BootAccountRepositoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    BootAccountRepository bootAccountRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getAllUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bootAccountRepository.findAll().forEach(</span><br><span class="line">                user -&gt; System.out.println(user.toString())</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot——Mybatis-注解（十五）</title>
      <link href="/2020/05/20/SpringBoot%E2%80%94%E2%80%94Mybatis-%E6%B3%A8%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/"/>
      <url>/2020/05/20/SpringBoot%E2%80%94%E2%80%94Mybatis-%E6%B3%A8%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Mapper配置类"><a href="#Mapper配置类" class="headerlink" title="Mapper配置类"></a>Mapper配置类</h1><p>注解方式是将xml转化为配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.qn.eneity.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapperAnocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"SELECT * FROM user"</span>)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getAllUsers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Mapper注解或是启动类扫描</p><h1 id="业务类"><a href="#业务类" class="headerlink" title="业务类"></a>业务类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.qn.eneity.User;</span><br><span class="line"><span class="keyword">import</span> com.qn.mapper.UserMapperAnocation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceAnocation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapperAnocation userMapperAnocation;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getAllUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapperAnocation.getAllUsers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">UserServiceAnocationTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserServiceAnocation userServiceAnocation;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getAllUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userServiceAnocation.getAllUsers()</span><br><span class="line">                .forEach(user -&gt; System.out.println(user.toString()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/SpringBoot%E2%80%94%E2%80%94Mybatis-%E6%B3%A8%E8%A7%A3%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89_2020-05-21-10-24-32.png" alt="SpringBoot——Mybatis-注解（十五）_2020-05-21-10-24-32.png"></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot——Mybatis-xml（十四）</title>
      <link href="/2020/05/20/SpringBoot%E2%80%94%E2%80%94Mybatis-xml%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
      <url>/2020/05/20/SpringBoot%E2%80%94%E2%80%94Mybatis-xml%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">mapper-locations</span>: <span class="string">classpath:mapping/*Mapper.xml</span></span><br><span class="line">    <span class="meta">type-aliases-package</span>: <span class="string">com.qn.eneity</span></span><br></pre></td></tr></table></figure><h1 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.eneity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String passWord;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String realName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassWord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> passWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassWord</span><span class="params">(String passWord)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.passWord = passWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRealName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> realName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRealName</span><span class="params">(String realName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.realName = realName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", userName='"</span> + userName + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", passWord='"</span> + passWord + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", realName='"</span> + realName + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Mapper-xml"><a href="#Mapper-xml" class="headerlink" title="Mapper.xml"></a>Mapper.xml</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.qn.mapper.UserMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"com.qn.eneity.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"userName"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">property</span>=<span class="string">"userName"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"passWord"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">property</span>=<span class="string">"passWord"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"realName"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">property</span>=<span class="string">"realName"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"Sel"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>&gt;</span>        select * from user where id = #&#123;id&#125;    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Mapper映射类"><a href="#Mapper映射类" class="headerlink" title="Mapper映射类"></a>Mapper映射类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.qn.eneity.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">User <span class="title">Sel</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="业务类"><a href="#业务类" class="headerlink" title="业务类"></a>业务类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.qn.eneity.User;</span><br><span class="line"><span class="keyword">import</span> com.qn.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">Sel</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userMapper.Sel(id);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="添加扫描"><a href="#添加扫描" class="headerlink" title="添加扫描"></a>添加扫描</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.CommandLineRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.ServletComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ServletComponentScan</span> 扫描Servlet, Filter, Listener 添加到容器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.qn.mapper"</span>) <span class="comment">//扫描的mapper</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootDemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommandLineRunner <span class="title">commandLineRunner</span><span class="params">(ApplicationContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args -&gt; &#123;</span><br><span class="line">            <span class="comment">// 开始检查spring boot 提供的 beans</span></span><br><span class="line">            System.out.println(<span class="string">"Let's inspect the beans provided by Spring Boot:"</span>);</span><br><span class="line">            String[] beanNames = ctx.getBeanDefinitionNames();</span><br><span class="line">            Arrays.sort(beanNames);</span><br><span class="line">            <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">                System.out.println(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.qn.eneity.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">UserServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = userService.Sel(<span class="number">2</span>);</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/SpringBoot%E2%80%94%E2%80%94Mybatis-xml%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89_2020-05-20-18-56-39.png" alt="SpringBoot——Mybatis-xml（十四）_2020-05-20-18-56-39.png"></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot——JPA（十三）</title>
      <link href="/2020/05/20/SpringBoot%E2%80%94%E2%80%94JPA%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/"/>
      <url>/2020/05/20/SpringBoot%E2%80%94%E2%80%94JPA%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Springboot data jpa 和 Spring jdbc 同属于 Spring开源组织，在 Spring jdbc 之后又开发了持久层框架，很明显 Spring data jpa 相对于 Spring jdbc 更加的便捷强大。它可以轻松的实现对数据访问层的增强支持。</p><h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Spring</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">jpa</span>:<span class="string"></span></span><br><span class="line">        <span class="meta">database-platform</span>: <span class="string">org.hibernate.dialect.MySQL5Dialect</span></span><br><span class="line">        <span class="meta">show-sql</span>: <span class="string">true</span></span><br><span class="line">        <span class="attr">hibernate</span>:<span class="string"></span></span><br><span class="line">          <span class="meta">ddl-auto</span>: <span class="string">update # create 每次都重新创建表，update，表若存在则不重建</span></span><br></pre></td></tr></table></figure><h1 id="数据实体类"><a href="#数据实体类" class="headerlink" title="数据实体类"></a>数据实体类</h1><p>Springboot Data JPA 是 ORM 的完整实现，实体类和数据表关系一一对应，因此实体类也就是数据表结构。spring.jpa.hibernate.ddl-auto=update 会在 JPA 运行时自动在数据表中创建被 @Entity 注解的实体数据表。如果表已经存在，则不会创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.eneity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.Column;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Table;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"account"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@Column</span>(nullable = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> money;</span><br><span class="line">    <span class="comment">//getter setter略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JPA操作接口"><a href="#JPA操作接口" class="headerlink" title="JPA操作接口"></a>JPA操作接口</h1><p>JPA 操作接口只需要继承 JpaRepository 就可以了，JpaRepository 里封装了常用的增删改查分页等方法，可以直接使用，如果需要自定义查询方式，可以通过构造方法名的方式增加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.qn.eneity.Account;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JpaService</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Account</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Account <span class="title">findByIdAndName</span><span class="params">(<span class="keyword">int</span> id, String name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.qn.eneity.Account;</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.PageRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jpa测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">JpaServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JpaService jpaService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Account&gt; list = jpaService.findAll();</span><br><span class="line">        list.forEach(account -&gt; System.out.println(account.toString()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(jpaService.findById(<span class="number">1</span>).toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分页查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getByPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PageRequest pageRequest = PageRequest.of(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Page&lt;Account&gt; userPage = jpaService.findAll(pageRequest);</span><br><span class="line"></span><br><span class="line">        List&lt;Account&gt; userList = userPage.getContent();</span><br><span class="line"></span><br><span class="line">        userList.forEach((user) -&gt; System.out.println(user));</span><br><span class="line"></span><br><span class="line">        Assert.assertNotNull(userList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Optional&lt;Account&gt; byId = jpaService.findById(<span class="number">1</span>);</span><br><span class="line">        Account account = byId.orElseThrow(() -&gt; <span class="keyword">new</span> RuntimeException(<span class="string">"用户信息没有取到"</span>));</span><br><span class="line">        account.setMoney(<span class="number">10000</span>);</span><br><span class="line">        Account save = jpaService.save(account);</span><br><span class="line">        Assert.assertNotNull(save);</span><br><span class="line">        System.out.println(save.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getByIdAndName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Account account = jpaService.findByIdAndName(<span class="number">4</span>, <span class="string">"曾烨烨"</span>);</span><br><span class="line">        System.out.println(account.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker——Mysql的安装</title>
      <link href="/2020/05/20/%E6%9C%8D%E5%8A%A1%E5%99%A8docker%E2%80%94%E2%80%94Mysql%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2020/05/20/%E6%9C%8D%E5%8A%A1%E5%99%A8docker%E2%80%94%E2%80%94Mysql%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h1><p>docker pull mysql </p><h1 id="通过镜像创建容器并运行"><a href="#通过镜像创建容器并运行" class="headerlink" title="通过镜像创建容器并运行"></a>通过镜像创建容器并运行</h1><p>docker run -d -p 3306:3306 –name mymysql -e MYSQL_ROOT_PASSWORD=root mysql</p><h1 id="查看容器信息"><a href="#查看容器信息" class="headerlink" title="查看容器信息"></a>查看容器信息</h1><p>docker inspect 容器id</p><h1 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h1><p>docker exec -it 62349aa31687 /bin/bash</p><h1 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h1><p>mysql -uroot -p</p><h1 id="授权远程连接"><a href="#授权远程连接" class="headerlink" title="授权远程连接"></a>授权远程连接</h1><p>#查看用户信息</p><p>select host,user,plugin,authentication_string from mysql.user; </p><p>#授予用户通过外网IP对于该数据库的全部权限</p><p>grant all privileges on <code>test</code>.* to ‘test’@’%’ ;</p><p>#授予用户在本地服务器对该数据库的全部权限</p><p>grant all privileges on <code>test</code>.* to ‘test’@’localhost’;   </p><p>grant select on test.* to ‘user1’@’localhost’; //给予查询权限</p><p>grant insert on test.* to ‘user1’@’localhost’; //添加插入权限</p><p>grant delete on test.* to ‘user1’@’localhost’; //添加删除权限</p><p>grant update on test.* to ‘user1’@’localhost’; //添加权限</p><p>flush privileges; //刷新权限</p><p>#如果想给xxx用户 就把root替换成xxx 密码随意</p><p>ALTER user ‘xxx’@’%’ IDENTIFIED WITH mysql_native_password BY ‘123456’;</p><p>#host为 % 表示不限制ip   localhost表示本机使用    plugin非mysql_native_password 则需要修改密码</p><h1 id="navicat连接"><a href="#navicat连接" class="headerlink" title="navicat连接"></a>navicat连接</h1><p><img src="/images/docker%E2%80%94%E2%80%94Mysql%E7%9A%84%E5%AE%89%E8%A3%85_2020-05-20-10-18-38.png" alt="docker——Mysql的安装_2020-05-20-10-18-38.png"></p><h1 id="mysql命令"><a href="#mysql命令" class="headerlink" title="mysql命令"></a>mysql命令</h1><p>create user “username”@”host” identified by “password”;//新建用户</p><p>drop user ‘username’@’host’;//删除用户</p><p>rename user ‘jack’@’%’ to ‘jim’@’%’;//修改用户名</p><p>SET PASSWORD FOR ‘root’@’localhost’ = PASSWORD(‘123456’);//修改密码</p><p>grant privileges on databasename.tablename to ‘username’@’host’ IDENTIFIED BY ‘PASSWORD’;//授权</p><p>show databases; //显示所有数据库</p><p>show grants for ‘jack’@’%’;//查看jack的权限</p><p>revoke privileges on databasename.tablename from ‘username’@’host’;//删除权限</p><p>create database &lt;数据库名&gt;//创建数据库</p><p>drop database &lt;数据库名&gt;//删除数据库</p><p>use mydatabase;//打开数据库</p><p>desc &lt;表名&gt;;//查看表结构</p><p>drop table &lt;表名&gt;;//删除表</p><p>SHOW VARIABLES LIKE ‘character%’;//查看所有字符集</p><p>set character_set_database=utf8;//改变数据库的编码方式</p><p>mysqldump -u 用户名 –p 数据库名 &gt; 导出的文件名;//到处数据库生成文件，终端执行</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot——JDBC（十二）</title>
      <link href="/2020/05/20/SpringBoot%E2%80%94%E2%80%94JDBC%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/05/20/SpringBoot%E2%80%94%E2%80%94JDBC%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>jdk 1.8</p><p>maven 3.0</p><p>idea</p><p>mysql</p><p>springBoot 2.2.7</p><p>初始化Mysql:</p><h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">datasource</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">driver-class-name</span>: <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url</span>: <span class="string">jdbc:mysql://localhost:3306/boot</span></span><br><span class="line">    <span class="attr">username</span>: <span class="string">qinnan</span></span><br><span class="line">    <span class="attr">password</span>: <span class="string">123456</span></span><br></pre></td></tr></table></figure><h1 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.eneity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id ;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> money;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Account&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", money="</span> + money +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.qn.eneity.Account;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">getAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(<span class="string">"SELECT * FROM account"</span>, <span class="keyword">new</span> Object[]&#123;&#125;,<span class="keyword">new</span> BeanPropertyRowMapper(Account<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">AccountServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        accountService.getAll().forEach(account -&gt; System.out.println(account.toString()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/SpringBoot%E2%80%94%E2%80%94JDBC%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89_2020-05-20-14-09-11.png" alt="SpringBoot——JDBC（十二）_2020-05-20-14-09-11.png"></p><h1 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h1><p>我们可以看到这里的连接池用的是 HikariPool，这是springBoot适配的连接池，我们也可以用自己的连接池：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.29<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Spring</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">datasource</span>:<span class="string"></span></span><br><span class="line">        <span class="meta">driver-class-name</span>: <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url</span>: <span class="string">jdbc:mysql://localhost:3306/boot</span></span><br><span class="line">        <span class="attr">username</span>: <span class="string">qinnan</span></span><br><span class="line">        <span class="attr">password</span>: <span class="string">123456</span></span><br><span class="line">        <span class="attr">type</span>: <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br></pre></td></tr></table></figure><p>启动测试：</p><p><img src="/images/SpringBoot%E2%80%94%E2%80%94JDBC%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89_2020-05-20-14-44-52.png" alt="SpringBoot——JDBC（十二）_2020-05-20-14-44-52.png"></p><h1 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h1><p>用 druid连接池自然要尝试以下监控：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Spring</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">datasource</span>:<span class="string"></span></span><br><span class="line">        <span class="meta">driver-class-name</span>: <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url</span>: <span class="string">jdbc:mysql://localhost:3306/boot</span></span><br><span class="line">        <span class="attr">username</span>: <span class="string">qinnan</span></span><br><span class="line">        <span class="attr">password</span>: <span class="string">123456</span></span><br><span class="line">        <span class="attr">type</span>: <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">initialSize</span>: <span class="string">5</span></span><br><span class="line">        <span class="attr">minIdle</span>: <span class="string">5</span></span><br><span class="line">        <span class="attr">maxActive</span>: <span class="string">20</span></span><br><span class="line">        <span class="attr">maxWait</span>: <span class="string">60000</span></span><br><span class="line">        <span class="attr">timeBetweenEvictionRunsMillis</span>: <span class="string">60000</span></span><br><span class="line">        <span class="attr">minEvictableIdleTimeMillis</span>: <span class="string">300000</span></span><br><span class="line">        <span class="attr">validationQuery</span>: <span class="string">SELECT 1 FROM DUAL</span></span><br><span class="line">        <span class="attr">testWhileIdle</span>: <span class="string">true</span></span><br><span class="line">        <span class="attr">testOnBorrow</span>: <span class="string">false</span></span><br><span class="line">        <span class="attr">testOnReturn</span>: <span class="string">false</span></span><br><span class="line">        <span class="attr">poolPreparedStatements</span>: <span class="string">true</span></span><br><span class="line"><span class="comment">        #   配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙</span></span><br><span class="line">        <span class="attr">filters</span>: <span class="string">stat</span></span><br><span class="line">        <span class="attr">maxPoolPreparedStatementPerConnectionSize</span>: <span class="string">20</span></span><br><span class="line">        <span class="attr">useGlobalDataSourceStat</span>: <span class="string">true</span></span><br><span class="line">        <span class="attr">connectionProperties</span>: <span class="string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span></span><br></pre></td></tr></table></figure><p>这里很多配置不是springboot已经自动配置的，所以需要我们用配置类加载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.support.http.StatViewServlet;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.support.http.WebStatFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringBootConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.ServletRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置绑定</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DruidDataSource <span class="title">druid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Druid的servlet</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">statViewServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServletRegistrationBean bean = <span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> StatViewServlet());</span><br><span class="line">        Map&lt;String, String&gt; initParams = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        initParams.put(<span class="string">"loginUsername"</span>, <span class="string">"admin"</span>);</span><br><span class="line">        initParams.put(<span class="string">"loginPassword"</span>, <span class="string">"123"</span>);</span><br><span class="line">        initParams.put(<span class="string">"allow"</span>, <span class="string">"127.0.0.1"</span>);</span><br><span class="line">        bean.setInitParameters(initParams);</span><br><span class="line">        bean.setUrlMappings(Arrays.asList(<span class="string">"/druid/*"</span>));</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">webStatFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FilterRegistrationBean&lt;WebStatFilter&gt; bean = <span class="keyword">new</span> FilterRegistrationBean&lt;&gt;(<span class="keyword">new</span> WebStatFilter());</span><br><span class="line">        HashMap&lt;String, String&gt; initParams = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        initParams.put(<span class="string">"exclusions"</span>, <span class="string">"/css,/druid/*"</span>);</span><br><span class="line">        bean.setInitParameters(initParams);</span><br><span class="line">        bean.setUrlPatterns(Arrays.asList(<span class="string">"/*"</span>));</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面配置了 Druid 监控访问路径为 /druid、登录用户是 admin、登录密码是123、允许访问的IP是127.0.0.1 本机、不需要监控的请求是 /css 和 /druid 开头的请求。</p><p>启动项目，访问请求数据库的服务，</p><p><img src="/images/SpringBoot%E2%80%94%E2%80%94JDBC%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89_2020-05-20-14-49-42.png" alt="SpringBoot——JDBC（十二）_2020-05-20-14-49-42.png"></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot——异常处理（）</title>
      <link href="/2020/05/19/SpringBoot%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/"/>
      <url>/2020/05/19/SpringBoot%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="自定义异常页面"><a href="#自定义异常页面" class="headerlink" title="自定义异常页面"></a>自定义异常页面</h1><p>从 SpringBoot 错误机制源码分析，知道当遇到错误情况时候，</p><ol><li>SpringBoot 会首先返回到模版引擎文件夹下的 <code>/error/HTTP</code> 状态码 文件，</li><li>如果不存在，则检查去模版引擎下的 <code>/error/4xx</code> 或者 <code>/error/5xx</code> 文件，</li><li>如果还不存在，则检查静态资源文件夹下对应的上述文件。</li></ol><p>并且在返回时会共享一些错误信息，这些错误信息可以在模版引擎中直接使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">errorAttributes.put(<span class="string">"timestamp"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">errorAttributes.put(<span class="string">"status"</span>, status);</span><br><span class="line">errorAttributes.put(<span class="string">"error"</span>, HttpStatus.valueOf(status).getReasonPhrase());</span><br><span class="line">errorAttributes.put(<span class="string">"errors"</span>, result.getAllErrors());</span><br><span class="line">errorAttributes.put(<span class="string">"exception"</span>, error.getClass().getName());</span><br><span class="line">errorAttributes.put(<span class="string">"message"</span>, error.getMessage());</span><br><span class="line">errorAttributes.put(<span class="string">"trace"</span>, stackTrace.toString());</span><br><span class="line">errorAttributes.put(<span class="string">"path"</span>, path);</span><br></pre></td></tr></table></figure><p>在 templates/error 下自定义 404.html 页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>[[$&#123;status&#125;]]<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Bootstrap core CSS --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"/webjars/bootstrap/4.1.3/css/bootstrap.min.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"m-5"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>错误码：[[$&#123;status&#125;]]<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>信息：[[$&#123;message&#125;]]<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>时间：[[$&#123;#dates.format(timestamp,'yyyy-MM-dd hh:mm:ss ')&#125;]]<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>请求路径：[[$&#123;path&#125;]]<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>随意访问不存在路径得到:</p><p><img src="/images/SpringBoot%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89_2020-05-19-13-40-09.png" alt="SpringBoot——异常处理（十一）_2020-05-19-13-40-09.png"></p><h1 id="自定义错误JSON"><a href="#自定义错误JSON" class="headerlink" title="自定义错误JSON"></a>自定义错误JSON</h1><p>根据上面的 SpringBoot 错误处理原理分析，得知最终返回的 JSON 信息是从一个 map 对象中转换出来的，那么，只要能自定义 map 中的值，就可以自定义错误信息的 json 格式了。直接重写 <code>DefaultErrorAttributes</code> 类的 <code>getErrorAttributes</code> 方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.error.DefaultErrorAttributes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.WebRequest;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorAttributesCustom</span> <span class="keyword">extends</span> <span class="title">DefaultErrorAttributes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getErrorAttributes</span><span class="params">(WebRequest webRequest, <span class="keyword">boolean</span> includeStackTrace)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">super</span>.getErrorAttributes(webRequest, includeStackTrace);</span><br><span class="line">        String code = map.get(<span class="string">"status"</span>).toString();</span><br><span class="line">        String message = map.get(<span class="string">"templates/error"</span>).toString();</span><br><span class="line">        HashMap&lt;String, Object&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="string">"code"</span>, code);</span><br><span class="line">        hashMap.put(<span class="string">"message"</span>, message);</span><br><span class="line">        <span class="keyword">return</span> hashMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/SpringBoot%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89_2020-05-19-14-03-00.png" alt="SpringBoot——异常处理（十一）_2020-05-19-14-03-00.png"></p><h1 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h1><p>使用 <code>@ControllerAdvice</code> 结合 <code>@ExceptionHandler</code> 注解可以实现统一的异常处理，<code>@ExceptionHandler</code> 注解的类会自动应用在每一个被 <code>@RequestMapping</code> 注解的方法。当程序中出现异常时会层层上抛</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">String</span> <span class="title">handleException</span>(<span class="title">Exception</span> <span class="title">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot——过滤器、监听器（十）</title>
      <link href="/2020/05/19/SpringBoot%E2%80%94%E2%80%94%E8%BF%87%E6%BB%A4%E5%99%A8%E3%80%81%E7%9B%91%E5%90%AC%E5%99%A8%EF%BC%88%E5%8D%81%EF%BC%89/"/>
      <url>/2020/05/19/SpringBoot%E2%80%94%E2%80%94%E8%BF%87%E6%BB%A4%E5%99%A8%E3%80%81%E7%9B%91%E5%90%AC%E5%99%A8%EF%BC%88%E5%8D%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Filter, Listener 是 Java web 的核心内容，那么springBoot怎么使用它们那？</p><h1 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.qn.interceptor.LogHandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebFilter</span>(urlPatterns = <span class="string">"/*"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Logger logger = LoggerFactory.getLogger(LogHandlerInterceptor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"过滤器生效！！！"</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义监听器"><a href="#自定义监听器" class="headerlink" title="自定义监听器"></a>自定义监听器</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.qn.interceptor.LogHandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextListener;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebListener;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Logger logger = LoggerFactory.getLogger(LogHandlerInterceptor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"监听器开始初始化"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"监听器开始销毁"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h1><p>添加到容器有两种方式，第一种使用注解扫描。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ServletComponentScan</span> 扫描Servlet,Filter,Listener 添加到容器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootDemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>或者直接添加到容器中去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.qn.filter.LogFilter;</span><br><span class="line"><span class="keyword">import</span> com.qn.listener.LogListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringBootConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.ServletListenerRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebCoreConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">myFitler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FilterRegistrationBean&lt;&gt;(<span class="keyword">new</span> LogFilter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletListenerRegistrationBean <span class="title">myListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServletListenerRegistrationBean(<span class="keyword">new</span> LogListener());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot——切面（九）</title>
      <link href="/2020/05/19/SpringBoot%E2%80%94%E2%80%94%E5%88%87%E9%9D%A2%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
      <url>/2020/05/19/SpringBoot%E2%80%94%E2%80%94%E5%88%87%E9%9D%A2%EF%BC%88%E4%B9%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>项目中我们经常会用到aop切面，比如日志记录，事务管理等。</p><h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="自定义切面"><a href="#自定义切面" class="headerlink" title="自定义切面"></a>自定义切面</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.RequestContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.ServletRequestAttributes;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Logger logger = LoggerFactory.getLogger(LogHandlerInterceptor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程存放信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ThreadLocal&lt;Long&gt; startTime = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义切入点</span></span><br><span class="line"><span class="comment">     * 第一个*：标识所有返回类型</span></span><br><span class="line"><span class="comment">     * 字母路径：包路径</span></span><br><span class="line"><span class="comment">     * 两个点..：当前包以及子包</span></span><br><span class="line"><span class="comment">     * 第二个*：所有的类</span></span><br><span class="line"><span class="comment">     * 第三个*：所有的方法</span></span><br><span class="line"><span class="comment">     * 最后的两个点：所有类型的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(public * com.qn.controller..*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">webLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在切入点开始处切入内容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"webLog()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录请求时间</span></span><br><span class="line">        startTime.set(System.currentTimeMillis());</span><br><span class="line">        <span class="comment">// 获取请求域</span></span><br><span class="line">        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = requestAttributes.getRequest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录请求内容</span></span><br><span class="line">        logger.info(<span class="string">"Aspect-URL: "</span> + request.getRequestURI().toLowerCase());</span><br><span class="line">        logger.info(<span class="string">"Aspect-HTTP_METHOD: "</span> + request.getMethod());</span><br><span class="line">        logger.info(<span class="string">"Aspect-IP: "</span> + request.getRemoteAddr());</span><br><span class="line">        logger.info(<span class="string">"Aspect-REQUEST_METHOD: "</span> + joinPoint.getSignature().getDeclaringTypeName() + <span class="string">"."</span> + joinPoint.getSignature().getName());</span><br><span class="line">        logger.info(<span class="string">"Aspect-Args: "</span> + Arrays.toString(joinPoint.getArgs()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在切入点之后处理内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"webLog()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在切入点return内容之后切入内容（可以用来对处理返回值做一些加工处理）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterReturning</span>(returning = <span class="string">"ret"</span>, pointcut = <span class="string">"webLog()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterReturning</span><span class="params">(Object ret)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Aspect-Response: "</span> + ret);</span><br><span class="line">        Long endTime = System.currentTimeMillis();</span><br><span class="line">        logger.info(<span class="string">"Aspect-SpeedTime: "</span> + (endTime - startTime.get()) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>启动 访问：</p><p><img src="/images/SpringBoot%E2%80%94%E2%80%94%E5%88%87%E9%9D%A2%EF%BC%88%E4%B9%9D%EF%BC%89_2020-05-19-10-16-03.png" alt="SpringBoot——切面（九）_2020-05-19-10-16-03.png"></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot——拦截器（八）</title>
      <link href="/2020/05/18/SpringBoot%E2%80%94%E2%80%94%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%88%E5%85%AB%EF%BC%89/"/>
      <url>/2020/05/18/SpringBoot%E2%80%94%E2%80%94%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%88%E5%85%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Springboot 中的 Interceptor 拦截器也就是 mvc 中的拦截器，只是省去了 xml 配置部分。</p><h1 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogHandlerInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(LogHandlerInterceptor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求方法执行之前</span></span><br><span class="line"><span class="comment">     * 返回true则通过</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> </span>&#123;</span><br><span class="line">        StringBuffer requestURL = request.getRequestURL();</span><br><span class="line">        logger.info(<span class="string">"preHandle请求URL："</span> + requestURL.toString());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回modelAndView之前执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> modelAndView</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"postHandle返回modelAndView之前"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行Handler完成执行此方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"afterCompletion执行完请求方法完全返回之后"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.qn.interceptor.LogHandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringBootConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcWebConfig</span>  <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加自定义拦截器</span></span><br><span class="line"><span class="comment">     * .addPathPatterns("/**")  拦截的请求路径</span></span><br><span class="line"><span class="comment">     * .excludePathPatterns("/user"); 排除的请求路径</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> LogHandlerInterceptor())</span><br><span class="line">                .addPathPatterns(<span class="string">"/**"</span>)</span><br><span class="line">                .excludePathPatterns(<span class="string">"/user"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>启动，访问：</p><p><img src="/images/SpringBoot%E2%80%94%E2%80%94%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%88%E5%85%AB%EF%BC%89_2020-05-19-09-47-28.png" alt="SpringBoot——拦截器（八）_2020-05-19-09-47-28.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>日志——Log4j</title>
      <link href="/2020/05/18/%E6%97%A5%E5%BF%97%E2%80%94%E2%80%94Log4j/"/>
      <url>/2020/05/18/%E6%97%A5%E5%BF%97%E2%80%94%E2%80%94Log4j/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在java中，记录日志有很多种方式：</p><ol><li><p>自己实现：自己写类，将日志数据，以io操作方式，写数据到文本文件、数据库中。</p></li><li><p>使用log4j：log4j可以将日志输出到console窗口、文本文件、数据库等，功能强大！</p></li><li><p>使用slfj：slfj也是一个很强大的功能，slfj旨在一统天下，提供了logging.jar 和 log4j的接口，可以通过slfj来调用log4j，也可以调用jdk的logging。</p></li><li><p>使用jdk自带的logging.jar中的方法</p></li><li><p>使用logback</p></li></ol><h1 id="log4j组件"><a href="#log4j组件" class="headerlink" title="log4j组件"></a>log4j组件</h1><p>Log4j有三个主要的组件：Loggers(记录器)、Appenders(输出源)和Layouts(布局)。</p><h2 id="Loggers"><a href="#Loggers" class="headerlink" title="Loggers"></a>Loggers</h2><p>Loggers组件在此系统中被分为五个级别：DEBUG、INFO、WARN、ERROR和FATAL。这五个级别是有顺序的，DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，分别用来指定这条日志信息的重要程度，明白这一点很重要。</p><p>Log4j有一个规则：只输出级别不低于设定级别的日志信息，假设Loggers级别设定为INFO，则INFO、WARN、ERROR和FATAL级别的日志信息都会输出，而级别比INFO低的DEBUG则不会输出。</p><h2 id="Appenders"><a href="#Appenders" class="headerlink" title="Appenders"></a>Appenders</h2><p>禁用和使用日志请求只是Log4j的基本功能，Log4j日志系统还提供许多强大的功能，比如允许把日志输出到不同的地方，如控制台（Console）、文件（Files）等，可以根据天数或者文件大小产生新的文件，可以以流的形式发送到其它地方等等。</p><p>常使用的类如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.apache.log4j.ConsoleAppender（控制台）</span></span><br><span class="line"><span class="attr">org.apache.log4j.FileAppender（文件）</span></span><br><span class="line"><span class="attr">org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）</span></span><br><span class="line"><span class="attr">org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）</span></span><br><span class="line"><span class="attr">org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</span></span><br></pre></td></tr></table></figure><p>配置模式</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">log4j.appender.appenderName</span> = <span class="string">className</span></span><br><span class="line"><span class="meta">log4j.appender.appenderName.Option1</span> = <span class="string">value1</span></span><br><span class="line"><span class="attr">…</span></span><br><span class="line"><span class="meta">log4j.appender.appenderName.OptionN</span> = <span class="string">valueN</span></span><br></pre></td></tr></table></figure><h2 id="Layouts"><a href="#Layouts" class="headerlink" title="Layouts"></a>Layouts</h2><p>有时用户希望根据自己的喜好格式化自己的日志输出，Log4j可以在Appenders的后面附加Layouts来完成这个功能。Layouts提供四种日志输出样式，如根据HTML样式、自由指定样式、包含日志级别与信息的样式和包含日志时间、线程、类别等信息的样式。</p><p>常使用的类如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.apache.log4j.HTMLLayout（以HTML表格形式布局）</span></span><br><span class="line"><span class="attr">org.apache.log4j.PatternLayout（可以灵活地指定布局模式）</span></span><br><span class="line"><span class="attr">org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）</span></span><br><span class="line"><span class="attr">org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等信息）</span></span><br></pre></td></tr></table></figure><p>配置模式：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">log4j.appender.appenderName.layout</span> =<span class="string">className</span></span><br><span class="line"><span class="meta">log4j.appender.appenderName.layout.Option1</span> = <span class="string">value1</span></span><br><span class="line"><span class="attr">…</span></span><br><span class="line"><span class="meta">log4j.appender.appenderName.layout.OptionN</span> = <span class="string">valueN</span></span><br></pre></td></tr></table></figure><h1 id="配置详解"><a href="#配置详解" class="headerlink" title="配置详解"></a>配置详解</h1><p>Log4j支持两种配置文件格式：一种是XML格式的文件，一种是properties属性文件。</p><p>下面以properties属性文件为例介绍log4j.properties的配置。</p><h2 id="配置根Logger"><a href="#配置根Logger" class="headerlink" title="配置根Logger"></a>配置根Logger</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">log4j.rootLogger</span> = <span class="string">[ level ] , appenderName1, appenderName2, …</span></span><br></pre></td></tr></table></figure><p><code>level</code>：设定日志记录的最低级别，可设的值有OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者自定义的级别，Log4j建议只使用中间四个级别。</p><p><code>appenderName</code>：就是指定日志信息要输出到哪里。可以同时指定多个输出目的地，用逗号隔开。</p><p>例：log4j.rootLogger＝INFO,A1,B2,C3</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">log4j.additivity.org.apache</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure><p>表示Logger不会在父Logger的appender里输出，默认为true。</p><h2 id="配置日志信息输出目的地（appender）"><a href="#配置日志信息输出目的地（appender）" class="headerlink" title="配置日志信息输出目的地（appender）"></a>配置日志信息输出目的地（appender）</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">log4j.appender.appenderName</span> = <span class="string">className</span></span><br></pre></td></tr></table></figure><p><code>appenderName</code>：自定义appderName，在log4j.rootLogger设置中使用；</p><p><code>className</code>：可设值如下：</p><p>org.apache.log4j.ConsoleAppender//控制台</p><p>org.apache.log4j.FileAppender//文件</p><p>org.apache.log4j.DailyRollingFileAppender//每天产生一个日志文件</p><p>org.apache.log4j.RollingFileAppender//文件大小到达指定尺寸的时候产生一个新的文件</p><p>org.apache.log4j.WriterAppender//将日志信息以流格式发送到任意指定的地方</p><ol><li>ConsoleAppender选项</li></ol><p><code>Threshold=WARN</code>：指定日志信息的最低输出级别，默认为DEBUG。</p><p><code>ImmediateFlush=true</code>：表示所有消息都会被立即输出，设为false则不输出，默认值是true。</p><p><code>Target=System.err</code>：默认值是System.out。</p><ol start="2"><li>FileAppender选项</li></ol><p><code>Threshold=WARN</code>：指定日志信息的最低输出级别，默认为DEBUG。</p><p><code>ImmediateFlush=true</code>：表示所有消息都会被立即输出，设为false则不输出，默认值是true。</p><p><code>Append=false</code>：true表示消息增加到指定文件中，false则将消息覆盖指定的文件内容，默认值是true。</p><p><code>File=D:/logs/logging.log4j</code>：指定消息输出到logging.log4j文件中。</p><ol start="3"><li>DailyRollingFileAppender选项</li></ol><p><code>Threshold=WARN</code>：指定日志信息的最低输出级别，默认为DEBUG。</p><p><code>ImmediateFlush=true</code>：表示所有消息都会被立即输出，设为false则不输出，默认值是true。</p><p><code>Append=false</code>：true表示消息增加到指定文件中，false则将消息覆盖指定的文件内容，默认值是true。</p><p><code>File=D:/logs/logging.log4j</code>：指定当前消息输出到logging.log4j文件中。</p><p><code>DatePattern=&#39;.&#39;yyyy-MM</code>：每月滚动一次日志文件，即每月产生一个新的日志文件。当前月的日志文件名为logging.log4j，前一个月的日志文件名为logging.log4j.yyyy-MM。<br>另外，也可以指定按周、天、时、分等来滚动日志文件，对应的格式如下：</p><p>1) ‘.’yyyy-MM：每月<br>2) ‘.’yyyy-ww：每周<br>3) ‘.’yyyy-MM-dd：每天<br>4) ‘.’yyyy-MM-dd-a：每天两次<br>5) ‘.’yyyy-MM-dd-HH：每小时<br>6) ‘.’yyyy-MM-dd-HH-mm：每分钟</p><ol start="4"><li>RollingFileAppender选项</li></ol><p><code>Threshold=WARN</code>：指定日志信息的最低输出级别，默认为DEBUG。</p><p><code>ImmediateFlush=true</code>：表示所有消息都会被立即输出，设为false则不输出，默认值是true。</p><p><code>Append=false</code>：true表示消息增加到指定文件中，false则将消息覆盖指定的文件内容，默认值是true。</p><p><code>File=D:/logs/logging.log4j</code>：指定消息输出到logging.log4j文件中。</p><p><code>MaxFileSize=100KB</code>：后缀可以是KB, MB 或者GB。在日志文件到达该大小时，将会自动滚动，即将原来的内容移到logging.log4j.1文件中。</p><p><code>MaxBackupIndex=2</code>：指定可以产生的滚动文件的最大数，例如，设为2则可以产生logging.log4j.1，logging.log4j.2两个滚动文件和一个logging.log4j文件。</p><h2 id="配置日志信息的输出格式（Layout）"><a href="#配置日志信息的输出格式（Layout）" class="headerlink" title="配置日志信息的输出格式（Layout）"></a>配置日志信息的输出格式（Layout）</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">log4j.appender.appenderName.layout</span>=<span class="string">className</span></span><br></pre></td></tr></table></figure><p><code>className</code>：可设值如下：</p><p>org.apache.log4j.HTMLLayout//以HTML表格形式布局</p><p>org.apache.log4j.PatternLayout//可以灵活地指定布局模式</p><p>org.apache.log4j.SimpleLayout//包含日志信息的级别和信息字符串</p><p>org.apache.log4j.TTCCLayout//包含日志产生的时间、线程、类别等等信息</p><ol><li>HTMLLayout选项</li></ol><p><code>LocationInfo=true</code>：输出java文件名称和行号，默认值是false。</p><p><code>Title=My Logging</code>： 默认值是Log4J Log Messages。</p><ol start="2"><li>PatternLayout选项</li></ol><p><code>ConversionPattern=%m%n</code>：设定以怎样的格式显示消息。</p><h1 id="格式化符号说明"><a href="#格式化符号说明" class="headerlink" title="格式化符号说明"></a>格式化符号说明</h1><p>%p：输出日志信息的优先级，即DEBUG，INFO，WARN，ERROR，FATAL。</p><p>%d：输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式</p><p>%r：输出自应用程序启动到输出该log信息耗费的毫秒数。</p><p>%t：输出产生该日志事件的线程名。</p><p>%l：输出日志事件的发生位置，相当于%c.%M(%F:%L)的组合，包括类全名、方法、文件名以及在代码中的行数。</p><p>%c：输出日志信息所属的类目，通常就是所在类的全名。</p><p>%M：输出产生日志信息的方法名。</p><p>%F：输出日志消息产生时所在的文件名称。</p><p>%L:：输出代码中的行号。</p><p>%m:：输出代码中指定的具体日志信息。</p><p>%n：输出一个回车换行符，Windows平台为”rn”，Unix平台为”n”。</p><p>%x：输出和当前线程相关联的NDC(嵌套诊断环境)，尤其用到像java servlets这样的多客户多线程的应用中。</p><p>%%：输出一个”%”字符。</p><p>另外，还可以在%与格式字符之间加上修饰符来控制其最小长度、最大长度、和文本的对齐方式。如：</p><p>1) c：指定输出category的名称，最小的长度是20，如果category的名称长度小于20的话，默认的情况下右对齐。</p><p>2) %-20c：”-“号表示左对齐。</p><p>3) %.30c：指定输出category的名称，最大的长度是30，如果category的名称长度大于30的话，就会将左边多出的字符截掉，但小于30的话也不会补空格。</p><h1 id="配置样例"><a href="#配置样例" class="headerlink" title="配置样例"></a>配置样例</h1><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">DEBUG,console,dailyFile,im</span></span><br><span class="line"><span class="meta">log4j.additivity.org.apache</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 控制台(console)</span></span><br><span class="line"><span class="meta">log4j.appender.console</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.console.Threshold</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.appender.console.ImmediateFlush</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">log4j.appender.console.Target</span>=<span class="string">System.err</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout.ConversionPattern</span>=<span class="string">[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志文件(logFile)</span></span><br><span class="line"><span class="meta">log4j.appender.logFile</span>=<span class="string">org.apache.log4j.FileAppender</span></span><br><span class="line"><span class="meta">log4j.appender.logFile.Threshold</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.appender.logFile.ImmediateFlush</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">log4j.appender.logFile.Append</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">log4j.appender.logFile.File</span>=<span class="string">D:/logs/log.log4j</span></span><br><span class="line"><span class="meta">log4j.appender.logFile.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.logFile.layout.ConversionPattern</span>=<span class="string">[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n</span></span><br><span class="line"><span class="comment"># 回滚文件(rollingFile)</span></span><br><span class="line"><span class="meta">log4j.appender.rollingFile</span>=<span class="string">org.apache.log4j.RollingFileAppender</span></span><br><span class="line"><span class="meta">log4j.appender.rollingFile.Threshold</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.appender.rollingFile.ImmediateFlush</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">log4j.appender.rollingFile.Append</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">log4j.appender.rollingFile.File</span>=<span class="string">D:/logs/log.log4j</span></span><br><span class="line"><span class="meta">log4j.appender.rollingFile.MaxFileSize</span>=<span class="string">200KB</span></span><br><span class="line"><span class="meta">log4j.appender.rollingFile.MaxBackupIndex</span>=<span class="string">50</span></span><br><span class="line"><span class="meta">log4j.appender.rollingFile.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.rollingFile.layout.ConversionPattern</span>=<span class="string">[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n</span></span><br><span class="line"><span class="comment"># 定期回滚日志文件(dailyFile)</span></span><br><span class="line"><span class="meta">log4j.appender.dailyFile</span>=<span class="string">org.apache.log4j.DailyRollingFileAppender</span></span><br><span class="line"><span class="meta">log4j.appender.dailyFile.Threshold</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.appender.dailyFile.ImmediateFlush</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">log4j.appender.dailyFile.Append</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">log4j.appender.dailyFile.File</span>=<span class="string">D:/logs/log.log4j</span></span><br><span class="line"><span class="meta">log4j.appender.dailyFile.DatePattern</span>=<span class="string">'.'yyyy-MM-dd</span></span><br><span class="line"><span class="meta">log4j.appender.dailyFile.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.dailyFile.layout.ConversionPattern</span>=<span class="string">[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n</span></span><br><span class="line"><span class="comment"># 应用于socket</span></span><br><span class="line"><span class="meta">log4j.appender.socket</span>=<span class="string">org.apache.log4j.RollingFileAppender</span></span><br><span class="line"><span class="meta">log4j.appender.socket.RemoteHost</span>=<span class="string">localhost</span></span><br><span class="line"><span class="meta">log4j.appender.socket.Port</span>=<span class="string">5001</span></span><br><span class="line"><span class="meta">log4j.appender.socket.LocationInfo</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># Set up for Log Factor 5</span></span><br><span class="line"><span class="meta">log4j.appender.socket.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.socket.layout.ConversionPattern</span>=<span class="string">[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n</span></span><br><span class="line"><span class="comment"># Log Factor 5 Appender</span></span><br><span class="line"><span class="meta">log4j.appender.LF5_APPENDER</span>=<span class="string">org.apache.log4j.lf5.LF5Appender</span></span><br><span class="line"><span class="meta">log4j.appender.LF5_APPENDER.MaxNumberOfRecords</span>=<span class="string">2000</span></span><br><span class="line"><span class="comment"># 发送日志到指定邮件</span></span><br><span class="line"><span class="meta">log4j.appender.mail</span>=<span class="string">org.apache.log4j.net.SMTPAppender</span></span><br><span class="line"><span class="meta">log4j.appender.mail.Threshold</span>=<span class="string">FATAL</span></span><br><span class="line"><span class="meta">log4j.appender.mail.BufferSize</span>=<span class="string">10</span></span><br><span class="line"><span class="meta">log4j.appender.mail.From</span> = <span class="string">xxx@mail.com</span></span><br><span class="line"><span class="meta">log4j.appender.mail.SMTPHost</span>=<span class="string">mail.com</span></span><br><span class="line"><span class="meta">log4j.appender.mail.Subject</span>=<span class="string">Log4J Message</span></span><br><span class="line"><span class="meta">log4j.appender.mail.To</span>= <span class="string">xxx@mail.com</span></span><br><span class="line"><span class="meta">log4j.appender.mail.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.mail.layout.ConversionPattern</span>=<span class="string">[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n</span></span><br><span class="line"><span class="comment"># 应用于数据库</span></span><br><span class="line"><span class="meta">log4j.appender.database</span>=<span class="string">org.apache.log4j.jdbc.JDBCAppender</span></span><br><span class="line"><span class="meta">log4j.appender.database.URL</span>=<span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="meta">log4j.appender.database.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">log4j.appender.database.user</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">log4j.appender.database.password</span>=<span class="string"></span></span><br><span class="line"><span class="meta">log4j.appender.database.sql</span>=<span class="string">INSERT INTO LOG4J (Message) VALUES('=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n')</span></span><br><span class="line"><span class="meta">log4j.appender.database.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.database.layout.ConversionPattern</span>=<span class="string">[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义Appender</span></span><br><span class="line"><span class="meta">log4j.appender.im</span> = <span class="string">net.cybercorlin.util.logger.appender.IMAppender</span></span><br><span class="line"><span class="meta">log4j.appender.im.host</span> = <span class="string">mail.cybercorlin.net</span></span><br><span class="line"><span class="meta">log4j.appender.im.username</span> = <span class="string">username</span></span><br><span class="line"><span class="meta">log4j.appender.im.password</span> = <span class="string">password</span></span><br><span class="line"><span class="meta">log4j.appender.im.recipient</span> = <span class="string">corlin@cybercorlin.net</span></span><br><span class="line"><span class="meta">log4j.appender.im.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.im.layout.ConversionPattern</span>=<span class="string">[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n</span></span><br></pre></td></tr></table></figure><p>Log4j的强大功能无可置疑，但实际应用中免不了遇到某个功能需要输出独立的日志文件的情况，怎样才能把所需的内容从原有日志中分离，形成单独的日志文件呢？其实只要在现有的Log4j基础上稍加配置即可轻松实现这一功能。</p><p>如果想对不同的类输出不同的文件(以cn.com.Test为例)，先要在Test.java中定义:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Log logger = LogFactory.getLog(Test<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><p>然后在log4j.properties中加入:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">log4j.logger.cn.com.Test</span>= <span class="string">DEBUG, test</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.appender.test</span>=<span class="string">org.apache.log4j.FileAppender</span></span><br><span class="line"><span class="meta">log4j.appender.test.File</span>=<span class="string">$&#123;myweb.root&#125;/WEB-INF/log/test.log</span></span><br><span class="line"><span class="meta">log4j.appender.test.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.test.layout.ConversionPattern</span>=<span class="string">%d %p [%c] - %m%n</span></span><br></pre></td></tr></table></figure><p>还有一个问题，就是这些自定义的日志默认是同时输出到log4j.rootLogger所配置的日志中的，如何能只让它们输出到自己指定的日志中呢？别急，这里有个开关：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">log4j.additivity.myTest1</span> = <span class="string">false</span></span><br></pre></td></tr></table></figure><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><ol><li><p>log4j需要导入的包，一般使用log4j需要与logging配合使用：</p><p> commons-logging-1.0.4.jar</p><p> log4j-1.2.15.jar</p></li><li><p>在src下，把log4j的配置文件添加进去log4j.properties。</p></li><li><p>main主函数调用：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log4jTest</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Logger logger1 = Logger.getLogger(Log4jTest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//logger1</span></span><br><span class="line">       logger1.trace(<span class="string">"我是logger1，trace"</span>);</span><br><span class="line">       logger1.debug(<span class="string">"我是logger1，debug"</span>);</span><br><span class="line">       logger1.info(<span class="string">"我是logger1，info"</span>);</span><br><span class="line">       logger1.warn(<span class="string">"我是logger1，warn"</span>);</span><br><span class="line">       logger1.error(<span class="string">"我是logger1，error"</span>);</span><br><span class="line">       logger1.fatal(<span class="string">"我是logger1，fatal"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="slf4j"><a href="#slf4j" class="headerlink" title="slf4j"></a>slf4j</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>SLF4J 不是一个真正的日志实现，而是一个抽象层，它允许你在后台使用任意一个日志类库。</p><p>如果一个项目已经使用了log4j，而你加载了一个类库，比方说 Apache Active MQ——它依赖于于另外一个日志类库logback，那么你就需要把它也加载进去。但如果Apache Active MQ使用了SLF4J，你可以继续使用你的日志类库而无需忍受加载和维护一个新的日志框架的痛苦。</p><p>除此之外，还有一个SLF4J API的特性是使得我坚持使用SLF4J而抛弃我长期间钟爱的Log4j的理由，是被称为占位符(place holder)，在代码中表示为“{}”的特性。</p><h2 id="实战-1"><a href="#实战-1" class="headerlink" title="实战"></a>实战</h2><p>需要导入的jar包：</p><p><img src="/images/%E6%97%A5%E5%BF%97%E2%80%94%E2%80%94Log4j_2020-05-18-13-39-06.png" alt="日志——Log4j_2020-05-18-13-39-06.png"></p><p>配置文件(log4j.properties)：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">debug, C</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.appender.A</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.A.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.A.layout.ConversionPattern</span>=<span class="string">%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%c]-[%p] %m%n</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.appender.B</span>=<span class="string">org.apache.log4j.FileAppender</span></span><br><span class="line"><span class="meta">log4j.appender.B.File</span>=<span class="string">E:\\log.log</span></span><br><span class="line"><span class="meta">log4j.appender.B.layout</span>=<span class="string">org.apache.log4j.SimpleLayout</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.appender.C</span>=<span class="string">org.apache.log4j.RollingFileAppender</span></span><br><span class="line"><span class="meta">log4j.appender.C.File</span>=<span class="string">E:\\log.html</span></span><br><span class="line"><span class="meta">log4j.appender.C.MaxFileSize</span>=<span class="string">1000KB</span></span><br><span class="line"><span class="meta">log4j.appender.C.MaxBackupIndex</span>=<span class="string">10</span></span><br><span class="line"><span class="meta">log4j.appender.C.layout</span>=<span class="string">org.apache.log4j.HTMLLayout</span></span><br><span class="line"><span class="meta">log4j.appender.C.encoding</span>=<span class="string">gbk</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.appender.D</span>=<span class="string">org.apache.log4j.DailyRollingFileAppender</span></span><br><span class="line"><span class="meta">log4j.appender.D.File</span>=<span class="string">E:\\log.log</span></span><br><span class="line"><span class="meta">log4j.appender.D.layout</span>=<span class="string">org.apache.log4j.TTCCLayout</span></span><br></pre></td></tr></table></figure><p>main方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xm.exam.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Slf4jTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(Slf4jTest<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">// slf4j日志记录器</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 普通的日志记录</span></span><br><span class="line">        logger.debug(<span class="string">"普通的日志记录"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &#123;&#125;占位符记录日志</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            logger.debug(<span class="string">"这是第&#123;&#125;条记录"</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用\转义&#123;&#125;</span></span><br><span class="line">        logger.debug(<span class="string">"Set \\&#123;&#125; differs from &#123;&#125;"</span>, <span class="string">"3"</span>); <span class="comment">// output:Set &#123;&#125; differs</span></span><br><span class="line">                                                        <span class="comment">// from 3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个参数</span></span><br><span class="line">        logger.debug(<span class="string">"两个占位符，可以传两个参数&#123;&#125;----&#123;&#125;"</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 多个参数(可变参数)</span></span><br><span class="line">        logger.debug(<span class="string">"debug:多个占位符，&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;"</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 多个参数(可变参数)</span></span><br><span class="line">        logger.info(<span class="string">"info:多个占位符，&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;"</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 多个参数(可变参数)</span></span><br><span class="line">        logger.error(<span class="string">"error:多个占位符，&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;"</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 Log4j </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot——模板引擎（七）</title>
      <link href="/2020/05/14/SpringBoot%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%EF%BC%88%E4%B8%83%EF%BC%89/"/>
      <url>/2020/05/14/SpringBoot%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%EF%BC%88%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Spring MVC 支持各种模版技术，如 Thymeleaf , FreeMarker , JSP 等。而Thyemeleaf 原型即页面的特性或许更符合 Spring Boot 快速开发的思想而被官方推荐。</p><p>Thymeleaf 是适用于 Web 开发的服务端 Java 模版引擎，Thymeleaf 为开发工作流程带来优雅自然的模版，由于其非侵入的特性，可以让页面不管是在静态原型下还是用作模版引擎时都有良好的页面展现。</p><h1 id="引入Thymeleaf"><a href="#引入Thymeleaf" class="headerlink" title="引入Thymeleaf"></a>引入Thymeleaf</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h1><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line"><span class="comment">  #模板引擎</span></span><br><span class="line">  <span class="attr">thymeleaf</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">encoding</span>: <span class="string">utf-8</span></span><br><span class="line">    <span class="attr">servlet</span>:<span class="string"></span></span><br><span class="line">      <span class="meta">content-type</span>: <span class="string">text/html</span></span><br><span class="line">    <span class="attr">prefix</span>: <span class="string">classpath:/html/</span></span><br><span class="line">    <span class="attr">suffix</span>: <span class="string">.html</span></span><br></pre></td></tr></table></figure><h1 id="html"><a href="#html" class="headerlink" title="html"></a>html</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:text</span>=<span class="string">"$&#123;hello&#125;"</span>&gt;</span>这里是原来的文本！<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 不转义 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:utext</span>=<span class="string">"$&#123;hello&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span> <span class="attr">th:each</span>=<span class="string">"user : $&#123;users&#125;"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:each</span>=<span class="string">"user : $&#123;users&#125;"</span>&gt;</span> [[$&#123;user&#125;]] <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/success"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">success</span><span class="params">(ModelMap model)</span> </span>&#123;</span><br><span class="line">       model.addAttribute(<span class="string">"hello"</span>, <span class="string">"&lt;h1&gt;Hello World&lt;/h1&gt;"</span>);</span><br><span class="line">       model.addAttribute(<span class="string">"users"</span>, Arrays.asList(<span class="string">"zhangsan"</span>, <span class="string">"lisi"</span>, <span class="string">"wangwu"</span>));</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p><img src="/images/SpringBoot%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%EF%BC%88%E4%B8%83%EF%BC%89_2020-05-18-15-59-21.png" alt="SpringBoot——模板引擎（七）_2020-05-18-15-59-21.png"></p><h1 id="不兼容"><a href="#不兼容" class="headerlink" title="不兼容"></a>不兼容</h1><p>当在使用Thymeleaf，实际上在用 ThymeleafViewResolver，这时mvc 的 InternalResourceViewResolver 不生效，当然我们可以通过配置让它们可以兼容使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> ViewResolver <span class="title">viewResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           InternalResourceViewResolver resolver = <span class="keyword">new</span> InternalResourceViewResolver();</span><br><span class="line">           resolver.setPrefix(<span class="string">"/WEB-INF/"</span>);</span><br><span class="line">           resolver.setSuffix(<span class="string">".jsp"</span>);</span><br><span class="line">           resolver.setViewNames(<span class="string">"jsp/*"</span>);</span><br><span class="line">           resolver.setOrder(<span class="number">2</span>);</span><br><span class="line">           <span class="keyword">return</span> resolver;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Bean</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> ITemplateResolver <span class="title">templateResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           SpringResourceTemplateResolver templateResolver = <span class="keyword">new</span> SpringResourceTemplateResolver();</span><br><span class="line">           templateResolver.setTemplateMode(<span class="string">"HTML5"</span>);</span><br><span class="line">           templateResolver.setPrefix(<span class="string">"/WEB-INF/"</span>);</span><br><span class="line">           templateResolver.setSuffix(<span class="string">".html"</span>);</span><br><span class="line">           templateResolver.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">           templateResolver.setCacheable(<span class="keyword">false</span>);</span><br><span class="line">           <span class="keyword">return</span> templateResolver;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Bean</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> SpringTemplateEngine <span class="title">templateEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           SpringTemplateEngine templateEngine = <span class="keyword">new</span> SpringTemplateEngine();</span><br><span class="line">           templateEngine.setTemplateResolver(templateResolver());</span><br><span class="line">           <span class="keyword">return</span> templateEngine;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Bean</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> ThymeleafViewResolver <span class="title">viewResolverThymeLeaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           ThymeleafViewResolver viewResolver = <span class="keyword">new</span> ThymeleafViewResolver();</span><br><span class="line">           viewResolver.setTemplateEngine(templateEngine());</span><br><span class="line">           viewResolver.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">           viewResolver.setViewNames(<span class="keyword">new</span> String[]&#123;<span class="string">"thymeleaf/*"</span>&#125;);</span><br><span class="line">           viewResolver.setOrder(<span class="number">1</span>);</span><br><span class="line">           <span class="keyword">return</span> viewResolver;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> </span>&#123;</span><br><span class="line">           configurer.enable();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">super</span>.addResourceHandlers(registry);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot——静态资源（六）</title>
      <link href="/2020/05/14/SpringBoot%E2%80%94%E2%80%94%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%EF%BC%88%E5%85%AD%EF%BC%89/"/>
      <url>/2020/05/14/SpringBoot%E2%80%94%E2%80%94%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%EF%BC%88%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMvc-对静态资源的访问"><a href="#SpringMvc-对静态资源的访问" class="headerlink" title="SpringMvc 对静态资源的访问"></a>SpringMvc 对静态资源的访问</h1><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&lt;!--对静态资源文件的访问方式1--&gt;</span></span><br><span class="line"><span class="meta">&lt;mvc</span>:<span class="string">resources mapping="/images/**" location="/images/" /&gt;  </span></span><br><span class="line"><span class="attr">&lt;!--对静态资源文件的访问方式2--&gt;</span></span><br><span class="line"><span class="meta">&lt;mvc</span>:<span class="string">default-servlet-handler/&gt;</span></span><br></pre></td></tr></table></figure><h1 id="springboot对静态资源的访问"><a href="#springboot对静态资源的访问" class="headerlink" title="springboot对静态资源的访问"></a>springboot对静态资源的访问</h1><h2 id="默认路径"><a href="#默认路径" class="headerlink" title="默认路径"></a>默认路径</h2><p>Spring Boot 默认对于静态资源的映射目录是：</p><p>/static<br>/public<br>/resources<br>/META-INF/resource。</p><p>优先级顺序：</p><p>/META-INF/resources&gt;resources&gt;static&gt;public</p><h2 id="自定义路径"><a href="#自定义路径" class="headerlink" title="自定义路径"></a>自定义路径</h2><p>配置文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">resources</span>:<span class="string"></span></span><br><span class="line">        <span class="meta">static-locations</span>: <span class="string">classpath:/html,classpath:/images,classpath:/templates,classpath:/static</span></span><br></pre></td></tr></table></figure><p>mvc配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcWebConfig</span>  <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">"/static/**"</span>).addResourceLocations(<span class="string">"classpath:/resources/static/"</span>);</span><br><span class="line">        <span class="keyword">super</span>.addResourceHandlers(registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种方式是有问题的，这种方式会屏蔽Spring Boot的@EnableAutoConfiguration中的设置。所以用这种方式在application.yml里的映射配置都要通过方法来重写。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot——日志（五）</title>
      <link href="/2020/05/13/SpringBoot%E2%80%94%E2%80%94%E6%97%A5%E5%BF%97%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2020/05/13/SpringBoot%E2%80%94%E2%80%94%E6%97%A5%E5%BF%97%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="springboot的日志框架"><a href="#springboot的日志框架" class="headerlink" title="springboot的日志框架"></a>springboot的日志框架</h1><p>Spring Boot 默认选择了 SLF4J 结合 LogBack。</p><p>在 Spring Boot 的 Maven 依赖里可以清楚的看到 Spring Boot 排除了其他日志框架。</p><p>其实 Spring Boot 也是使用了 SLF4J+logback 的日志框架组合，查看 Spring Boot 项目的 Maven 依赖关系可以看到 Spring Boot 的核心启动器 spring-boot-starter 引入了 spring-boot-starter-logging.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而 spring-boot-starter-logging 的 Maven 依赖主要引入了 logback-classic ，log4j-to-slf4j ，jul-to-slf4j .</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-to-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jul-to-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">LogbackTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.trace(<span class="string">"Trace 日志..."</span>);</span><br><span class="line">        logger.debug(<span class="string">"Debug 日志..."</span>);</span><br><span class="line">        logger.info(<span class="string">"Info 日志..."</span>);</span><br><span class="line">        logger.warn(<span class="string">"Warn 日志..."</span>);</span><br><span class="line">        logger.error(<span class="string">"Error 日志..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已知日志级别从小到大为 trace &lt; debug &lt; info &lt; warn &lt; error . 运行得到输出如下。由此可见 Spring Boot 默认日志级别为 INFO.</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">2020-05-14</span> <span class="string">13:28:11.340  INFO 7180 --- [           main] com.qn.test.LogbackTest                  : Info 日志...</span></span><br><span class="line"><span class="meta">2020-05-14</span> <span class="string">13:28:11.340  WARN 7180 --- [           main] com.qn.test.LogbackTest                  : Warn 日志...</span></span><br><span class="line"><span class="meta">2020-05-14</span> <span class="string">13:28:11.340 ERROR 7180 --- [           main] com.qn.test.LogbackTest                  : Error 日志...</span></span><br></pre></td></tr></table></figure><p>结合日志来看，默认的日志格式为：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">%d&#123;yyyy-MM-dd</span> <span class="string">HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span></span><br><span class="line"><span class="comment"># %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; 时间</span></span><br><span class="line"><span class="comment"># %thread 线程名称</span></span><br><span class="line"><span class="comment"># %-5level 日志级别从左显示5个字符宽度</span></span><br><span class="line"><span class="comment"># %logger&#123;50&#125; 类名</span></span><br><span class="line"><span class="comment"># %msg%n 日志信息加换行</span></span><br></pre></td></tr></table></figure><h1 id="自定义日志输出"><a href="#自定义日志输出" class="headerlink" title="自定义日志输出"></a>自定义日志输出</h1><p>properties:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">logging.file.path</span>=<span class="string">log </span></span><br><span class="line"><span class="meta">logging.file.max-history</span>=<span class="string">10</span></span><br><span class="line"><span class="meta">logging.file.max-size</span>=<span class="string">10MB</span></span><br><span class="line"><span class="meta">logging.level.com.qn</span>=<span class="string">debug</span></span><br><span class="line"><span class="meta">logging.pattern.console</span>=<span class="string">%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span></span><br><span class="line"><span class="meta">logging.pattern.file</span>=<span class="string">%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span></span><br></pre></td></tr></table></figure><p>yml：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">file</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">path</span>: <span class="string">log</span></span><br><span class="line">    <span class="meta">max-history</span>: <span class="string">10</span></span><br><span class="line">    <span class="meta">max-size</span>: <span class="string">10MB</span></span><br><span class="line">  <span class="attr">level</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">com</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">qn</span> : <span class="string">debug</span></span><br><span class="line">  <span class="attr">pattern</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">console</span>: <span class="string">'%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n'</span></span><br><span class="line">    <span class="attr">file</span>: <span class="string">'%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n'</span></span><br></pre></td></tr></table></figure><h1 id="使用配置文件"><a href="#使用配置文件" class="headerlink" title="使用配置文件"></a>使用配置文件</h1><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">config</span>: <span class="string">classpath:logging-config.xml</span></span><br></pre></td></tr></table></figure><h1 id="log4j"><a href="#log4j" class="headerlink" title="log4j"></a>log4j</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> <span class="comment">&lt;!-- exclude掉spring-boot的默认log配置 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> <span class="comment">&lt;!-- 引入log4j2依赖 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  <span class="comment">&lt;!-- 加上这个才能辨认到log4j2.yml文件 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-yaml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>log4j2.yml</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Configuration</span>:  <span class="string"></span></span><br><span class="line">  <span class="attr">status</span>: <span class="string">warn  </span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">Properties</span>: <span class="string"># 定义全局变量  </span></span><br><span class="line">    <span class="attr">Property</span>: <span class="string"># 缺省配置（用于开发环境）。其他环境需要在VM参数中指定，如下：  </span></span><br><span class="line"><span class="comment">      #测试：-Dlog.level.console=warn -Dlog.level.xjj=trace  </span></span><br><span class="line"><span class="comment">      #生产：-Dlog.level.console=warn -Dlog.level.xjj=info        </span></span><br><span class="line">      <span class="meta">-</span> <span class="string">name: log.level.console  </span></span><br><span class="line">        <span class="attr">value</span>: <span class="string">trace  </span></span><br><span class="line">      <span class="meta">-</span> <span class="string">name: log.level.xjj  </span></span><br><span class="line">        <span class="attr">value</span>: <span class="string">trace         </span></span><br><span class="line">      <span class="meta">-</span> <span class="string">name: log.path  </span></span><br><span class="line">        <span class="attr">value</span>: <span class="string">/opt/logs  </span></span><br><span class="line">      <span class="meta">-</span> <span class="string">name: project.name  </span></span><br><span class="line">        <span class="attr">value</span>: <span class="string">my-spring-boot  </span></span><br><span class="line">    </span><br><span class="line">  <span class="attr">Appenders</span>:  <span class="string"></span></span><br><span class="line">    <span class="attr">Console</span>:  <span class="string">#输出到控制台  </span></span><br><span class="line">      <span class="attr">name</span>: <span class="string">CONSOLE  </span></span><br><span class="line">      <span class="attr">target</span>: <span class="string">SYSTEM_OUT  </span></span><br><span class="line">      <span class="attr">ThresholdFilter</span>:  <span class="string"></span></span><br><span class="line">        <span class="attr">level</span>: <span class="string">$&#123;sys:log.level.console&#125; # “sys:”表示：如果VM参数中没指定这个变量值，则使用本文件中定义的缺省全局变量值  </span></span><br><span class="line">        <span class="attr">onMatch</span>: <span class="string">ACCEPT  </span></span><br><span class="line">        <span class="attr">onMismatch</span>: <span class="string">DENY  </span></span><br><span class="line">      <span class="attr">PatternLayout</span>:  <span class="string"></span></span><br><span class="line">        <span class="attr">pattern</span>: <span class="string">"%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125;:%4p %t (%F:%L) - %m%n"  </span></span><br><span class="line">    <span class="attr">RollingFile</span>: <span class="string"># 输出到文件，超过128MB归档  </span></span><br><span class="line">      <span class="meta">-</span> <span class="string">name: ROLLING_FILE  </span></span><br><span class="line">        <span class="attr">ignoreExceptions</span>: <span class="string">false  </span></span><br><span class="line">        <span class="attr">fileName</span>: <span class="string">$&#123;log.path&#125;/$&#123;project.name&#125;.log  </span></span><br><span class="line">        <span class="attr">filePattern</span>: <span class="string">"$&#123;log.path&#125;/$$&#123;date:yyyy-MM&#125;/$&#123;project.name&#125;-%d&#123;yyyy-MM-dd&#125;-%i.log.gz"  </span></span><br><span class="line">        <span class="attr">PatternLayout</span>:  <span class="string"></span></span><br><span class="line">          <span class="attr">pattern</span>: <span class="string">"%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125;:%4p %t (%F:%L) - %m%n"  </span></span><br><span class="line">        <span class="attr">Policies</span>:  <span class="string"></span></span><br><span class="line">          <span class="attr">SizeBasedTriggeringPolicy</span>:  <span class="string"></span></span><br><span class="line">            <span class="attr">size</span>: <span class="string">"128 MB"  </span></span><br><span class="line">        <span class="attr">DefaultRolloverStrategy</span>:  <span class="string"></span></span><br><span class="line">          <span class="attr">max</span>: <span class="string">1000  </span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">Loggers</span>:  <span class="string"></span></span><br><span class="line">    <span class="attr">Root</span>:  <span class="string"></span></span><br><span class="line">      <span class="attr">level</span>: <span class="string">info  </span></span><br><span class="line">      <span class="attr">AppenderRef</span>:  <span class="string"></span></span><br><span class="line">        <span class="meta">-</span> <span class="string">ref: CONSOLE  </span></span><br><span class="line">        <span class="meta">-</span> <span class="string">ref: ROLLING_FILE  </span></span><br><span class="line">    <span class="attr">Logger</span>: <span class="string"># 为com.xjj包配置特殊的Log级别，方便调试  </span></span><br><span class="line">      <span class="meta">-</span> <span class="string">name: com.xjj  </span></span><br><span class="line">        <span class="attr">additivity</span>: <span class="string">false  </span></span><br><span class="line">        <span class="attr">level</span>: <span class="string">$&#123;sys:log.level.xjj&#125;  </span></span><br><span class="line">        <span class="attr">AppenderRef</span>:  <span class="string"></span></span><br><span class="line">          <span class="meta">-</span> <span class="string">ref: CONSOLE  </span></span><br><span class="line">          <span class="meta">-</span> <span class="string">ref: ROLLING_FILE</span></span><br></pre></td></tr></table></figure><h1 id="logback的优势"><a href="#logback的优势" class="headerlink" title="logback的优势"></a>logback的优势</h1><ol><li>更快的执行速度：logback重写了内部实现，在某些特定的场景下，甚至比之前快了10倍。在保证logback组件更快速的同时所需内存更小。</li><li>与SLF4J组合使用。</li><li>自动刷新配置文件：这个过程很快，无需资源竞争，不会创建一个单独的线程去扫描。</li><li>优雅的从I/O错误中恢复，文件服务器宕机，无需重新启动。</li><li>过滤：可以设置特定用户日志级别。</li><li>logback原生支持同时按日期和文件大小分割。</li></ol>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot——多环境配置（四）</title>
      <link href="/2020/05/13/SpringBoot%E2%80%94%E2%80%94%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2020/05/13/SpringBoot%E2%80%94%E2%80%94%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h1><p>在主配置文件编写的时候，文件名可以是 application-{name}.properties.默认使用的是application.properties.</p><p>那么如何在配置文件中激活其他的配置文件呢？只需要在 application.properties 启用其他文件。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 激活 application-prod.properties文件</span></span><br><span class="line"><span class="meta">spring.profiles.active</span>=<span class="string">prod</span></span><br></pre></td></tr></table></figure><h1 id="yml"><a href="#yml" class="headerlink" title="yml"></a>yml</h1><p>yml 配置文件编写时可以参照 properties 文件编写多个环境配置文件，也可以在一个yml文件中进行多环境配置，如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person</span>:<span class="string"></span></span><br><span class="line">  <span class="meta">last-name</span>: <span class="string">cyy</span></span><br><span class="line">  <span class="attr">age</span>: <span class="string">28</span></span><br><span class="line">  <span class="attr">birth</span>: <span class="string">2020/02/02</span></span><br><span class="line">  <span class="attr">email</span>: <span class="string">gmail@gmail.com</span></span><br><span class="line">  <span class="attr">maps</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">key1</span>: <span class="string">java</span></span><br><span class="line">    <span class="attr">key2</span>: <span class="string">golang</span></span><br><span class="line">  <span class="attr">lists</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">-</span> <span class="string">a</span></span><br><span class="line">    <span class="meta">-</span> <span class="string">b</span></span><br><span class="line">    <span class="meta">-</span> <span class="string">c</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">profiles</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">active</span>: <span class="string">prod</span></span><br><span class="line"><span class="comment">  # 使用三个---进行文档块区分</span></span><br><span class="line"><span class="attr">---</span></span><br><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8084</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">profiles</span>: <span class="string">dev</span></span><br><span class="line"><span class="attr">---</span></span><br><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8085</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">profiles</span>: <span class="string">prod</span></span><br></pre></td></tr></table></figure><h1 id="profile"><a href="#profile" class="headerlink" title="@profile"></a>@profile</h1><p>使用 spring.profiles.active 参数,搭配@Profile注解,可以实现不同环境下（开发、测试、生产）配置参数的切换。</p><p>1.@Profile注解使用范围：@Configration 和 @Component 注解的类及其方法，其中包括继承了@Component的注解：@Service、@Controller、@Repository等… </p><p>2.@Profile可接受一个或者多个参数，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"dev"</span>,<span class="string">"sit"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonValue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接从配置文件读取一个值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;person.last-name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持SpEL表达式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123;11*4/2&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;person.birth&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不支持复杂类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; lists;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不支持数据校验</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"xxx@@@@"</span>)</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dev环境与sit环境才会被spring管理。</p><h1 id="激活-profile"><a href="#激活-profile" class="headerlink" title="激活 profile"></a>激活 profile</h1><h2 id="命令行方式："><a href="#命令行方式：" class="headerlink" title="命令行方式："></a>命令行方式：</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">java</span> <span class="string">-jar order-service-v1.0.jar --spring.profiles.active=dev &amp;&gt; order-service.log &amp;</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">java</span> <span class="string">-Dspring.profiles.active=dev -jar order-service-v1.0.jar &amp;&gt; order-service.log &amp;</span></span><br></pre></td></tr></table></figure><h2 id="系统变量方式："><a href="#系统变量方式：" class="headerlink" title="系统变量方式："></a>系统变量方式：</h2><p>编辑环境变量配置文件/etc/profile，添加名为SPRING_PROFILES_ACTIVE的环境变量，如下所示：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># spring 环境激活</span></span><br><span class="line"><span class="attr">export</span> <span class="string">SPRING_PROFILES_ACTIVE=dev</span></span><br></pre></td></tr></table></figure><h2 id="java系统属性方式"><a href="#java系统属性方式" class="headerlink" title="java系统属性方式"></a>java系统属性方式</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">java</span> <span class="string">-Dspring.profiles.active=dev -jar order-service-v1.0.jar &amp;&gt; order-service.log &amp;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot——配置文件（三）</title>
      <link href="/2020/05/12/SpringBoot%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2020/05/12/SpringBoot%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="yml-与-properties"><a href="#yml-与-properties" class="headerlink" title="yml 与 properties"></a>yml 与 properties</h1><p>我们都会发现在 resource 有一个配置文件 application.properties,也有可能是application.yml.这个文件也就是 Spring Boot 默认的的配置文件。</p><p>yml的数据格式：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务启动端口号</span></span><br><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8080</span></span><br><span class="line"><span class="comment"># 配置person属性值</span></span><br><span class="line"><span class="attr">person</span>:<span class="string"></span></span><br><span class="line">  <span class="meta">last-name</span>: <span class="string">Darcy</span></span><br><span class="line">  <span class="attr">age</span>: <span class="string">20</span></span><br><span class="line">  <span class="attr">birth</span>: <span class="string">2018/01/01</span></span><br><span class="line">  <span class="attr">email</span>: <span class="string">gmail@gmail.com</span></span><br><span class="line">  <span class="attr">maps</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">key1</span>:<span class="string">java</span></span><br><span class="line">    <span class="attr">key2</span>:<span class="string">golang</span></span><br><span class="line">  <span class="attr">lists</span>:<span class="string"></span></span><br><span class="line">  <span class="meta">-</span> <span class="string">a</span></span><br><span class="line">  <span class="meta">-</span> <span class="string">b</span></span><br><span class="line">  <span class="meta">-</span> <span class="string">c</span></span><br><span class="line">  <span class="attr">dog</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">旺财</span></span><br><span class="line">    <span class="attr">age</span>: <span class="string">2</span></span><br></pre></td></tr></table></figure><p>properties的数据格式:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务启动端口号</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8080</span></span><br><span class="line"><span class="comment"># 配置属性值（使用IDE进行配置需要处理编码问题，不然中文会发送乱码现象）</span></span><br><span class="line"><span class="meta">person.last-name</span>=<span class="string">张三</span></span><br><span class="line"><span class="meta">person.age</span>=<span class="string">18</span></span><br><span class="line"><span class="meta">person.birth</span>=<span class="string">2018/12/06</span></span><br><span class="line"><span class="meta">person.email</span>=<span class="string">niu@gmail.com</span></span><br><span class="line"><span class="meta">person.maps.key1</span>=<span class="string">c</span></span><br><span class="line"><span class="meta">person.maps.key2</span>=<span class="string">java</span></span><br><span class="line"><span class="meta">person.maps.key3</span>=<span class="string">golang</span></span><br><span class="line"><span class="meta">person.lists</span>=<span class="string">a,b,c,d</span></span><br><span class="line"><span class="meta">person.dog.name</span>=<span class="string">旺财</span></span><br><span class="line"><span class="meta">person.dog.age</span>=<span class="string">1</span></span><br></pre></td></tr></table></figure><h1 id="随机数和占位符"><a href="#随机数和占位符" class="headerlink" title="随机数和占位符"></a>随机数和占位符</h1><p>RandomValuePropertySource 类对于注入随机值很有用（例如，注入秘密或测试用例）。它可以生成整数，长整数，uuid 或字符串等，通过 Spring Boot 对我们的封装，我们可以轻松的使用。</p><p>占位符允许在配置的值中引用之前定义过的变量。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成随机值</span></span><br><span class="line"><span class="meta">bootapp.secret</span>=<span class="string">$ &#123;random.value&#125;</span></span><br><span class="line"><span class="meta">bootapp.number</span>=<span class="string">$ &#123;random.int&#125;</span></span><br><span class="line"><span class="meta">bootapp.bignumber</span>=<span class="string">$ &#123;random.long&#125;</span></span><br><span class="line"><span class="meta">bootapp.uuid</span>=<span class="string">$ &#123;random.uuid&#125;</span></span><br><span class="line"><span class="meta">bootapp.number.less.than.ten</span>=<span class="string">$ &#123;random.int（10）&#125;</span></span><br><span class="line"><span class="meta">bootapp.number.in.range</span>=<span class="string">$ &#123;random.int [1024,65536]&#125;</span></span><br><span class="line"><span class="comment"># 属性的占位符</span></span><br><span class="line"><span class="meta">bootapp.name</span>=<span class="string">SpringBoot</span></span><br><span class="line"><span class="meta">bootapp.description</span>=<span class="string">$&#123;bootapp.name&#125;是一个spring应用程序</span></span><br></pre></td></tr></table></figure><h1 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h1><p>@ConfigurationProperties 注解是 Spring Boot 提供的一种使用属性的注入方法。不仅可以方便的把配置文件中的属性值与所注解类绑定，还支持松散绑定，JSR-303 数据校验等功能。</p><p>以上面演示的 Properties 的配置为例演示 @ConfigurationProperties 注解的使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="meta">@Max</span>(<span class="number">150</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; lists;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持数据校验</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h1><p>@Value 支持直接从配置文件中读取值，同时支持 SpEL 表达式，但是不支持复杂数据类型和数据验证，下面是具体的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonValue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接从配置文件读取一个值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;person.last-name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持SpEL表达式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123;11*4/2&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;person.birth&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不支持复杂类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; lists;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不支持数据校验</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"xxx@@@@"</span>)</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的示例，也可以发现 @ConfigurationProperties 和 @Value的区别：</p><table><thead><tr><th>特征</th><th>@ConfigurationProperties</th><th>@Value</th></tr></thead><tbody><tr><td>功能</td><td>批量注入配置文件属性</td><td>一个一个注入</td></tr><tr><td>松散绑定（松散的语法）</td><td>支持</td><td>不支持</td></tr><tr><td>SpEL</td><td>不支持</td><td>支持</td></tr><tr><td>JSR-303 数据校验</td><td>支持</td><td>不支持</td></tr><tr><td>复杂类型</td><td>支持</td><td>不支持</td></tr></tbody></table><h1 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h1><p>随着业务复杂性的增加，配置文件也越来越多，我们会觉得所有的配置都写在一个 properties 文件会使配置显得繁杂不利于管理，因此希望可以把映射属性类的配置单独的抽取出来。</p><p>这时可以使用 @PropertySource 注解来指定要读取的配置文件。</p><p>如果抽取 person 配置为单独文件 person.properties：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">person.last-name</span>=<span class="string">张三</span></span><br><span class="line"><span class="meta">person.age</span>=<span class="string">18</span></span><br><span class="line"><span class="meta">person.birth</span>=<span class="string">2018/12/06</span></span><br><span class="line"><span class="meta">person.email</span>=<span class="string">niu@gmail.com</span></span><br><span class="line"><span class="meta">person.maps.key1</span>=<span class="string">c</span></span><br><span class="line"><span class="meta">person.maps.key2</span>=<span class="string">java</span></span><br><span class="line"><span class="meta">person.maps.key3</span>=<span class="string">golang</span></span><br><span class="line"><span class="meta">person.lists</span>=<span class="string">a,b,c,d</span></span><br></pre></td></tr></table></figure><p>配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="meta">@PropertySource</span>(value = <span class="string">"classpath:person.properties"</span>)</span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(value = <span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonSource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; lists;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持数据校验</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot——单元测试（二）</title>
      <link href="/2020/05/12/SpringBoot%E2%80%94%E2%80%94%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/05/12/SpringBoot%E2%80%94%E2%80%94%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>结合上面提到的 Spring Boot 启动器知识，Spring Boot 已经为我们提供了丰富的第三方框架，测试框架也不例外。</p><p>导入单元测试依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">HelloControllerTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloController helloController;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(helloController.index());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot——Hello入门（一）</title>
      <link href="/2020/05/12/SpringBoot%E2%80%94%E2%80%94Hello%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/05/12/SpringBoot%E2%80%94%E2%80%94Hello%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Spring Boot 提供了一组工具只需要极少的配置就可以快速的构建并启动基于 Spring 的应用程序。解决了传统 Spring 开发需要配置大量配置文件的痛点。</p><p>同时 Spring Boot 对于第三方库设置了合理的默认值，可以快速的构建起应用程序。</p><p>当然 Spring Boot 也可以轻松的自定义各种配置，无论是在开发的初始阶段还是投入生成的后期阶段。</p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>快速的创建可以独立运行的 Spring 项目以及与主流框架的集成。</p><p>使用嵌入式的 Servlet 容器，用于不需要打成war包。</p><p>使用很多的启动器（Starters）自动依赖与版本控制。</p><p>大量的自动化配置，简化了开发，当然，我们也可以修改默认值。</p><p>不需要配置 XML 文件，无代码生成，开箱即用。</p><p>准生产环境的运行时应用监控。</p><p>与云计算的天然集成。</p><h1 id="创建一个springBoot项目"><a href="#创建一个springBoot项目" class="headerlink" title="创建一个springBoot项目"></a>创建一个springBoot项目</h1><p>用idea可以快速的创建一个SpringBoot项目，项目结构如下：</p><p><img src="/images/SpringBoot%E2%80%94%E2%80%94Hello%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89_2020-05-12-15-33-16.png" alt="SpringBoot——Hello入门（一）_2020-05-12-15-33-16.png"></p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>springboot-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>spring-boot-starter-parent</code> 是Spring Boot 的核心依赖，它里面定义了各种在开发中会用到的第三方 jar 的版本信息，因此我们在引入其他的 Spring Boot 为我们封装的启动器的时候都不在需要指定版本信息。如果我们需要自定义版本信息，可以直接覆盖版本属性值即可。</p><p><code>spring-boot-starter-web</code> 提供 web 以及 MVC 和 validator 等web开发框架的支持。</p><p><code>spring-boot-starter-test</code> 提供测试模块的支持。如 Junit，Mockito。</p><p><code>spring-boot-maven-plugin</code> springboot提供maven打包的plugin。</p><p>Spring Boot 为我们提供了很多的已经封装好的称为启动器（starter）的依赖项。让我们在使用的时候不需要再进行复杂的配置就可以迅速的进行应用集成。所有的官方启动器依赖可以在这里查看。</p><h2 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootDemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommandLineRunner <span class="title">commandLineRunner</span><span class="params">(ApplicationContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args -&gt; &#123;</span><br><span class="line">            <span class="comment">// 开始检查spring boot 提供的 beans</span></span><br><span class="line">            System.out.println(<span class="string">"Let's inspect the beans provided by Spring Boot:"</span>);</span><br><span class="line">            String[] beanNames = ctx.getBeanDefinitionNames();</span><br><span class="line">            Arrays.sort(beanNames);</span><br><span class="line">            <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">                System.out.println(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Greetings from Spring Boot!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h2><p><img src="/images/SpringBoot%E2%80%94%E2%80%94Hello%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89_2020-05-12-15-45-09.png" alt="SpringBoot——Hello入门（一）_2020-05-12-15-45-09.png"></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot——自动装配原理</title>
      <link href="/2020/04/30/SpringBoot%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/"/>
      <url>/2020/04/30/SpringBoot%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h1><p>SpringBoot启动的时候加载主配置类，开启了自动配置功能 <code>@EnableAutoConfiguration</code></p><p>在spring中有关于 <code>@Enablexxx</code> 的注解是开启某一项功能的注解，比如 <code>@EnableScheduling</code> 表示开启spring的定时任务。其原理是借助 <code>@Import</code> 的帮助，将所有符合自动配置条件的bean定义加载到Ioc容器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAutoConfiguration</span> </span>&#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">"spring.boot.enableautoconfiguration"</span>;</span><br><span class="line"><span class="comment">//按类型排序不需要自动装配的类</span></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="comment">//按名称排除不需要自动装配的类</span></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以知道，最关键的要属 <code>@Import(EnableAutoConfigurationImportSelector.class)</code>，借助<code>EnableAutoConfigurationImportSelector</code> ，<code>@EnableAutoConfiguration</code> 可以帮助SpringBoot应用将所有符合条件的 <code>@Configuration</code> 配置都加载到当前SpringBoot创建并使用的IoC容器。</p><p>同时借助于 Spring 框架原有的一个工具类：SpringFactoriesLoader，<code>@EnableAutoConfiguration</code> 就可以实现智能的自动配置。</p><ol><li><p><code>@EnableAutoConfiguration</code> 作用就是从classpath中搜寻所有的 META-INF/spring.factories 配置文件</p></li><li><p>将其中 org.springframework.boot.autoconfigure.EnableutoConfiguration 对应的配置项通过反射（Java Refletion）实例化为对应的标注了@Configuration的JavaConfig形式的IoC容器配置类，然后汇总为一个并加载到IoC容器。</p></li><li><p>这些功能配置类要生效的话，会去classpath中找是否有该类的依赖类,所以功能类能生效需要的条件：</p><ul><li>spring.factories里面有这个类的配置类（一个配置类可以创建多个围绕该功能的依赖类）</li><li>pom.xml里面需要有对应的jar包</li></ul></li></ol><h1 id="以Redis自动装配为例"><a href="#以Redis自动装配为例" class="headerlink" title="以Redis自动装配为例"></a>以Redis自动装配为例</h1><ol><li><p>从spring-boot-autoconfigure.jar/META-INF/spring.factories中获取redis的相关配置类全限定名（有120多个的配置类）RedisAutoConfiguration</p></li><li><p>RedisAutoConfiguration配置类生效的一个条件是在classpath路径下有RedisOperations类存在，因此springboot的自动装配机制会会去classpath下去查找对应的class文件。 其中 <code>@ConditionalOnClass</code> 注解是关键。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(RedisOperations<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">EnableConfigurationProperties</span>(<span class="title">RedisProperties</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Import</span>(</span>&#123; LettuceConnectionConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">JedisConnectionConfiguration</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">RedisAutoConfiguration</span> </span>&#123;</span><br><span class="line">...&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>如果pom.xml有对应的jar包,就能匹配到对应依赖class</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>匹配成功，这个功能配置类才会生效，同时会注入默认的属性配置类 @EnableConfigurationProperties(RedisProperties.class)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.redis"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> database = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String host = <span class="string">"localhost"</span>;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port = <span class="number">6379</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="5"><li>Redis功能配置里面会根据条件生成最终的JedisConnectionFactory、RedisTemplate,并提供了默认的配置形式@ConditionalOnMissingBean(name = “redisTemplate”)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(RedisOperations<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">EnableConfigurationProperties</span>(<span class="title">RedisProperties</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Import</span>(</span>&#123; LettuceConnectionConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">JedisConnectionConfiguration</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">RedisAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line"><span class="comment">//用户没定义就使用默认的</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(name = <span class="string">"redisTemplate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            RedisConnectionFactory redisConnectionFactory)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(StringRedisTemplate<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">StringRedisTemplate</span> <span class="title">stringRedisTemplate</span>(</span></span><br><span class="line"><span class="class">            <span class="title">RedisConnectionFactory</span> <span class="title">redisConnectionFactory</span>) <span class="title">throws</span> <span class="title">UnknownHostException</span> </span>&#123;</span><br><span class="line">        StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><p>容器在启动的时候Application.run，会调用EnableAutoConfigurationImportSelector.class的selectImports方法（其实是其父类的方法）</p></li><li><p>selectImports方法最终会调用SpringFactoriesLoader.loadFactoryNames方法来获取一个全面的常用BeanConfiguration列表</p></li><li><p>loadFactoryNames方法会读取 FACTORIES_RESOURCE_LOCATION（也就是spring-boot-autoconfigure.jar 下面的spring.factories），获取到所有的Spring相关的Bean的全限定名ClassName，大概120多个</p></li><li><p>selectImports 方法继续调用 filter(configurations, autoConfigurationMetadata);这个时候会根据这些BeanConfiguration里面的条件，来一一筛选，最关键的是 @ConditionalOnClass，这个条件注解会去classpath下查找，jar包里面是否有这个条件依赖类，所以必须有了相应的jar包，才有这些依赖类，才会生成IOC环境需要的一些默认配置Bean</p></li><li><p>最后把符合条件的BeanConfiguration注入默认的EnableConfigurationPropertie类里面的属性值，并且注入到IOC环境当中</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring——事务理论</title>
      <link href="/2020/04/27/Spring%E2%80%94%E2%80%94%E4%BA%8B%E5%8A%A1%E7%90%86%E8%AE%BA/"/>
      <url>/2020/04/27/Spring%E2%80%94%E2%80%94%E4%BA%8B%E5%8A%A1%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>事务是一组不可分割的操作，要么全部成功，要么全部失败。</p><h1 id="事务的四个特性"><a href="#事务的四个特性" class="headerlink" title="事务的四个特性"></a>事务的四个特性</h1><ol><li><p>原子性(Atomicity)：事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p></li><li><p>一致性(Consistency)：事务在完成后数据的完整性必须保持一致。</p></li><li><p>隔离性(Isolation)：多个用户并发访问数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间的数据要相互隔离。</p></li><li><p>持久性（Durability）：一个事务一旦被提交，它对数据库中数据的改变应该是永久性的，即使数据库发生故障也不应该对其有任何影响。</p></li></ol><p>注：事物的原子性，一致性，持久性是通过数据库的 redo/undo 日志文件实现的。<br>redo log 处理系统故障，undo log 处理事务回滚。 如果在事务提交后出现数据库崩溃的情况，当恢复时，数据库会根据重写日志对数据进行回滚。</p><h1 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h1><ol><li><p>脏读 ：一个事务读到了另一个事务的未提交的数据</p></li><li><p>不可重复读 ：一个事务读到了另一个事务已经提交的 update 的数据导致多次查询结果不一致</p></li><li><p>幻读 ：一个事务读到了另一个事务已经提交的 insert 的数据导致多次查询结果不一致</p></li></ol><p>在 Spring 事务管理中，为我们定义了如下的隔离级别：</p><ol><li><p>ISOLATION_DEFAULT：使用数据库默认的隔离级别</p></li><li><p>ISOLATION_READ_UNCOMMITTED：最低的隔离级别，允许读取已改变而没有提交的数据，可能会导致脏读、幻读或不可重复读</p></li><li><p>ISOLATION_READ_COMMITTED：允许读取事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</p></li><li><p>ISOLATION_REPEATABLE_READ：对同一字段的多次读取结果都是一致的，除非数据事务本身改变，可以阻止脏读和不可重复读，但幻读仍有可能发生</p></li><li><p>ISOLATION_SERIALIZABLE：最高的隔离级别，完全服从ACID的隔离级别，确保不发生脏读、不可重复读以及幻读，也是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的</p></li></ol><p>Read uncommitted:</p><p>读未提交，就是一个事务可以读取另一个未提交事务的数据。</p><p>事例：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。</p><p>分析：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读。</p><p>那怎么解决脏读呢？Read committed！读提交，能解决脏读问题。</p><p>Read committed:</p><p>读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。</p><p>事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的…</p><p>分析：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。</p><p>那怎么解决可能的不可重复读问题？Repeatable read ！</p><p>Repeatable read:</p><p>重复读，就是在开始读取数据（事务开启）时，不再允许修改操作。MySQL的默认事务隔离级别</p><p>事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（事务开启，不允许其他事务的UPDATE修改操作），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。</p><p>分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。</p><p>什么时候会出现幻读？</p><p>事例：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。</p><p>那怎么解决幻读问题？Serializable！</p><p>Serializable 序列化:</p><p>Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。简单来说，Serializable会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用问题。这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。</p><h1 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h1><p>Spring事务传播机制规定了事务方法和事务方法发生嵌套调用时事务如何进行传播。</p><p>Spring定义了七种传播行为，这里以方法A和方法B发生嵌套调用时如何传播事务为例说明：</p><ol><li><p>PROPAGATION_REQUIRED：A如果有事务，B将使用该事务；如果A没有事务，B将创建一个新的事务</p></li><li><p>PROPAGATION_SUPPORTS：A如果有事务，B将使用该事务；如果A没有事务，B将以非事务执行</p></li><li><p>PROPAGATION_MANDATORY：A如果有事务，B将使用该事务；如果A没有事务，B将抛异常</p></li><li><p>PROPAGATION_REQUIRES_NEW：A如果有事务，将A的事务挂起，B创建一个新的事务；如果A没有事务，B创建一个新的事务</p></li><li><p>PROPAGATION_NOT_SUPPORTED：A如果有事务，将A的事务挂起，B将以非事务执行；如果A没有事务，B将以非事务执行</p></li><li><p>PROPAGATION_NEVER：A如果有事务，B将抛异常；A如果没有事务，B将以非事务执行</p></li><li><p>PROPAGATION_NESTED：A和B底层采用保存点机制，形成嵌套事务</p></li></ol><h1 id="是否只读-事务超时-回滚规则"><a href="#是否只读-事务超时-回滚规则" class="headerlink" title="是否只读 事务超时 回滚规则"></a>是否只读 事务超时 回滚规则</h1><p>如果将事务设置为只读，表示这个事务只读取数据但不更新数据, 这样可以帮助数据库引擎优化事务</p><p>事务超时就是事务的一个定时器，在特定时间内事务如果没有执行完毕，那么就会自动回滚，而不是一直等待其结束。在 TransactionDefinition 中以 int 的值来表示超时时间，默认值是-1，其单位是秒</p><p>回滚规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到运行期异常时才会回滚</p><h1 id="Spring事务管理接口"><a href="#Spring事务管理接口" class="headerlink" title="Spring事务管理接口"></a>Spring事务管理接口</h1><p>Spring 事务管理为我们提供了三个高层抽象的接口，分别是TransactionProxyFactoryBean，TransactionDefinition，TransactionStatus</p><h2 id="PlatformTransactionManager事务管理器"><a href="#PlatformTransactionManager事务管理器" class="headerlink" title="PlatformTransactionManager事务管理器"></a>PlatformTransactionManager事务管理器</h2><p>Spring框架并不直接管理事务，而是通过这个接口为不同的持久层框架提供了不同的PlatformTransactionManager接口实现类，也就是将事务管理的职责委托给Hibernate或者iBatis等持久化框架的事务来实现：</p><ol><li>org.springframework.jdbc.datasource.DataSourceTransactionManager：使用JDBC或者iBatis进行持久化数据时使用</li><li>org.springframework.orm.hibernate5.HibernateTransactionManager：使用hibernate5版本进行持久化数据时使用</li><li>org.springframework.orm.jpa.JpaTransactionManager：使用JPA进行持久化数据时使用</li><li>org.springframework.jdo.JdoTransactionManager：当持久化机制是jdo时使用</li><li>org.springframework.transaction.jta.JtaTransactionManager：使用一个JTA实现来管理事务，在一个事务跨越多个资源时必须使用</li></ol><p>PlatformTransactionManager接口源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//事务管理器通过TransactionDefinition，获得“事务状态”，从而管理事务</span></span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(@Nullable TransactionDefinition var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">    <span class="comment">//根据状态提交</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">   <span class="comment">//根据状态回滚</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TransactionDefinition定义事务基本属性"><a href="#TransactionDefinition定义事务基本属性" class="headerlink" title="TransactionDefinition定义事务基本属性"></a>TransactionDefinition定义事务基本属性</h2><p>它定义了Spring事务管理的五大属性：隔离级别、传播行为、是否只读、事务超时、回滚规则</p><h2 id="TransactionStatus事务状态"><a href="#TransactionStatus事务状态" class="headerlink" title="TransactionStatus事务状态"></a>TransactionStatus事务状态</h2><p>该接口定义了一组方法，用来获取或判断事务的相应状态信息</p><h1 id="Spring事务实现方式"><a href="#Spring事务实现方式" class="headerlink" title="Spring事务实现方式"></a>Spring事务实现方式</h1><p>Spring 事务管理有两种方式：编程式事务管理、声明式事务管理</p><h2 id="编程式事务管理"><a href="#编程式事务管理" class="headerlink" title="编程式事务管理"></a>编程式事务管理</h2><p>编程式事务管理可以管理到代码块的事务。</p><p>编程式事务管理我们可以通过PlatformTransactionManager实现来进行事务管理，同样的Spring也为我们提供了模板类TransactionTemplate进行事务管理，下面主要介绍模板类，我们需要在配置文件中配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置事务管理的模板--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.transaction.support.TransactionTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionManager"</span> <span class="attr">ref</span>=<span class="string">"transactionManager"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--定义事务隔离级别,-1表示使用数据库默认级别--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"isolationLevelName"</span> <span class="attr">value</span>=<span class="string">"ISOLATION_DEFAULT"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"propagationBehaviorName"</span> <span class="attr">value</span>=<span class="string">"PROPAGATION_REQUIRED"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>TransactionTemplate帮我们封装了许多代码，节省了我们的工作。</p><p>建表SQL都省略，直接看Test</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">locations</span> </span>= &#123;<span class="string">"classpath:spring-test.xml"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionTest</span></span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BaseSevice baseSevice;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before transaction"</span>);</span><br><span class="line">        Integer sum1 = baseSevice.sum();</span><br><span class="line">        System.out.println(<span class="string">"before transaction sum: "</span>+sum1);</span><br><span class="line">        System.out.println(<span class="string">"transaction...."</span>);</span><br><span class="line">        transactionTemplate.execute(<span class="keyword">new</span> TransactionCallbackWithoutResult() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doInTransactionWithoutResult</span><span class="params">(TransactionStatus status)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    baseSevice.insert(<span class="string">"INSERT INTO tbl_account VALUES (100);"</span>,<span class="keyword">false</span>);</span><br><span class="line">                    baseSevice.insert(<span class="string">"INSERT INTO tbl_account VALUES (100);"</span>,<span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    <span class="comment">//对于抛出Exception类型的异常且需要回滚时,需要捕获异常并通过调用status对象的setRollbackOnly()方法告知事务管理器当前事务需要回滚</span></span><br><span class="line">                    status.setRollbackOnly();</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"after transaction"</span>);</span><br><span class="line">        Integer sum2 = baseSevice.sum();</span><br><span class="line">        System.out.println(<span class="string">"after transaction sum: "</span>+sum2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="失明式事务管理"><a href="#失明式事务管理" class="headerlink" title="失明式事务管理"></a>失明式事务管理</h2><p>声明式事务管理有两种常用的方式，一种是基于tx和aop命名空间的xml配置文件，一种是基于@Transactional注解</p><ol><li>基于tx和aop命名空间的xml配置文件</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--配置事务的通知--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"transfer*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pointcut1"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.tx.service.impl.*ServiceImpl.*(..))"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut1"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>基于注解的方式</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置事务管理器--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--开启事务注解--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>在事务方法中添加@Transaction注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferMoney</span><span class="params">(String source, String destination, Long amount)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        transferDao.payMoney(source, amount);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">100</span>/<span class="number">0</span>;</span><br><span class="line">        transferDao.collectMoney(destination, amount);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a>@Transactional</h1><p>@Transactional注解可以作用于接口、接口方法、类以及类方法上 。</p><ol><li><p>当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性</p></li><li><p>当作用在方法级别时会覆盖类级别的定义</p></li><li><p>当作用在接口和接口方法时则只有在使用基于接口的代理时它才会生效，也就是JDK动态代理，而不是Cglib代理 </p></li><li><p>当在 protected、private 或者默认可见性的方法上使用 @Transactional 注解时是不会生效的，也不会抛出任何异常</p></li><li><p>默认情况下，只有来自外部的方法调用才会被AOP代理捕获，也就是，类内部方法调用本类内部的其他方法并不会引起事务行为，即使被调用方法使用@Transactional注解进行修饰</p></li><li><p>非检查异常才能被事务回滚</p></li></ol><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ol><li>readOnly</li></ol><p>该属性用于设置当前事务是否为只读事务，设置为true表示只读，false则表示可读写，默认值为false</p><ol start="2"><li>rollbackFor</li></ol><p>该属性用于设置需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则进行事务回滚。例如： 1. 指定单一异常类：@Transactional(rollbackFor=RuntimeException.class) 2. 指定多个异常类：@Transactional(rollbackFor={RuntimeException.class, BusnessException.class})</p><ol start="3"><li>rollbackForClassName</li></ol><p>该属性用于设置需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，则进行事务回滚。例如： 1. 指定单一异常类名称：@Transactional(rollbackForClassName=”RuntimeException”) 2. 指定多个异常类名称：@Transactional(rollbackForClassName={“RuntimeException”,”BusnessException”})</p><ol start="4"><li>noRollbackFor</li></ol><p>该属性用于设置不需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，不进行事务回滚</p><ol start="5"><li>noRollbackForClassName</li></ol><p>参照上方的例子</p><ol start="6"><li>timeout</li></ol><p>该属性用于设置事务的超时秒数，默认值为-1表示永不超时</p><ol start="7"><li>propagation</li></ol><p>该属性用于设置事务的传播行为 例如：@Transactional(propagation=Propagation.NOT_SUPPORTED)</p><ol start="8"><li>isolation</li></ol><p>该属性用于设置底层数据库的事务隔离级别</p><p>事务隔离级别介绍:</p><p>@Transactional(isolation = Isolation.READ_UNCOMMITTED)读取未提交数据(会出现脏读, 不可重复读) 基本不使用<br>@Transactional(isolation = Isolation.READ_COMMITTED)读取已提交数据(会出现不可重复读和幻读)<br>@Transactional(isolation = Isolation.REPEATABLE_READ)可重复读(会出现幻读)<br>@Transactional(isolation = Isolation.SERIALIZABLE)串行化</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring——Bean的生命周期</title>
      <link href="/2020/04/27/Spring%E2%80%94%E2%80%94Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2020/04/27/Spring%E2%80%94%E2%80%94Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>对于普通的Java对象，当new的时候创建对象，当它没有任何引用的时候被垃圾回收机制回收。由Spring IoC容器托管的对象，它们的生命周期完全由容器控制。</p><p>Spring 只帮我们管理单例模式 Bean 的完整生命周期，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。</p><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>首先看下生命周期图：</p><p><img src="/images/Spring%E2%80%94%E2%80%94Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F_2020-04-27-15-09-58.png" alt="Spring——Bean的生命周期_2020-04-27-15-09-58.png"></p><h2 id="实例化Bean"><a href="#实例化Bean" class="headerlink" title="实例化Bean"></a>实例化Bean</h2><p>对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。</p><p>对于ApplicationContext容器，当容器启动结束后，便实例化所有的bean。 容器通过获取BeanDefinition对象中的信息进行实例化。并且这一步仅仅是简单的实例化，并未进行依赖注入。 实例化对象被包装在BeanWrapper对象中，BeanWrapper提供了设置对象属性的接口，从而避免了使用反射机制设置属性。</p><h2 id="设置对象属性（依赖注入）"><a href="#设置对象属性（依赖注入）" class="headerlink" title="设置对象属性（依赖注入）"></a>设置对象属性（依赖注入）</h2><p>实例化后的对象被封装在BeanWrapper对象中，并且此时对象仍然是一个原生的状态，并没有进行依赖注入。 紧接着，Spring根据BeanDefinition中的信息进行依赖注入。 并且通过BeanWrapper提供的设置属性的接口完成依赖注入。</p><h2 id="注入Aware接口"><a href="#注入Aware接口" class="headerlink" title="注入Aware接口"></a>注入Aware接口</h2><p>紧接着，Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给bean。</p><h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><p>当经过上述几个步骤后，bean对象已经被正确构造，但如果你想要对象被使用前再进行一些自定义的处理，就可以通过BeanPostProcessor接口实现。 </p><p>该接口提供了两个函数：</p><p>postProcessBeforeInitialzation( Object bean, String beanName ) 当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。 这个函数会先于InitialzationBean执行，因此称为前置处理。 所有Aware接口的注入就是在这一步完成的。</p><p>postProcessAfterInitialzation( Object bean, String beanName ) 当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。 这个函数会在InitialzationBean完成后执行，因此称为后置处理。</p><h2 id="InitializingBean与init-method"><a href="#InitializingBean与init-method" class="headerlink" title="InitializingBean与init-method"></a>InitializingBean与init-method</h2><p>当BeanPostProcessor的前置处理完成后就会进入本阶段。 </p><p>InitializingBean接口只有一个函数：</p><p>afterPropertiesSet()这一阶段也可以在bean正式构造完成前增加我们自定义的逻辑，但它与前置处理不同，由于该函数并不会把当前bean对象传进来，因此在这一步没办法处理对象本身，只能增加一些额外的逻辑。 若要使用它，我们需要让bean实现该接口，并把要增加的逻辑写在该函数中。然后Spring会在前置处理完成后检测当前bean是否实现了该接口，并执行afterPropertiesSet函数。</p><p>当然，Spring为了降低对客户代码的侵入性，给bean的配置提供了init-method属性，该属性指定了在这一阶段需要执行的函数名。Spring便会在初始化阶段执行我们设置的函数。init-method本质上仍然使用了InitializingBean接口。</p><h2 id="DisposableBean和destroy-method"><a href="#DisposableBean和destroy-method" class="headerlink" title="DisposableBean和destroy-method"></a>DisposableBean和destroy-method</h2><p>和init-method一样，通过给destroy-method指定函数，就可以在bean销毁前执行指定的逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring Bean的生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring——注解大全</title>
      <link href="/2020/04/26/Spring%E2%80%94%E2%80%94%E6%B3%A8%E8%A7%A3%E5%A4%A7%E5%85%A8/"/>
      <url>/2020/04/26/Spring%E2%80%94%E2%80%94%E6%B3%A8%E8%A7%A3%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="声明bean的注解"><a href="#声明bean的注解" class="headerlink" title="声明bean的注解"></a>声明bean的注解</h1><ul><li>@Component 组件，没有明确的角色</li><li>@Service 在业务逻辑层使用（service层）</li><li>@Repository 在数据访问层使用（dao层）</li><li>@Controller 在展现层使用，控制器的声明</li></ul><h1 id="注入bean的注解"><a href="#注入bean的注解" class="headerlink" title="注入bean的注解"></a>注入bean的注解</h1><ul><li>@Autowired：由Spring提供，根据类型进行自动装配，如果组合@Qualifier使用将按名称进行装配</li><li>@Inject：由JSR-330提供使用时需要导入javax.inject.Inject;实现注入同样是根据类型进行自动装配，如果需要按名称进行装配，则需要配合@Named</li><li>@Resource：由JSR-250提供，使用需要导入javax.annotation，根据名称进行自动装配的，一般会指定一个name属性</li></ul><h1 id="功能注解"><a href="#功能注解" class="headerlink" title="功能注解"></a>功能注解</h1><ul><li>@Transactional声明事务</li><li>@Cacheable声明缓存</li></ul><h1 id="配置类相关注解"><a href="#配置类相关注解" class="headerlink" title="配置类相关注解"></a>配置类相关注解</h1><ul><li>@Configuration 声明当前类为配置类</li><li>@Bean 注解在方法上，声明当前方法的返回值为一个bean</li><li>@ComponentScan 用于对Component进行扫描，</li><li>@WishlyConfiguration 为@Configuration与@ComponentScan的组合注解，可以替代这两个注解</li></ul><h1 id="切面（AOP）相关注解"><a href="#切面（AOP）相关注解" class="headerlink" title="切面（AOP）相关注解"></a>切面（AOP）相关注解</h1><ul><li>@Aspect 声明一个切面</li><li>@After 在方法执行之后执行</li><li>@Before 在方法执行之前执行</li><li>@Around 在方法执行之前与之后都执行</li><li>@PointCut 声明切点</li></ul><h1 id="Bean的属性支持"><a href="#Bean的属性支持" class="headerlink" title="@Bean的属性支持"></a>@Bean的属性支持</h1><p>@Scope设置Spring新建Bean的类型，可选择包括：</p><ul><li>Singleton 单例,一个Spring容器中只有一个bean实例，默认模式</li><li>Protetype 每次调用新建一个bean</li><li>Request web项目中，给每个http request新建一个bean</li><li>Session web项目中，给每个http session新建一个bean</li><li>GlobalSession（给每一个 global http session新建一个Bean实例</li></ul><h1 id="类生命周期注解"><a href="#类生命周期注解" class="headerlink" title="类生命周期注解"></a>类生命周期注解</h1><ul><li>@PostConstruct 由JSR-250提供，在类的构造函数执行完之后执行，等价于xml配置文件中bean的initMethod</li><li>@PreDestory 由JSR-250提供，在Bean销毁之前执行</li></ul><h1 id="配置注入"><a href="#配置注入" class="headerlink" title="配置注入"></a>配置注入</h1><p>@Value为属性注入值，支持如下方式的注入：</p><ul><li>普通字符@Value(“Michael Jackson”)</li><li>操作系统属性@Value(“#{systemProperties[‘os.name’]}”)</li><li>表达式结果@Value(“#{ T(java.lang.Math).random() * 100 }”)</li><li>其它bean属性@Value(“#{domeClass.name}”)</li><li>文件资源@Value(“classpath:cn/shiyujun/test.txt”)</li><li>网站资源@Value(“<a href="https://shiyujun.cn&quot;" target="_blank" rel="noopener">https://shiyujun.cn&quot;</a>)</li><li>配置文件属性@Value(“${book.name}”)</li><li>注入配置文件@PropertySource(“classpath:cn/shiyujun/test.propertie”)</li></ul><h1 id="环境切换"><a href="#环境切换" class="headerlink" title="环境切换"></a>环境切换</h1><ul><li>@Profile 通过设定Environment的ActiveProfiles来设定当前context需要使用的配置环境</li><li>@Conditional根据代码中设置的条件装载不同的bean，包括一系列的注解</li><li>@ConditionalOnBean存在bean</li><li>@ConditionalOnMissingBean不存在bean</li><li>@ConditionalOnClass存在某个类</li><li>@ConditionalOnMissingClass不存在某个类</li><li>@ConditionalOnProperty(prefix = “syj”, name = “algorithm”, havingValue = “token”)当存在配置文件中以syj为前缀的属性，属性名称为algorithm，然后它的值为token时才会实例化一个类。</li><li>@ConditionalOnProperty(prefix = “syj”, name = “algorithm”, havingValue = “counter”, matchIfMissing = true)如果所有的都不满足的话就选择counter为默认实现</li><li>@ConditionalOnJava如果是Java应用</li><li>@ConditionalOnWebApplication如果是Web应用</li></ul><h1 id="异步相关"><a href="#异步相关" class="headerlink" title="异步相关"></a>异步相关</h1><p>@Async 在实际执行的bean方法使用该注解来申明其是一个异步任务</p><h1 id="定时任务相关"><a href="#定时任务相关" class="headerlink" title="定时任务相关"></a>定时任务相关</h1><p>@Scheduled 来申明这是一个任务，包括cron,fixDelay,fixRate等类型</p><h1 id="事务相关"><a href="#事务相关" class="headerlink" title="事务相关"></a>事务相关</h1><p>@Transactional注解可以作用于接口、接口方法、类以及类方法上 ，管理事务。</p><h1 id="开启某些功能"><a href="#开启某些功能" class="headerlink" title="开启某些功能"></a>开启某些功能</h1><ul><li>@EnableAspectJAutoProxy 开启对AspectJ自动代理的支持</li><li>@EnableAsync 开启异步方法的支持</li><li>@EnableScheduling 开启计划任务的支持</li><li>@EnableWebMvc 开启Web MVC的配置支持</li><li>@EnableConfigurationProperties 开启对@ConfigurationProperties注解配置Bean的支持</li><li>@EnableJpaRepositories 开启对SpringData JPA Repository的支持</li><li>@EnableTransactionManagement 开启注解式事务的支持</li><li>@EnableCaching 开启注解式的缓存支持</li></ul><h1 id="测试相关注解"><a href="#测试相关注解" class="headerlink" title="测试相关注解"></a>测试相关注解</h1><ul><li>@RunWith Spring中通常用于对JUnit的支持</li><li>@ContextConfiguration 用来加载配置ApplicationContext</li></ul><h1 id="SpringMVC部分"><a href="#SpringMVC部分" class="headerlink" title="SpringMVC部分"></a>SpringMVC部分</h1><ul><li>@RequestMapping 用于映射Web请求，包括访问路径和参数</li><li>@ResponseBody 支持将返回值放在response内，而不是一个页面</li><li>@PathVariable 用于接收路径参数</li><li>@RestController 该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody</li><li>@ControllerAdvice 通过该注解，我们可以将对于控制器的全局配置放置在同一个位置，注解了@Controller的类的方法可使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上， 这对所有注解了 @RequestMapping的控制器内的方法有效。</li><li>@ExceptionHandler 用于全局处理控制器里的异常</li><li>@InitBinder 用来设置WebDataBinder，WebDataBinder用来自动绑定前台请求参数到Model中。</li><li>@ModelAttribute 本来的作用是绑定键值对到Model里，在@ControllerAdvice中是让全局的- @RequestMapping都能获得在此处设置的键值对。</li></ul><h1 id="SpringBoot相关"><a href="#SpringBoot相关" class="headerlink" title="SpringBoot相关"></a>SpringBoot相关</h1><ul><li>@EnableAutoConfiguration自动载入应用程序所需的所有Bean。该注解组合了@Import注解，@Import注解导入了EnableAutoCofigurationImportSelector类，它使用SpringFactoriesLoader.loaderFactoryNames方法来扫描具有META-INF/spring.factories文件的jar包。而spring.factories里声明了有哪些自动配置​+ @SpingBootApplication SpringBoot的核心注解，主要目的是开启自动配置。它也是一个组合注解，主要组合了@Configurer，@EnableAutoConfiguration（核心）和@ComponentScan。可以通过@SpringBootApplication(exclude={想要关闭的自动配置的类名.class})来关闭特定的自动配置</li><li>@ImportResource加载xml配置的</li><li>@AutoConfigureAfter在指定的自动配置类之后再配置</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring——MVC理论下</title>
      <link href="/2020/04/26/Spring%E2%80%94%E2%80%94MVC%E7%90%86%E8%AE%BA%E4%B8%8B/"/>
      <url>/2020/04/26/Spring%E2%80%94%E2%80%94MVC%E7%90%86%E8%AE%BA%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="返回json"><a href="#返回json" class="headerlink" title="返回json"></a>返回json</h1><p>目前主流的 JSON 处理工具主要有三种：</p><ul><li>jackson</li><li>gson</li><li>fastjson</li></ul><p>在 SpringMVC 中，对 jackson 和 gson 都提供了相应的支持，就是如果使用这两个作为 JSON 转换器，只需要添加对应的依赖就可以了，返回的对象和返回的集合、Map 等都会自动转为 JSON，</p><p>但是，如果使用 fastjson，除了添加相应的依赖之外，还需要自己手动配置 HttpMessageConverter 转换器。其实前两个也是使用 HttpMessageConverter 转换器，但是是 SpringMVC 自动提供的，SpringMVC 没有给 fastjson 提供相应的转换器。</p><h2 id="jackson"><a href="#jackson" class="headerlink" title="jackson"></a>jackson</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>依赖添加成功后，凡是在接口中直接返回的对象，集合等等，都会自动转为 JSON。</p><p>添加了 jackson ，就能够自动返回 JSON，这个依赖于一个名为 HttpMessageConverter 的类，这本身是一个接口，从名字上就可以看出，它的作用是 Http 消息转换器，既然是消息转换器，它提供了两方面的功能：</p><ul><li>将返回的对象转为 JSON</li><li>将前端提交上来的 JSON 转为对象</li></ul><p>HttpMessageConverter 只是一个接口，由各个 JSON 工具提供相应的实现，在 jackson 中，实现的名字叫做 MappingJackson2HttpMessageConverter，而这个东西的初始化，则由 SpringMVC 来完成。</p><p>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="meta">@JsonFormat</span>(pattern = <span class="string">"yyyy-MM-dd"</span>,timezone = <span class="string">"Asia/Shanghai"</span>)</span><br><span class="line">    <span class="keyword">private</span> Date publish;</span><br></pre></td></tr></table></figure><p>全局配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"httpMessageConverter"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"</span> <span class="attr">id</span>=<span class="string">"httpMessageConverter"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"objectMapper"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.fasterxml.jackson.databind.ObjectMapper"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dateFormat"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"java.text.SimpleDateFormat"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"pattern"</span> <span class="attr">value</span>=<span class="string">"yyyy-MM-dd HH:mm:ss"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeZone"</span> <span class="attr">value</span>=<span class="string">"Asia/Shanghai"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="gson"><a href="#gson" class="headerlink" title="gson"></a>gson</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果项目中，同时存在 jackson 和 gson 的话，那么默认使用的是 jackson，为社么呢？在 org.springframework.http.converter.support.AllEncompassingFormHttpMessageConverter 类的构造方法中，加载顺序就是先加载 jackson 的 HttpMessageConverter，后加载 gson 的 HttpMessageConverter。</p><p>自定义配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"httpMessageConverter"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.json.GsonHttpMessageConverter"</span> <span class="attr">id</span>=<span class="string">"httpMessageConverter"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"gson"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.google.gson.Gson"</span> <span class="attr">factory-bean</span>=<span class="string">"gsonBuilder"</span> <span class="attr">factory-method</span>=<span class="string">"create"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.google.gson.GsonBuilder"</span> <span class="attr">id</span>=<span class="string">"gsonBuilder"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dateFormat"</span> <span class="attr">value</span>=<span class="string">"yyyy-MM-dd"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="fastjson"><a href="#fastjson" class="headerlink" title="fastjson"></a>fastjson</h1><p>fastjson 号称最快的 JSON 解析器，但是也是这三个中 BUG 最多的一个。在 SpringMVC 并没针对 fastjson 提供相应的 HttpMessageConverter，所以，fastjson 在使用时，一定要自己手动配置 HttpMessageConverter（前面两个如果没有特殊需要，直接添加依赖就可以了）。</p><p>使用fastjosn,首先引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.60<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 SpringMVC 的配置文件中配置 HttpMessageConverter：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"httpMessageConverter"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter"</span> <span class="attr">id</span>=<span class="string">"httpMessageConverter"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"fastJsonConfig"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.alibaba.fastjson.support.config.FastJsonConfig"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dateFormat"</span> <span class="attr">value</span>=<span class="string">"yyyy-MM-dd"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>fastjson 默认中文乱码，添加如下配置解决：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"httpMessageConverter"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter"</span> <span class="attr">id</span>=<span class="string">"httpMessageConverter"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"fastJsonConfig"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.alibaba.fastjson.support.config.FastJsonConfig"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dateFormat"</span> <span class="attr">value</span>=<span class="string">"yyyy-MM-dd"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"supportedMediaTypes"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>application/json;charset=utf-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="接收json"><a href="#接收json" class="headerlink" title="接收json"></a>接收json</h1><p>在 SpringMVC 中，我们可以通过一个注解来快速的将一个 JSON 字符串转为一个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/addbook3"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook3</span><span class="params">(@RequestBody Book book)</span> </span>&#123;</span><br><span class="line">    System.out.println(book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p>SpringMVC 中对文件上传做了封装，我们可以更加方便的实现文件上传。提供了两个处理器：</p><ul><li>CommonsMultipartResolver  SpringMVC3.0</li><li>StandardServletMultipartResolver  SpringMVC3.1</li></ul><p>第一个处理器兼容性较好，可以兼容 Servlet3.0 之前的版本，但是它依赖了 commons-fileupload 这个第三方工具，所以如果使用这个，一定要添加 commons-fileupload 依赖。<br>第二个处理器兼容性较差，它适用于 Servlet3.0 之后的版本，它不依赖第三方工具，使用它，可以直接做文件上传。</p><h2 id="CommonsMultipartResolver"><a href="#CommonsMultipartResolver" class="headerlink" title="CommonsMultipartResolver"></a>CommonsMultipartResolver</h2><p>使用 CommonsMultipartResolver 做文件上传，需要首先添加 commons-fileupload 依赖，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，在 SpringMVC 的配置文件中，配置 MultipartResolver：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意，这个 Bean 一定要有 id，并且 id 必须是 multipartResolver</strong>。</p><p>接下来，创建 jsp 页面：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/upload"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"上传"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>文件上传接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadController</span> </span>&#123;</span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"/yyyy/MM/dd/"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/upload"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(MultipartFile file, HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">        String format = sdf.format(<span class="keyword">new</span> Date());</span><br><span class="line">        String realPath = req.getServletContext().getRealPath(<span class="string">"/img"</span>) + format;</span><br><span class="line">        File folder = <span class="keyword">new</span> File(realPath);</span><br><span class="line">        <span class="keyword">if</span> (!folder.exists()) &#123;</span><br><span class="line">            folder.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        String oldName = file.getOriginalFilename();</span><br><span class="line">        String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file.transferTo(<span class="keyword">new</span> File(folder, newName));</span><br><span class="line">            String url = req.getScheme() + <span class="string">"://"</span> + req.getServerName() + <span class="string">":"</span> + req.getServerPort() + <span class="string">"/img"</span> + format + newName;</span><br><span class="line">            <span class="keyword">return</span> url;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"failed"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 SpringMVC 中，静态资源默认都是被自动拦截的，无法访问，意味着上传成功的图片无法访问，因此，还需要我们在 SpringMVC 的配置文件中，再添加如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/**"</span> <span class="attr">location</span>=<span class="string">"/"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>当然，默认的配置不一定满足我们的需求，我们还可以自己手动配置文件上传大小等：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--默认的编码--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultEncoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--上传的总文件大小--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxUploadSize"</span> <span class="attr">value</span>=<span class="string">"1048576"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--上传的单个文件大小--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxUploadSizePerFile"</span> <span class="attr">value</span>=<span class="string">"1048576"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--内存中最大的数据量，超过这个数据量，数据就要开始往硬盘中写了--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxInMemorySize"</span> <span class="attr">value</span>=<span class="string">"4096"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--临时目录，超过 maxInMemorySize 配置的大小后，数据开始往临时目录写，等全部上传完成后，再将数据合并到正式的文件上传目录--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"uploadTempDir"</span> <span class="attr">value</span>=<span class="string">"file:///E:\\tmp"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="StandardServletMultipartResolver"><a href="#StandardServletMultipartResolver" class="headerlink" title="StandardServletMultipartResolver"></a>StandardServletMultipartResolver</h1><p>这种文件上传方式，不需要依赖第三方 jar（主要是不需要添加 commons-fileupload 这个依赖），但是也不支持 Servlet3.0 之前的版本。</p><p>配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.support.StandardServletMultipartResolver"</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意，这里 Bean 的名字依然叫 multipartResolver</strong></p><p>这个 Bean 无法直接配置上传文件大小等限制。需要在 web.xml 中进行配置（这里，即使不需要限制文件上传大小，也需要在 web.xml 中配置 multipart-config）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">multipart-config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--文件保存的临时目录，这个目录系统不会主动创建--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">location</span>&gt;</span>E:\\temp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--上传的单个文件大小--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">max-file-size</span>&gt;</span>1048576<span class="tag">&lt;/<span class="name">max-file-size</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--上传的总文件大小--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">max-request-size</span>&gt;</span>1048576<span class="tag">&lt;/<span class="name">max-request-size</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这个就是内存中保存的文件最大大小--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file-size-threshold</span>&gt;</span>4096<span class="tag">&lt;/<span class="name">file-size-threshold</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">multipart-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置完成后，就可以测试文件上传了，测试方式和上面一样。</p><h2 id="多文件上传"><a href="#多文件上传" class="headerlink" title="多文件上传"></a>多文件上传</h2><p>多文件上传分为两种，一种是 key 相同的文件，另一种是 key 不同的文件。</p><p>key相同的文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/upload2"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"files"</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"上传"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/upload2"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upload2</span><span class="params">(MultipartFile[] files, HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">    String format = sdf.format(<span class="keyword">new</span> Date());</span><br><span class="line">    String realPath = req.getServletContext().getRealPath(<span class="string">"/img"</span>) + format;</span><br><span class="line">    File folder = <span class="keyword">new</span> File(realPath);</span><br><span class="line">    <span class="keyword">if</span> (!folder.exists()) &#123;</span><br><span class="line">        folder.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (MultipartFile file : files) &#123;</span><br><span class="line">            String oldName = file.getOriginalFilename();</span><br><span class="line">            String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">            file.transferTo(<span class="keyword">new</span> File(folder, newName));</span><br><span class="line">            String url = req.getScheme() + <span class="string">"://"</span> + req.getServerName() + <span class="string">":"</span> + req.getServerPort() + <span class="string">"/img"</span> + format + newName;</span><br><span class="line">            System.out.println(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>key不同的文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/upload3"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"上传"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/upload3"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upload3</span><span class="params">(MultipartFile file1, MultipartFile file2, HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">    String format = sdf.format(<span class="keyword">new</span> Date());</span><br><span class="line">    String realPath = req.getServletContext().getRealPath(<span class="string">"/img"</span>) + format;</span><br><span class="line">    File folder = <span class="keyword">new</span> File(realPath);</span><br><span class="line">    <span class="keyword">if</span> (!folder.exists()) &#123;</span><br><span class="line">        folder.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String oldName = file1.getOriginalFilename();</span><br><span class="line">        String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">        file1.transferTo(<span class="keyword">new</span> File(folder, newName));</span><br><span class="line">        String url1 = req.getScheme() + <span class="string">"://"</span> + req.getServerName() + <span class="string">":"</span> + req.getServerPort() + <span class="string">"/img"</span> + format + newName;</span><br><span class="line">        System.out.println(url1);</span><br><span class="line">        String oldName2 = file2.getOriginalFilename();</span><br><span class="line">        String newName2 = UUID.randomUUID().toString() + oldName2.substring(oldName2.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">        file2.transferTo(<span class="keyword">new</span> File(folder, newName2));</span><br><span class="line">        String url2 = req.getScheme() + <span class="string">"://"</span> + req.getServerName() + <span class="string">":"</span> + req.getServerPort() + <span class="string">"/img"</span> + format + newName2;</span><br><span class="line">        System.out.println(url2);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="静态资源访问"><a href="#静态资源访问" class="headerlink" title="静态资源访问"></a>静态资源访问</h1><p>SpringMVC 中，静态资源，默认都是被拦截的，例如 html、js、css、jpg、png、txt、pdf 等等，都是无法直接访问的。因为所有请求都被拦截了，所以，针对静态资源，我们要做额外处理，处理方式很简单，直接在 SpringMVC 的配置文件中，添加如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/static/html/**"</span> <span class="attr">location</span>=<span class="string">"/static/html/"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><p>SpringMVC 中的拦截器，相当于 Jsp/Servlet 中的过滤器，只不过拦截器的功能更为强大。</p><p>拦截器的定义非常容易：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor1</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个是请求预处理的方法，只有当这个方法返回值为 true 的时候，后面的方法才会执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyInterceptor1:preHandle"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyInterceptor1:postHandle"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyInterceptor1:afterCompletion"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor2</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个是请求预处理的方法，只有当这个方法返回值为 true 的时候，后面的方法才会执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyInterceptor2:preHandle"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyInterceptor2:postHandle"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyInterceptor2:afterCompletion"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>springMVC文件配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/**"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"myInterceptor1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/**"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"myInterceptor2"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h1><p>项目中，可能会抛出多个异常，我们不可以直接将异常的堆栈信息展示给用户，有两个原因：</p><ol><li>用户体验不好</li><li>非常不安全</li></ol><p>SpringMVC 中，针对全局异常也提供了相应的解决方案，主要是通过 @ControllerAdvice 和 @ExceptionHandler 两个注解来处理的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span><span class="comment">//表示这是一个增强版的 Controller，主要用来做全局数据处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ModelAndView</span> <span class="title">fileuploadException</span>(<span class="title">Exception</span> <span class="title">e</span>) </span>&#123;</span><br><span class="line">        ModelAndView error = <span class="keyword">new</span> ModelAndView(<span class="string">"error"</span>);</span><br><span class="line">        error.addObject(<span class="string">"error"</span>, e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring MVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring——MVC理论上</title>
      <link href="/2020/04/24/Spring%E2%80%94%E2%80%94MVC%E7%90%86%E8%AE%BA%E4%B8%8A/"/>
      <url>/2020/04/24/Spring%E2%80%94%E2%80%94MVC%E7%90%86%E8%AE%BA%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Spring基于MVC设计模式的轻量级web框架。</p><h1 id="与Spring关系"><a href="#与Spring关系" class="headerlink" title="与Spring关系"></a>与Spring关系</h1><p><img src="/images/Spring%E2%80%94%E2%80%94MVC%E7%90%86%E8%AE%BA_2020-04-24-13-18-30.png" alt="Spring——MVC理论_2020-04-24-13-18-30.png"></p><p>SpringMVC是基于Spring的开源项目。以web项目为例：</p><p>servletContext容器是web项目根本容器。</p><p>Spring容器 会通过ServletContextListener监听类与context-param配置的xml文件创建。</p><p>SpringMVC容器 则通过 DispatcherServlet创建，并将Spring容器设为Parent。</p><ol><li>为什么不用spring容器去扫描所有的Bean?</li></ol><p>不可能，请求达到服务端后，找 DispatcherServlet 去处理，只会去 SpringMVC 容器中找，这就意味着 Controller 必须在 SpringMVC 容器中扫描。</p><ol start="2"><li>为什么不在 SpringMVC 容器中扫描所有 Bean？</li></ol><p>这个是可行的，但是为了配置文件的管理，以及在 Spring+SpringMVC+Hibernate 组合中，实际上也不支持这种写法。</p><h1 id="工作流程及组件"><a href="#工作流程及组件" class="headerlink" title="工作流程及组件"></a>工作流程及组件</h1><p><img src="/images/Spring%E2%80%94%E2%80%94MVC%E7%90%86%E8%AE%BA_2020-04-24-11-00-49.png" alt="Spring——MVC理论_2020-04-24-11-00-49.png"></p><ol><li>DispatcherServlet：前端控制器</li></ol><p>是整个流程控制的中心，相当于是 SpringMVC 的大脑，由它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。</p><ol start="2"><li>HandlerMapping：处理器映射器</li></ol><p>负责根据用户请求找到 Handler 即处理器（也就是我们所说的 Controller）。</p><ol start="3"><li>Handler：处理器</li></ol><p>前端控制器的后端控制器，在DispatcherServlet 的控制下 Handler 对具体的用户请求进行处理。（这里所说的 Handler 就是指我们的 Controller）</p><p>4.HandlAdapter：处理器适配器</p><p>通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p><p>5.ViewResolver：视图解析器</p><p>ViewResolver 负责将处理结果生成 View 视图，ViewResolver 首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。</p><h1 id="mvc-annotation-driven"><a href="#mvc-annotation-driven" class="headerlink" title="mvc:annotation-driven"></a><a href="mvc:annotation-driven" target="_blank" rel="noopener">mvc:annotation-driven</a></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController3</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello3"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"hello3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要能够访问到这个接口，我们需要 RequestMappingHandlerMapping 才能定位到需要执行的方法，需要 RequestMappingHandlerAdapter，所以配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.javaboy.helloworld"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"</span> <span class="attr">id</span>=<span class="string">"handlerMapping"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"</span> <span class="attr">id</span>=<span class="string">"handlerAdapter"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--视图解析器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span> <span class="attr">id</span>=<span class="string">"viewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/jsp/"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然我们还有简化写法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h1><p>这个注解用来标记一个接口, 表示我们用的是 RequestMappingHandlerMapping 这个处理器映射器。</p><h2 id="请求url"><a href="#请求url" class="headerlink" title="请求url"></a>请求url</h2><p>标记请求 URL 很简单，只需要在相应的方法上添加该注解即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当请求地址为 /hello 的时候，这个方法会被触发。其中，地址可以是多个，就是可以多个地址映射到同一个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(&#123;<span class="string">"/hello"</span>,<span class="string">"/hello2"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>/hello 和 /hello2 都可以访问到该方法。</p><h2 id="请求窄化"><a href="#请求窄化" class="headerlink" title="请求窄化"></a>请求窄化</h2><p>同一个项目中，会存在多个接口，例如订单相关的接口都是 /order/xxx 格式的，用户相关的接口都是 /user/xxx 格式的。为了方便处理，这里的前缀（就是 /order、/user）可以统一在 Controller 上面处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(&#123;<span class="string">"/hello"</span>,<span class="string">"/hello2"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当类上加了 @RequestMapping 注解之后，此时，要想访问到 hello ，地址就应该是 /user/hello 或者 /user/hello2。</p><h2 id="请求方法限定"><a href="#请求方法限定" class="headerlink" title="请求方法限定"></a>请求方法限定</h2><p>使用 @RequestMapping 注解定义好的方法，可以被 GET 请求访问到，也可以被 POST 请求访问到，但是 DELETE 请求以及 PUT 请求不可以访问到。</p><p>当然，我们也可以指定具体的访问方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 @RequestMapping 注解，指定了该接口只能被 GET 请求访问到，此时，该接口就不可以被 POST 以及请求请求访问到了。</p><p>当然，限定的方法也可以有多个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>,method = &#123;RequestMethod.GET,RequestMethod.POST,RequestMethod.PUT,RequestMethod.DELETE&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，这个接口就可以被 GET、POST、PUT、以及 DELETE 访问到了。</p><h1 id="视图解析器"><a href="#视图解析器" class="headerlink" title="视图解析器"></a>视图解析器</h1><p>配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"WEB-INF/jsp/"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于/hello请求，DispatcherServlet会将请求转发到前缀+ view-name + suffix = /WEB-INF/jsp/hello.jsp。</p><h1 id="Controller-方法的返回值"><a href="#Controller-方法的返回值" class="headerlink" title="Controller 方法的返回值"></a>Controller 方法的返回值</h1><h2 id="返回-ModelAndView"><a href="#返回-ModelAndView" class="headerlink" title="返回 ModelAndView"></a>返回 ModelAndView</h2><p>如果是前后端不分的开发，大部分情况下，我们返回 ModelAndView，即数据模型+视图：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="string">"hello"</span>);</span><br><span class="line">        mv.addObject(<span class="string">"username"</span>, <span class="string">"javaboy"</span>);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Model 中，放我们的数据，然后在 ModelAndView 中指定视图名称。</p><h2 id="返回-Void"><a href="#返回-Void" class="headerlink" title="返回 Void"></a>返回 Void</h2><p>没有返回值。没有返回值，并不一定真的没有返回值，只是方法的返回值为 void，我们可以通过其他方式给前端返回。实际上，这种方式也可以理解为 Servlet 中的那一套方案。</p><p>注意，由于默认的 Maven 项目没有 Servlet，因此这里需要额外添加一个依赖：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.0.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="服务端跳转："><a href="#服务端跳转：" class="headerlink" title="服务端跳转："></a>服务端跳转：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello2</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    req.getRequestDispatcher(<span class="string">"/jsp/hello.jsp"</span>).forward(req,resp);<span class="comment">//服务器端跳转</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重定向："><a href="#重定向：" class="headerlink" title="重定向："></a>重定向：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello3"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello3</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    resp.sendRedirect(<span class="string">"/hello.jsp"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="返回字符串"><a href="#返回字符串" class="headerlink" title="返回字符串"></a>返回字符串</h2><h3 id="返回逻辑视图"><a href="#返回逻辑视图" class="headerlink" title="返回逻辑视图"></a>返回逻辑视图</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello5"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello5</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"username"</span>, <span class="string">"javaboy"</span>);<span class="comment">//这是数据模型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello"</span>;<span class="comment">//表示去查找一个名为 hello 的视图</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务端跳转"><a href="#服务端跳转" class="headerlink" title="服务端跳转"></a>服务端跳转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello5"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"forward:/jsp/hello.jsp"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端跳转"><a href="#客户端跳转" class="headerlink" title="客户端跳转"></a>客户端跳转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello5"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/user/hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="真的返回字符串"><a href="#真的返回字符串" class="headerlink" title="真的返回字符串"></a>真的返回字符串</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello5"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/user/hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码表示就是想返回一段内容为 redirect:/user/hello 的字符串，他没有特殊含义。注意，这里如果单纯的返回一个中文字符串，是会乱码的，可以在 @RequestMapping 中添加 produces 属性来解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/hello5"</span>,produces = <span class="string">"text/html;charset=utf-8"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Java 语言程序设计"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h1><h2 id="默认支持的参数类型"><a href="#默认支持的参数类型" class="headerlink" title="默认支持的参数类型"></a>默认支持的参数类型</h2><p>默认支持的参数类型，就是可以直接写在 @RequestMapping 所注解的方法中的参数类型，一共有四类：</p><ul><li>HttpServletRequest</li><li>HttpServletResponse</li><li>HttpSession</li><li>Model/ModelMap</li></ul><h2 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h2><p>Integer、Boolean、Double 等等简单数据类型也都是支持的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/book"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addBook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"addbook"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/doAdd"</span>,method = RequestMethod.POST)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAdd</span><span class="params">(String name,String author,Double price,Boolean ispublic)</span> </span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(author);</span><br><span class="line">        System.out.println(price);</span><br><span class="line">        System.out.println(ispublic);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>POST 请求传上来的中文会乱码，所以，我们在 web.xml 中再额外添加一个编码过滤器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceRequestEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的绑定中，有一个要求，表单中字段的 name 属性要和接口中的变量名一一对应，才能映射成功，否则服务端接收不到前端传来的数据。</p><p>如果前后端不一致，这个时候我们可以通过 @RequestParam 注解来解决。</p><p>这个注解的的功能主要有三方面：</p><ul><li>给变量取别名</li><li>设置变量是否必填</li><li>给变量设置默认值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/doAdd"</span>,method = RequestMethod.POST)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAdd</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span> String bookname, String author, Double price, Boolean ispublic) </span>&#123;</span><br><span class="line">    System.out.println(bookname);</span><br><span class="line">    System.out.println(author);</span><br><span class="line">    System.out.println(price);</span><br><span class="line">    System.out.println(ispublic);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解中的 “name” 表示给 bookname 这个变量取的别名，也就是说，bookname 将接收前端传来的 name 这个变量的值。在这个注解中，还可以添加 required 属性和 defaultValue 属性，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/doAdd"</span>,method = RequestMethod.POST)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAdd</span><span class="params">(@RequestParam(value = <span class="string">"name"</span>,required = <span class="keyword">true</span>,defaultValue = <span class="string">"三国演义"</span>)</span> String bookname, String author, Double price, Boolean ispublic) </span>&#123;</span><br><span class="line">    System.out.println(bookname);</span><br><span class="line">    System.out.println(author);</span><br><span class="line">    System.out.println(price);</span><br><span class="line">    System.out.println(ispublic);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>required 属性默认为 true，即只要添加了 @RequestParam 注解，这个参数默认就是必填的，如果不填，请求无法提交，会报 400 错误，如果这个参数不是必填项，可以手动把 required 属性设置为 false。但是，如果同时设置了 defaultValue，这个时候，前端不传该参数到后端，即使 required 属性为 true，它也不会报错。</p><h2 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h2><p>参数除了是简单数据类型之外，也可以是实体类。实际上，在开发中，大部分情况下，都是实体类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/doAdd"</span>,method = RequestMethod.POST)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAdd</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">    System.out.println(book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端页面传值的时候和上面的一样，只需要写属性名就可以了，不需要写 book 对象名。</p><h2 id="自定义参数转换"><a href="#自定义参数转换" class="headerlink" title="自定义参数转换"></a>自定义参数转换</h2><p>特殊的数据类型，系统无法自动转换，例如日期。例如前端传一个日期到后端，后端不是用字符串接收，而是使用一个 Date 对象接收，这个时候就会出现参数类型转换失败。这个时候，需要我们手动定义参数类型转换器，将日期字符串手动转为一个 Date 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sdf.parse(source);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在自定义的参数类型转换器中，将一个 String 转为 Date 对象，同时，将这个转换器注册为一个 Bean。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">"conversionService"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.format.support.FormattingConversionServiceFactoryBean"</span> <span class="attr">id</span>=<span class="string">"conversionService"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"dateConverter"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置完成后，在服务端就可以接收前端传来的日期参数了。</p><h2 id="集合类的参数"><a href="#集合类的参数" class="headerlink" title="集合类的参数"></a>集合类的参数</h2><h3 id="String数组"><a href="#String数组" class="headerlink" title="String数组"></a>String数组</h3><p>String 数组可以直接用数组去接收，前端传递的时候，数组的传递其实就多相同的 key，这种一般用在 checkbox 中较多。</p><p>前端：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/doAdd"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>书名：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>作者姓名：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"author.name"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>作者年龄：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"author.age"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>出生日期：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"date"</span> <span class="attr">name</span>=<span class="string">"author.birthday"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>兴趣爱好：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"favorites"</span> <span class="attr">value</span>=<span class="string">"足球"</span>&gt;</span>足球</span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"favorites"</span> <span class="attr">value</span>=<span class="string">"篮球"</span>&gt;</span>篮球</span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"favorites"</span> <span class="attr">value</span>=<span class="string">"乒乓球"</span>&gt;</span>乒乓球</span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>价格：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"price"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>是否上架：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"true"</span> <span class="attr">name</span>=<span class="string">"ispublic"</span>&gt;</span>是</span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"false"</span> <span class="attr">name</span>=<span class="string">"ispublic"</span>&gt;</span>否</span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"添加"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/doAdd"</span>,method = RequestMethod.POST)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAdd</span><span class="params">(Book book,String[] favorites)</span> </span>&#123;</span><br><span class="line">    System.out.println(Arrays.toString(favorites));</span><br><span class="line">    System.out.println(book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，前端传来的数组对象，服务端不可以使用 List 集合去接收。</p><h3 id="list集合"><a href="#list集合" class="headerlink" title="list集合"></a>list集合</h3><p>如果需要使用 List 集合接收前端传来的数据，List 集合本身需要放在一个封装对象中，这个时候，List 中，可以是基本数据类型，也可以是对象。例如有一个班级类，班级里边有学生，学生有多个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; students;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"MyClass&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", students="</span> + students +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">getStudents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> students;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStudents</span><span class="params">(List&lt;Student&gt; students)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.students = students;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加班级的时候，可以传递多个 Student，前端页面写法如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/addclass"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>班级编号：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>学生编号：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"students[0].id"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>学生姓名：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"students[0].name"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>学生编号：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"students[1].id"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>学生姓名：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"students[1].name"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/addclass"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addClass</span><span class="params">(MyClass myClass)</span> </span>&#123;</span><br><span class="line">    System.out.println(myClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>相对于实体类而言，Map 是一种比较灵活的方案，但是，Map 可维护性比较差，因此一般不推荐使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; students;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; info;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"MyClass&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", students="</span> + students +</span><br><span class="line">                <span class="string">", info="</span> + info +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(Map&lt;String, Object&gt; info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">getStudents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> students;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStudents</span><span class="params">(List&lt;Student&gt; students)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.students = students;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/addclass"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>班级编号：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>班级名称：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"info['name']"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>班级位置：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"info['pos']"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>学生编号：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"students[0].id"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>学生姓名：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"students[0].name"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>学生编号：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"students[1].id"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>学生姓名：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"students[1].name"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="服务端请求参数校验"><a href="#服务端请求参数校验" class="headerlink" title="服务端请求参数校验"></a>服务端请求参数校验</h1><h2 id="普通校验"><a href="#普通校验" class="headerlink" title="普通校验"></a>普通校验</h2><p>首先，我们需要加入校验需要的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"</span> <span class="attr">id</span>=<span class="string">"validatorFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"providerClass"</span> <span class="attr">value</span>=<span class="string">"org.hibernate.validator.HibernateValidator"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">validator</span>=<span class="string">"validatorFactoryBean"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>假设学生编号不能为空，学生姓名长度不能超过 10 且不能为空，邮箱地址要合法，年龄不能超过 150。那么在定义实体类的时候，就可以加入这个判断条件了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Size</span>(min = <span class="number">2</span>,max = <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="meta">@Max</span>(<span class="number">150</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", email='"</span> + email + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义完成后，接下来，在 Controller 中定义接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/addstudent"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addStudent</span><span class="params">(@Validated Student student, BindingResult result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//校验未通过，获取所有的异常信息并展示出来</span></span><br><span class="line">            List&lt;ObjectError&gt; allErrors = result.getAllErrors();</span><br><span class="line">            <span class="keyword">for</span> (ObjectError allError : allErrors) &#123;</span><br><span class="line">                System.out.println(allError.getObjectName()+<span class="string">":"</span>+allError.getDefaultMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里：</p><ul><li>@Validated 表示 Student 中定义的校验规则将会生效</li><li>BindingResult 表示出错信息，如果这个变量不为空，表示有错误，否则校验通过。</li></ul><h2 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h2><p>由于校验规则都是定义在实体类上面的，但是，在不同的数据提交环境下，校验规则可能不一样。例如，用户的 id 是自增长的，添加的时候，可以不用传递用户 id，但是修改的时候则必须传递用户 id，这种情况下，就需要使用分组校验。</p><p>分组校验，首先需要定义校验组，所谓的校验组，其实就是空接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ValidationGroup1</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ValidationGroup2</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"&#123;student.id.notnull&#125;"</span>,groups = ValidationGroup1<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">Integer</span> <span class="title">id</span></span>;</span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"&#123;student.name.notnull&#125;"</span>,groups = &#123;ValidationGroup1<span class="class">.<span class="keyword">class</span>, <span class="title">ValidationGroup2</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">    @<span class="title">Size</span>(<span class="title">min</span> </span>= <span class="number">2</span>,max = <span class="number">10</span>,message = <span class="string">"&#123;student.name.length&#125;"</span>,groups = &#123;ValidationGroup1<span class="class">.<span class="keyword">class</span>, <span class="title">ValidationGroup2</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">String</span> <span class="title">name</span></span>;</span><br><span class="line">    <span class="meta">@Email</span>(message = <span class="string">"&#123;student.email.error&#125;"</span>,groups = &#123;ValidationGroup1<span class="class">.<span class="keyword">class</span>, <span class="title">ValidationGroup2</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">String</span> <span class="title">email</span></span>;</span><br><span class="line">    <span class="meta">@Max</span>(value = <span class="number">150</span>,message = <span class="string">"&#123;student.age.error&#125;"</span>,groups = &#123;ValidationGroup2<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">Integer</span> <span class="title">age</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", email='"</span> + email + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 group 中指定每一个校验规则所属的组，一个规则可以属于一个组，也可以属于多个组。</p><p>最后，在接收参数的地方，指定校验组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/addstudent"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addStudent</span><span class="params">(@Validated(ValidationGroup2.class)</span> Student student, BindingResult result) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//校验未通过，获取所有的异常信息并展示出来</span></span><br><span class="line">            List&lt;ObjectError&gt; allErrors = result.getAllErrors();</span><br><span class="line">            <span class="keyword">for</span> (ObjectError allError : allErrors) &#123;</span><br><span class="line">                System.out.println(allError.getObjectName()+<span class="string">":"</span>+allError.getDefaultMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后，属于 ValidationGroup2 这个组的校验规则，才会生效。</p><h2 id="校验注解"><a href="#校验注解" class="headerlink" title="校验注解"></a>校验注解</h2><p>校验注解，主要有如下几种：</p><ul><li>@Null 被注解的元素必须为 null</li><li>@NotNull 被注解的元素必须不为 null</li><li>@AssertTrue 被注解的元素必须为 true</li><li>@AssertFalse 被注解的元素必须为 false</li><li>@Min(value) 被注解的元素必须是一个数字，其值必须大于等于指定的最小值</li><li>@Max(value) 被注解的元素必须是一个数字，其值必须小于等于指定的最大值</li><li>@DecimalMin(value) 被注解的元素必须是一个数字，其值必须大于等于指定的最小值</li><li>@DecimalMax(value) 被注解的元素必须是一个数字，其值必须小于等于指定的最大值</li><li>@Size(max=, min=) 被注解的元素的大小必须在指定的范围内</li><li>@Digits (integer, fraction) 被注解的元素必须是一个数字，其值必须在可接受的范围内</li><li>@Past 被注解的元素必须是一个过去的日期</li><li>@Future 被注解的元素必须是一个将来的日期</li><li>@Pattern(regex=,flag=) 被注解的元素必须符合指定的正则表达式</li><li>@NotBlank(message =) 验证字符串非 null，且长度必须大于0</li><li>@Email 被注解的元素必须是电子邮箱地址</li><li>@Length(min=,max=) 被注解的字符串的大小必须在指定的范围内</li><li>@NotEmpty 被注解的字符串的必须非空</li><li>@Range(min=,max=,message=) 被注解的元素必须在合适的范围内</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring MVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA基础——代理</title>
      <link href="/2020/04/21/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86/"/>
      <url>/2020/04/21/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>代理模式：通过某种方式给某个对象提供一个代理对象，在不改变原有对象代码的前提下对方法的增强。</p><h1 id="为什么要使用代理模式？"><a href="#为什么要使用代理模式？" class="headerlink" title="为什么要使用代理模式？"></a>为什么要使用代理模式？</h1><p>在项目中如果需要打印方法入参及出参时、需要记录方法执行时间时、需要验证权限时、需要统一异常处理时等等各种场景，基本上都是通过拦截器和过滤器来实现。 这些拦截器过滤器的底层实现其实都是使用了代理模式。</p><h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>静态代理其实就是在程序运行之前，提前写好被代理方法的代理类，编译后运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainServiceImpl</span> <span class="keyword">implements</span> <span class="title">MainService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"doSomeThing......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想在 <code>dosomeTime</code> 方法前后做一些动作，比如记录方法执行时间，我们一般会这么做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"begin time:"</span>+System.currentTimeMillis());</span><br><span class="line">       mainService.doSomeThing();</span><br><span class="line">       System.out.println(<span class="string">"end time:"</span>+System.currentTimeMillis());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>只是这样就改变了原有类的代码结构，这个时候我们就可以用静态代理来解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> <span class="keyword">implements</span> <span class="title">MainService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MainService mainService;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticProxy</span><span class="params">(MainService mainService)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mainService=mainService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"begin time:"</span>+System.currentTimeMillis());</span><br><span class="line">        mainService.doSomeThing();</span><br><span class="line">        System.out.println(<span class="string">"end time:"</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建的了一个代理类，代理类持有原对象，把所有新增的需求放到代理类中，这样就不需要修改代码了。 我们可以使用如下代码测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        MainService mainService=<span class="keyword">new</span> MainServiceImpl();</span><br><span class="line">        MainService staticProxy=<span class="keyword">new</span> StaticProxy(mainService);</span><br><span class="line">        staticProxy.doSomeThing();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用静态代理虽然解决了不修改代码的需求，但是如果原对象有多个方法的话就必须全部实现且加上打印的逻辑</p><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>动态代理主要是通过反射机制，在运行时动态生成所需代理的class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MainService mainService;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(MainService mainService)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mainService=mainService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                mainService.getClass().getClassLoader(),</span><br><span class="line">                mainService.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"begin time:"</span>+System.currentTimeMillis());</span><br><span class="line">                        method.invoke(mainService, args);</span><br><span class="line">                        System.out.println(<span class="string">"end time:"</span>+System.currentTimeMillis());</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上方的getProxy方法是返回的一个代理对象，切是在这个对象的所有方法执行前后都执行了打印执行时间的逻辑 看一下测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String args[])</span></span>&#123;</span><br><span class="line">       MainService mainService=<span class="keyword">new</span> MainServiceImpl();</span><br><span class="line">       DynamicProxy dynamicProxy=<span class="keyword">new</span> DynamicProxy(mainService);</span><br><span class="line">       ((MainService)dynamicProxy.getProxy()).doSomeThing();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>关于动态代理设及到一些工具类和接口，比如：InvocationHandler接口</p><p>在使用动态代理时，我们需要定义一个位于代理类与委托类之间的中介类，这个中介类被要求实现InvocationHandler接口，这个接口的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用处理程序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123; </span><br><span class="line">    <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态代理不会直接让代理类去调用委托类，实际上是通过调用中介类的 <code>invoke</code> 方法，由invoke决定调用 proxy 哪个委托类。真正的代理内容也是在中介类里定义。</p><p>Proxy.newProxyInstance(ClassLoader classloader,Class aclass[],InvocationHandler invocationhandler)方法会生成一个一个对中介类的代理类。</p><p>动态代理实现的已经非常优雅了，但是它还是有个缺点，那就是想要实现代理的原对象必须具有顶层接口，对没有实现的接口的类就无能为力了。</p><h1 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h1><p>cglib是使用字节码技术直接生成一个子类然后重写父类的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"begin time:"</span>+System.currentTimeMillis());</span><br><span class="line">        Object object = methodProxy.invokeSuper(obj, objects);</span><br><span class="line">        System.out.println(<span class="string">"end time:"</span>+System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(MainServiceImpl<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> CglibInterceptor());</span><br><span class="line">        MainService proxy= (MainService)enhancer.create();</span><br><span class="line">        proxy.doSomeThing();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代理对象的生成过程由Enhancer类实现，大概步骤如下：</p><ol><li>生成代理类Class的二进制字节码；</li><li>通过Class.forName加载二进制字节码，生成Class对象；</li><li>通过反射机制获取实例构造，并初始化代理类对象。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>DK是基于反射机制,生成一个实现代理接口的匿名类,然后重写方法,实现方法的增强.它生成类的速度很快,但是运行时因为是基于反射,调用后续的类操作会很慢。只能对实现了接口的类生成代理，而不能针对类。</p><p>CGLIB是基于继承机制,继承被代理类,所以方法不要声明为final,然后重写父类方法达到增强了类的作用.它底层是基于asm第三方框架,是对代理对象类的class文件加载进来,通过修改其字节码生成子类来处理.生成类的速度慢,但是后续执行类的操作时候很快.</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring——ApplicationContxt解读</title>
      <link href="/2020/04/20/Spring%E2%80%94%E2%80%94ApplicationContxt%E8%A7%A3%E8%AF%BB/"/>
      <url>/2020/04/20/Spring%E2%80%94%E2%80%94ApplicationContxt%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="BeanFactory-和-ApplicationContext"><a href="#BeanFactory-和-ApplicationContext" class="headerlink" title="BeanFactory 和 ApplicationContext"></a>BeanFactory 和 ApplicationContext</h1><p>Application由BeanFactory派生而来，提供了更多面向实际的功能。</p><p>我们一般称BeanFactory为IoC容器，而称ApplicationContext为应用上下文。</p><p>对于BeanFactory 和 ApplicationContext的用途：</p><ul><li>BeanFactory是Spring框架的基础设施，面向Spring本身。</li><li>ApplicationContext面向使用Spring框架的开发者，几乎所有的应用场合都可以直接使用Application而非底层的BeanFactory。</li></ul><p><strong>spring Ioc容器的实现，从根源上是beanfactory，但真正可以作为一个可以独立使用的ioc容器还是DefaultListableBeanFactory</strong></p><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>BeanFactory负责配置、创建、管理Bean。</p><p>Application继承了HierachicalBeanFactory和ListableBeanFactory接口，在此基础上，还通过其他接口扩展了BeanFactory的功能。</p><p>这些接口如下：</p><ul><li>ApplicationEventPublisher:让容器拥有发布应用上下文事件的功能，包括容器的启动事件、关闭事件等。</li><li>MessageSource：为应用提供i18N国际化消息访问的功能</li><li>ResourcePatternResolver：加载资源，可以通过带前缀的Ant风格的资源文件路径装载Spring的配置文件</li><li>LifeCycle：该接口提供start()和stop()方法，主要用于控制异步处理的过程，以达到管理和控制JMX、任务调度等目的</li></ul><p>ConfigurableApplicationContext扩展于ApplicationContext，主要新增了两个方法 refresh()和close(),让Application具有启动、刷新、关闭应用上下文的能力。</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>ApplicationContext的初始化和BeanFactory初始化有一个重大区别：</p><ul><li>BeanFactory在初始化容器时，并没有实例化Bean，直到第一次访问某个Bean时才实例化目标Bean。</li><li>ApplicationContext会在初始化应用上下文时就实例化所有单实例的Bean。</li></ul><h1 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h1><ul><li>AnnotationConfigApplicationContext：从一个或多个基于java的配置类中加载上下文定义，适用于java注解的方式。</li><li>ClassPathXmlApplicationContext：从类路径下的一个或多个xml配置文件中加载上下文定义，适用于xml配置的方式。</li><li>FileSystemXmlApplicationContext：从文件系统下的一个或多个xml配置文件中加载上下文定义，也就是说系统盘符中加载xml配置文件。</li><li>AnnotationConfigWebApplicationContext：专门为web应用准备的，适用于注解方式。</li><li>XmlWebApplicationContext：从web应用下的一个或多个xml配置文件加载上下文定义，适用于xml配置方式。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring ApplicationContext </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring——IOC源码解析下</title>
      <link href="/2020/04/20/Spring%E2%80%94%E2%80%94IOC%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8B/"/>
      <url>/2020/04/20/Spring%E2%80%94%E2%80%94IOC%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="refresh"><a href="#refresh" class="headerlink" title="refresh()"></a>refresh()</h1><p>接上文：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize message source for this context.</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line"><span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset 'active' flag.</span></span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate exception to caller.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line"><span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="prepareBeanFactory"><a href="#prepareBeanFactory" class="headerlink" title="prepareBeanFactory()"></a>prepareBeanFactory()</h2><p>现在回到最开始的 <code>refresh()</code> 方法 <code>prepareBeanFactory()</code> 这个方法主要会:</p><ul><li>设置 BeanFactory的类加载器</li><li>添加几个 BeanPostProcessor、事件监听器</li><li>手动注册几个特殊的bean</li></ul><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置为加载当前ApplicationContext类的类加载器</span></span><br><span class="line">   beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置 BeanExpressionResolver</span></span><br><span class="line">   beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line"></span><br><span class="line">   beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这里是Spring的又一个扩展点</span></span><br><span class="line">   <span class="comment">//在所有实现了Aware接口的bean在初始化的时候，这个 processor负责回调，</span></span><br><span class="line">   <span class="comment">// 这个我们很常用，如我们会为了获取 ApplicationContext 而 implement ApplicationContextAware</span></span><br><span class="line">   <span class="comment">// 注意：它不仅仅回调 ApplicationContextAware，还会负责回调 EnvironmentAware、ResourceLoaderAware 等</span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 下面几行的意思就是，如果某个 bean 依赖于以下几个接口的实现类，在自动装配的时候忽略它们，Spring 会通过其他方式来处理这些依赖。</span></span><br><span class="line">   beanFactory.ignoreDependencyInterface(EnvironmentAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ResourceLoaderAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(MessageSourceAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationContextAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//下面几行就是为特殊的几个 bean 赋值，如果有 bean 依赖了以下几个，会注入这边相应的值</span></span><br><span class="line">   beanFactory.registerResolvableDependency(BeanFactory<span class="class">.<span class="keyword">class</span>, <span class="title">beanFactory</span>)</span>;</span><br><span class="line">   beanFactory.registerResolvableDependency(ResourceLoader<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationEventPublisher<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationContext<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 注册 事件监听器</span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果存在bean名称为loadTimeWeaver的bean则注册一个BeanPostProcessor</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">      <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">      beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果没有定义 "environment" 这个 bean，那么 Spring 会 "手动" 注册一个</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果没有定义 "systemProperties" 这个 bean，那么 Spring 会 "手动" 注册一个</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果没有定义 "systemEnvironment" 这个 bean，那么 Spring 会 "手动" 注册一个</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="postProcessBeanFactory"><a href="#postProcessBeanFactory" class="headerlink" title="postProcessBeanFactory()"></a>postProcessBeanFactory()</h2><p>这个比较简单，又是Spring的一个扩展点</p><p>如果有Bean实现了BeanFactoryPostProcessor接口， 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</p><h2 id="invokeBeanFactoryPostProcessors"><a href="#invokeBeanFactoryPostProcessors" class="headerlink" title="invokeBeanFactoryPostProcessors()"></a>invokeBeanFactoryPostProcessors()</h2><p>调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法</p><p><strong>我们加载.properties文件设计到的PreferencesPlaceholderConfigurer类，也是在这里完成解析的</strong>。</p><h2 id="registerBeanPostProcessors"><a href="#registerBeanPostProcessors" class="headerlink" title="registerBeanPostProcessors()"></a>registerBeanPostProcessors()</h2><p>又是一个扩展点</p><p>注册 BeanPostProcessor 的实现类，注意不是BeanFactoryPostProcessor 此接口有两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization 分别会在Bean初始化之前和初始化之后得到执行</p><h2 id="initMessageSource"><a href="#initMessageSource" class="headerlink" title="initMessageSource()"></a>initMessageSource()</h2><p>初始化当前 ApplicationContext 的 MessageSource，有想了解国际化的相关知识可以深入研究一下</p><h2 id="initApplicationEventMulticaster"><a href="#initApplicationEventMulticaster" class="headerlink" title="initApplicationEventMulticaster()"></a>initApplicationEventMulticaster()</h2><p>这个方法主要为初始化当前 ApplicationContext 的事件广播器</p><h2 id="onRefresh"><a href="#onRefresh" class="headerlink" title="onRefresh()"></a>onRefresh()</h2><p>又是一个扩展点，子类可以在这里来搞事情</p><h2 id="11-registerListeners"><a href="#11-registerListeners" class="headerlink" title="11. registerListeners()"></a>11. registerListeners()</h2><p>注册事件监听器</p><h2 id="bean实例化"><a href="#bean实例化" class="headerlink" title="bean实例化"></a>bean实例化</h2><p>上文我们介绍了几个方法，几乎都是对于初始化前后的扩展，但注意我们还没有开始初始化，一直到 <code>finishBeanFactoryInitialization()</code> 方法才开始初始化Bean(单例)的工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化所有剩余的单例bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 为容器注册conversion service，用于转化属性值</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">beanFactory.setConversionService(</span><br><span class="line">beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果没有的话(比如PropertyPlaceholderConfigurer)，注册一个默认的嵌入值解析器(value resoler)。</span></span><br><span class="line"><span class="comment"> * 用于解析通过注解导入的值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//先初始化 LoadTimeWeaverAware 类型的 Bean</span></span><br><span class="line">String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line"><span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">getBean(weaverAwareName);</span><br><span class="line">&#125;</span><br><span class="line">       <span class="comment">//停止使用用于类型匹配的临时类加载器</span></span><br><span class="line">beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line">      <span class="comment">//冻结所有的bean定义，即已注册的bean定义将不会被修改或后处理</span></span><br><span class="line">beanFactory.freezeConfiguration();</span><br><span class="line">      <span class="comment">//初始化</span></span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先来看一下 ConversionService.</p><h3 id="ConversionService"><a href="#ConversionService" class="headerlink" title="ConversionService"></a>ConversionService</h3><p>类型转换器，这种类型的bean最实用的场景就是用来：<br>将前端传过来的参数和后端的controller方法上的参数格式转换的时候使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToDateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dateFormat.parse(date);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"日期转换失败!"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置bean:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"conversionService"</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</span><br><span class="line">  &lt;property name=<span class="string">"converters"</span>&gt;</span><br><span class="line">    &lt;list&gt;</span><br><span class="line">      &lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.shiyujun.utils.StringToDateConverter"</span>/&gt;</span><br><span class="line">    &lt;/list&gt;</span><br><span class="line">  &lt;/property&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h3 id="EmbeddedValueResolver"><a href="#EmbeddedValueResolver" class="headerlink" title="EmbeddedValueResolver"></a>EmbeddedValueResolver</h3><p>利用EmbeddedValueResolver可以很方便的实现读取配置文件的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesUtil</span> <span class="keyword">implements</span> <span class="title">EmbeddedValueResolverAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringValueResolver resolver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmbeddedValueResolver</span><span class="params">(StringValueResolver resolver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resolver = resolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取属性时直接传入属性名称即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPropertiesValue</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        StringBuilder name = <span class="keyword">new</span> StringBuilder(<span class="string">"$&#123;"</span>).append(key).append(<span class="string">"&#125;"</span>);</span><br><span class="line">        <span class="keyword">return</span> resolver.resolveStringValue(name.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="preInstantiateSingletons"><a href="#preInstantiateSingletons" class="headerlink" title="preInstantiateSingletons()"></a>preInstantiateSingletons()</h5><p>真正开始初始化的方法，里面包括 <code>getBean()</code>,<code>createBean()</code>等方法，处理了循环依赖、别名、懒加载的问题。</p><p>这里关于bean的初始化我们要知道：</p><ol><li><p>如果bean的scope是singleton的，并且lazy-init为false（默认是false，所以可以不用设置），则 ApplicationContext启动的时候就实例化该Bean，并且将实例化的Bean放在一个map结构的缓存中，下次再使 用该 Bean的时候，直接从这个缓存中取 </p></li><li><p>如果bean的scope是singleton的，并且lazy-init为true，则该Bean的实例化是在第一次使用该Bean的时候进 行实例化 </p></li><li><p>如果bean的scope是prototype的，则该Bean的实例化是在第一次使用该Bean的时候进行实例化 </p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.logger.debug(<span class="string">"Pre-instantiating singletons in "</span> + <span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// this.beanDefinitionNames 保存了所有的 beanNames</span></span><br><span class="line">   List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 合并父 Bean 中的配置，主意&lt;bean id="" class="" parent="" /&gt; 中的 parent属性</span></span><br><span class="line">      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 不是抽象类、是单例的且不是懒加载的</span></span><br><span class="line">      <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">         <span class="comment">// 处理 FactoryBean</span></span><br><span class="line">         <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">            <span class="comment">//在 beanName 前面加上“&amp;” 符号</span></span><br><span class="line">            <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">            <span class="comment">// 判断当前 FactoryBean 是否是 SmartFactoryBean 的实现</span></span><br><span class="line">            <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">               isEagerInit = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> Boolean <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                     <span class="keyword">return</span> ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                     ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line"></span><br><span class="line">               getBean(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不是FactoryBean的直接使用此方法进行初始化</span></span><br><span class="line">            getBean(beanName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 如果bean实现了 SmartInitializingSingleton 接口的，那么在这里得到回调</span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">      Object singletonInstance = getSingleton(beanName);</span><br><span class="line">      <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">         <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">         <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;, getAccessControlContext());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bean初始化调用的是AbstractBeanFactory.getBean，最终调用的是AbstractBeanFactory.doGetBean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> String name, <span class="keyword">final</span> Class&lt;T&gt; requiredType, <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="comment">// 获取beanName，处理两种情况，一个是前面说的 FactoryBean(前面带 ‘&amp;’)，再一个这个方法是可以根据别名来获取Bean的，所以在这里是要转换成最正统的BeanName</span></span><br><span class="line">  <span class="comment">//主要逻辑就是如果是FactoryBean就把&amp;去掉如果是别名就把根据别名获取真实名称后面就不贴代码了</span></span><br><span class="line">   <span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//最后的返回值</span></span><br><span class="line">   Object bean; </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 检查是否已初始化</span></span><br><span class="line">   Object sharedInstance = getSingleton(beanName);</span><br><span class="line">  <span class="comment">//如果已经初始化过了，且没有传args参数就代表是get，直接取出返回</span></span><br><span class="line">   <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            logger.debug(<span class="string">"..."</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.debug(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 这里如果是普通Bean 的话，直接返回，如果是 FactoryBean 的话，返回它创建的那个实例对象</span></span><br><span class="line">      bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 如果存在prototype类型的这个bean</span></span><br><span class="line">      <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果当前BeanDefinition不存在这个bean且具有父BeanFactory</span></span><br><span class="line">      BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">      <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">         String nameToLookup = originalBeanName(name);</span><br><span class="line"><span class="comment">// 返回父容器的查询结果</span></span><br><span class="line">         <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">         <span class="comment">// typeCheckOnly 为 false，将当前 beanName 放入一个 alreadyCreated 的 Set 集合中。</span></span><br><span class="line">         markBeanAsCreated(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 到这就要创建bean了</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">         checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 先初始化依赖的所有 Bean， depends-on 中定义的依赖</span></span><br><span class="line">         String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">         <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">               <span class="comment">// 检查是不是有循环依赖</span></span><br><span class="line">               <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 注册一下依赖关系</span></span><br><span class="line">               registerDependentBean(dep, beanName);</span><br><span class="line">               <span class="comment">// 先初始化被依赖项</span></span><br><span class="line">               getBean(dep);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果是单例的</span></span><br><span class="line">         <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">            sharedInstance = getSingleton(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                     <span class="comment">// 执行创建 Bean，下面说</span></span><br><span class="line">                     <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                     destroySingleton(beanName);</span><br><span class="line">                     <span class="keyword">throw</span> ex;</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果是prototype</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">            Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               beforePrototypeCreation(beanName);</span><br><span class="line">               <span class="comment">// 执行创建 Bean</span></span><br><span class="line">               prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">               afterPrototypeCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果不是 singleton 和 prototype 那么就是自定义的scope、例如Web项目中的session等类型，这里就交给自定义scope的应用方去实现</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            String scopeName = mbd.getScope();</span><br><span class="line">            <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">            <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               Object scopedInstance = scope.get(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                     beforePrototypeCreation(beanName);</span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 执行创建 Bean</span></span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">finally</span> &#123;</span><br><span class="line">                        afterPrototypeCreation(beanName);</span><br><span class="line">                     &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                     <span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; consider "</span> +</span><br><span class="line">                     <span class="string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,</span><br><span class="line">                     ex);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//检查bean的类型</span></span><br><span class="line">   <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; bean != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Failed to convert bean '"</span> + name + <span class="string">"' to required type '"</span> +</span><br><span class="line">                  ClassUtils.getQualifiedName(requiredType) + <span class="string">"'"</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了上方方法我们知道了原来Spring本身只定义了两种Scope，也知道了SpringMVC的几种Scope是如何实现的了。 然后发现一开始会先判断bean存不存在，如果存在就直接返回了。</p><p>创建bean实例的方法为：AbstractAutowireCapableBeanFactory.createBean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 确保 BeanDefinition 中的 Class 被加载</span></span><br><span class="line">   Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">   <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">      mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 准备方法覆写，如果bean中定义了 &lt;lookup-method /&gt; 和 &lt;replaced-method /&gt;</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      mbdToUse.prepareMethodOverrides();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">            beanName, <span class="string">"Validation of method overrides failed"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 如果有代理的话直接返回</span></span><br><span class="line">      Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">      <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> bean; </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">            <span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 创建 bean</span></span><br><span class="line">   Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">   BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line"> <span class="comment">//如果是.factoryBean则从缓存删除</span></span><br><span class="line">      instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 实例化 Bean，这个方法里面才是终点，下面说</span></span><br><span class="line">      instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//bean实例</span></span><br><span class="line">   <span class="keyword">final</span> Object bean = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedInstance() : <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//bean类型</span></span><br><span class="line">   Class&lt;?&gt; beanType = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedClass() : <span class="keyword">null</span>);</span><br><span class="line">   mbd.resolvedTargetType = beanType;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 循环调用实现了MergedBeanDefinitionPostProcessor接口的postProcessMergedBeanDefinition方法</span></span><br><span class="line">   <span class="comment">// Spring对这个接口有几个默认的实现，其中大家最熟悉的一个是操作@Autowired注解的</span></span><br><span class="line">            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                  <span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 解决循环依赖问题</span></span><br><span class="line">   <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">         isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">   <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">               <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"> <span class="comment">//当正在创建A时，A依赖B，此时通过（8将A作为ObjectFactory放入单例工厂中进行early expose，此处B需要引用A，但A正在创建，从单例工厂拿到ObjectFactory，从而允许循环依赖</span></span><br><span class="line">      addSingletonFactory(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Object exposedObject = bean;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 负责属性装配,很重要，下面说</span></span><br><span class="line">      populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">      <span class="keyword">if</span> (exposedObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 这里是处理bean初始化完成后的各种回调，例如init-method、InitializingBean 接口、BeanPostProcessor 接口</span></span><br><span class="line">         exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">         <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">               mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//同样的，如果存在循环依赖</span></span><br><span class="line">   <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">      Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">            exposedObject = earlySingletonReference;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">            String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">            Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(dependentBeans.length);</span><br><span class="line">            <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                  actualDependentBeans.add(dependentBean);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                     <span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                     <span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line">                     <span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line">                     <span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line">                     <span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 把bean注册到相应的Scope中</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createBean主要的函数为doCreateBean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化bean</span></span><br><span class="line">BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object bean = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedInstance() : <span class="keyword">null</span>);</span><br><span class="line">Class&lt;?&gt; beanType = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedClass() : <span class="keyword">null</span>);</span><br><span class="line">mbd.resolvedTargetType = beanType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition来修改merged bean definition</span></span><br><span class="line"><span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line"><span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 缓存单例，用于解决循环引用的问题。</span></span><br><span class="line"><span class="comment">    * lifecycle接口比如BeanFactoryAware可能会引发循环引用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">&#125;</span><br><span class="line">addSingletonFactory(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化bean实例</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 注入成员以及属性</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line"><span class="keyword">if</span> (exposedObject != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 初始化实例</span></span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line"><span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(dependentBeans.length);</span><br><span class="line"><span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line"><span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">actualDependentBeans.add(dependentBean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line"><span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line"><span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line"><span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line"><span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line"><span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean as disposable.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化bean调用的是AbstractAutowireCapableBeanFactory.createBeanInstance：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 解析bean的定义</span></span><br><span class="line">Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 判断bean是否是public</span></span><br><span class="line"><span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Bean class isn't public, and non-public access not allowed: "</span> + beanClass.getName());</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 如果bean有工厂方法，则使用工厂方法来实例化，然后直接返回</span></span><br><span class="line"><span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>)  &#123;</span><br><span class="line"><span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果显式指定了构造函数则调用`autowireConstructor`，否则调用`instantiateBean`</span></span><br><span class="line"><span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line"><span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">resolved = <span class="keyword">true</span>;</span><br><span class="line">autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果可以确定构造函数，则直接实例化bean</span></span><br><span class="line"><span class="keyword">if</span> (resolved) &#123;</span><br><span class="line"><span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不能确定构造函数，则尝试从BeanPostProcessor中获取构造函数</span></span><br><span class="line">Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (ctors != <span class="keyword">null</span> ||</span><br><span class="line">mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果还是无法确定构造函数，则使用默认的无参构造函数</span></span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造函数中注入相应的参数:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">autowireConstructor</span><span class="params">(String beanName, RootBeanDefinition mbd, Constructor&lt;?&gt;[] ctors, Object[] explicitArgs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ConstructorResolver(<span class="keyword">this</span>).autowireConstructor(beanName, mbd, ctors, explicitArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>autowireConstructor实际的工作在于寻找构造函数、参数，然后调用InstantiationStrategy.instantiate来实例化bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanInstance = <span class="keyword">this</span>.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, <span class="keyword">this</span>.beanFactory, constructorToUse, argsToUse);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, String beanName, BeanFactory owner, <span class="keyword">final</span> Constructor&lt;?&gt; ctor, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果bean中有被容器重写的方法，则调用instantiateWithMethodInjection实例化bean</span></span><br><span class="line"><span class="comment">     * 否则，调用BeanUtils.instantiateClass实例化bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (bd.getMethodOverrides().isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// use own privileged to change accessibility (when security is on)</span></span><br><span class="line">AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ReflectionUtils.makeAccessible(ctor);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 调用ctor.newInstance(args)来实例化</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">     <span class="keyword">return</span> BeanUtils.instantiateClass(ctor, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用cglib来生成一个子类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner, ctor, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bean实例化完成之后，调用AbstractAutowireCapableBeanFactory.populateBean注入其中的成员以及变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">PropertyValues pvs = mbd.getPropertyValues();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to null instance"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果bean为null，则跳过填充的阶段</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用InstantiationAwareBeanPostProcessor来修改bean的状态。可以用于支持字段注入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">boolean</span> continueWithPropertyPopulation = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line"><span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">continueWithPropertyPopulation = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果调用InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation返回false，则跳过填充阶段。表示不再需要继续填充</span></span><br><span class="line"><span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果自动装配的类型有AUTOWIRE_BY_NAME和AUTOWIRE_BY_TYPE，则分别尝试根据名称自动装配、根据类型自动装配</span></span><br><span class="line"><span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line"><span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line"><span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pvs = newPvs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line"><span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class="line">PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line"><span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用InstantiationAwareBeanPostProcessor的具体子类的ibp.postProcessPropertyValues方法注入属性。</span></span><br><span class="line"><span class="comment"> * 当我们使用<span class="doctag">@Resource</span>注解的时候，具体的子类是CommonAnnotationBeanPostProcessor，</span></span><br><span class="line"><span class="comment"> * 如果使用的是<span class="doctag">@Autowired</span>注解，则具体的子类是AutowiredAnnotationBeanPostProcessor。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line"><span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="finishRefresh"><a href="#finishRefresh" class="headerlink" title="finishRefresh()"></a>finishRefresh()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//看名字就知道了，清理刚才一系列操作使用到的资源缓存</span></span><br><span class="line">clearResourceCaches();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化LifecycleProcessor</span></span><br><span class="line">initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法的内部实现是启动所有实现了Lifecycle接口的bean</span></span><br><span class="line">getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">//发布ContextRefreshedEvent事件</span></span><br><span class="line">publishEvent(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查spring.liveBeansView.mbeanDomain是否存在，有就会创建一个MBeanServer</span></span><br><span class="line">LiveBeansView.registerApplicationContext(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="resetCommonCaches"><a href="#resetCommonCaches" class="headerlink" title="resetCommonCaches()"></a>resetCommonCaches()</h2><p>最后还是一步还是清除缓存</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="http://shiyujun.cn/posts/SpringIOC%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html" target="_blank" rel="noopener">SpringIOC源码解析（上）</a></p><p><a href="http://shiyujun.cn/posts/SpringIOC%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89.html" target="_blank" rel="noopener">SpringIOC源码解析（下）</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring IOC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring——AOP理论</title>
      <link href="/2020/04/16/Spring%E2%80%94%E2%80%94AOP%E7%90%86%E8%AE%BA/"/>
      <url>/2020/04/16/Spring%E2%80%94%E2%80%94AOP%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>AOP ，即面向切面编程，可以用来管理一些和主业务无关的周边业务，如日志记录，事务管理等；</p><h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><p><code>Join point</code> ：连接点，表示程序执行期间的一个点，在 Spring AOP 表示的就是一个方法，即一个方法可以看作是一个 Join point</p><p><code>pointcut</code> ：切点，就是与连接点匹配的谓词，什么意思呢，就是需要执行 Advice 的连接点就是切点</p><p><code>Advice</code> ：增强，在连接点执行的操作，分为前置、后置、异常、最终、环绕增强五种</p><p><code>Aspect</code> ：切面，由 pointcut 和 Advice 组成，可以简单的认为 @Aspect 注解的类就是一个切面</p><p><code>Target object</code> ：目标对象，即 织入 advice 的目标对象</p><p><code>AOP proxy</code> ：代理类，在 Spring AOP 中, 一个 AOP 代理是一个 JDK 动态代理对象或 CGLIB 代理对象</p><p><code>Weaving</code> ：织入，将 Aspect 应用到目标对象中去</p><h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><p>要想使用 Spring  AOP ，首先先得在 Spring 配置文件中配置如下标签：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:aspectj-autoproxy expose-proxy=<span class="string">"true"</span> proxy-target-<span class="class"><span class="keyword">class</span></span>=<span class="string">"true"</span>/&gt;</span><br></pre></td></tr></table></figure><p><code>expose-proxy</code> : 是否需要将当前的代理对象使用 ThreadLocal 进行保存,默认为false。</p><p>例如 Aop 需要对某个接口下的所有方法进行拦截，但是有些方法在内部进行自我调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">2    </span>&#123;   </span><br><span class="line"><span class="number">3</span>        <span class="keyword">this</span>.test_2();</span><br><span class="line"><span class="number">4</span>    &#125;</span><br><span class="line"><span class="number">5</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">6    </span>&#123;</span><br><span class="line"><span class="number">7</span>    &#125;</span><br></pre></td></tr></table></figure><p>调用 test_1，此时 test_2 将不会被拦截进行增强。所以该属性 expose-proxy  就是用来解决这个问题的，即 AOP 代理的获取。</p><p><code>proxy-target-class</code> ：是否使用 CGLIB 进行代理，默认为false,使用JDK代理。当需要代理的类没有实现任何接口的时候才会使用 CGLIB 进行代理。如果想都是用 CGLIB 进行代理，可以把该属性设置为 true 即可。</p><p>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(User user)</span></span>;</span><br><span class="line"><span class="number">3</span>    <span class="function">User <span class="title">query</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="number">4</span>    <span class="function">List&lt;User&gt; <span class="title">qyertAll</span><span class="params">()</span></span>;</span><br><span class="line"><span class="number">5</span>    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="number">6</span>    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span></span>;</span><br><span class="line"><span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure><p>接口实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="meta">@Service</span>(<span class="string">"userServiceImpl"</span>)</span><br><span class="line"> <span class="number">2</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line"> <span class="number">3</span></span><br><span class="line"> <span class="number">4</span>    <span class="meta">@Override</span></span><br><span class="line"> <span class="number">5</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line"> <span class="number">6</span>        System.out.println(<span class="string">"添加用户成功，user="</span> + user);</span><br><span class="line"> <span class="number">7</span>    &#125;</span><br><span class="line"> <span class="number">8</span></span><br><span class="line"> <span class="number">9</span>    <span class="meta">@Override</span></span><br><span class="line"><span class="number">10</span>    <span class="function"><span class="keyword">public</span> User <span class="title">query</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="number">11</span>        System.out.println(<span class="string">"根据name查询用户成功"</span>);</span><br><span class="line"><span class="number">12</span>        User user = <span class="keyword">new</span> User(name, <span class="number">20</span>, <span class="number">1</span>, <span class="number">1000</span>, <span class="string">"java"</span>);</span><br><span class="line"><span class="number">13</span>        <span class="keyword">return</span> user;</span><br><span class="line"><span class="number">14</span>    &#125;</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span>    <span class="meta">@Override</span></span><br><span class="line"><span class="number">17</span>    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">qyertAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">18</span>        List&lt;User&gt; users = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">2</span>);</span><br><span class="line"><span class="number">19</span>        users.add(<span class="keyword">new</span> User(<span class="string">"zhangsan"</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">1000</span>, <span class="string">"java"</span>));</span><br><span class="line"><span class="number">20</span>        users.add(<span class="keyword">new</span> User(<span class="string">"lisi"</span>, <span class="number">25</span>, <span class="number">0</span>, <span class="number">2000</span>, <span class="string">"Python"</span>));</span><br><span class="line"><span class="number">21</span>        System.out.println(<span class="string">"查询所有用户成功, users = "</span> + users);</span><br><span class="line"><span class="number">22</span>        <span class="keyword">return</span> users;</span><br><span class="line"><span class="number">23</span>    &#125;</span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">25</span>    <span class="meta">@Override</span></span><br><span class="line"><span class="number">26</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="number">27</span>        System.out.println(<span class="string">"根据name删除用户成功, name = "</span> + name);</span><br><span class="line"><span class="number">28</span>    &#125;</span><br><span class="line"><span class="number">29</span></span><br><span class="line"><span class="number">30</span>    <span class="meta">@Override</span></span><br><span class="line"><span class="number">31</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line"><span class="number">32</span>        System.out.println(<span class="string">"更新用户成功, user = "</span> + user);</span><br><span class="line"><span class="number">33</span>    &#125;</span><br><span class="line"><span class="number">34</span>&#125;</span><br></pre></td></tr></table></figure><p>定义AOP切面 前置增强：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="meta">@Component</span></span><br><span class="line"> <span class="number">2</span><span class="meta">@Aspect</span></span><br><span class="line"> <span class="number">3</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAspectj</span> </span>&#123;</span><br><span class="line"> <span class="number">4</span></span><br><span class="line"> <span class="number">5</span>    <span class="comment">// 在方法执行之前执行</span></span><br><span class="line"> <span class="number">6</span>    <span class="meta">@Before</span>(<span class="string">"execution(* main.tsmyk.mybeans.inf.IUserService.add(..))"</span>)</span><br><span class="line"> <span class="number">7</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before_1</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="number">8</span>        System.out.println(<span class="string">"log: 在 add 方法之前执行...."</span>);</span><br><span class="line"> <span class="number">9</span>    &#125;</span><br><span class="line"><span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure><p>如果想要获取目标方法执行的参数等信息呢，我们可在 切点的方法中添参数 JoinPoint ，通过它了获取目标对象的相关信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>    <span class="meta">@Before</span>(<span class="string">"execution(* main.tsmyk.mybeans.inf.IUserService.add(..))"</span>)</span><br><span class="line"><span class="number">2</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before_2</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line"><span class="number">3</span>        Object[] args = joinPoint.getArgs();</span><br><span class="line"><span class="number">4</span>        User user = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">5</span>        <span class="keyword">if</span>(args[<span class="number">0</span>].getClass() == User<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line"><span class="number">6</span>            user = (User) args[<span class="number">0</span>];</span><br><span class="line"><span class="number">7</span>        &#125;</span><br><span class="line"><span class="number">8</span>        System.out.println(<span class="string">"log: 在 add 方法之前执行, 方法参数 = "</span> + user);</span><br><span class="line"><span class="number">9</span>    &#125;</span><br></pre></td></tr></table></figure><p>后置增强：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>    <span class="comment">// 在方法执行之后执行</span></span><br><span class="line"><span class="number">2</span>    <span class="meta">@After</span>(<span class="string">"execution(* main.tsmyk.mybeans.inf.IUserService.add(..))"</span>)</span><br><span class="line"><span class="number">3</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after_1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="number">4</span>        System.out.println(<span class="string">"log: 在 add 方法之后执行...."</span>);</span><br><span class="line"><span class="number">5</span>    &#125;</span><br></pre></td></tr></table></figure><p>返回增强：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="meta">@AfterReturning</span>(pointcut=<span class="string">"execution(* main.tsmyk.mybeans.inf.IUserService.query(..))"</span>, returning=<span class="string">"object"</span>)</span><br><span class="line"><span class="number">2</span><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after_return</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line"><span class="number">3</span>    System.out.println(<span class="string">"在 query 方法返回后执行, 返回值= "</span> + object);</span><br><span class="line"><span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure><p>异常增强：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="meta">@AfterThrowing</span>(pointcut=<span class="string">"execution(* main.tsmyk.mybeans.inf.IUserService.query(..))"</span>, throwing = <span class="string">"ex"</span>)</span><br><span class="line"><span class="number">2</span><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after_throw</span><span class="params">(Exception ex)</span></span>&#123;</span><br><span class="line"><span class="number">3</span>    System.out.println(<span class="string">"在 query 方法抛异常时执行, 异常= "</span> + ex);</span><br><span class="line"><span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure><p>环绕增强：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="meta">@Around</span>(<span class="string">"execution(* main.tsmyk.mybeans.inf.IUserService.delete(..))"</span>)</span><br><span class="line"><span class="number">2</span><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="number">3</span>    Object[] args = joinPoint.getArgs();</span><br><span class="line"><span class="number">4</span>    System.out.println(<span class="string">"log : delete 方法执行之前, 参数 = "</span> + args[<span class="number">0</span>].toString());</span><br><span class="line"><span class="number">5</span>    joinPoint.proceed();</span><br><span class="line"><span class="number">6</span>    System.out.println(<span class="string">"log : delete 方法执行之后"</span>);</span><br><span class="line"><span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure><p>也可以现在可以使用 @Pointcut 来声明一个可重用的切点表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span><span class="comment">// 声明 pointcut</span></span><br><span class="line"> <span class="number">2</span><span class="meta">@Pointcut</span>(<span class="string">"execution(* main.tsmyk.mybeans.inf.IUserService.query(..))"</span>)</span><br><span class="line"> <span class="number">3</span><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="number">4</span>&#125;</span><br><span class="line"> <span class="number">5</span></span><br><span class="line"> <span class="number">6</span><span class="meta">@Before</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"> <span class="number">7</span><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before_3</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="number">8</span>    System.out.println(<span class="string">"log: 在 query 方法之前执行"</span>);</span><br><span class="line"> <span class="number">9</span>&#125;</span><br><span class="line"><span class="number">10</span><span class="meta">@After</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="number">11</span><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after_4</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="number">12</span>    System.out.println(<span class="string">"log: 在 query 方法之后执行...."</span>);</span><br><span class="line"><span class="number">13</span>&#125;</span><br></pre></td></tr></table></figure><h1 id="指示符"><a href="#指示符" class="headerlink" title="指示符"></a>指示符</h1><ol><li><p><code>execution</code> : 它用来匹配方法执行的连接点，也是 Spring AOP 使用的主要指示符，在切点表达式中使用了通配符 ()  和  (.. )，其中，( )可以表示任意方法，任意返回值，(..)表示方法的任意参数。</p></li><li><p><code>within</code> : 匹配特定包下的所有类的所有 Joinpoint（方法），包括子包，注意是所有类，而不是接口，如果写的是接口，则不会生效。</p></li><li><p><code>@within</code> : 匹配所有持有指定注解类型的方法，如 @within(Secure)，任何目标对象持有Secure注解的类方法；必须是在目标对象上声明这个注解，在接口上声明的对它不起作用。</p></li><li><p><code>target</code> : 匹配的是一个目标对象，target(main.tsmyk.mybeans.inf.IUserService)匹配的是该接口下的所有 Join point 。</p></li><li><p><code>@target</code> : 匹配一个目标对象，这个对象必须有特定的注解，如 @target(org.springframework.transaction.annotation.Transactional) 匹配任何 有 @Transactional 注解的方法。</p></li><li><p><code>this</code> : 匹配当前AOP代理对象类型的执行方法，this(service.IPointcutService)，当前AOP对象实现了 IPointcutService接口的任何方法。</p></li><li><p><code>arg</code> : 匹配参数。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配只有一个参数 name 的方法</span></span><br><span class="line"> <span class="meta">@Before</span>(<span class="string">"execution(* main.tsmyk.mybeans.inf.IUserService.query(String)) &amp;&amp; args(name)"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_arg</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 匹配第一个参数为 name 的方法</span></span><br><span class="line"> <span class="meta">@Before</span>(<span class="string">"execution(* main.tsmyk.mybeans.inf.IUserService.query(String)) &amp;&amp; args(name, ..)"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_arg2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 匹配第二个参数为 name 的方法</span></span><br><span class="line"> <span class="meta">@Before</span>(<span class="string">"execution(* main.tsmyk.mybeans.inf.IUserService.query(String)) &amp;&amp; args(*, name, ..)"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_arg3</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol start="8"><li><p><code>@arg</code> : 匹配参数，参数有特定的注解，@args(Anno))，方法参数标有Anno注解。</p></li><li><p><code>bean</code> : 匹配特定的 bean 名称的方法</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>    <span class="comment">// 匹配 bean 的名称为 userServiceImpl 的所有方法</span></span><br><span class="line"> <span class="number">2</span>    <span class="meta">@Before</span>(<span class="string">"bean(userServiceImpl)"</span>)</span><br><span class="line"> <span class="number">3</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_bean</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="number">4</span>        System.out.println(<span class="string">"==================="</span>);</span><br><span class="line"> <span class="number">5</span>    &#125;</span><br><span class="line"> <span class="number">6</span></span><br><span class="line"> <span class="number">7</span>    <span class="comment">// 匹配 bean 名称以 ServiceImpl 结尾的所有方法</span></span><br><span class="line"> <span class="number">8</span>    <span class="meta">@Before</span>(<span class="string">"bean(*ServiceImpl)"</span>)</span><br><span class="line"> <span class="number">9</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_bean2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="number">10</span>        System.out.println(<span class="string">"+++++++++++++++++++"</span>);</span><br><span class="line"><span class="number">11</span>    &#125;</span><br></pre></td></tr></table></figure><ol start="10"><li><code>@annotation</code> : 匹配特定注解<br>@annotation(org.springframework.transaction.annotation.Transactional) 匹配 任何带有 @Transactional 注解的方法。</li></ol><h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><p>上文描述了用注解方式实现AOP的方法，一下是xml配置方式。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"arithmeticCalculator"</span> <span class="attr">class</span>=<span class="string">"com.spring.aop.AtitheticCalculatorImp"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切面的BEan--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loggingAspect"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"com.spring.aop.impl.LoggingAspect"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"vlidationAspect"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"com.spring.aop.impl.Aspect2"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置AOP--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切点表达式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.spring.aop.*.*(int,int))"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切面以及通知--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"loggingAspect"</span> <span class="attr">order</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"beforeMethod"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"afterMethod"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">"afterThrowing"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span> <span class="attr">throwing</span>=<span class="string">"ex"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"vlidationAspect"</span> <span class="attr">order</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"validationArgs"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>声明式事务配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置c3po连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注入属性值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/wangyiyun"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"153963"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 第一步：配置事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSourceTransactionManager"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注入dataSource --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 第二步：配置事务增强 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txadvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"dataSourceTransactionManager"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 做事务操作 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 设置进行事务操作的方法匹配规则 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- account开头的所有方法 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">          propagation:事务传播行为； </span></span><br><span class="line"><span class="comment">          isolation：事务隔离级别；</span></span><br><span class="line"><span class="comment">          read-only：是否只读；</span></span><br><span class="line"><span class="comment">          rollback-for：发生那些异常时回滚 </span></span><br><span class="line"><span class="comment">          timeout:事务过期时间</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"account*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span></span></span><br><span class="line"><span class="tag"><span class="attr">isolation</span>=<span class="string">"DEFAULT"</span> <span class="attr">read-only</span>=<span class="string">"false"</span> <span class="attr">rollback-for</span>=<span class="string">""</span> <span class="attr">timeout</span>=<span class="string">"-1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 第三步：配置切面 切面即把增强用在方法的过程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 切入点 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* cn.itcast.service.OrdersService.*(..))"</span></span></span><br><span class="line"><span class="tag"><span class="attr">id</span>=<span class="string">"pointcut1"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txadvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring——IOC源码解析（注解示）</title>
      <link href="/2020/04/15/Spring%E2%80%94%E2%80%94IOC%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E6%B3%A8%E8%A7%A3%EF%BC%89/"/>
      <url>/2020/04/15/Spring%E2%80%94%E2%80%94IOC%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E6%B3%A8%E8%A7%A3%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>spring2x版本，提供了注解配置的方式，本文会基于注解的方向分析SpringIOC模块的整体流程。</p><p>主要关注注解方式启动spring与xml配置方式有何变化？</p><h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationIOCDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"cn.shiyujun.config"</span>);</span><br><span class="line">        IOCService iocService=context.getBean(IOCService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(iocService.hollo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AnnotationConfigApplicationContext"><a href="#AnnotationConfigApplicationContext" class="headerlink" title="AnnotationConfigApplicationContext"></a>AnnotationConfigApplicationContext</h1><h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><p><img src="/images/Spring%E2%80%94%E2%80%94IOC%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E6%B3%A8%E8%A7%A3%E7%A4%BA%EF%BC%89_2020-04-16-15-20-31.png" alt="Spring——IOC源码解析（注解示）_2020-04-16-15-20-31.png"></p><p>可以看到相较于 <code>ClassPathXmlApplicationContext</code> 和   <code>FileSystemXmlApplicationContext</code> 来说<code>AnnotationConfigApplicationContext</code> 这个类的辈分好像更高一些</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>();</span><br><span class="line">scan(basePackages);</span><br><span class="line">refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里能看出与 <code>ClassPathXmlApplicationContext</code> 有很多不一样的地方了。</p><h3 id="this"><a href="#this" class="headerlink" title="this()"></a>this()</h3><p>首先看this:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注解bean读取器</span></span><br><span class="line"><span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//注解bean扫描器</span></span><br><span class="line"><span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AnnotatedBeanDefinitionReader</code>, <code>ClassPathBeanDefinitionScanner</code>这两个核心类比较重要。</p><h4 id="AnnotatedBeanDefinitionReader"><a href="#AnnotatedBeanDefinitionReader" class="headerlink" title="AnnotatedBeanDefinitionReader"></a>AnnotatedBeanDefinitionReader</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry, Environment environment)</span> </span>&#123;</span><br><span class="line">Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">Assert.notNull(environment, <span class="string">"Environment must not be null"</span>);</span><br><span class="line"><span class="comment">// 设置registry，本质上是annotationConfigApplicationContext实例</span></span><br><span class="line"><span class="keyword">this</span>.registry = registry;</span><br><span class="line"><span class="comment">// 新建conditionEvaluator，用于处理Conditional注释</span></span><br><span class="line"><span class="keyword">this</span>.conditionEvaluator = <span class="keyword">new</span> ConditionEvaluator(registry, environment, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册AnnotationConfigProcessors，包括：</span></span><br><span class="line"><span class="comment"> * ConfigurationClassPostProcessor</span></span><br><span class="line"><span class="comment"> * AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment"> * RequiredAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment"> * CommonAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment"> * PersistenceAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment"> * EventListenerMethodProcessor</span></span><br><span class="line"><span class="comment"> * DefaultEventListenerFactory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里应该联想到想到 <code>XmlBeanDefinitionReader</code></p><p>AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry)会把一些自动注解处理器加入到AnnotationConfigApplicationContext下的BeanFactory的BeanDefinitions中</p><h4 id="ClassPathBeanDefinitionScanner"><a href="#ClassPathBeanDefinitionScanner" class="headerlink" title="ClassPathBeanDefinitionScanner"></a>ClassPathBeanDefinitionScanner</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="keyword">boolean</span> useDefaultFilters, Environment environment, ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line"><span class="comment">// 设置registry，本质上是annotationConfigApplicationContext实例</span></span><br><span class="line"><span class="keyword">this</span>.registry = registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (useDefaultFilters) &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为<span class="doctag">@Component</span>注册默认的过滤器</span></span><br><span class="line"><span class="comment"> * 隐含地注册包含<span class="doctag">@Component</span>的注释，包括：<span class="doctag">@Repository</span>, <span class="doctag">@Service</span>, <span class="doctag">@Controller</span></span></span><br><span class="line"><span class="comment"> * 也支持<span class="doctag">@ManagedBean</span>以及<span class="doctag">@Named</span>注释</span></span><br><span class="line"><span class="comment"> * 保存在List&lt;TypeFilter&gt; includeFilters里</span></span><br><span class="line"><span class="comment"> * AnnotationTypeFilter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">registerDefaultFilters();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置environment，StandardEnvironment</span></span><br><span class="line">setEnvironment(environment);</span><br><span class="line"><span class="comment">// 设置resourceLoader，本质上还是annotationConfigApplicationContext实例</span></span><br><span class="line">setResourceLoader(resourceLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置扫描过滤，设置环境变量，加载资源文件。</p><h4 id="GenericApplicationContext"><a href="#GenericApplicationContext" class="headerlink" title="GenericApplicationContext"></a>GenericApplicationContext</h4><p>我们还记得 <code>ClassPathXmlApplicationContext</code> 的父类 <code>AbstractXmlApplicationContext</code> 吗？</p><p>与 <code>GenericApplicationContext</code> 有何区别？</p><p>子类的构造方法执行之前肯定会先执行父类的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationConfigApplicationContext</span> <span class="keyword">extends</span> <span class="title">GenericApplicationContext</span> <span class="keyword">implements</span> <span class="title">AnnotationConfigRegistry</span> </span>&#123;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GenericApplicationContext</span><span class="params">()</span> </span>&#123;      </span><br><span class="line">    <span class="comment">//这个bean的相关知识请参考之前的文章</span></span><br><span class="line">    <span class="keyword">this</span>.beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DefaultListableBeanFactory</code> 这个背景强大的类是不是很熟悉。。。</p><h3 id="scan"><a href="#scan" class="headerlink" title="scan()"></a>scan()</h3><p>接着看 <code>scan</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line"><span class="keyword">this</span>.scanner.scan(basePackages);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>啊啊，这里就可以看到这里调用的是<code>this</code> 注解的bean扫描器 <code>ClassPathBeanDefinitionScanner</code> 的<code>scan</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">scan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//获取当前注册bean的数量</span></span><br><span class="line"><span class="keyword">int</span> beanCountAtScanStart = <span class="keyword">this</span>.registry.getBeanDefinitionCount();</span><br><span class="line">        <span class="comment">//往下看</span></span><br><span class="line">doScan(basePackages);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.includeAnnotationConfig) &#123;</span><br><span class="line">           <span class="comment">//注册配置处理器</span></span><br><span class="line">AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">//返回此次注册的数量</span></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span>.registry.getBeanDefinitionCount() - beanCountAtScanStart);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着往下看 <code>doScan</code> 方法。</p><h4 id="doScan"><a href="#doScan" class="headerlink" title="doScan()"></a>doScan()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历需要扫描的包路径</span></span><br><span class="line"><span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">    <span class="comment">//先跟进去看，下面的方法先忽略</span></span><br><span class="line">Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line"><span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">definitionHolder =</span><br><span class="line">AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">beanDefinitions.add(definitionHolder);</span><br><span class="line">registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanDefinitions;</span><br></pre></td></tr></table></figure><p>再来看它扫描包的方法 <code>findCandidateComponents</code></p><h4 id="扫描包"><a href="#扫描包" class="headerlink" title="扫描包"></a>扫描包</h4><h5 id="findCandidateComponents"><a href="#findCandidateComponents" class="headerlink" title="findCandidateComponents()"></a>findCandidateComponents()</h5><p>这个方法判断忽略了Filter指定包不扫描</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;BeanDefinition&gt; <span class="title">findCandidateComponents</span><span class="params">(String basePackage)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//判断是否使用Filter指定忽略包不扫描</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.componentsIndex != <span class="keyword">null</span> &amp;&amp; indexSupportsIncludeFilters()) &#123;</span><br><span class="line"><span class="keyword">return</span> addCandidateComponentsFromIndex(<span class="keyword">this</span>.componentsIndex, basePackage);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//扫描包</span></span><br><span class="line"><span class="keyword">return</span> scanCandidateComponents(basePackage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以还要进入 <code>scanCandidateComponents</code> 方法看一下,不过之前我们有必要先认识一个接口 MetadataReader</p><h5 id="MetadataReader"><a href="#MetadataReader" class="headerlink" title="MetadataReader"></a>MetadataReader</h5><p>根据扫描包反射生成的元数据接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MetadataReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Resource <span class="title">getResource</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ClassMetadata <span class="title">getClassMetadata</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">AnnotationMetadata <span class="title">getAnnotationMetadata</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个返回Resource就不必多说了，就是配置类的资源对象。第二个第三个根据名字我们可以猜到是类的元数据和注解的元数据 可以看一下它们两个的方法。</p><h5 id="scanCandidateComponents"><a href="#scanCandidateComponents" class="headerlink" title="scanCandidateComponents()"></a>scanCandidateComponents()</h5><p>这个方法就很清晰了：</p><ol><li>组装扫描路径</li><li>遍历根据路径获取资源对象数组</li><li>根据反射生成的元数据是否有@Conditional一系列的注解，然后是否满足注册Bean的条件</li><li>满足Bean的条件，用 <code>ScannedGenericBeanDefinition</code> 类去组装他，存入 BeanDefinition 的Set集合。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Set&lt;BeanDefinition&gt; <span class="title">scanCandidateComponents</span><span class="params">(String basePackage)</span> </span>&#123;</span><br><span class="line">Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//组装扫描路径（组装完成后是这种格式：classpath*:cn/shiyujun/config/**/*.class）</span></span><br><span class="line">String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +</span><br><span class="line">resolveBasePackage(basePackage) + <span class="string">'/'</span> + <span class="keyword">this</span>.resourcePattern;</span><br><span class="line">   <span class="comment">//根据路径获取资源对象</span></span><br><span class="line">Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);</span><br><span class="line"><span class="keyword">boolean</span> traceEnabled = logger.isTraceEnabled();</span><br><span class="line"><span class="keyword">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br><span class="line"><span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line"><span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">logger.trace(<span class="string">"Scanning "</span> + resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (resource.isReadable()) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">//根据资源对象通过反射获取资源对象的MetadataReader，具体就不展开说了</span></span><br><span class="line">MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);</span><br><span class="line">   <span class="comment">//查看配置类是否有@Conditional一系列的注解，然后是否满足注册Bean的条件，关于这个知识点可以参考我之前的文章：https://mp.weixin.qq.com/s/RXYIh_g5iU1e3liK-8n5zA</span></span><br><span class="line"><span class="keyword">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line">ScannedGenericBeanDefinition sbd = <span class="keyword">new</span> ScannedGenericBeanDefinition(metadataReader);</span><br><span class="line">sbd.setResource(resource);</span><br><span class="line">sbd.setSource(resource);</span><br><span class="line"><span class="keyword">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class="line"><span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">logger.debug(<span class="string">"Identified candidate component class: "</span> + resource);</span><br><span class="line">&#125;</span><br><span class="line">candidates.add(sbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">logger.debug(<span class="string">"Ignored because not a concrete top-level class: "</span> + resource);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">logger.trace(<span class="string">"Ignored because not matching any filter: "</span> + resource);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="string">"Failed to read candidate component class: "</span> + resource, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">logger.trace(<span class="string">"Ignored because not readable: "</span> + resource);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"I/O failure during classpath scanning"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> candidates;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现这里就已经出现了 BeanDifinition，上文xml配置启动我们是在refresh()方法。。。 </p><h4 id="创建-BeanDefinition"><a href="#创建-BeanDefinition" class="headerlink" title="创建 BeanDefinition"></a>创建 BeanDefinition</h4><p>让我们回到 <code>doScan()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历需要扫描的包路径</span></span><br><span class="line"><span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">    <span class="comment">//获取所有符合条件的BeanDefinition</span></span><br><span class="line">Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line"><span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">             <span class="comment">//绑定BeanDefinition与Scope</span></span><br><span class="line">ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">                <span class="comment">//查看是否配置类是否指定bean的名称，如没指定则使用类名首字母小写</span></span><br><span class="line">String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line">                <span class="comment">//下面两个if是处理lazy、Autowire、DependencyOn、initMethod、enforceInitMethod、destroyMethod、enforceDestroyMethod、Primary、Role、Description这些逻辑的</span></span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">&#125;</span><br><span class="line">                <span class="comment">//检查bean是否存在</span></span><br><span class="line"><span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">                 <span class="comment">//又包装了一层</span></span><br><span class="line">BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">                    <span class="comment">//检查scope是否创建，如未创建则进行创建</span></span><br><span class="line">definitionHolder =</span><br><span class="line">AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">beanDefinitions.add(definitionHolder);</span><br><span class="line">                   <span class="comment">//重点来了，往下看</span></span><br><span class="line">registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们又把 <code>Set&lt;BeanDefinition&gt;</code> 里的数据进行一番处理后又存入 <code>Set&lt;BeanDefinitionHolder&gt;</code>。 接下来我们来看一下 <code>registerBeanDefinition</code> 方法</p><h4 id="注册-Bean"><a href="#注册-Bean" class="headerlink" title="注册 Bean"></a>注册 Bean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String beanName = definitionHolder.getBeanName();</span><br><span class="line"><span class="comment">// 注册bean，往下看</span></span><br><span class="line">registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果存在别名则循环注册别名，逻辑跟上方差不多，就不展开了</span></span><br><span class="line">String[] aliases = definitionHolder.getAliases();</span><br><span class="line"><span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String alias: aliases) &#123;</span><br><span class="line">registry.registerAlias(beanName, alias);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这个注册bean的方法是DefaultListableBeanFactory的方法，之前的文章已经解析过了,最终会将注册了的 BeanDefinition 存入 beanDefinitionMap这里就很明白了：</p><p><strong>相对与xml配置的方式，注解式将创建bean，注解bean的过程放在 <code>scan()</code> 里执行</strong></p><p>那我们再看看 <code>refresh</code> 方法。。。</p><h3 id="refresh"><a href="#refresh" class="headerlink" title="refresh()"></a>refresh()</h3><p>首先整个方法进来以后跟使用XML的时候是一样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 记录容器的启动时间、标记“已启动”状态、检查环境变量</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 初始化BeanFactory容器、注册BeanDefinition</span></span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 扩展点</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line">         <span class="comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册 BeanPostProcessor 的实现类</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化MessageSource</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化事件广播器</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 扩展点</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册事件监听器</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化所有的 singleton beans</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 广播事件</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                  <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 销毁已经初始化的的Bean</span></span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 设置 'active' 状态</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// 清除缓存</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="与xml不同"><a href="#与xml不同" class="headerlink" title="与xml不同"></a>与xml不同</h4><p>其实之前的解析xml、创建Bean、注册Bean都是在 <code>obtainFreshBeanFactory</code> 方法进行，我们花了好长的时间去解析，现在再看注解式它的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">refreshBeanFactory();</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.refreshed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="string">"GenericApplicationContext does not support multiple refresh attempts: just call 'refresh' once"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.beanFactory.setSerializationId(getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的核心方法 <code>refreshBeanFactory</code> 只有这么点了，它来自 <code>GenericApplicationContext</code> 类，是我们的 <code>AnnotationConfigApplicationContext</code>的父类，在对比下 <code>ClassPathXmlApplicationContext</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractXmlApplicationContext</span> </span>&#123;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationConfigApplicationContext</span> <span class="keyword">extends</span> <span class="title">GenericApplicationContext</span> <span class="keyword">implements</span> <span class="title">AnnotationConfigRegistry</span> </span>&#123;</span><br></pre></td></tr></table></figure><p><code>refreshBeanFactory</code> 是 <code>AbstractApplicationContext</code> 类的抽象方法，</p><p><code>GenericApplicationContext</code> 与 <code>AbstractRefreshableApplicationContext</code> 分别重写了这个方法，而这两个类分别是 <code>AnnotationConfigApplicationContext</code> 和 <code>ClassPathXmlApplicationContext</code> 的父类和超父类</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化就和xml配置一样了，就不赘述了。</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>我们在日常开发中有时候xml配置和注解是通用的，比如我们在xml里配置扫描：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"com.qn"</span>/&gt;</span><br></pre></td></tr></table></figure><p>我们还记得在上篇文章中的一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line"><span class="comment">// default namespace 涉及到的就四个标签 &lt;import /&gt;、&lt;alias /&gt;、&lt;bean /&gt; 和 &lt;beans /&gt;</span></span><br><span class="line">   <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">      NodeList nl = root.getChildNodes();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">         Node node = nl.item(i);</span><br><span class="line">         <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">            Element ele = (Element) node;</span><br><span class="line">            <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">               <span class="comment">// 解析 default namespace 下面的几个元素</span></span><br><span class="line">               parseDefaultElement(ele, delegate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 解析其他 namespace 的元素</span></span><br><span class="line">               delegate.parseCustomElement(ele);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 解析其他 namespace 的元素</span></span><br><span class="line">      delegate.parseCustomElement(root);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>context</code> 标签会走进 <code>parseCustomElement</code> 方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parseCustomElement</span><span class="params">(Element ele, @Nullable BeanDefinition containingBd)</span> </span>&#123;</span><br><span class="line">        String namespaceUri = <span class="keyword">this</span>.getNamespaceURI(ele);</span><br><span class="line">        <span class="keyword">if</span> (namespaceUri == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            NamespaceHandler handler = <span class="keyword">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">            <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.error(<span class="string">"Unable to locate Spring NamespaceHandler for XML schema namespace ["</span> + namespaceUri + <span class="string">"]"</span>, ele);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>它最终会走进parse方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">        BeanDefinitionParser parser = <span class="keyword">this</span>.findParserForElement(element, parserContext);</span><br><span class="line">        <span class="keyword">return</span> parser != <span class="keyword">null</span> ? parser.parse(element, parserContext) : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>接着走：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">        String basePackage = element.getAttribute(<span class="string">"base-package"</span>);</span><br><span class="line">        basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage);</span><br><span class="line">        String[] basePackages = StringUtils.tokenizeToStringArray(basePackage, <span class="string">",; \t\n"</span>);</span><br><span class="line">        ClassPathBeanDefinitionScanner scanner = <span class="keyword">this</span>.configureScanner(parserContext, element);</span><br><span class="line">        Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages);</span><br><span class="line">        <span class="keyword">this</span>.registerComponents(parserContext.getReaderContext(), beanDefinitions, element);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>Set&lt;BeanDefinitionHolder&gt;</code> 是不是很熟悉， <code>scanner.doScan(basePackages)</code> 是不是很熟悉。。。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="http://shiyujun.cn/posts/SpringIOC%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%EF%BC%89.html" target="_blank" rel="noopener">SpringIOC源码解析（基于注解）</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring 注解式源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring——IOC源码解析上</title>
      <link href="/2020/04/13/Spring%E2%80%94%E2%80%94IOC%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8A/"/>
      <url>/2020/04/13/Spring%E2%80%94%E2%80%94IOC%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><p>读取配置文件启动Spring：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOCDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:application-ioc.xml"</span>);</span><br><span class="line">        IOCService iocService=context.getBean(IOCService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(iocService.hollo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ClassPathXmlApplicationContext"><a href="#ClassPathXmlApplicationContext" class="headerlink" title="ClassPathXmlApplicationContext"></a>ClassPathXmlApplicationContext</h1><h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><p>继承关系图：</p><p><img src="/images/Spring%E2%80%94%E2%80%94IOC%E6%BA%90%E7%A2%BC%E8%A7%A3%E6%9E%90_2020-04-13-16-16-22.png" alt="Spring——IOC源碼解析_2020-04-13-16-16-22.png"></p><p>最上方的 ApplicationContext 则是大名鼎鼎的Spring核心上下文了。</p><p>左下角的就是ClassPathXmlApplicationContext、与它同级的是FileSystemXmlApplicationContext。都是通过加载配置文件来启动Spring的，只不过一个是从程序内加载一个是从系统内加载。</p><p>AnnotationConfigApplicationContext比较值得我们关注，这个类是用来处理注解式编程的。详细请移步 </p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractXmlApplicationContext</span> </span>&#123;</span><br><span class="line">  <span class="comment">//配置文件数组</span></span><br><span class="line">  <span class="keyword">private</span> Resource[] configResources;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指定ApplicationContext的父容器</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, ApplicationContext parent)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    <span class="comment">// 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割)</span></span><br><span class="line">    setConfigLocations(configLocations);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">      refresh(); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类构造主要有 <code>setConfigLocations</code>和 <code>refresh</code> 这两个方法，这两个方法也是IOC的核心。</p><p><code>setConfigLocations</code> 方法主要工作：</p><ol><li>创建环境对象ConfigurableEnvironment</li><li>处理ClassPathXmlApplicationContext传入的字符串中的占位符</li></ol><p><code>refresh</code> 方法主要工作：</p><ol><li>检查环境</li><li>创建BeanFactory</li><li>解析xml配置文件</li><li>创建Bean</li><li>注册Bean</li><li>扩展点</li><li>初始化</li></ol><h2 id="setConfigLocations"><a href="#setConfigLocations" class="headerlink" title="setConfigLocations()"></a>setConfigLocations()</h2><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigLocations</span><span class="params">(String... locations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (locations != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Assert.noNullElements(locations, <span class="string">"Config locations must not be null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.configLocations = <span class="keyword">new</span> String[locations.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; locations.length; i++) &#123;</span><br><span class="line">            <span class="comment">//往下看</span></span><br><span class="line">            <span class="keyword">this</span>.configLocations[i] = resolvePath(locations[i]).trim();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.configLocations = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">resolvePath</span><span class="params">(String path)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> getEnironment().resolveRequiredPlaceholders(path); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会读取传入的 locations 数组并遍历，具体操作是由<code>resolvePath</code> 方法实现。</p><h3 id="创建环境变量"><a href="#创建环境变量" class="headerlink" title="创建环境变量"></a>创建环境变量</h3><p>看一下 <code>getEniroment</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableEnvironment <span class="title">getEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.environment == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.environment = createEnvironment();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ConfigurableEnvironment"><a href="#ConfigurableEnvironment" class="headerlink" title="ConfigurableEnvironment"></a>ConfigurableEnvironment</h4><p>继承关系图：</p><p><img src="/images/Spring%E2%80%94%E2%80%94IOC%E6%BA%90%E7%A2%BC%E8%A7%A3%E6%9E%90_2020-04-15-14-38-24.png" alt="Spring——IOC源碼解析_2020-04-15-14-38-24.png"></p><p>它直接继承类 <code>Environment</code> 和 <code>ConfigurablePropertyResolver</code> 。</p><p>这个接口比较重要的两部分作用：</p><ul><li>spring.profile配置</li><li>系统资源Property</li></ul><p>接着看 <code>createEnvironment()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableEnvironment <span class="title">createEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>返回 <code>StandardEnvironment</code> 类，而这个类中的<code>customizePropertySources</code> 方法就会往资源列表中添加Java进程中的变量和系统的环境变量:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizePropertySources</span><span class="params">(MutablePropertySources propertySources)</span> </span>&#123;</span><br><span class="line">    propertySources.addLast(<span class="keyword">new</span> MapPropertySource(SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME, getSystemProperties()));</span><br><span class="line">    propertySources.addLast(<span class="keyword">new</span> SystemEnvironmentPropertySource(SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, getSystemEnvironment()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理占位符"><a href="#处理占位符" class="headerlink" title="处理占位符"></a>处理占位符</h3><p>回到 <code>resovePath.resolveRequiredPlaceholders</code> 方法：</p><p>这个方法主要就是处理所有使用${}方式的占位符，这里主要是为了处理 <code>ClassPathXmlApplicationContext</code> 传过来的占位符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:$&#123;prefixName&#125;-spring.xml"</span>);</span><br></pre></td></tr></table></figure><h2 id="refresh"><a href="#refresh" class="headerlink" title="refresh"></a>refresh</h2><p>读取环境及系统变量、配置文件名称解析完毕后，就到了最关键的一步<code>refresh</code> 方法。</p><p><strong>它也是spring管理bean的核心，bean的创建、注册、初始化都由这个方法完成</strong>。</p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">//做一些准备工作，记录容器的启动时间、标记“已启动”状态、检查环境变量等.</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// BeanFactory的初始化、Bean的加载和注册等事件.</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize message source for this context.</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line"><span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset 'active' flag.</span></span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate exception to caller.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line"><span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="检查环境"><a href="#检查环境" class="headerlink" title="检查环境"></a>检查环境</h3><p><code>prepareRefresh</code> 方法主要做一些准备工作，记录容器的启动时间、标记“已启动”状态、检查环境变量等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">"Refreshing "</span> + <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化加载配置文件方法，并没有具体实现，一个留给用户的扩展点</span></span><br><span class="line">initPropertySources();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查环境变量</span></span><br><span class="line">getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法最重要的是倒数二三行，具体详情请访问：<a href="https://www.cnblogs.com/warehouse/p/9384735.html" target="_blank" rel="noopener">准备环境</a></p><h3 id="obtainFreshBeanFactory"><a href="#obtainFreshBeanFactory" class="headerlink" title="obtainFreshBeanFactory()*"></a>obtainFreshBeanFactory()*</h3><p>这个方法很长，这里先总结它的主要工作：</p><ul><li>初始化一个ConfigurableListableBeanFactory容器</li><li>Rousource接口处理xml配置文件的流，解析配置文件</li><li>根据解析出的配置dom,创建BeanDefinition示例</li><li>注册了所有的BeanDefinition到beanDefinitionMap</li></ul><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 核心</span></span><br><span class="line">   refreshBeanFactory();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回刚刚创建的 BeanFactory</span></span><br><span class="line">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析这个方法之前，我们先要了解两个核心类 <code>DefaultListableBeanFactory</code> 和 <code>BeanDefinition</code>。</p><h4 id="DefaultListableBeanFactory"><a href="#DefaultListableBeanFactory" class="headerlink" title="DefaultListableBeanFactory"></a>DefaultListableBeanFactory</h4><p>继承关系：</p><p><img src="/images/Spring%E2%80%94%E2%80%94IOC%E6%BA%90%E7%A2%BC%E8%A7%A3%E6%9E%90_2020-04-15-15-37-36.png" alt="Spring——IOC源碼解析_2020-04-15-15-37-36.png"></p><p>BeanFacoty 有三个直接子类 <code>ListableBeanFactory</code>、<code>HierarchicalBeanFactory</code> 和 <code>AutowireCapableBeanFactory</code>;</p><p><code>DefaultListableBeanFactory</code> 为最终默认实现，它实现了所有接口。</p><p><strong>实际上我们应用spring也是通过ApplicationContex和DefaultListableBeanFactory一起来完成的</strong>。</p><h4 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h4><p>我们知道 BeanFactory 是一个 Bean 容器，而 BeanDefinition 就是 Bean 的一种形式（它里面包含了 Bean 指向的类、是否单例、是否懒加载、Bean 的依赖关系等相关的属性）。BeanFactory 中就是保存的 BeanDefinition。</p><p>看看BeanDefinition的接口源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinition</span> <span class="keyword">extends</span> <span class="title">AttributeAccessor</span>, <span class="title">BeanMetadataElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Bean的生命周期，默认只提供sington和prototype两种，在WebApplicationContext中还会有request, session, globalSession, application, websocket 等</span></span><br><span class="line">   String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line">   String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 设置父Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setParentName</span><span class="params">(String parentName)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取父Bean</span></span><br><span class="line">   <span class="function">String <span class="title">getParentName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置Bean的类名称</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setBeanClassName</span><span class="params">(String beanClassName)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取Bean的类名称</span></span><br><span class="line">   <span class="function">String <span class="title">getBeanClassName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置bean的scope</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setScope</span><span class="params">(String scope)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function">String <span class="title">getScope</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置是否懒加载</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setLazyInit</span><span class="params">(<span class="keyword">boolean</span> lazyInit)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isLazyInit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置该Bean依赖的所有Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setDependsOn</span><span class="params">(String... dependsOn)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回该Bean的所有依赖</span></span><br><span class="line">   String[] getDependsOn();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置该Bean是否可以注入到其他Bean中</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setAutowireCandidate</span><span class="params">(<span class="keyword">boolean</span> autowireCandidate)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 该Bean是否可以注入到其他Bean中</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isAutowireCandidate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 同一接口的多个实现，如果不指定名字的话，Spring会优先选择设置primary为true的bean</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setPrimary</span><span class="params">(<span class="keyword">boolean</span> primary)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否是primary的</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isPrimary</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 指定工厂名称</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setFactoryBeanName</span><span class="params">(String factoryBeanName)</span></span>;</span><br><span class="line">   <span class="comment">// 获取工厂名称</span></span><br><span class="line">   <span class="function">String <span class="title">getFactoryBeanName</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">// 指定工厂类中的工厂方法名称</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setFactoryMethodName</span><span class="params">(String factoryMethodName)</span></span>;</span><br><span class="line">   <span class="comment">// 获取工厂类中的工厂方法名称</span></span><br><span class="line">   <span class="function">String <span class="title">getFactoryMethodName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 构造器参数</span></span><br><span class="line">   <span class="function">ConstructorArgumentValues <span class="title">getConstructorArgumentValues</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Bean 中的属性值，后面给 bean 注入属性值的时候会说到</span></span><br><span class="line">   <span class="function">MutablePropertyValues <span class="title">getPropertyValues</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否 singleton</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否 prototype</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果这个 Bean 是被设置为 abstract，那么不能实例化，常用于作为 父bean 用于继承</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isAbstract</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">getRole</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function">String <span class="title">getResourceDescription</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function">BeanDefinition <span class="title">getOriginatingBeanDefinition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="refreshBeanFactory"><a href="#refreshBeanFactory" class="headerlink" title="refreshBeanFactory()"></a>refreshBeanFactory()</h4><p>我们回到 <code>obtainFreshBeanFactory</code>，看一下 <code>refreshBeanFactory</code> 方法。</p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="comment">// 判断当前ApplicationContext是否存在BeanFactory，如果存在的话就销毁所有 Bean，关闭 BeanFactory</span></span><br><span class="line">   <span class="comment">// 注意，一个应用可以存在多个BeanFactory，这里判断的是当前ApplicationContext是否存在BeanFactory</span></span><br><span class="line">   <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">      destroyBeans();</span><br><span class="line">      closeBeanFactory();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 初始化DefaultListableBeanFactory</span></span><br><span class="line">      DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">      beanFactory.setSerializationId(getId());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用</span></span><br><span class="line">      customizeBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 加载 Bean 到 BeanFactory 中</span></span><br><span class="line">      loadBeanDefinitions(beanFactory);</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">         <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入 <code>loadBeanDefinitions</code>方法。</p><h5 id="loadBeanDefinitions"><a href="#loadBeanDefinitions" class="headerlink" title="loadBeanDefinitions()"></a>loadBeanDefinitions()</h5><h6 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Overrideprotected</span> <span class="function"><span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">   <span class="comment">// 实例化XmlBeanDefinitionReader</span></span><br><span class="line">   XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">   beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">   beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">   beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始化 BeanDefinitionReader</span></span><br><span class="line">   initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">   <span class="comment">// 接着往下看</span></span><br><span class="line">   loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">   Resource[] configResources = getConfigResources();</span><br><span class="line">   <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">      reader.loadBeanDefinitions(configResources);</span><br><span class="line">   &#125;</span><br><span class="line">   String[] configLocations = getConfigLocations();</span><br><span class="line">   <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">      reader.loadBeanDefinitions(configLocations);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个if是看有没有系统指定的配置文件，如果没有的话就走第二个if加载我们最开始传入的 <code>classpath:application-ioc.xml</code></p><p>XmlBeanDefinitionReader 是我们解析xml配置的核心类。</p><h6 id="XmlBeanDefinitionReader"><a href="#XmlBeanDefinitionReader" class="headerlink" title="XmlBeanDefinitionReader"></a>XmlBeanDefinitionReader</h6><p>，它的父类是 <code>AbstractBeanDefinitionReader</code> 它实现了 <code>BeanDefinitionReader</code> 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.registry = registry;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.registry <span class="keyword">instanceof</span> ResourceLoader) &#123;</span><br><span class="line">            <span class="keyword">this</span>.resourceLoader = (ResourceLoader)<span class="keyword">this</span>.registry;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.resourceLoader = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.registry <span class="keyword">instanceof</span> EnvironmentCapable) &#123;</span><br><span class="line">            <span class="keyword">this</span>.environment = ((EnvironmentCapable)<span class="keyword">this</span>.registry).getEnvironment();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.environment = <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>它提供了读取环境变量，加载location资源，以及 BeanDefinitionRegistry的 注册Bean方法。</p><h6 id="Resourse"><a href="#Resourse" class="headerlink" title="Resourse"></a>Resourse</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">Assert.notNull(encodedResource, <span class="string">"EncodedResource must not be null"</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">"Loading XML bean definitions from "</span> + encodedResource.getResource());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line"><span class="keyword">if</span> (currentResources == <span class="keyword">null</span>) &#123;</span><br><span class="line">currentResources = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="string">"Detected cyclic loading of "</span> + encodedResource + <span class="string">" - check your import definitions!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//获取文件流</span></span><br><span class="line">InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line"><span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//加载</span></span><br><span class="line"><span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">inputStream.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="string">"IOException parsing XML document from "</span> + encodedResource.getResource(), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">currentResources.remove(encodedResource);</span><br><span class="line"><span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中间省略了一些源码，其实这几个方法的目的就是把流交给 <code>Resource</code> 接口来处理，它的每一个实现类都代表了一种资源的访问策略，这里用的就是EncodedResource。</p><h6 id="DOM解析"><a href="#DOM解析" class="headerlink" title="DOM解析"></a>DOM解析</h6><p>进去看 <code>doLoadBeanDefinitions()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//将 xml 文件转换为 Document 对象</span></span><br><span class="line">Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">   <span class="comment">//根据Document对象注册Bean</span></span><br><span class="line"><span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (SAXParseException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line"><span class="string">"Line "</span> + ex.getLineNumber() + <span class="string">" in XML document from "</span> + resource + <span class="string">" is invalid"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (SAXException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line"><span class="string">"XML document from "</span> + resource + <span class="string">" is invalid"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ParserConfigurationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line"><span class="string">"Parser configuration exception parsing XML from "</span> + resource, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line"><span class="string">"IOException parsing XML document from "</span> + resource, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line"><span class="string">"Unexpected exception parsing XML document from "</span> + resource, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml转dom解析这里不用费神了，主要是 <code>registerBeanDefinitions()</code>。</p><h6 id="注册-Bean"><a href="#注册-Bean" class="headerlink" title="注册 Bean"></a>注册 Bean</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">   <span class="comment">//构建读取Document的工具类</span></span><br><span class="line">   BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">   <span class="comment">//获取已注册的bean数量</span></span><br><span class="line">   <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">   <span class="comment">// 在这接着往下看</span></span><br><span class="line">   documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">   <span class="comment">//总注册的bean减去之前注册的bean就是本次注册的bean</span></span><br><span class="line">   <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">logger.debug(<span class="string">"Loading bean definitions"</span>);</span><br><span class="line">        <span class="comment">//获取Document的根节点</span></span><br><span class="line">Element root = doc.getDocumentElement();</span><br><span class="line">        <span class="comment">//继续往下</span></span><br><span class="line">doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 当前根节点</span></span><br><span class="line">BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line"><span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line"><span class="comment">// 获取 &lt;beans ... profile="***" /&gt; 中的 profile参数与当前环境是否匹配，如果不匹配则不再进行解析</span></span><br><span class="line">String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line"><span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">"Skipped XML bean definition file due to specified profiles ["</span> + profileSpec +</span><br><span class="line"><span class="string">"] not matching: "</span> + getReaderContext().getResource());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 前置扩展点</span></span><br><span class="line">preProcessXml(root);</span><br><span class="line"><span class="comment">// 往下看</span></span><br><span class="line">parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line"><span class="comment">// 后置扩展点</span></span><br><span class="line">postProcessXml(root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是具体解析xml配置文件的方法 <code>parseBeanDefinitions()</code>;</p><h6 id="解析xml标签"><a href="#解析xml标签" class="headerlink" title="解析xml标签"></a>解析xml标签</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line"><span class="comment">// default namespace 涉及到的就四个标签 &lt;import /&gt;、&lt;alias /&gt;、&lt;bean /&gt; 和 &lt;beans /&gt;</span></span><br><span class="line">   <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">      NodeList nl = root.getChildNodes();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">         Node node = nl.item(i);</span><br><span class="line">         <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">            Element ele = (Element) node;</span><br><span class="line">            <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">               <span class="comment">// 解析 default namespace 下面的几个元素</span></span><br><span class="line">               parseDefaultElement(ele, delegate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 解析其他 namespace 的元素</span></span><br><span class="line">               delegate.parseCustomElement(ele);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 解析其他 namespace 的元素</span></span><br><span class="line">      delegate.parseCustomElement(root);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下 default 标签的处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 处理 &lt;import /&gt; 标签</span></span><br><span class="line">      importBeanDefinitionResource(ele);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 处理 &lt;alias /&gt; 标签</span></span><br><span class="line">      <span class="comment">// &lt;alias name="fromName" alias="toName"/&gt;</span></span><br><span class="line">      processAliasRegistration(ele);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 处理 &lt;bean /&gt; 标签定义</span></span><br><span class="line">      processBeanDefinition(ele, delegate);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 处理 &lt;beans /&gt; 标签</span></span><br><span class="line">      doRegisterBeanDefinitions(ele);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下bean标签的处理方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">//创建BeanDefinition</span></span><br><span class="line">BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line"><span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Register the final decorated instance.</span></span><br><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Send registration event.</span></span><br><span class="line">getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下第一行的 <code>parseBeanDefinitionElement</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> parseBeanDefinitionElement(ele, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">   String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">   String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">   List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 将 name 属性的定义按照 “逗号、分号、空格” 切分，形成一个 别名列表数组，</span></span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">      String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">      aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   String beanName = id;</span><br><span class="line">   <span class="comment">// 如果没有指定id, 那么用别名列表的第一个名字作为beanName</span></span><br><span class="line">   <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">      beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">"No XML 'id' specified - using '"</span> + beanName +</span><br><span class="line">               <span class="string">"' as bean name and "</span> + aliases + <span class="string">" as aliases"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">      checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 根据 &lt;bean ...&gt;...&lt;/bean&gt; 中的配置创建 BeanDefinition，然后把配置中的信息都设置到实例中,</span></span><br><span class="line">   <span class="comment">// 这行执行完毕，一个 BeanDefinition 实例就出来了。等下接着往下看</span></span><br><span class="line">   AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// &lt;bean /&gt; 标签完成</span></span><br><span class="line">   <span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果没有设置 id 和 name，那么此时的 beanName 就会为 null</span></span><br><span class="line">      <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">               beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">                     beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line"></span><br><span class="line">               String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">               <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">                     !<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                  <span class="comment">// 把 beanClassName 设置为 Bean 的别名</span></span><br><span class="line">                  aliases.add(beanClassName);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">               logger.debug(<span class="string">"Neither XML 'id' nor 'name' specified - "</span> +</span><br><span class="line">                     <span class="string">"using generated bean name ["</span> + beanName + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            error(ex.getMessage(), ele);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">      <span class="comment">// 返回 BeanDefinitionHolder</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下这个方法的 <code>parseBeanDefinitionElement(Element ele, BeanDefinition containingBean)</code>。</p><p><strong>这个方法就是根据配置创建 BeanDefinition 实例的方法，前面山路十八弯，其中解析xml占据了大部分源码。。。</strong></p><h6 id="创建-BeanDefinition"><a href="#创建-BeanDefinition" class="headerlink" title="创建 BeanDefinition*"></a>创建 BeanDefinition*</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionElement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Element ele, String beanName, BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> BeanEntry(beanName));</span><br><span class="line"></span><br><span class="line">   String className = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">      className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      String parent = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">         parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 创建 BeanDefinition，然后设置类信息</span></span><br><span class="line">      AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置 BeanDefinition 的一堆属性，这些属性定义在 AbstractBeanDefinition 中</span></span><br><span class="line">      parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">      bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 下面的一堆是解析 &lt;bean&gt;......&lt;/bean&gt; 内部的子元素，</span></span><br><span class="line"><span class="comment">       * 解析出来以后的信息都放到 bd 的属性中</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 解析 &lt;meta /&gt;</span></span><br><span class="line">      parseMetaElements(ele, bd);</span><br><span class="line">      <span class="comment">// 解析 &lt;lookup-method /&gt;</span></span><br><span class="line">      parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">      <span class="comment">// 解析 &lt;replaced-method /&gt;</span></span><br><span class="line">      parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">    <span class="comment">// 解析 &lt;constructor-arg /&gt;</span></span><br><span class="line">      parseConstructorArgElements(ele, bd);</span><br><span class="line">      <span class="comment">// 解析 &lt;property /&gt;</span></span><br><span class="line">      parsePropertyElements(ele, bd);</span><br><span class="line">      <span class="comment">// 解析 &lt;qualifier /&gt;</span></span><br><span class="line">      parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">      bd.setResource(<span class="keyword">this</span>.readerContext.getResource());</span><br><span class="line">      bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> bd;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">      error(<span class="string">"Bean class ["</span> + className + <span class="string">"] not found"</span>, ele, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (NoClassDefFoundError err) &#123;</span><br><span class="line">      error(<span class="string">"Class that bean class ["</span> + className + <span class="string">"] depends on not found"</span>, ele, err);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      error(<span class="string">"Unexpected failure during bean definition parsing"</span>, ele, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 BeanDefinitionParserDelegate 类的 <code>parseBeanDefinitionElement</code> 进行元素解析，返回BeanDefinitionHolder，返回的实例包含了配置文件中配置的各种属性了，比如class、name、id、alias之类的属性。</p><h6 id="注册Bean"><a href="#注册Bean" class="headerlink" title="注册Bean"></a>注册Bean</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 上面说的一堆</span></span><br><span class="line">   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">   <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果有自定义属性的话，进行相应的解析</span></span><br><span class="line">      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 注册Bean</span></span><br><span class="line">         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">         getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">               bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 注册完成后，发送事件</span></span><br><span class="line">      getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册操作委托给了BeanDefinitionReaderUtils，看看真正注册Bean的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">   String beanName = definitionHolder.getBeanName();</span><br><span class="line">   <span class="comment">// 注册这个 Bean</span></span><br><span class="line">   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果配置有别名的话，也要根据别名全部注册一遍</span></span><br><span class="line">   String[] aliases = definitionHolder.getAliases();</span><br><span class="line">   <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">         registry.registerAlias(beanName, alias);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们要注意这个类 <code>BeanDefinitionRegistry</code> 接口, 我们注册Bean、删除Bean,用到的都是这个类。当然我们用的是它的实现类<code>DefaultListableBeanFactory</code> 的方法。</p><p>还要往里看。。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">   Assert.hasText(beanName, <span class="string">"Bean name must not be empty"</span>);</span><br><span class="line">   Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(...);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   BeanDefinition oldBeanDefinition;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 所有的 Bean 注册后都会被放入到这个beanDefinitionMap 中，查看是否已存在这个bean</span></span><br><span class="line">   oldBeanDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理重复名称的 Bean 定义的情况</span></span><br><span class="line">   <span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">         <span class="comment">// 如果不允许覆盖的话，抛异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Cannot register bean definition ["</span> + beanDefinition + <span class="string">"] for bean '"</span> + beanName +</span><br><span class="line"><span class="string">"': There is already ["</span> + oldBeanDefinition + <span class="string">"] bound."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">         <span class="comment">// 用框架定义的 Bean 覆盖用户自定义的 Bean </span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.warn(<span class="string">"Overriding user-defined bean definition for bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' with a framework-generated bean definition: replacing ["</span> +</span><br><span class="line">oldBeanDefinition + <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(oldBeanDefinition)) &#123;</span><br><span class="line">         <span class="comment">// 用新的 Bean 覆盖旧的 Bean</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.warn(<span class="string">"Overriding user-defined bean definition for bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' with a framework-generated bean definition: replacing ["</span> +</span><br><span class="line">oldBeanDefinition + <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// log...用同等的 Bean 覆盖旧的 Bean</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.info(<span class="string">"Overriding bean definition for bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' with a different definition: replacing ["</span> + oldBeanDefinition +</span><br><span class="line"><span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 覆盖</span></span><br><span class="line">      <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 判断是否已经有其他的 Bean 开始初始化了.注意，"注册Bean" 这个动作结束，Bean 依然还没有初始化 在 Spring 容器启动的最后，会 预初始化 所有的 singleton beans</span></span><br><span class="line">      <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">         <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">         <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">            updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">            updatedDefinitions.add(beanName);</span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">               Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">               updatedSingletons.remove(beanName);</span><br><span class="line">               <span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">         <span class="comment">// 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition</span></span><br><span class="line">         <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">         <span class="comment">// 这是个 ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字</span></span><br><span class="line">         <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">         <span class="comment">// 这是个 LinkedHashSet，代表的是手动注册的 singleton bean，</span></span><br><span class="line">         <span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">      resetBeanDefinition(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里已经初始化了 Bean 容器，的配置也相应的转换为了一个个BeanDefinition，然后注册了所有的 BeanDefinition 到beanDefinitionMap，</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实这一长串源码下来，关于读取配置文件、创建Bean、加载Bean,实际上是：<br>BeanDefinitionReader 如何将 Resource 转换为 IoC 容器独特的数据存储对象：BeanDefinition</p><p>当然这里 bean 还没有初始化，只是完成了bean的注册。关于Bean初始化的内容请看下文 <a href="/2020/04/20/Spring%E2%80%94%E2%80%94IOC%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8B/" title="Spring——IOC源码解析下">Spring——IOC源码解析下</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring IOC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring——概述</title>
      <link href="/2020/04/13/Spring%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/04/13/Spring%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="什麽是Spring"><a href="#什麽是Spring" class="headerlink" title="什麽是Spring?"></a>什麽是Spring?</h1><p>Spring 是一个轻量级的控制反转（IoC）和面向切面（AOP）的开源容器（框架）。</p><p>优点：</p><ul><li>开源免费</li><li>非侵入，轻量级</li><li>对事务的支持，对框架的支持</li></ul><h1 id="什么是-“控制反转”-“依赖注入”？"><a href="#什么是-“控制反转”-“依赖注入”？" class="headerlink" title="什么是 “控制反转” “依赖注入”？"></a>什么是 “控制反转” “依赖注入”？</h1><h2 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h2><p>将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。</p><p><strong>IoC 容器是 Spring 用来实现 IoC 的载体，IoC 容器实际上就是个 Map(key,value)，Map 中存放的是各种对象</strong>。</p><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。</p><h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><p><img src="/images/Spring%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0_2020-04-13-15-22-05.png" alt="Spring——概述_2020-04-13-15-22-05.png"></p><h2 id="Core-Container"><a href="#Core-Container" class="headerlink" title="Core Container"></a>Core Container</h2><p>Core Container（核心容器）包含有 Core、Beans、Context 和 SpEL 模块。其中 Core 和 Beans 模块是框架的基础部分，提供 IoC（控制反转）和依赖注入功能。</p><h3 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h3><p>主要包含 Spring 框架基本的核心工具类。</p><h3 id="Beans"><a href="#Beans" class="headerlink" title="Beans"></a>Beans</h3><p>是所有应用都要用到的，它包含访问配置文件、创建和管理 bean 以及进行  Inversion of Control/Dependency Injection(Ioc/DI) 操作相关的所有类。</p><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>构建于 Core 和 Beans 模块基础之上，提供了一种类似于 JNDI 注册器的框架式的对象访问方法。Context 模块继承了 Beans 的特性，为 Spring 核心提供了大量的扩展，添加了对国际化（如资源绑定）、事件传播、资源加载和对 Context 的透明创建的支持。</p><h3 id="SpEL"><a href="#SpEL" class="headerlink" title="SpEL"></a>SpEL</h3><p>只依赖于 Core 模块，可以单独使用。该模块提供了一个强大的表达式语言用于在运行时查询和操纵对象，该语言支持设置/获取属性的值，属性的分配，方法的调用，访问数组上下文、容器和索引器、逻辑和算术运算符、命名变量以及从 Spring 的 IoC 容器中根据名称检索对象。</p><h2 id="Data-Access-Integration"><a href="#Data-Access-Integration" class="headerlink" title="Data Access/Integration"></a>Data Access/Integration</h2><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p>提供了一个 JDBC 抽象层，它可以消除冗长的 JDBC 编码和解析数据库厂商特有的错误代码，这个模块包含了 Spring 对 JDBC 数据访问进行封装的所有类。</p><h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><p>为流行的对象-关系映射 API，如 JPA、JDO、Hibernate、iBatis 等，提供了一个交互层，利用 ORM 封装包，可以混合使用所有 Spring 提供的特性进行 O/R 映射，如前边提到的简单声明性事务管理。</p><h3 id="OXM"><a href="#OXM" class="headerlink" title="OXM"></a>OXM</h3><p>提供了一个 Object/XML 映射实现的抽象层，Object/XML 映射实现抽象层包括 JAXB、Castor、XMLBeans、JiBX 和 XStream。</p><h3 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h3><p>模块主要包含了一些制造和消费消息的特性。</p><h3 id="Transaction"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction</h3><p>支持编程和声明式事物管理，这些事务类必须实现特定的接口，并且对所有 POJO 都适用 。</p><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><p>Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文，所以 Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</p><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。</p><p>Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。 </p><h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><p>Test 模块支持使用 Junit 和 TestNG 对 Spring 组件进行测试。</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h2><p>Resource 主要负责对资源的抽象，它的每一个实现类都代表了一种资源的访问策略，如 ClasspathResource 、 URLResource ，FileSystemResource 等。</p><p>Spring 利用 ResourceLoader 来进行统一资源加载，关系图如下：</p><p><img src="/images/Spring%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0_2020-04-26-14-38-30.png" alt="Spring——概述_2020-04-26-14-38-30.png"></p><h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>资源加载完毕之后就需要 BeanFactory 来进行加载解析，它是一个 bean 容器，其中  BeanDefinition 是它的基本结构，它内部维护着一 个 BeanDefinition map ，并可根据 BeanDefinition 的描述进行 bean 的创建和管理。</p><p><img src="/images/Spring%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0_2020-04-26-14-39-03.png" alt="Spring——概述_2020-04-26-14-39-03.png"></p><p>BeanFacoty 有三个直接子类 ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory，DefaultListableBeanFactory 为最终默认实现，它实现了所有接口。</p><h2 id="BeanDifinition"><a href="#BeanDifinition" class="headerlink" title="BeanDifinition"></a>BeanDifinition</h2><p>BeanDefinition 用来描述 Spring 中的 Bean 对象。</p><p><img src="/images/Spring%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0_2020-04-26-14-40-39.png" alt="Spring——概述_2020-04-26-14-40-39.png"></p><h2 id="BeanDefinitionReader"><a href="#BeanDefinitionReader" class="headerlink" title="BeanDefinitionReader"></a>BeanDefinitionReader</h2><p>BeanDefinitionReader 的作用是读取 Spring 配置文件中的内容，将其转换为 IoC 容器内部的数据结构：BeanDefinition。</p><p><img src="/images/Spring%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0_2020-04-26-14-41-44.png" alt="Spring——概述_2020-04-26-14-41-44.png"></p><h2 id="SpringApplicationContext"><a href="#SpringApplicationContext" class="headerlink" title="SpringApplicationContext"></a>SpringApplicationContext</h2><p>ApplicationContext 是个 Spring 容器，也叫做应用上下文。它继承  BeanFactory，同时也是  BeanFactory 的扩展升级版。</p><p>由于 ApplicationContext 的结构就决定了它与 BeanFactory 的不同，其主要区别有： </p><ol><li>继承 MessageSource ，提供国际化的标准访问策略；</li><li>继承 ApplicationEventPublisher，提供强大的事件机制；</li><li>扩展 ResourceLoader，可以用来加载多个 Resource，可以灵活访问不同的资源；</li><li>对 Web 应用的支持。</li></ol><p><img src="/images/Spring%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0_2020-04-26-14-43-04.png" alt="Spring——概述_2020-04-26-14-43-04.png"></p><p><img src="/images/Spring%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0_2020-04-26-14-43-17.png" alt="Spring——概述_2020-04-26-14-43-17.png"></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring 概述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM——永久代到元空間</title>
      <link href="/2020/04/08/JVM%E2%80%94%E2%80%94%E6%B0%B8%E4%B9%85%E4%BB%A3%E5%88%B0%E5%85%83%E7%A9%BA%E9%96%93/"/>
      <url>/2020/04/08/JVM%E2%80%94%E2%80%94%E6%B0%B8%E4%B9%85%E4%BB%A3%E5%88%B0%E5%85%83%E7%A9%BA%E9%96%93/</url>
      
        <content type="html"><![CDATA[<h1 id="java6-gt-java7-gt-java8的内存結構的演變"><a href="#java6-gt-java7-gt-java8的内存結構的演變" class="headerlink" title="java6-&gt;java7-&gt;java8的内存結構的演變"></a>java6-&gt;java7-&gt;java8的内存結構的演變</h1><p><img src="/images/JVM%E2%80%94%E2%80%94java8%E6%B0%B8%E4%B9%85%E4%BB%A3%E5%88%B0%E5%85%83%E7%A9%BA%E9%96%93_2020-04-08-14-58-49.png" alt="JVM——java8永久代到元空間_2020-04-08-14-58-49.png"></p><p><img src="/images/JVM%E2%80%94%E2%80%94java8%E6%B0%B8%E4%B9%85%E4%BB%A3%E5%88%B0%E5%85%83%E7%A9%BA%E9%96%93_2020-04-08-14-59-13.png" alt="JVM——java8永久代到元空間_2020-04-08-14-59-13.png"></p><p><img src="/images/JVM%E2%80%94%E2%80%94java8%E6%B0%B8%E4%B9%85%E4%BB%A3%E5%88%B0%E5%85%83%E7%A9%BA%E9%96%93_2020-04-08-14-59-26.png" alt="JVM——java8永久代到元空間_2020-04-08-14-59-26.png"></p><p>在java7及以前，物理上来说，它们是连续的一块内存，逻辑上依旧是分开的。对于习惯了在HotSpot虚拟机上开发、部署的程序员来说，很多都愿意将方法区称作永久代。</p><p>Java7中永久代中存储的部分数据已经开始转移到堆或本地方法區中了。比如，符号引用转移到了本地方法區；字符串常量池转移到了堆；类的静态变量转移到了堆。</p><p>java8中Hotspot取消了永久代，永久代的参数 <code>-XX:PermSize</code> 和<code>-XX：MaxPermSize</code> 也随之失效。在Java8中，元空间登上舞台，方法区存在于元空间。同时，元空间不再与堆连续，而且是存在于本地内存。</p><h1 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h1><p>元空间存在于本地内存，意味着只要本地内存足够，它不会出现像永久代中“java.lang.OutOfMemoryError: PermGen space”这种错误。看上图中的方法区，是不是“膨胀”了。</p><p><img src="/images/JVM%E2%80%94%E2%80%94java8%E6%B0%B8%E4%B9%85%E4%BB%A3%E5%88%B0%E5%85%83%E7%A9%BA%E9%96%93_2020-04-08-15-08-44.png" alt="JVM——java8永久代到元空間_2020-04-08-15-08-44.png"></p><p>本地内存，也称为 C-Heap，是供JVM自身进程使用的。当Java Heap空间不足时会触发GC，但Native memory空间不够却不会触发GC。</p><p>默认情况下元空间是可以无限使用本地内存的，但为了不让它如此膨胀，JVM同样提供了参数来限制它使用的使用。</p><ul><li><code>-XX:MetaspaceSize</code>，class metadata的初始空间配额，以bytes为单位，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当的降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize（如果设置了的话），适当的提高该值。</li><li><code>-XX：MaxMetaspaceSize</code>，可以为class metadata分配的最大空间。默认是没有限制的。</li><li><code>-XX：MinMetaspaceFreeRatio</code>,在GC之后，最小的Metaspace剩余空间容量的百分比，减少为class metadata分配空间导致的垃圾收集。</li><li><code>-XX:MaxMetaspaceFreeRatio</code>,在GC之后，最大的Metaspace剩余空间容量的百分比，减少为class metadata释放空间导致的垃圾收集。</li></ul><h1 id="永久代为什么被替换了"><a href="#永久代为什么被替换了" class="headerlink" title="永久代为什么被替换了"></a>永久代为什么被替换了</h1><ul><li>字符串存在永久代中，容易出现性能问题和内存溢出</li><li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出</li><li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低</li><li>将 HotSpot 与 JRockit 合二为一</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM——GC分析</title>
      <link href="/2020/04/07/JVM%E2%80%94%E2%80%94GC%E5%88%86%E6%9E%90/"/>
      <url>/2020/04/07/JVM%E2%80%94%E2%80%94GC%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="GC-的概念"><a href="#GC-的概念" class="headerlink" title="GC 的概念"></a>GC 的概念</h1><p>GC是java语言的垃圾回收机制，一般不需要专门编写内存回收和垃圾清理代码，对内存泄露和溢出的问题，也不需要像C程序员那样战战兢兢。这是因为在Java虚拟机中，存在自动内存管理和垃圾清扫机制。</p><p>概括地说，该机制对JVM（Java Virtual Machine）中的内存进行标记，并确定哪些内存需要回收，根据一定的回收策略，自动的回收内存，永不停息（Nerver Stop）的保证JVM中的内存空间，防止出现内存泄露和溢出问题。</p><p>GC主要有 YoungGC，OldGC，FullGC。（还有G1中独有的Mixed GC，收集整个young区以及部分Old区）</p><ul><li>YoungGC：回收Eden区，有些地方称之为Minor GC，或者简称YGC</li><li>OldGC：回收Old区，只单独回收Old区的只有CMS GC，且是CMS的concurrent collection模式。</li><li>FullGC：收集整个GC堆，也称之为Major GC。</li></ul><p>注：如果配置了CMS垃圾回收器，那么jstat中的FGC并不表示就一定发生了FullGC，很有可能是发生了CMS GC，而且每发生一次CMS GC，jstat中的FGC就会+2**。</p><h1 id="FullGC-触发条件"><a href="#FullGC-触发条件" class="headerlink" title="FullGC 触发条件"></a>FullGC 触发条件</h1><ol><li>没有配置 -XX:+DisableExplicitGC的情况下System.gc()会触发FullGC;</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>执行jmap histo : live 或 jmap -dump ：live；</li></ol><p>注：统计发现之前YGC的平均晋升大小比目前old gen剩余的空间大，触发CMS GC；Metaspace Space使用达到Metaspace阈值是触发CMS GC；</p><h1 id="健康的-GC"><a href="#健康的-GC" class="headerlink" title="健康的 GC"></a>健康的 GC</h1><p>无论是定位YoungGC，OldGC，FullGC哪一种GC，判断其是否正常主要从两个维度：GC频率和STW时间；<br>要得到这两个维度的值，我们需要知道JVM运行了多久，执行如下命令即可：</p><p><code>ps -p pid -o etime</code></p><p>可参考的健康的GC状况:</p><ol><li>YoungGC频率5秒/次；</li><li>CMS GC频率不超过1天/次；</li><li>每次YoungGC的时间不超过30ms；</li><li>FullGC频率尽可能完全杜绝；</li></ol><p>G1&amp;CMS时，FullGC回收算法会退化成Serial+SerialOld，即单线程串行回收，且完全STW，影响很大且STW时间完全不可预估，所以FullGC频率尽可能完全杜绝。</p><h1 id="如何获取-GC-日志"><a href="#如何获取-GC-日志" class="headerlink" title="如何获取 GC 日志"></a>如何获取 GC 日志</h1><p>一般情况可以通过两种方式来获取GC日志，一种是使用命令动态查看，一种是在容器中设置相关参数打印GC日志。</p><h2 id="命令动态查看"><a href="#命令动态查看" class="headerlink" title="命令动态查看"></a>命令动态查看</h2><p><code>jstat-gc</code> 统计垃圾回收堆的行为</p><p><img src="/images/JVM%E2%80%94%E2%80%94GC%E5%88%86%E6%9E%90_2020-04-07-16-45-35.png" alt="JVM——GC分析_2020-04-07-16-45-35.png"></p><p>也可以设置间隔固定时间来打印：</p><p><code>jstat -gc 1262 2000 20</code></p><p>这个命令意思就是每隔2000ms输出1262的gc情况，一共输出20次。</p><p>更多详细内容请参考这篇文章：<a href="/2020/04/01/JVM%E2%80%94%E2%80%94%E5%91%BD%E4%BB%A4%E8%B0%83%E4%BC%98/" title="JVM——命令调优">JVM——命令调优</a></p><h2 id="GC-参数"><a href="#GC-参数" class="headerlink" title="GC 参数"></a>GC 参数</h2><ul><li>-XX:+PrintGC 输出GC日志</li><li>-XX:+PrintGCDetails 输出GC的详细日志</li><li>-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）</li><li>-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2017-09-04T21:53:59.234+0800）</li><li>-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息</li><li>-Xloggc:../logs/gc.log 日志文件的输出路径</li></ul><h2 id="Tomcat设置"><a href="#Tomcat设置" class="headerlink" title="Tomcat设置"></a>Tomcat设置</h2><p>我们经常在tomcat的启动参数中添加JVM相关参数，这里有一个典型的示例：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">JAVA_OPTS</span>=<span class="string">"-server -Xms2000m -Xmx2000m -Xmn800m -XX:PermSize=64m -XX:MaxPermSize=256m -XX:SurvivorRatio=4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">-verbose</span>:<span class="string">gc -Xloggc:$CATALINA_HOME/logs/gc.log </span></span><br><span class="line"></span><br><span class="line"><span class="meta">-Djava.awt.headless</span>=<span class="string">true </span></span><br><span class="line"></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">+PrintGCTimeStamps -XX:+PrintGCDetails </span></span><br><span class="line"></span><br><span class="line"><span class="meta">-Dsun.rmi.dgc.server.gcInterval</span>=<span class="string">600000 -Dsun.rmi.dgc.client.gcInterval=600000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">+UseConcMarkSweepGC -XX:MaxTenuringThreshold=15"</span></span><br></pre></td></tr></table></figure><p><code>-verbose:gc-Xloggc:$CATALINA_HOME/logs/gc.log</code></p><p>将虚拟机每次垃圾回收的信息写到日志文件中，文件名由file指定，文件格式是平文件，内容和-verbose:gc输出内容相同。</p><p><code>-Djava.awt.headless=true Headless</code></p><p>模式是系统的一种配置模式。在该模式下，系统缺少了显示设备、键盘或鼠标。</p><p><code>-XX:+PrintGCTimeStamps-XX:+PrintGCDetails</code></p><p>设置gc日志的格式</p><p><code>-Dsun.rmi.dgc.server.gcInterval=600000-Dsun.rmi.dgc.client.gcInterval=600000</code></p><p>指定rmi调用时gc的时间间隔</p><h1 id="GC日志分析工具"><a href="#GC日志分析工具" class="headerlink" title="GC日志分析工具"></a>GC日志分析工具</h1><p>GChisto GC Easy 詳細請訪問：<a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247483986&idx=1&sn=a2d7c9f2e73dfcc938a3ec934b3ad3a4&chksm=ebf6da2ddc81533beb5e6fb54c872b5f79524d0780c484718a57ca0712916cd67bda7dee4073&scene=21#wechat_redirect" target="_blank" rel="noopener">Java GC 分析</a></p><h1 id="如何减少GC出现的次数"><a href="#如何减少GC出现的次数" class="headerlink" title="如何减少GC出现的次数"></a>如何减少GC出现的次数</h1><ol><li>对象不用时显示置null。</li><li>少用System.gc()。</li><li>尽量少用静态变量。</li><li>尽量使用StringBuffer，而不用String累加字符串。</li><li>分散对象创建或删除的时间。</li><li>少用finalize函数。</li><li>如果需要使用经常用到的图片，可以使用软引用类型，它可以尽可能将图片保存在内存中，供程序调用，而不引起OOM。</li><li>能用基本类型就不用基本类型封装类。</li><li>增大-Xmx的值。</li></ol><p>在生产环境中，根据需要配置相应的参数来监控JVM运行情况。</p><h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247484042&idx=1&sn=51d2ed451151be872b601007597dd47f&chksm=ebf6daf5dc8153e3a7cb88ca97621cfae5aeaaeec0a1ff63e16278fbea6a43457e50a7fc9f0b&scene=21#wechat_redirect" target="_blank" rel="noopener">如何优化Java GC</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247484071&idx=1&sn=84604a51fd18b91f73c46507c182540a&chksm=ebf6dad8dc8153cebb029372c0745a3c6570e527e1f95cee2fb9fb33c50d46c64f20722a3d96&scene=21#wechat_redirect" target="_blank" rel="noopener">教你如何成为Java的OOM Killer</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm GC分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM——命令调优</title>
      <link href="/2020/04/01/JVM%E2%80%94%E2%80%94%E5%91%BD%E4%BB%A4%E8%B0%83%E4%BC%98/"/>
      <url>/2020/04/01/JVM%E2%80%94%E2%80%94%E5%91%BD%E4%BB%A4%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>运用jvm自带的命令可以方便的在生产监控和打印堆栈的日志信息帮忙我们来定位问题！</p><p>jvm调优成熟的工具已经有很多：<code>jconsole</code>、大名鼎鼎的<code>VisualVM</code>，IBM的 <code>Memory Analyzer</code> 等等。</p><p>但是在生产环境出现问题的时候，一方面工具的使用会有所限制。</p><p>所有的工具几乎都是依赖于jdk的接口和底层的这些命令，研究这些命令的使用也让我们更能了解jvm构成和特性。</p><h1 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h1><p>显示指定系统内所有的HotSpot虚拟机进程。</p><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>jps [option] [hostid]</code></p><h2 id="option-参数"><a href="#option-参数" class="headerlink" title="option 参数"></a>option 参数</h2><ul><li>-l : 输出主类全名或jar路径</li><li>-q : 只输出LVMID</li><li>-m : 输出JVM启动时传递给main()的参数</li><li>-v : 输出JVM启动时显示指定的JVM参数</li></ul><h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><p><img src="/images/JVM%E2%80%94%E2%80%94%E5%91%BD%E4%BB%A4%E8%B0%83%E4%BC%98_2020-04-07-17-16-11.png" alt="JVM——命令调优_2020-04-07-17-16-11.png"></p><h1 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h1><p>监视虚拟机运行时状态信息，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p><h2 id="命令格式-1"><a href="#命令格式-1" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>jstat [option] LVMID [interval] [count]</code></p><ul><li>[option] : 操作参数</li><li>LVMID : 本地虚拟机进程ID</li><li>[interval] : 连续输出的时间间隔</li><li>[count] : 连续输出的次数</li></ul><h2 id="option-参数-1"><a href="#option-参数-1" class="headerlink" title="option 参数"></a>option 参数</h2><p><img src="/images/JVM%E2%80%94%E2%80%94%E5%91%BD%E4%BB%A4%E8%B0%83%E4%BC%98_2020-04-08-13-23-05.png" alt="JVM——命令调优_2020-04-08-13-23-05.png"></p><h2 id="例-1"><a href="#例-1" class="headerlink" title="例"></a>例</h2><p><img src="/images/JVM%E2%80%94%E2%80%94%E5%91%BD%E4%BB%A4%E8%B0%83%E4%BC%98_2020-04-08-13-26-19.png" alt="JVM——命令调优_2020-04-08-13-26-19.png"></p><h1 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h1><p>用于生成heap dump文件,还阔以查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。</p><h2 id="命令格式-2"><a href="#命令格式-2" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>jmap [option] LVMID</code></p><h2 id="option-参数-2"><a href="#option-参数-2" class="headerlink" title="option 参数"></a>option 参数</h2><ul><li>dump : 生成堆转储快照</li><li>finalizerinfo : 显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象</li><li>heap : 显示Java堆详细信息</li><li>histo : 显示堆中对象的统计信息</li><li>permstat : to print permanent generation statistics</li><li>F : 当-dump没有响应时，强制生成dump快照</li></ul><h2 id="例-2"><a href="#例-2" class="headerlink" title="例"></a>例</h2><p><img src="/images/JVM%E2%80%94%E2%80%94%E5%91%BD%E4%BB%A4%E8%B0%83%E4%BC%98_2020-04-08-13-37-36.png" alt="JVM——命令调优_2020-04-08-13-37-36.png"></p><p><img src="/images/JVM%E2%80%94%E2%80%94%E5%91%BD%E4%BB%A4%E8%B0%83%E4%BC%98_2020-04-08-13-40-58.png" alt="JVM——命令调优_2020-04-08-13-40-58.png"></p><p><img src="/images/JVM%E2%80%94%E2%80%94%E5%91%BD%E4%BB%A4%E8%B0%83%E4%BC%98_2020-04-08-14-07-54.png" alt="JVM——命令调优_2020-04-08-14-07-54.png"></p><h1 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h1><p>与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看。</p><h2 id="命令格式-3"><a href="#命令格式-3" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>jhat [dumpfile]</code></p><h2 id="例-3"><a href="#例-3" class="headerlink" title="例"></a>例</h2><p><img src="/images/JVM%E2%80%94%E2%80%94%E5%91%BD%E4%BB%A4%E8%B0%83%E4%BC%98_2020-04-08-13-52-57.png" alt="JVM——命令调优_2020-04-08-13-52-57.png"></p><h1 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h1><p>用于生成java虚拟机当前时刻的线程快照。</p><h2 id="命令格式-4"><a href="#命令格式-4" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>jstack [option] LVMID</code></p><h2 id="option-参数-3"><a href="#option-参数-3" class="headerlink" title="option 参数"></a>option 参数</h2><ul><li>-F : 当正常输出请求不被响应时，强制输出线程堆栈</li><li>-l : 除堆栈外，显示关于锁的附加信息</li><li>-m : 如果调用到本地方法的话，可以显示C/C++的堆栈</li></ul><h2 id="例-4"><a href="#例-4" class="headerlink" title="例"></a>例</h2><p><img src="/images/JVM%E2%80%94%E2%80%94%E5%91%BD%E4%BB%A4%E8%B0%83%E4%BC%98_2020-04-08-13-56-46.png" alt="JVM——命令调优_2020-04-08-13-56-46.png"></p><h1 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h1><p>实时查看和调整虚拟机运行参数。 </p><p>之前的jps -v口令只能查看到显示指定的参数，如果想要查看未被显示指定的参数的值就要使用jinfo口令</p><h2 id="命令格式-5"><a href="#命令格式-5" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>jinfo [option] [args] LVMID</code></p><h2 id="option参数"><a href="#option参数" class="headerlink" title="option参数"></a>option参数</h2><ul><li>-flag : 输出指定args参数的值</li><li>-flags : 不需要args参数，输出所有JVM参数的值</li><li>-sysprops : 输出系统属性，等同于System.getProperties()</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>$ jinfo -flag 11494</p></blockquote><blockquote><p>-XX:CMSInitiatingOccupancyFraction=80</p></blockquote><h1 id="调优工具"><a href="#调优工具" class="headerlink" title="调优工具"></a>调优工具</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247484023&idx=1&sn=39be119fdf3132240adc84a85bf8a054&chksm=ebf6da08dc81531e3719389555150f2d0237554b6b6c07a123efdea7c78c0ae2f064cc577bd4&scene=21#wechat_redirect" target="_blank" rel="noopener">jvm调优-工具篇</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm 命令调优 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM——垃圾回收算法</title>
      <link href="/2020/04/01/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
      <url>/2020/04/01/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>垃圾回收主要集中于堆与方法区中，在程序运行期间，这部分内存的分配和使用都是动态的。</p><h1 id="对象存活判断"><a href="#对象存活判断" class="headerlink" title="对象存活判断"></a>对象存活判断</h1><p>要对对象进行垃圾回收，首先要判断对象是否存活，一般有两种方式：</p><ol><li>引用计数法</li></ol><p>每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。</p><p>此方法简单，确无法解决对象相互循环引用的问题。</p><ol start="2"><li>可达性分析</li></ol><p>从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。</p><p>在Java语言中，GC Roots包括：</p><ul><li>虚拟机栈中引用的对象。</li><li>方法区中 类静态属性实体 引用的对象。</li><li>方法区中 常量 引用的对象。</li><li>本地方法栈中JNI引用的对象。</li></ul><h1 id="finalize-二次标记"><a href="#finalize-二次标记" class="headerlink" title="finalize()二次标记"></a>finalize()二次标记</h1><p>一个对象是否应该在垃圾回收器在GC时回收，至少要经历两次标记过程。</p><ol><li><p>通过可达性分析算法分析对象是否与GC Roots可达。经过第一次标记，并且被筛选为不可达的对象会进行第二次标记。</p></li><li><p>判断不可达对象是否有必要执行finalize方法。执行条件是当前对象的finalize方法被重写，并且还未被系统调用过。如果允许执行那么这个对象将会被放到一个叫F-Query的队列中，等待被执行。</p></li></ol><p>注：由于finalize由一个优先级比较低的Finalizer线程运行，所以该对象的的finalize方法不一定被执行，即使被执行了，也不保证finalize方法一定会执行完。</p><h1 id="对象引用分类"><a href="#对象引用分类" class="headerlink" title="对象引用分类"></a>对象引用分类</h1><p>一个对象在这种定义下只有“被引用”或者“未被引用”两种状态，对于描述一些“食之无味，弃之可惜”的对象就显得无能为力。譬如我们希望能描述一类对象：当内存空间还足够时，能保留在内存之中，如果内存空间在进行垃圾收集后仍然非常紧张，那就可以抛弃这些对象。</p><p>Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用和虚引用4种，这4种引用强度依次逐渐减弱。</p><ol><li>强引用</li></ol><p>在代码中普遍存在的，类似Object obj = new Object()这类引用;</p><p>只要强引用还在，垃圾收集器永远不会回收掉被引用的对象。</p><ol start="2"><li>软引用</li></ol><p>有用但并非必需的对象，可用 SoftReference 类来实现软引用。</p><p>在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。</p><ol start="3"><li>弱引用</li></ol><p>非必需的对象，但它的强度比软引用更弱，被弱引用关联的对象只能生存到下一次垃圾收集发生之前，JDK提供了 WeakReference 类来实现弱引用。</p><p>无论当前内存是否足够，用软引用相关联的对象都会被回收掉。</p><ol start="4"><li>虚引用</li></ol><p>虚引用也称为幽灵引用或幻影引用，是最弱的一种引用关系，JDK提供了 PhantomReference 类来实现虚引用。</p><p>为一个对象设置虚引用的唯一目的是：能在这个对象在垃圾回收器回收时收到一个系统通知。</p><h1 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h1><p>方法区垃圾收集的“性价比”通常也是比较低的：在Java堆中，尤其是在新生代中，对常规应用进行一次垃圾收集通常可以回收70%至99%的内存空间，相比之下，方法区回收囿于苛刻的判定条件，其区域垃圾收集的回收成果往往远低于此。</p><p>方法区的垃圾收集主要回收两部分内容：废弃的常量与符号引用和不再使用的类型。</p><p>如果已经没有任何字符串对象引用常量池中的常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且垃圾收集器判断确有必要的话，这个常量就将会被系统清理出常量池。常量池中其他类（接口）、方法、字段的符号引用也与此类似。</p><p>而要判定一个类型是否属于“不再被使用的类型”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</li><li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如<br>OSGi、JSP的重加载等，否则通常是很难达成的。</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方<br>法。</li></ul><p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。</p><p>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p><h1 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h1><h2 id="分代假说"><a href="#分代假说" class="headerlink" title="分代假说"></a>分代假说</h2><p>当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”（Generational Collection）[1]的理论进行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上：</p><ul><li>弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。</li><li>强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消<br>亡。</li></ul><p>这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将Java堆划分<br>出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区<br>域之中存储。</p><p>显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那<br>么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对<br>象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块，<br>虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有<br>效利用。</p><p>在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域<br>——因而才有了“Minor GC”“Major GC”“Full GC”这样的回收类型的划分；也才能够针对不同的区域安<br>排与里面存储对象存亡特征相匹配的垃圾收集算法——因而发展出了“标记-复制算法”“标记-清除算<br>法”“标记-整理算法”等针对性的垃圾收集算法。</p><h2 id="跨代引用假说"><a href="#跨代引用假说" class="headerlink" title="跨代引用假说"></a>跨代引用假说</h2><p>分代收集并非只是简单划分一下内存区域那么容易，它至少存在一个明显的困难：对象不<br>是孤立的，对象之间会存在跨代引用。</p><p>假如要现在进行一次只局限于新生代区域内的收集（Minor GC），但新生代中的对象是完全有可<br>能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整<br>个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样[3]。遍历整个老年代所有对象<br>的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担。为了解决这个问题，就需要对分<br>代收集理论添加第三条经验法则：</p><p>跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极<br>少数。</p><p>举个例子，如果某个新生代对象存在跨代引用，由于老年代对象难以<br>消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时<br>跨代引用也随即被消除了。</p><p>依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录<br>每一个对象是否存在及存在哪些跨代引用，只需在老年代上建立一个全局的数据结构（该结构被称<br>为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会<br>存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC<br>Roots进行扫描。</p><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h2 id="标记清楚算法"><a href="#标记清楚算法" class="headerlink" title="标记清楚算法"></a>标记清楚算法</h2><p><img src="/images/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_2020-04-07-10-08-14.png" alt="JVM——垃圾回收_2020-04-07-10-08-14.png"></p><p>原理：</p><p>首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。</p><p>它是最基础的收集算法，因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。</p><p>优点：</p><p>实现简单，对象不需要移动。</p><p>缺点：</p><ul><li>效率问题，标记和清除过程的效率都不高</li><li>空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ul><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p><img src="/images/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_2020-04-07-10-08-36.png" alt="JVM——垃圾回收_2020-04-07-10-08-36.png"></p><p>原理：</p><p>它将内存区域划分成相同的两个内存块。每次仅使用一半的空间，JVM生成的新对象放在一半空间中。当一半空间用完时进行GC，把可到达对象复制到另一半空间，然后把使用过的内存空间一次清理掉。</p><p>优点：</p><p>这种收集算法解决了标记清除算法存在的效率问题。</p><p>按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。</p><p>缺点：</p><p>可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。</p><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p><img src="/images/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_2020-04-07-10-13-55.png" alt="JVM——垃圾回收_2020-04-07-10-13-55.png"></p><p>原理：</p><p>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p>优点：</p><p>解决了标记-清理算法存在的内存碎片问题。</p><p>缺点：</p><p>仍需要进行局部对象移动，一定程度上降低了效率。</p><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>原理：</p><p>分代收集算法，顾名思义是根据对象的存活周期将内存划分为几块。一般包括年轻代、老年代 和 永久代，如图所示：</p><p><img src="/images/JVM%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_2020-04-07-10-16-04.png" alt="JVM——垃圾回收_2020-04-07-10-16-04.png"></p><ol><li>年轻代</li></ol><p>对象被创建时，内存的分配首先发生在年轻代（大对象可以直接被创建在年老代），大部分的对象在创建后很快就不再使用，因此很快变得不可达，于是被年轻代的GC机制清理掉，这个GC机制被称为 Minor GC 或 Young GC。</p><p>年轻代上的内存分配是这样的，年轻代可以分为3个区域：Eden区和两个存活区（Survivor 0 、Survivor 1）。</p><p>内存分配过程为：</p><p>绝大多数刚创建的对象会被分配在Eden区，其中的大多数对象很快就会消亡。Eden区是连续的内存空间，因此在其上分配内存极快；</p><p>当Eden区满的时候，执行Minor GC，将消亡的对象清理掉，并将剩余的对象复制到一个存活区Survivor0（此时，Survivor1是空白的，两个Survivor总有一个是空白的）。</p><p>此后，每次Eden区满了，就执行一次Minor GC，并将剩余的对象都添加到Survivor0；当Survivor0也满的时候，将其中仍然活着的对象直接复制到Survivor1，以后Eden区执行Minor GC后，就将剩余的对象添加Survivor1（此时，Survivor0是空白的）。</p><p>当两个存活区切换了几次仍然存活的对象（其实只有一小部分，比如，我们自己定义的对象），将被复制到老年代。</p><p>总结：</p><p>Eden区是连续的空间，且Survivor总有一个为空。经过一次GC和复制，一个Survivor中保存着当前还活 着的对象，而Eden区和另一个Survivor区的内容都不再需要了，可以直接清空，到下一次GC时，两个Survivor的角色再互换。因此，这种方 式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是复制算法（将Eden区和一个Survivor中仍然存活的对象拷贝到另一个Survivor中）。</p><ol start="2"><li>老年代</li></ol><p>对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次 Young GC后存活了下来），则会被复制到年老代。</p><p>年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。当年老代内存不足时， 将执行Major GC，也叫 Full GC。　　</p><p>可以使用 <code>-XX:+UseAdaptiveSizePolicy</code> 开关来控制是否采用动态控制策略，如果动态控制，则动态调整Java堆中各个区域的大小以及进入老年代的年龄。</p><p>如果对象比较大（比如长字符串或大数组），Young空间不足，则大对象会直接分配到老年代上（大对象可能触发提前GC，应少用，更应避免使用短命的大对象）。</p><p>用 <code>-XX:PretenureSizeThreshold</code> 来控制直接升入老年代的对象大小，大于这个值的对象会直接分配在老年代上。</p><p>可能存在年老代对象引用新生代对象的情况，如果需要执行Young GC，则可能需要查询整个老年代以确定是否可以清理回收，这显然是低效的。</p><p>解决的方法是，年老代中维护一个512 byte的块——”card table“，所有老年代对象引用新生代对象的记录都记录在这里。Young GC时，只要查这里即可，不用再去查全部老年代，因此性能大大提高。</p><ol start="3"><li>永久代</li></ol><p>永久代的回收有两种：常量池中的常量，无用的类信息，常量的回收很简单，没有引用了就可以被回收。</p><p>永久代的回收并不是必须的，可以通过参数来设置是否对类进行回收。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm 垃圾回收算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM——类的加载机制</title>
      <link href="/2020/04/01/JVM%E2%80%94%E2%80%94%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/04/01/JVM%E2%80%94%E2%80%94%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是类加载"><a href="#什么是类加载" class="headerlink" title="什么是类加载"></a>什么是类加载</h1><p>通过类加载器，将已经编译为.class格式的文件加载进内存，而其中类型的加载、连接和初始化过程都是在程序运行阶段运行的，这些会对提前编译造成困难和工作量，确为java应用提供了极高的扩展性和灵活性。</p><h1 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h1><ul><li>使用new关键字实例化对象的时候。</li><li>读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）<br>的时候。</li><li>调用一个类型的静态方法的时候。</li><li>反射</li><li>初始化时，有父类要先初始化父类</li><li>执行main方法</li><li>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有<br>这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li></ul><h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><p><img src="/images/JVM%E2%80%94%E2%80%94%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6_2020-04-03-14-26-42.png" alt="JVM——类的加载机制_2020-04-03-14-26-42.png"></p><p>其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。</p><p>在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持 Java 语言的运行时绑定（例如多态）。</p><p>另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入<br>口。</li></ul><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚<br>拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p><ul><li>文件格式验证</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ul><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverifynone 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段，按照逻辑上来讲，这些变量都会在方法区中分配内存，JDK8之后，类变量也随着类变量储存在堆中。</p><p>初始值通常为数据类型的零值，而把实际值赋给变量的操作要到类加载的初始化（clinit）阶段才会进行。</p><p>也会存在特殊情况，如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值，如类变量被final修饰。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>class对象中符号引用转换为直接引用的过程。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序。</p><p>初始化阶段就是执行类构造器<clinit>()方法的过程。<clinit>()并不是程序员在Java代码中直接编写的方法，它是Javac编译器的自动生成物。主要为静态变量和静态代码块进行初始化，赋予程序值。</p><h2 id="结束生命周期"><a href="#结束生命周期" class="headerlink" title="结束生命周期"></a>结束生命周期</h2><ul><li>执行了 System.exit()方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致 Java 虚拟机进程终止</li></ul><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p><img src="/images/JVM%E2%80%94%E2%80%94%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6_2020-04-03-15-14-55.png" alt="JVM——类的加载机制_2020-04-03-15-14-55.png"></p><ol><li><p>启动类加载器</p><p> <code>BootstrapClassLoader</code>，负责加载存放在 <code>JDK\jre\lib</code> (JDK 代表 JDK 的安装目录，下同)下，或被 <code>-Xbootclasspath</code> 参数指定的路径中的，并且能被虚拟机识别的类库（如 rt.jar，所有的 java.开头的类均被 <code>BootstrapClassLoader</code>加载）。</p><p> 启动类加载器是无法被 Java 程序直接引用的。</p></li><li><p>扩展类加载器</p><p> <code>ExtensionClassLoader</code>，该加载器由 <code>sun.misc.Launcher\$ExtClassLoader</code> 实现，它负责加载 <code>JDK\jre\lib\ext</code> 目录中，或者由 <code>java.ext.dirs</code> 系统变量指定的路径中的所有类库（如 javax.开头的类）。</p><p> 开发者可以直接使用扩展类加载器。</p></li><li><p>应用类加载器</p><p> <code>ApplicationClassLoader</code>，该类加载器由 <code>sun.misc.Launcher$AppClassLoader</code> 来实现，它负责加载用户类路径（ClassPath）所指定的类。</p><p> 开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p></li><li><p>自定义类加载器</p><p> 应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。</p><p> 因为 JVM 自带的 ClassLoader 只是懂得从本地文件系统加载标准的 java class 文件，因此如果编写了自己的 ClassLoader，便可以做到如下几点：</p><ul><li><p>在执行非置信代码之前，自动验证数字签名。</p></li><li><p>动态地创建符合用户特定需要的定制化构建类。</p></li><li><p>从特定的场所取得 java class，例如数据库中和网络中。</p></li></ul></li></ol><h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><ol><li>全盘负责<br>当一个类加载器负责加某个 Class 时，该 Class 所依赖的和引用的其他 Class 也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。</li><li>父类委托/双亲委派<br>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。系统类防止内存中出现多份同样的字节码</li><li>缓存机制<br>缓存机制将会保证所有加载过的 Class 都会被缓存，当程序中需要使用某个 Class 时，类加载器先从缓存区寻找该 Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成 Class 对象，存入缓存区。这就是为什么修改了 Class 后，必须重启 JVM，程序的修改才会生效。</li></ol><h1 id="类加载方式"><a href="#类加载方式" class="headerlink" title="类加载方式"></a>类加载方式</h1><p>类加载有三种方式：</p><ol><li>命令行启动应用时候由 JVM 初始化加载。</li><li>通过 Class.forName()方法动态加载。</li><li>通过 ClassLoader.loadClass()方法动态加载。</li></ol><p>Class.forName()和 ClassLoader.loadClass()区别：</p><ul><li><code>Class.forName()</code>：将类的.class 文件加载到 jvm 中之外，还会对类进行解释，执行类中的 static 块；</li><li><code>ClassLoader.loadClass()</code>：只干一件事情，就是将.class 文件加载到 jvm 中，不会执行 static 中的内容,只有在 newInstance 才会去执行 static 块。</li><li><code>Class.forName(name,initialize,loader)</code> 带参函数也可控制是否加载 static 块。并且只有调用了 newInstance()方法采用调用构造函数，创建类的对象 。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm 类加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM——内存结构</title>
      <link href="/2020/04/01/JVM%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
      <url>/2020/04/01/JVM%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这里主要介绍一下 <code>JVM</code> 在启动后，作为操作系统的一个进程的基本结构，以及从操作系统角度看，<code>JVM</code> 如何管理它从操作系统里申请来的内存的，也就是 <code>JVM</code> 的内存结构或者叫 <code>JVM</code> 内存模型。</p><p>根据 JVM 规范，JVM 把内存划分成了如下几个区域：</p><ol><li>堆区（Heap）</li><li>方法区（Method Area）</li><li>虚拟机栈（VM Stack）</li><li>本地方法栈（Native Method Stack）</li><li>程序计数器（Program Counter Register）</li></ol><p>根据线程安全策略，又分为线程私有和共享区域。</p><p><img src="/images/JVM%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84_2020-04-01-14-35-50.png" alt="JVM——内存结构_2020-04-01-14-35-50.png"></p><h1 id="线程私有区域"><a href="#线程私有区域" class="headerlink" title="线程私有区域"></a>线程私有区域</h1><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</p><p>在Java虚拟机的概念模型里[1]，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。</p><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧[1]（Stack Frame）用于存储 局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><ol><li><p>局部变量表</p><p> 存放了编译期可知的各种Java虚拟机基本数据类型、对象引用和returnAddress类型（指向了一条字节码指令的地址）。</p><p> 这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。（这种说法不一定准确，操作系统如果是64位，槽的大小也会是64位长度）</p><p> 局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p></li><li><p>操作数栈</p><p> 也被称为操作栈，它是一个后入先出栈。同局部变量表一样，操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项之中。操作数栈的每一个元素都可以是包括long和double在内的任意Java数据类型。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。Javac编译器的数据流分析工作保证了在方法执行的任何时候，操作数栈的深度都不会超过在max_stacks数据项中设定的最大值。</p></li><li><p>动态链接</p><p> 每个栈帧都包含一个指向运行时常量池[1]中该栈帧所属方法的引用，持有这个引用是为了支持方法调用。我们知道Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析。另外一部分将在每一次运行期间都转化为直接引用，这部分就称为动态连接。</p></li><li><p>返回地址</p><p> 当一个方法开始执行后，只有两种方式退出这个方法。</p><p> 第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者或者主调方法），方法是否有返回值以及返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为“正常调用完成”（Normal Method Invocation Completion）。</p><p> 另外一种退出方式是在方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处理。</p></li></ol><h1 id="线程共享区域"><a href="#线程共享区域" class="headerlink" title="线程共享区域"></a>线程共享区域</h1><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java世界里“几乎”所有的对象实例都在这里分配内存。堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区又称非堆，类加载之后生成的class对象会存储在这个位置，它用于存储已被虚拟机加载的类信息（字段、方法、接口等）、常量、静态变量、即时编译器编译后的代码等数据。</p><p>对于习惯在 HotSpot 虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为 HotSpot 虚拟机的设计团队选择把 GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而已。</p><p>到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。</p><p>运行时常量池是方法区的一部分，.class文件经过编译，会生成本地常量池，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。其中符号引用会被解析成直接引用。</p><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的 Native 方法服务。</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中<br>定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所<br>以我们放到这里一起讲解。</p><p>在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区<br>（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面<br>的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免<br>了在Java堆和Native堆中来回复制数据。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm 内存结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM——学习导读</title>
      <link href="/2020/04/01/JVM%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AF%BB/"/>
      <url>/2020/04/01/JVM%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-JVM"><a href="#什么是-JVM" class="headerlink" title="什么是 JVM?"></a>什么是 JVM?</h1><p>JVM就是虚拟机，模拟计算机环境，加载.class文件，划分内存区域，将字节码解释为计算机能识别的机器码，是Java语言实现一处编译，到处运行的关键。</p><h1 id="JDK、JRE、JVM"><a href="#JDK、JRE、JVM" class="headerlink" title="JDK、JRE、JVM"></a>JDK、JRE、JVM</h1><p>JDK 是 Java 语言的软件开发工具包。JDK 物理存在，是 programming tools、JRE 和 JVM 的一个集合。</p><p>JRE（Java Runtime Environment）Java 运行时环境，JRE 物理存在，主要由 Java API(java 类库) 和 JVM 组成，提供了用于执行 java 应用程序最低要求的环境。</p><p>JDK有编译器而JRE没有，但是只要有JRE我们就可以运行java程序，一些开发软件idea都有自己的编译器。</p><p>JRE有JVM没有的lib库，JVM对字节码的解析要依赖这些类库。</p><h1 id="JVM结构"><a href="#JVM结构" class="headerlink" title="JVM结构"></a>JVM结构</h1><p>主要为三部分：类装载器子系统，运行时数据区，执行引擎。</p><p>类加载子系统负责从文件系统或者网络中加载Class信息，加载的类信息存放于一块称为方法区的内存空间。</p><p>执行引擎是java虚拟机的最核心组件之一，它负责执行虚拟机的字节码，现代虚拟机为了提高执行效率，会使用即时编译技术将方法编译成机器码后再执行。</p><p>运行时数据区主要时JVM虚拟机的内存结构体系，详见<a href="/2020/04/01/JVM%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/" title="JVM——内存结构">JVM——内存结构</a></p><h1 id="编译和执行过程"><a href="#编译和执行过程" class="headerlink" title="编译和执行过程"></a>编译和执行过程</h1><p><img src="/images/JVM%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AF%BB_2020-04-01-14-11-26.png" alt="JVM——学习导读_2020-04-01-14-11-26.png"></p><h1 id="JVM-学习体系"><a href="#JVM-学习体系" class="headerlink" title="JVM 学习体系"></a>JVM 学习体系</h1><ol><li><p>内存结构</p></li><li><p>类的加载机制</p></li><li><p>对象的创建</p></li><li><p>GC 算法 垃圾回收</p></li><li><p>GC 分析 命令调优</p></li></ol><p>这些知识点在之后的文章中有详细的介绍，这里只做主干的梳理。</p><h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><a href="/2020/04/01/JVM%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/" title="JVM——内存结构">JVM——内存结构</a><p>主要关注点：</p><ol><li><p>jvm 内存结构都是什么</p></li><li><p>对象分配规则</p></li></ol><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><ol><li><p>对象内存的分配方式</p></li><li><p>分配内存的线程安全问题</p></li><li><p>对象的内存分布</p></li><li><p>对象的访问定位</p></li></ol><h2 id="类的加载机制"><a href="#类的加载机制" class="headerlink" title="类的加载机制"></a>类的加载机制</h2><a href="/2020/04/01/JVM%E2%80%94%E2%80%94%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" title="JVM——类的加载机制">JVM——类的加载机制</a><p>主要关注点：</p><ol><li><p>什么是类的加载</p></li><li><p>类的生命周期</p></li><li><p>类加载器</p></li><li><p>双亲委派模型</p></li></ol><h2 id="GC-算法-垃圾回收"><a href="#GC-算法-垃圾回收" class="headerlink" title="GC 算法 垃圾回收"></a>GC 算法 垃圾回收</h2><p>主要关注点：</p><ol><li><p>对象存活判断</p></li><li><p>GC 算法</p></li><li><p>垃圾回收器</p></li></ol><h2 id="GC-分析-命令调优"><a href="#GC-分析-命令调优" class="headerlink" title="GC 分析 命令调优"></a>GC 分析 命令调优</h2><a href="/2020/04/01/JVM%E2%80%94%E2%80%94%E5%91%BD%E4%BB%A4%E8%B0%83%E4%BC%98/" title="JVM——命令调优">JVM——命令调优</a><p>主要关注点：</p><ol><li><p>GC 日志分析</p></li><li><p>调优命令</p></li><li><p>调优工具</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm 学习导读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（十）——总结</title>
      <link href="/2020/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>高并发——高可用手段（八）</title>
      <link href="/2020/03/31/%E9%AB%98%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E9%AB%98%E5%8F%AF%E7%94%A8%E6%89%8B%E6%AE%B5%EF%BC%88%E4%B8%83%EF%BC%89/"/>
      <url>/2020/03/31/%E9%AB%98%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E9%AB%98%E5%8F%AF%E7%94%A8%E6%89%8B%E6%AE%B5%EF%BC%88%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是高可用？"><a href="#什么是高可用？" class="headerlink" title="什么是高可用？"></a>什么是高可用？</h1><p>系统无中断地执行其功能的能力，代表系统的可用性程度，是进行系统设计时的准则之一。</p><p>这个难点或是重点在于“无中断”，要做到 7x24 小时无中断无异常的服务提供。</p><h1 id="高可用的评价维度"><a href="#高可用的评价维度" class="headerlink" title="高可用的评价维度"></a>高可用的评价维度</h1><p>在业界有一套比较出名的评定网站可用性的指标，常用 N 个 9 来量化可用性，可以直接映射到网站正常运行时间的百分比上：</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%AB%98%E5%8F%AF%E7%94%A8%E6%89%8B%E6%AE%B5%EF%BC%88%E4%B8%83%EF%BC%89_2020-03-31-15-12-02.png" alt="JAVA并发——高并发之高可用手段（七）_2020-03-31-15-12-02.png"></p><p>科学方式：</p><p>一段时间内的停机影响请求量占比</p><p>停机时间的响应请求量/总的请求量</p><h1 id="影响高可用"><a href="#影响高可用" class="headerlink" title="影响高可用"></a>影响高可用</h1><ol><li><p>突发大流量</p></li><li><p>秒杀设计</p></li><li><p>硬件方面 等等</p></li></ol><h1 id="高可用手段"><a href="#高可用手段" class="headerlink" title="高可用手段"></a>高可用手段</h1><p>高可用是一个比较复杂的命题，基本上在所有的处理中都会涉及到高可用，所有在设计高可用方案也涉及到了方方面面。</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B9%8B%E9%AB%98%E5%8F%AF%E7%94%A8%E6%89%8B%E6%AE%B5%EF%BC%88%E4%B8%83%EF%BC%89_2020-03-31-15-14-04.png" alt="JAVA并发——高并发之高可用手段（七）_2020-03-31-15-14-04.png"></p><h2 id="服务冗余"><a href="#服务冗余" class="headerlink" title="服务冗余"></a>服务冗余</h2><p>为了防止一台机器因为软件或硬件问题导致不可用，需要部署多个服务器，单机房保证服务部署在不同的机架或机柜上，防止一台机架或机柜停电导致不可用。多台机器就会使服务冗余。</p><p>服务冗余的结果就是要做无状态化。所谓的无状态化就是要使冗余部署的服务是对等的，比如部署两台，请求进来通过网关不管传入哪一台服务器，都是不影响的。</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>在网关接收到请求时，需要转发，一般应用服务器有多台，如何合理的进行请求转发到不同的服务器使用的策略就是负载均衡策略，使用负载均衡可以使请求合理的分配到不同的服务器上进行处理。</p><p>做负载均衡的同时，也需要考虑做<strong>幂等</strong>设计，避免多次接受请求。</p><h2 id="超时机制"><a href="#超时机制" class="headerlink" title="超时机制"></a>超时机制</h2><p>如果请求等待时间过长，获取不到请求结果，需要设计一个超时等待的机制。</p><p>异步化设计: 做架构的异步化是提高吞吐量。</p><p>使用好处: 在不关心的数据和结果可以使用异步化来做。核心的流量采样同步来做，非核心的采用异步化来做。</p><h2 id="服务限流熔断降级"><a href="#服务限流熔断降级" class="headerlink" title="服务限流熔断降级"></a>服务限流熔断降级</h2><p>降低服务的请求量，不同服务之间调用异常，会导致等待时间过久，需要做服务熔断。在某些场景下，某些服务访问量会突然飙升，为了降低服务器压力，会把某些冷门服务进行降级关闭，把资源分配到比较常用的服务上。</p><h2 id="数据复制-缓存-sharding"><a href="#数据复制-缓存-sharding" class="headerlink" title="数据复制/缓存/sharding"></a>数据复制/缓存/sharding</h2><p>数据复制可以保证数据的同步性，使用缓存可以是数据访问效率较快提高吞吐量</p><h2 id="服务拆分"><a href="#服务拆分" class="headerlink" title="服务拆分"></a>服务拆分</h2><p>架构拆分可以降低应用的复杂度，进行服务治理也是。同时架构拆分还可以降低服务的压力</p><h2 id="服务实时监控"><a href="#服务实时监控" class="headerlink" title="服务实时监控"></a>服务实时监控</h2><p>更快的预先判断哪些服务可能会发生某些问题，在不可用之前进行监控改进。</p><h2 id="开关控制"><a href="#开关控制" class="headerlink" title="开关控制"></a>开关控制</h2><p>限流开关、业务开关等等</p>]]></content>
      
      
      <categories>
          
          <category> 高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 高可用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发——数据库分库、切库、分表（七）</title>
      <link href="/2020/03/31/%E9%AB%98%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E5%88%86%E5%BA%93%E3%80%81%E5%88%87%E5%BA%93%E3%80%81%E5%88%86%E8%A1%A8%EF%BC%88%E4%B8%83%EF%BC%89/"/>
      <url>/2020/03/31/%E9%AB%98%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E5%88%86%E5%BA%93%E3%80%81%E5%88%87%E5%BA%93%E3%80%81%E5%88%86%E8%A1%A8%EF%BC%88%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>随着高并发的压力，数据库很容易出现瓶颈：</p><ul><li>单个库数据量太大；考虑多个库解决问题。</li><li>单个数据库服务器压力过大、读写瓶颈；考虑多个库、读写分离解决问题。</li><li>单个表数据量过大；考虑分表解决问题。</li></ul><h1 id="分库和切库"><a href="#分库和切库" class="headerlink" title="分库和切库"></a>分库和切库</h1><p>对数据库的操作中读多写少，且读操作占用系统资源多，耗时长，适用多个分库进行负载均衡。</p><p>它们都是底层是多个数据库在提供服务。</p><p><strong>分库</strong>是属于在微服务应用拆分的时候都有自己的数据库。</p><p><strong>切库</strong>是在没有进行应用拆分的时候就已经分成两个库了，根据业务使用不同的代码连接不同的数据库。</p><p>实现：</p><p><a href="https://www.cnblogs.com/shamo89/p/10032117.html" target="_blank" rel="noopener">SpringBoot+SpringAOP+Java 自定义注解+mybatis 实现切库读写分离</a></p><p><a href="https://www.cnblogs.com/shamo89/p/10032390.html" target="_blank" rel="noopener">SpringBoot+mybatis 实现多数据源支持</a></p><h1 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h1><p>一张表的数据量很大，即使我们进行了一系列 sql 优化之后依然效率很低，我们就要考虑将它的数据进行分表。</p><h2 id="水平切割"><a href="#水平切割" class="headerlink" title="水平切割"></a>水平切割</h2><p>水平切割分为库内分表和分库分表，是根据表内数据内在的逻辑关系，将同一个表按不同的条件分散到多个数据库或多个表中，每个表中只包含一部分数据，从而使得单个表的数据量变小，达到分布式的效果。</p><h3 id="水平分割优点"><a href="#水平分割优点" class="headerlink" title="水平分割优点"></a>水平分割优点</h3><ol><li><p>不存在单库数据量过大、高并发的性能瓶颈，提升系统稳定性和负载能力</p></li><li><p>应用端改造较小，不需要拆分业务模块</p></li></ol><h3 id="水平分割缺点"><a href="#水平分割缺点" class="headerlink" title="水平分割缺点"></a>水平分割缺点</h3><ol><li><p>跨分片的事务一致性难以保证</p></li><li><p>跨库的 join 关联查询性能较差</p></li><li><p>数据多次扩展难度和维护量极大</p></li></ol><h3 id="数据分片规则"><a href="#数据分片规则" class="headerlink" title="数据分片规则"></a>数据分片规则</h3><ol><li>根据数值范围</li></ol><p>按照时间区间或 ID 区间来切分。例如：按日期将不同月甚至是日的数据分散到不同的库中；将 userId 为 1<del>9999 的记录分到第一个库，10000</del>20000 的分到第二个库，以此类推。某种意义上，某些系统中使用的”冷热数据分离”，将一些使用较少的历史数据迁移到其他库中，业务功能上只提供热点数据的查询，也是类似的实践。</p><p>这样的优点在于：</p><ul><li>单表大小可控</li><li>天然便于水平扩展，后期如果想对整个分片集群扩容时，只需要添加节点即可，无需对其他分片的数据进行迁移</li><li>使用分片字段进行范围查找时，连续分片可快速定位分片进行快速查询，有效避免跨分片查询的问题。</li></ul><p>缺点：</p><ul><li>热点数据成为性能瓶颈。连续分片可能存在数据热点，例如按时间字段分片，有些分片存储最近时间段内的数据，可能会被频繁的读写，而有些分片存储的历史数据，则很少被查询</li></ul><ol start="2"><li>根据数值取模</li></ol><p>一般采用 hash 取模 mod 的切分方式，例如：将 Customer 表根据 cusno 字段切分到 4 个库中，余数为 0 的放到第一个库，余数为 1 的放到第二个库，以此类推。这样同一个用户的数据会分散到同一个库中，如果查询条件带有 cusno 字段，则可明确定位到相应库去查询。</p><p>优点：</p><ul><li>数据分片相对比较均匀，不容易出现热点和并发访问的瓶颈</li></ul><p>缺点：</p><ul><li>后期分片集群扩容时，需要迁移旧的数据（使用一致性 hash 算法能较好的避免这个问题）</li><li>容易面临跨分片查询的复杂问题。比如上例中，如果频繁用到的查询条件中不带 cusno 时，将会导致无法定位数据库，从而需要同时向 4 个库发起查询，再在内存中合并数据，取最小集返回给应用，分库反而成为拖累。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><a href="https://www.cnblogs.com/shamo89/p/10033349.html" target="_blank" rel="noopener">spring+mybatis 的插件【shardbatis2.0】+mysql+java 自定义注解实现分表</a></p><h2 id="垂直切割"><a href="#垂直切割" class="headerlink" title="垂直切割"></a>垂直切割</h2><p>垂直分表是基于数据库中的”列”进行，某个表字段较多，可以新建一张扩展表，将不经常用或字段长度较大的字段拆分出去到扩展表中。在字段很多的情况下（例如一个大表有 100 多个字段），通过”大表拆小表”，更便于开发与维护，也能避免跨页问题</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E3%80%81%E5%88%87%E5%BA%93%E3%80%81%E5%88%86%E8%A1%A8%EF%BC%88%E5%85%AD%EF%BC%89_2020-03-31-14-07-27.png" alt="JAVA并发——高并发之数据库分库、切库、分表（六）_2020-03-31-14-07-27.png"></p><h3 id="垂直切割优点"><a href="#垂直切割优点" class="headerlink" title="垂直切割优点"></a>垂直切割优点</h3><ol><li><p>解决业务系统层面的耦合，业务清晰</p></li><li><p>与微服务的治理类似，也能对不同业务的数据进行分级管理、维护、监控、扩展等</p></li><li><p>高并发场景下，垂直切分一定程度的提升 IO、数据库连接数、单机硬件资源的瓶颈</p></li></ol><h3 id="垂直切割缺点"><a href="#垂直切割缺点" class="headerlink" title="垂直切割缺点"></a>垂直切割缺点</h3><ol><li><p>部分表无法 join，只能通过接口聚合方式解决，提升了开发的复杂度</p></li><li><p>分布式事务处理复杂</p></li><li><p>依然存在单表数据量过大的问题（需要水平切分）</p></li></ol><h1 id="分库分表带来的问题"><a href="#分库分表带来的问题" class="headerlink" title="分库分表带来的问题"></a>分库分表带来的问题</h1><h2 id="事务一致性问题"><a href="#事务一致性问题" class="headerlink" title="事务一致性问题"></a>事务一致性问题</h2><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>当更新内容同时分布在不同库中，不可避免会带来跨库事务问题。跨分片事务也是分布式事务，没有简单的方案，一般可使用”XA 协议”和”两阶段提交”处理。</p><p>分布式事务能最大限度保证了数据库操作的原子性。但在提交事务时需要协调多个节点，推后了提交事务的时间点，延长了事务的执行时间。导致事务在访问共享资源时发生冲突或死锁的概率增高。随着数据库节点的增多，这种趋势会越来越严重，从而成为系统在数据库层面上水平扩展的枷锁。</p><h3 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h3><p>对于那些性能要求很高，但对一致性要求不高的系统，往往不苛求系统的实时一致性，只要在允许的时间段内达到最终一致性即可，可采用事务补偿的方式。与事务在执行中发生错误后立即回滚的方式不同，事务补偿是一种事后检查补救的措施，一些常见的实现方法有：对数据进行对账检查，基于日志进行对比，定期同标准数据来源进行同步等等。事务补偿还要结合业务系统来考虑。</p><h2 id="跨节点关联查询-join-问题"><a href="#跨节点关联查询-join-问题" class="headerlink" title="跨节点关联查询 join 问题"></a>跨节点关联查询 join 问题</h2><p>切分之前，系统中很多列表和详情页所需的数据可以通过 sql join 来完成。而切分之后，数据可能分布在不同的节点上，此时 join 带来的问题就比较麻烦了，考虑到性能，尽量避免使用 join 查询。</p><p>解决这个问题的一些方法：</p><ol><li>全局表</li></ol><p>全局表，也可看做是”数据字典表”，就是系统中所有模块都可能依赖的一些表，为了避免跨库 join 查询，可以将这类表在每个数据库中都保存一份。这些数据通常很少会进行修改，所以也不担心一致性的问题。</p><ol start="2"><li>字段冗余</li></ol><p>一种典型的反范式设计，利用空间换时间，为了性能而避免 join 查询。例如：订单表保存 userId 时候，也将 userName 冗余保存一份，这样查询订单详情时就不需要再去查询”买家 user 表”了。</p><p>但这种方法适用场景也有限，比较适用于依赖字段比较少的情况。而冗余字段的数据一致性也较难保证，就像上面订单表的例子，买家修改了 userName 后，是否需要在历史订单中同步更新呢？这也要结合实际业务场景进行考虑。</p><ol start="3"><li>数据组装</li></ol><p>在系统层面，分两次查询，第一次查询的结果集中找出关联数据 id，然后根据 id 发起第二次请求得到关联数据。最后将获得到的数据进行字段拼装。</p><h2 id="跨节点分页、排序、函数问题"><a href="#跨节点分页、排序、函数问题" class="headerlink" title="跨节点分页、排序、函数问题"></a>跨节点分页、排序、函数问题</h2><p>跨节点多库进行查询时，会出现 limit 分页、order by 排序等问题。分页需要按照指定字段进行排序，当排序字段就是分片字段时，通过分片规则就比较容易定位到指定的分片；当排序字段非分片字段时，就变得比较复杂了。需要先在不同的分片节点中将数据进行排序并返回，然后将不同分片返回的结果集进行汇总和再次排序，最终返回给用户.</p><p>在分库分表环境中，由于表中数据同时存在不同数据库中，主键值平时使用的自增长将无用武之地，某个分区数据库自生成的 ID 无法保证全局唯一。因此需要单独设计全局主键，以避免跨库主键重复问题。有一些常见的主键生成策略：</p><h2 id="全局主键避重问题"><a href="#全局主键避重问题" class="headerlink" title="全局主键避重问题"></a>全局主键避重问题</h2><p>1）UUID</p><p>UUID 标准形式包含 32 个 16 进制数字，分为 5 段，形式为 8-4-4-4-12 的 36 个字符，例如：550e8400-e29b-41d4-a716-446655440000</p><p>UUID 是主键是最简单的方案，本地生成，性能高，没有网络耗时。但缺点也很明显，由于 UUID 非常长，会占用大量的存储空间；另外，作为主键建立索引和基于索引进行查询时都会存在性能问题，在 InnoDB 下，UUID 的无序性会引起数据位置频繁变动，导致分页</p><h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><p><a href="https://juejin.im/entry/5c258e02f265da617573d346" target="_blank" rel="noopener">数据库分库分表，怎么分？何时分？</a></p>]]></content>
      
      
      <categories>
          
          <category> 高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 数据库分库、切库、分表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发——服务降级和熔断（六）</title>
      <link href="/2020/03/31/%E9%AB%98%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%E5%92%8C%E7%86%94%E6%96%AD%EF%BC%88%E5%85%AD%EF%BC%89/"/>
      <url>/2020/03/31/%E9%AB%98%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%E5%92%8C%E7%86%94%E6%96%AD%EF%BC%88%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h1><p>服务压力剧增的时候根据当前的业务情况及流量对一些服务和页面有策略的降级，以此缓解服务器的压力，以保证核心任务的进行。</p><p>方案：</p><ol><li><p>服务接口拒绝服务：页面能访问，但是添加删除提示服务器繁忙。页面内容也可在 Varnish 或 CDN 内获取。</p></li><li><p>页面拒绝服务：页面提示由于服务繁忙此服务暂停。跳转到 varnish 或 nginx 的一个静态页面。</p></li><li><p>延迟持久化：页面访问照常，但是涉及记录变更，会提示稍晚能看到结果，将数据记录到 异步队列 或 log ，服务恢复后执行。</p></li><li><p>随机拒绝服务：服务 接口随机 拒绝服务，让用户重试，目前较少有人采用。因为用户体验不佳。</p></li></ol><h1 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h1><p>如果某个目标服务调用慢或者有大量超时，此时，熔断该服务的调用，对于后续调用请求，不在继续调用目标服务，直接返回，快速释放资源。如果目标服务情况好转则恢复调用。</p><p>熔断设计：</p><ol><li><p>熔断请求判断机制算法：使用无锁循环队列计数，每个熔断器默认维护 10 个 bucket，每 1 秒一个 bucket，每个 blucket 记录请求的成功、失败、超时、拒绝的状态，默认错误超过 50%且 10 秒内超过 20 个请求进行中断拦截。</p></li><li><p>熔断恢复：对于被熔断的请求，每隔 5s 允许部分请求通过，若请求都是健康的（RT&lt;250ms）则对请求健康恢复。</p></li><li><p>熔断报警：对于熔断的请求打日志，异常请求超过某些设定则报警</p></li></ol><h1 id="熔断和降级的区别"><a href="#熔断和降级的区别" class="headerlink" title="熔断和降级的区别"></a>熔断和降级的区别</h1><p>首先我们总结以下：</p><ul><li>降级的目的是为了解决整体项目的压力，而牺牲掉某一服务模块而采取的措施。</li><li>熔断的目的是当 A 服务模块中的某块程序出现故障后为了不影响其他客户端的请求而做出的及时回应。</li></ul><h1 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h1><ol><li><p>目的很一致，都是从可用性可靠性着想，为防止系统的整体缓慢甚至崩溃，采用的技术手段；</p></li><li><p>最终表现类似，对于两者来说，最终让用户体验到的是某些功能暂时不可达或不可用；</p></li><li><p>粒度一般都是服务级别，当然，业界也有不少更细粒度的做法，比如做到数据持久层（允许查询，不允许增删改）；</p></li><li><p>自治性要求很高，熔断模式一般都是服务基于策略的自动触发，降级虽说可人工干预，但在微服务架构下，完全靠人显然不可能，开关预置、配置中心都是必要手段 ；</p></li></ol><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><ol><li><p>触发原因不太一样， 服务降级一般是从整体负荷考虑，而服务熔断一般是某个服务（下游服务）故障引起 ；</p></li><li><p>管理目标的层次不太一样， 降级一般需要对业务有层级之分（比如降级一般是从最外围服务开始）；熔断 其实是一个框架级的处理，每个微服务都需要（无层级之分）。</p></li></ol><h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><a href="/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BHystrix/" title="springcloud解析之Hystrix">springcloud解析之Hystrix</a>]]></content>
      
      
      <categories>
          
          <category> 高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 服务降级和熔断 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发——应用限流（五）</title>
      <link href="/2020/03/31/%E9%AB%98%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E9%99%90%E6%B5%81%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2020/03/31/%E9%AB%98%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E9%99%90%E6%B5%81%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>高并发场景下，爆炸性大量的对数据库的请求操作不仅会占用十分高比例的网络带宽，导致其他应用对数据库的请求受阻，还会导致从库与主库的延迟大大增加，降低了从库数据的不准确率，也降低了缓存的命中率。</p><p>如图：</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%BA%94%E7%94%A8%E9%99%90%E6%B5%81%EF%BC%88%E4%BA%94%EF%BC%89_2020-03-31-10-44-13.png" alt="JAVA并发——高并发之应用限流（五）_2020-03-31-10-44-13.png"></p><h1 id="限流方式"><a href="#限流方式" class="headerlink" title="限流方式"></a>限流方式</h1><ul><li>限制总并发数：如数据库连接池、线程池；</li><li>限制瞬时并发数：如 nginx 的 limit_conn 模块，用来限制瞬时并发连接数；</li><li>限制时间窗口内的平均速率：如 Guava 的 RateLimiter、nginx 的 limit_req 模块，限制每秒的平均速率；</li></ul><h1 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h1><ol><li>计数器法</li><li>滑动窗口</li><li>漏桶算法</li><li>令牌桶算法</li></ol><h2 id="计数器法"><a href="#计数器法" class="headerlink" title="计数器法"></a>计数器法</h2><p>计数器法是最简单、最易实现的限流算法。通过重复设置计数器，对接口一定时间段内的访问频率进行限制。</p><p>弊端：存在临界问题。<br>如下图所示：</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%BA%94%E7%94%A8%E9%99%90%E6%B5%81%EF%BC%88%E4%BA%94%EF%BC%89_2020-03-31-10-46-19.png" alt="JAVA并发——高并发之应用限流（五）_2020-03-31-10-46-19.png"></p><p>如上图所示，在临界的小时间段内，发送了 200 个请求，导致限流的不成功，可能会导致应用的崩溃。</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>滑动窗口可以被看做是一个高精度的计数器算法。其中小窗口的个数越多，对限流中请求的统计会越精确，但占用的系统资源会多。</p><p>如下图所示：</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%BA%94%E7%94%A8%E9%99%90%E6%B5%81%EF%BC%88%E4%BA%94%EF%BC%89_2020-03-31-10-47-28.png" alt="JAVA并发——高并发之应用限流（五）_2020-03-31-10-47-28.png"></p><p>其中，虚线包括了 6 个小窗口，这该 6 个小窗口组成了一个滑动窗口，滑动窗口对请求数量进行限定；每个小窗口都有一个计数器，都限定了相同的一定时间。每经过该小窗口的时间，滑动窗口就向右侧移动一格，如上图的所示，从而避免了计数器法中的弊端。</p><h2 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h2><p>漏桶算法（Leaky Bucket）作为计量工具（The Leaky Bucket Algorithm as a Meter）时，可以用于流量整形（Traffic Shaping）和流量控制（TrafficPolicing）。</p><p>其算法示意图如下：</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%BA%94%E7%94%A8%E9%99%90%E6%B5%81%EF%BC%88%E4%BA%94%EF%BC%89_2020-03-31-10-48-41.png" alt="JAVA并发——高并发之应用限流（五）_2020-03-31-10-48-41.png"></p><p>漏桶算法构建一个容量固定的漏桶，请求数会先放入漏桶，以可控的一定速率流出来，当漏桶满了时，多余的请求会被丢弃。</p><h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><p>令牌桶算法可以看做是漏桶算法和滑动窗口思想的结合体，构造一个存放固定容量令牌的桶，按照可控的固定速率往桶里添加令牌。</p><p>如下图所示：</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%BA%94%E7%94%A8%E9%99%90%E6%B5%81%EF%BC%88%E4%BA%94%EF%BC%89_2020-03-31-10-49-30.png" alt="JAVA并发——高并发之应用限流（五）_2020-03-31-10-49-30.png"></p><p>当桶满了时，新添加的令牌会被丢弃或拒绝。当一个请求过来时，该桶就移除一个令牌；当桶中没了令牌时，请求也就无法通过。其中移除令牌是没有延迟时间的，若当设置该延迟时间后，就十分近似漏桶算法了。它通过将桶总量划分为多个令牌的容量，不会造成大量请求的突发，可以很好地解决临界问题。</p><h2 id="令牌桶算法与漏桶算法的比较"><a href="#令牌桶算法与漏桶算法的比较" class="headerlink" title="令牌桶算法与漏桶算法的比较"></a>令牌桶算法与漏桶算法的比较</h2><ul><li>令牌桶是按照固定速率往桶中添加令牌，请求是否被处理需要看桶中令牌是否足够，当令牌数减为零时则拒绝新的请求；</li><li>漏桶则是按照常量固定速率流出请求，流入请求速率任意，当流入的请求数累积到漏桶容量时，则新流入的请求被拒绝；</li><li>令牌桶限制的是平均流入速率（允许突发请求，只要有令牌就可以处理，支持一次拿 3 个令牌，4 个令牌），并允许一定程度突发流量；</li><li>漏桶限制的是常量流出速率（即流出速率是一个固定常量值，比如都是 1 的速率流出，而不能一次是 1，下次又是 2），从而平滑突发流入速率；</li><li>令牌桶允许一定程度的突发，而漏桶主要目的是平滑流入速率；<br>两个算法实现可以一样，但是方向是相反的，对于相同的参数得到的限流效果是一样的。</li></ul><h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><p><a href="https://blog.csdn.net/g_hongjin/article/details/51649246" target="_blank" rel="noopener">限流特技</a></p>]]></content>
      
      
      <categories>
          
          <category> 高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 应用限流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发——应用拆分（四）</title>
      <link href="/2020/03/31/%E9%AB%98%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E6%8B%86%E5%88%86%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2020/03/31/%E9%AB%98%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E6%8B%86%E5%88%86%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一个服务器再怎么优化，其处理能力都是有限的。根据项目情况，将一个整体应用拆分为多个应用也不失为一个方案。比如按功能模块及功能模块使用频率拆分。</p><h1 id="应用拆分的好处"><a href="#应用拆分的好处" class="headerlink" title="应用拆分的好处"></a>应用拆分的好处</h1><ol><li>减轻并优化了整个统一的应用的压力。</li><li>拆分后的应用可以被更精准的监控。</li><li>不同子应用会更容易管理及局部优化。</li><li>更利于功能模块内部的团队协作。</li></ol><h1 id="应用拆分的弊端"><a href="#应用拆分的弊端" class="headerlink" title="应用拆分的弊端"></a>应用拆分的弊端</h1><ol><li>管理的复杂度上升。</li><li>代价昂贵。使用资源的成本增加。</li><li>网络开销增加，带宽要求增加。</li></ol><h1 id="应用拆分的原则"><a href="#应用拆分的原则" class="headerlink" title="应用拆分的原则"></a>应用拆分的原则</h1><ol><li>业务优先。优先按照业务的功能拆分为小应用。</li><li>循序渐进，迭代拆分并进行测试。</li><li>兼顾技术：重构、分层。</li><li>可靠测试。减少或避免累积错误的出现。</li></ol><h1 id="应用拆分的思考"><a href="#应用拆分的思考" class="headerlink" title="应用拆分的思考"></a>应用拆分的思考</h1><ol><li>应用之间通信：RPC（dubbo 等）或消息队列（适用于传输数据包小，但传输量大，对数据的实时性要求不高的场景）。</li><li>应用之间的数据库设计：每个应用都应有自己的数据库，其中一些共同的信息可以另建一个公共数据库来存放。</li><li>避免事务操作跨应用，降低耦合度。</li></ol><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p>dubbo</p><p>spring cloud</p><h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1>]]></content>
      
      
      <categories>
          
          <category> 高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 应用拆分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发——队列（四）</title>
      <link href="/2020/03/30/%E9%AB%98%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E9%98%9F%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2020/03/30/%E9%AB%98%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E9%98%9F%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>消息队列是用来传递消息的中间件，有以下特性：</p><ol><li><p>与业务无关 : 只做消息分发</p></li><li><p>FIFO : 先投递先到达</p></li><li><p>容灾 : 节点的动态增删和消息的持久化</p></li><li><p>性能 : 吞吐量提升,系统内部通信效率提高</p></li></ol><h1 id="消息队列的作用"><a href="#消息队列的作用" class="headerlink" title="消息队列的作用"></a>消息队列的作用</h1><ol><li><p>业务解耦</p></li><li><p>最终一致性: 通常用于分布式事务</p></li><li><p>广播： 如果没有消息队列每一个新的业务方介入都需要联调一次接口,使用消息队列只需要关心消息是否送达到消息队列,新接入的接口订阅相关的消息自己做处理就可以了;</p></li><li><p>错峰与流控 : 上下游对于事情的处理是不同的,比如 WEB 前端每秒承受上千万的请求都是可以的但是数据库的处理却非常有限;迫于成本的压力我们不能要求数据库的机器数量与前端资源一样;这样的问题同样存在于系统与系统之间,比如短信系统的速度卡在网关上边它与前端的并发量不是一个数量级的,用户玩几秒种收到短信也是可以的;针对于这样的场景如果没有消息队列也能实现但是系统的复杂度非常的高;</p></li></ol><h1 id="常见的消息队列"><a href="#常见的消息队列" class="headerlink" title="常见的消息队列"></a>常见的消息队列</h1><p>kafka、RabbitMQ等</p>]]></content>
      
      
      <categories>
          
          <category> 高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发——缓存（三）</title>
      <link href="/2020/03/30/%E9%AB%98%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2020/03/30/%E9%AB%98%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>目前磁盘 IO 和网络 IO 相对于内存 IO 的成百上千倍的性能劣势。</p><p>通过将高频使用的数据存在离 cpu 更近的位置，以减少数据传输时间，从而提高处理效率，这就是缓存的意义。</p><h1 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h1><p>浏览器会缓存页面的元素，这样在重复访问网页时，就避开了要从互联网上下载数据（例如大图片）</p><p>缺点：</p><p>客户端缓存减少了的服务器请求，避免了文件重复加载，显著地提升了用户地方。但是当网站发生了更新的时候（如替换了 css、js 以及图片文件），浏览器本地仍保存着旧版本的文件，从而导致无法预料后果。</p><h1 id="CDN-缓存"><a href="#CDN-缓存" class="headerlink" title="CDN 缓存"></a>CDN 缓存</h1><p>浏览器本地缓存失效后，浏览器会向 CDN 边缘节点发起请求。类似浏览器缓存，CDN 边缘节点也存在着一套缓存机制。</p><p>CDN 可以理解为分布在每个县城的火车票代售点，用户在浏览网站的时候，CDN 会选择一个离用户最近的 CDN 边缘节点来响应用户的请求。</p><p>缺点：CDN 的分流作用不仅减少了用户的访问延时，也减少的源站的负载。但其缺点也很明显：当网站更新时，如果 CDN 节点上数据没有及时更新，即便用户再浏览器使用 Ctrl +F5 的方式使浏览器端的缓存失效，也会因为 CDN 边缘节点没有同步最新数据而导致用户访问异常。</p><h1 id="数据库缓存"><a href="#数据库缓存" class="headerlink" title="数据库缓存"></a>数据库缓存</h1><p>数据库会缓存查询，所以同一条查询第二次就是要比第一次快。</p><h1 id="分布式-缓存"><a href="#分布式-缓存" class="headerlink" title="分布式 缓存"></a>分布式 缓存</h1><p>（如 redis Memcache）选择把数据存在内存而非硬盘里。</p><h1 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h1><p>编程实现(成员变量、局部变量、静态变量)、Guava Cache</p><h1 id="高并发下缓存的常见问题"><a href="#高并发下缓存的常见问题" class="headerlink" title="高并发下缓存的常见问题"></a>高并发下缓存的常见问题</h1><ol><li>缓存一致性</li></ol><p>当数据时效性要求很高时，需要保证缓存中的数据与数据库中的保持一致，而且需要保证缓存节点和副本中的数据也保持一致，不能出现差异现象。这就比较依赖缓存的过期和更新策略。</p><p>一般会在数据发生更改的时，主动更新缓存中的数据或者移除对应的缓存。</p><ol start="2"><li>缓存穿透</li></ol><p>缓存穿透是说收到了一个请求，但是该请求缓存里没有，只能去数据库里查询，然后放进缓存。这里面有两个风险，一个是同时有好多请求访问同一个数据，然后业务系统把这些请求全发到了数据库；第二个是有人恶意构造一个逻辑上不存在的数据，然后大量发送这个请求，这样每次请求都会被发送到数据库，可能导致数据挂掉。</p><p>怎么应对这种情况呢？对于恶意访问，一个思路是事先做校验，对恶意数据直接过滤掉，不要发到数据库层；第二个思路是缓存空结果，就是对查询不存在的数据仍然记录一条该数据不存在在缓存里，这样能有效的减少查询数据库的次数。</p><ol start="3"><li>缓存击穿</li></ol><p>缓存击穿其实是缓存穿透中，非恶意访问的情况。比如缓存中某热点数据过期失效，所有请求都被下放到数据库去请求更新缓存，数据库被压垮。</p><p>怎么防范这种问题呢？一个思路是全局锁，就是所有访问某个数据的请求都共享一个锁，获得锁的那个才有资格去访问数据库，其他线程必须等待。但是现在的业务都是分布式的，本地锁没法控制其他服务器也等待，所以要用到全局锁，比如用 redis 的 setnx 实现全局锁。</p><p>另一个思路是对即将过期的数据主动刷新，做法可以有很多，比如起一个线程轮询数据，比如把所有数据划分为不同的缓存区间，定期分区间刷新数据等等。这第二个思路又和我们接下来要讲的缓存雪崩有关系。</p><ol start="4"><li>缓存雪崩</li></ol><p>缓存雪崩是指比如我们给所有的数据设置了同样的过期时间，然后在某一个历史性时刻，整个缓存的数据全部过期了，然后瞬间所有的请求都被打到了数据库，数据库就崩了。</p><p>解决思路要么是分治，划分更小的缓存区间，按区间过期；要么是给每个 key 的过期时间加个随机值，避免同时过期，达到错峰刷新缓存的目的。</p><ol start="5"><li>缓存无底洞</li></ol><p>该问题由 facebook 的工作人员提出的， facebook 在 2010 年左右，memcached 节点就已经达 3000 个，缓存数千 G 内容。他们发现了一个问题—memcached 连接频率，效率下降了，于是加 memcached 节点，添加了后，发现因为连接频率导致的问题，仍然存在，并没有好转，称之为”无底洞现象”。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>缓存无底洞情况并不常见，在绝大多数公司根本不会遇到。</p>]]></content>
      
      
      <categories>
          
          <category> 高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发——扩容（二）</title>
      <link href="/2020/03/30/%E9%AB%98%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E6%89%A9%E5%AE%B9%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/03/30/%E9%AB%98%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E6%89%A9%E5%AE%B9%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在无状态服务下，扩容可能是迄今为止效果最明显的增加并发量的技巧之一，但扩容的最大问题就是成本。</p><h1 id="垂直扩容（纵向扩展）"><a href="#垂直扩容（纵向扩展）" class="headerlink" title="垂直扩容（纵向扩展）"></a>垂直扩容（纵向扩展）</h1><p>提高单个服务（服务器、数据库）自身能力</p><p>但会增大单个服务中其他软件设施的依赖与管理、服务内部复杂度</p><h1 id="水平扩容（横向扩展）"><a href="#水平扩容（横向扩展）" class="headerlink" title="水平扩容（横向扩展）"></a>水平扩容（横向扩展）</h1><p>增加更多服务成员</p><p>但会增加网络、数据库 IO 开销、管理多个服务器的难度</p><h2 id="对数据库的扩容方案"><a href="#对数据库的扩容方案" class="headerlink" title="对数据库的扩容方案"></a>对数据库的扩容方案</h2><ul><li>读操作多：采用垂直扩容方案（redis、CDN）。采用水平扩容没有太大的意义，因为性能的瓶颈不在写操作，所以不需要实时去完成，用更多的服务器来分担压力性价比太低。所以针对单个系统去强化它的读性能就可以了</li><li>写操作多：采用水平扩容方案（HBase、增加服务器、数据库）。也可以考虑垂直扩容提升单个数据库的性能，但会发现资金与硬盘的 IO 能力是有限的，所以需要增加更多数据库来分担写的压力。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 扩容 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发——高并发与高可用的设计原则（一）</title>
      <link href="/2020/03/30/%E9%AB%98%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/03/30/%E9%AB%98%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>高并发是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。</p><p>高可用就是抵御不确定性，保证系统 7*24 小时健康服务。</p><p>系统的主要原则即如何在高并发的条件下，保证系统的高可用。</p><h1 id="高并发指标："><a href="#高并发指标：" class="headerlink" title="高并发指标："></a>高并发指标：</h1><ul><li><p>响应时间：系统对请求做出响应的时间。例如系统处理一个 HTTP 请求需要 200ms，这个 200ms 就是系统的响应时间。</p></li><li><p>吞吐量：单位时间内处理的请求数量。</p></li><li><p>QPS：每秒响应请求数。在互联网领域，这个指标和吞吐量区分的没有这么明显。</p></li><li><p>并发用户数：同时承载正常使用系统功能的用户数量。例如一个即时通讯系统，同时在线量一定程度上代表了系统的并发用户数。</p></li></ul><h1 id="高并发原则"><a href="#高并发原则" class="headerlink" title="高并发原则"></a>高并发原则</h1><ul><li>无状态设计：因为有状态可能涉及锁操作，锁又可能导致并发的串行化。</li><li>保持合理的粒度：无论拆分还是服务化，其实就是服务粒度控制，控制粒度为了分散请求提高并发，或为了从管理等角度提高可操性。</li><li>缓存、队列、并发等技巧在高并发设计上可供参考，但需依场景使用。</li></ul><h1 id="高可用原则"><a href="#高可用原则" class="headerlink" title="高可用原则"></a>高可用原则</h1><ul><li>系统的任何发布必须具有可回滚能力。</li><li>系统任何外部依赖必须准确衡量是否可降级，是否可无损降级，并提供降级开关。</li><li>系统对外暴露的接口必须配置好限流，限流值必须尽量准确可靠。</li></ul><h1 id="业务设计原则"><a href="#业务设计原则" class="headerlink" title="业务设计原则"></a>业务设计原则</h1><ul><li>安全性：防抓取，防刷单、防表单重复提交，等等等等。</li><li>at least 消费，应考虑是否采用<strong>幂等</strong>设计</li><li>业务流程动态化，业务规则动态化</li><li>系统 owner 负责制、人员备份制、值班制</li><li>系统文档化</li><li>后台操作可追溯</li></ul><h1 id="高并发处理手段"><a href="#高并发处理手段" class="headerlink" title="高并发处理手段"></a>高并发处理手段</h1><ol><li>提高处理速度：缓存、异步</li><li>增加处理人手：多线程（多进程）、扩容</li><li>减少访问人数：预处理（本文不涉及）</li></ol><h1 id="高可用处理手段"><a href="#高可用处理手段" class="headerlink" title="高可用处理手段"></a>高可用处理手段</h1><p>高并发下的高可用很难完全避免，我们处理高可用的手段，其实就是容灾，其不同的‘灾难’，对应不同的容灾级别。</p><p>为了对抗这些不同级别的不确定性，就要付出不同级别的成本，因此可用性也应是有标准的。这标准就是大家常说的 N 个 9。随着 N 的增加，成本也相应增加。</p><p>当然高可用不止包含了容灾级别，也应考虑到故障处理时间。</p><p>我这里则尝试使用‘事情’来分个类。这里的‘事’就是故障，分为：事前（故障发生以前）、事发（故障发生到系统或人感知到故障）、事中（故障发生到故障处理这段时间）、事后（故障结束之后）。</p><p>按照上述分类，不同的阶段应有着不同的技巧：</p><ol><li>事前：副本、隔离、配额、提前预案、探知</li><li>事发：监控、报警</li><li>事中：降级、回滚、应急预案，failXXX 系列</li><li>事后：复盘、思考、技改</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上文简单介绍了高并发系统的设计原则，以及高并发高可用的设计手段，具体的思路请见下文。</p>]]></content>
      
      
      <categories>
          
          <category> 高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 设计原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程安全——线程池</title>
      <link href="/2020/03/27/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E5%8D%81%EF%BC%89/"/>
      <url>/2020/03/27/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E5%8D%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>现在 CPU 都是有多个核心，并行已经成为事实，一方面我们希望最大限度利用机器性能（利用多线程提高吞吐率），另一方面机器的硬件资源是有限的，我们也不能无限制的去申请，这时候我们就需要线程池。它帮我们管理线程，避免频繁创建线程和销毁线程的资源损耗。</p><p>幸运的是，JDK 已经为我们提供了 ExecutorService 的实现，还提供了 Executors 工厂类方便我们生成模板线程池。</p><h1 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h1><p>在 JDK 1.5 之后推出了相关的 api，常见的创建线程池方式有以下几种：</p><ul><li>Executors.newCachedThreadPool()：无限线程池。</li><li>Executors.newFixedThreadPool(nThreads)：创建固定大小的线程池。</li><li>Executors.newSingleThreadExecutor()：创建单个线程的线程池。</li></ul><p>其实看这三种方式创建的源码就会发现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上还是利用 <code>ThreadPoolExecutor</code> 类实现的。</p><h1 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h1><h2 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h2><ul><li><p><code>corePoolSize</code>:<br>指定线程池核心线程的数量</p></li><li><p><code>maximumPoolSize</code>:<br>指定线程池中线程的最大数量</p></li><li><p><code>keepAliveTime</code>:<br>当线程池线程的数量超过 corePoolSize 的时候，多余的空闲线程存活的时间，如果超过了 corePoolSize，在 keepAliveTime 的时间之后，销毁线程</p></li><li><p><code>unit</code>:<br>keepAliveTime 的单位</p></li><li><p><code>workQueue</code>:<br>工作队列，将被提交但尚未执行的任务缓存起来</p></li><li><p><code>threadFactory</code>:<br>线程工厂，用于创建线程，不指定为默认线程工厂 DefaultThreadFactory</p></li><li><p><code>handler</code>:<br>拒绝策略</p></li></ul><h2 id="执行过程："><a href="#执行过程：" class="headerlink" title="执行过程："></a>执行过程：</h2><ol><li><p>如果核心线程还没满，则直接起线程；</p></li><li><p>如果核心线程已满而队列没满则直接入队；</p></li><li><p>如果队列满了但最大线程不够则再起线程达到最大线程；</p></li><li><p>如果队列多了则按抛弃策略来抛弃；</p></li></ol><p>这就是线程池的一个基本运行过程</p><h2 id="成员变量-clt"><a href="#成员变量-clt" class="headerlink" title="成员变量 clt"></a>成员变量 clt</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CAS，无锁并发</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>成员变量 ctl 是由 AtomicInteger 这个类定义的，可以通过 CAS 达到无锁并发，效率比较高。</p><p><strong>这个变量有双重身份，它的高三位表示线程池的状态，低 29 位表示线程池中现有的线程数</strong>，这也是 Doug Lea 一个天才的设计，用最少的变量来减少锁竞争，提高并发效率。</p><h2 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h2><p>关于线程池的状态，有 5 种，</p><ol><li><code>RUNNING</code>: 运行状态，值也是最小的，刚创建的线程池就是此状态。</li><li><code>SHUTDOWN</code>: 停工状态，不再接收新任务，已经接收的会继续执行</li><li><code>STOP</code>: 停止状态，不再接收新任务，已经接收正在执行的，也会中断</li><li><code>TIDYING</code>: 清空状态，所有任务都停止了，工作的线程也全部结束了</li><li><code>TERMINATED</code>: 终止状态，线程池已销毁</li></ol><p>用图表示：</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0_2020-03-27-19-34-26.png" alt="JAVA并发——线程池_2020-03-27-19-34-26.png"></p><h2 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ol><li><p><code>Worker</code>: 本身实现了 Runnable 接口，自然也实现了 run()方法，我们提交的任务实际上也是交给 Worker 来执行。</p></li><li><p><code>Workers</code>: 是一个 HashSet 结构的容器，用来存放要执行的线程。</p></li><li><p><code>WorkQueue</code>: 有界阻塞队列,核心线程已满，队列未满新的任务添加进队列</p></li></ol><h3 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h3><ol><li><p>当我们提交任务到线程池：通过 <code>workerCountOf(c)</code> 提取 Workers 里的 Worker 的数量。如果小于核心线程数，则会尝试进行 <code>addWorker</code> 操作,core为true,否则执行步骤 2。</p></li><li><p>如果 worker 数量大于等于核心线程数根据 c（c 就是 ctl 的值）判断线程池是否还在运行，并且尝试添加任务到队列中。成功则执行 3，失败则执行 4。</p></li><li><p>再次检查线程池的状态，如果线程池没有 RUNNING，且成功从阻塞队列中移除任务，则执行 <code>reject</code> 方法处理任务；</p></li><li><p>那么如果把任务放入阻塞队列失败，即队列已满呢（workQueue.offer(command)返回 false），这时候，直接尝试增加一个 worker，core为false,如果失败，则执行拒绝策略处理该条任务。</p></li></ol><h3 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h3><ol><li><p>判断线程池的状态，如果线程池的状态值大于或等 SHUTDOWN，则不处理提交的任务，直接返回；</p></li><li><p>通过参数 core 判断是否需要创建线程，ture与核心池最大数比较，flase与最大线程数比较，成功则添加Worker。</p></li></ol><h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><ol><li><p>继承了 AQS 类，可以方便的实现工作线程的中止操作；</p></li><li><p>实现了 Runnable 接口，可以将自身作为一个任务在工作线程中执行；</p></li><li><p>当前提交的任务 firstTask 作为参数传入 Worker 的构造方法；</p></li></ol><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0_2020-03-27-20-42-34.png" alt="JAVA并发——线程池_2020-03-27-20-42-34.png"></p><p>注意：这里有一个 Worker 的参数 <code>firsttask</code>，这里为什么第一个任务呢，因为一个 worker 创建出来，一开始会有个任务，这个任务执行完了呢，就会执行 <code>getTask</code> 方法，从队列中去获取任务。</p><h3 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker"></a>runWorker</h3><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0_2020-03-27-20-42-47.png" alt="JAVA并发——线程池_2020-03-27-20-42-47.png"></p><p>runWorker 方法是线程池的核心：</p><ol><li><p>线程启动之后，通过 unlock 方法释放锁，设置 AQS 的 state 为 0，表示运行中断；</p></li><li><p>获取第一个任务 firstTask，执行任务的 run 方法，不过在执行任务之前，会进行加锁操作，任务执行完会释放锁；</p></li><li><p>在执行任务的前后，可以根据业务场景自定义 beforeExecute 和 afterExecute 方法；</p></li><li><p>firstTask 执行完成之后，通过 getTask 方法从阻塞队列中获取等待的任务，如果队列中没有任务，getTask 方法会被阻塞并挂起，不会占用 cpu 资源；</p></li></ol><h3 id="getTask"><a href="#getTask" class="headerlink" title="getTask"></a>getTask</h3><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0_2020-03-27-20-44-24.png" alt="JAVA并发——线程池_2020-03-27-20-44-24.png"></p><p>整个 getTask 操作在自旋下完成：</p><ol><li><p>workQueue.take：如果阻塞队列为空，当前线程会被挂起等待；当队列中有任务加入时，线程被唤醒，take 方法返回任务，并执行；</p></li><li><p>workQueue.poll：如果在 keepAliveTime 时间内，阻塞队列还是没有任务，则返回 null；</p></li></ol><p>所以，线程池中实现的线程可以一直执行由用户提交的任务。</p><h2 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h2><p>线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了 4 种策略：</p><ol><li><p><code>AbortPolicy</code>：直接抛出异常，默认策略；</p></li><li><p><code>CallerRunsPolicy</code>：用调用者所在的线程来执行任务；</p></li><li><p><code>DiscardOldestPolicy</code>：丢弃阻塞队列中靠最前的任务，并执行当前任务；</p></li><li><p><code>DiscardPolicy</code>：直接丢弃任务； 当然也可以根据应用场景实现 RejectedExecutionHandler 接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</p></li></ol><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ol><li><p>可以看到 execute 方法中没有用到重量级锁，ctl 虽然可以保证本身变化的原子性，但是不能保证方法内部的代码块的原子性，是否会有并发问题？</p><p> execute 方法虽然没有加锁，但是在 addWorker 方法内部，加锁了，这样可以保证不会创建超过我们预期的线程数，大师在设计的时候，做到了在最小的范围内加锁，尽量减少锁竞争，</p></li></ol><ol start="2"><li><p>上面提到过，addWorker 方法可以添加工作线程（核心或者非核心），线程本身没有核心或者非核心的标识，core 参数只是用来确定当前线程数的比较对象是线程池设置的核心线程数还是最大线程数，真实情况是不是这样？</p><p>可以看到，core 参数，只是用来判断当前线程数是否超量的时候跟 corePoolSize 还是 maxPoolSize 比较，Worker 本身无核心或者非核心的概念。</p></li><li><p>线程池的线程是如何做到复用的？</p><p> 线程池中的线程在循环中尝试取任务执行，这一步会被阻塞，就是任务在并不只执行创建时指定的 firstTask 第一任务，还会从任务队列的中自己主动取任务执行，而且是有/无时间限定的阻塞等待，保证线程的存活; </p><p> 如果设置了 allowCoreThreadTimeOut 为 true，则线程池中的所有线程都会在 keepAliveTime 时间超时后还未取到任务而退出。或者线程池已经 STOP，那么所有线程都会被中断，然后退出。</p></li><li><p>线程池是如何做到高效并发的？</p><ul><li>线程池状态和工作线程数量的变更。这个由一个 AtomicInteger 变量 ctl 来解决原子性问题。</li><li>向工作 Worker 容器 workers 中添加新的 Worker 的时候。这个线程池本身已经加锁了。</li><li>工作线程 Worker 从等待队列中取任务的时候。这个由工作队列本身来保证线程安全，比如 LinkedBlockingQueue 等。</li></ul></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>线程池对于线程的复用很重要，避免了频繁创建线程造成的内存和 CPU 调度的消耗。</li><li>线程池、队列大小要设计的合理，尽量的让任务从队列中获取执行。</li><li>如果任务多，线程执行时间短可以调大 keepalive 值，使得线程尽量不被回收从而可以复用线程。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 线程安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程安全 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发——线程（二）</title>
      <link href="/2020/03/19/%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/03/19/%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><p><code>进程</code>: 是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。</p><p>可以这样理解，我们在电脑上打开的 eclipse 软件，就会创建一个进程去执行它。</p><p><code>线程</code>: 是指进程中的一个执行单元，一个进程中可以运行多个线程。</p><p>线程没有自己的虚拟地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。</p><h1 id="啥是多线程？-串行，并行，并发"><a href="#啥是多线程？-串行，并行，并发" class="headerlink" title="啥是多线程？ 串行，并行，并发"></a>啥是多线程？ 串行，并行，并发</h1><p><code>多线程</code>： 指的是这个程序（一个进程）运行时产生了不止一个线程。</p><p><code>并发</code>：是指同一个时间段内多个任务同时都在执行，并且都没有执行结束。并发任务强调在一个时间段内同时执行，而一个时间段由多个单位时间累积而成，所以说并发的多个任务在单位时间内不一定同时在执行。</p><p><code>并行</code>：是说在单位时间内多个任务同时在执行 。</p><p>注：在多线程编程实践中，线程的个数往往多于 CPU 的个数，所以一般都称多线程并发编程而不是多线程并行编程。</p><p>举个例子：</p><p>一个程序员一天的工作：看文档 发邮件 摸鱼 写代码 ，正常来说这几件事不可能顺序执行，我们通常都是开会文档摸会鱼，写会代码摸会鱼。</p><p>单核 CPU 处理多线程的调度也是一样，只是看上去让你认为它在同时执行多个任务，实际上只是<strong>串行</strong>执行。</p><p>多核 CPU 处理多线程的调度，就像多个程序员协同工作，有的在看文档，有的在写代码，有的在摸鱼。这时候哪怕有人啥事不干，也比一个人工作效率高。</p><p>那单核 CPU 下还有多线程的必要吗？有的，比如我们写代码时遇到了问题，暂时解决不了，我们不至于停在那儿，可以先去看看文档，找找解决方法。 单核 CPU 下多线程也是如此，有一个任务被堵塞住了，我们可以先执行其他任务。</p><p>所以多核 CPU 下的多线程调度才是真正的并行，也是多线程开发的真正目的。</p><h1 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h1><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B_2020-03-19-17-36-41.png" alt="JAVA并发——线程_2020-03-19-17-36-41.png"></p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B_2020-03-19-17-38-13.png" alt="JAVA并发——线程_2020-03-19-17-38-13.png"></p><ol><li><p>初始化状态：新建一个线程对象</p></li><li><p>可运行状态：其他线程调用了该线程对象的 start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取 CPU 的使用权</p></li><li><p>运行状态：可运行状态的线程获得了 cpu 时间片（timeslice），执行程序代码</p></li><li><p>阻塞状态：线程因为某种原因放弃 CPU 使用权，暂时停止运行。直到线程再次进入可运行状态，才有机会转到运行状态。如图所示，会有三种不同类型的阻塞状态：</p><ul><li>等待阻塞：运行中的线程执行 wait()方法，线程会进入等待队列中。等待 notify()、notifyAll()或 interrupt()对其唤醒或中断</li><li>同步阻塞：运行中的线程执行在获取同步锁（注：只有 synchronized 这种方式的锁（monitor 锁）才会让线程出现 BLOCKED 状态，等待 ReentrantLock 则不会）时，若该锁已被其他线程占用，线程则会进入锁池队列。等待获取到锁</li><li>其他阻塞：运行的线程执行 sleep()、join()，或触发了 I/O 请求，该该线程被置为阻塞状态。当 sleep()状态超时、join()等待线程终止或超时、I/O 处理完成，线程会重新进入可运行状态。</li></ul></li><li><p>死亡状态：线程执行完或因异常退出 run()方法，线程生命周期结束</p></li></ol><h1 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h1><ol><li><p><code>Thread.sleep(long millis)</code> 静态方法。当前线程调用此方法，使当前线程进入阻塞状态（其他阻塞），但不释放任何锁资源，一定时间后线程自动进入 runnable 状态。给其它线程执行机会的最佳方式。</p></li><li><p><code>obj.wait()</code> 或 <code>obj.wait(long timeout)</code> 当前线程调用某对象的 wait()方法，当前线程释放对象锁（wait 一定在 synchronized 代码块/方法中，故一定得到了锁，才进来的此方法），进入阻塞状态（等待队列）。等待 notify 或 wait 设置的 timeout 到期，方可进入另外一个阻塞状态（锁池）。</p></li><li><p><code>t.join()</code> 或 <code>t.join(long millis)</code> 非静态方法。当前线程 A 执行过程中，调用 B 线程的 join 方法，使当前线程进入阻塞状态（其他阻塞），但不释放对象锁，等待 B 线程执行完后或一定时间 millis 后，A 线程进入 runnable 状态。</p></li><li><p><code>Thread.yield()</code> 静态方法。当前线程调用此方法，使线程由 running 态进入 runnable 态，放弃 cpu 使用权，让 cpu 再次选择要执行的线程。 注：实际过程中，yield 仅仅是让其它具有同等优先级的 runnable 线程获取执行权，但并不能保证其它具有同等优先级的线程就一定能获得 cpu 执行权。因为做出让步的当前线程，可能会被 cpu 再次选中，进入 running 状态。yield()不会导致阻塞。</p></li></ol><h1 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h1><ol><li>继承 Thread</li></ol><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B_2020-03-19-17-42-47.png" alt="JAVA并发——线程_2020-03-19-17-42-47.png"></p><p>在这里我们思考一下为什么不直接调用 <code>run（）</code>方法而是去调用 <code>start（）</code>方法？</p><p>线程的 <code>run()</code>方法是由 java 虚拟机直接调用的</p><p>如果我们没有启动线程（没有调用线程的 <code>start()</code>方法）而是在应用代码中直接调用 <code>run()</code>方法，那么这个线程的 <code>run()</code>方法其实运行在当前线程（即 <code>run()</code>方法的调用方所在的线程）之中，而不是运行在其自身的线程中。</p><p>所以就是先访问 start 创建线程 jvm 去调用 <code>run（）</code>方法！</p><p>这种方式的弊端是一个类只能继承一个父类，如果这个类本身已经继承了其它类，就不能使用这种方式了。</p><ol start="2"><li>实现 Runnable 接口</li></ol><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B_2020-03-19-17-48-06.png" alt="JAVA并发——线程_2020-03-19-17-48-06.png"></p><p>实现 Runnable 接口，这种方式的好处是一个类可以实现多个接口，不影响其继承体系。</p><ol start="3"><li>实现 Callabe 接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatingThread04</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"> System.out.println(Thread.currentThread().getId() + <span class="string">" is running"</span>);</span><br><span class="line"> <span class="keyword">return</span> Thread.currentThread().getId();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"> FutureTask&lt;Long&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> CreatingThread04());</span><br><span class="line"> <span class="keyword">new</span> Thread(task).start();</span><br><span class="line"> System.out.println(<span class="string">"等待完成任务"</span>);</span><br><span class="line"> Long result = task.get();</span><br><span class="line"> System.out.println(<span class="string">"任务结果："</span> + result);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FutureTask 可用于异步获取执行结果或取消执行任务的场景。通过传入 Runnable 或者 Callable 的任务给 FutureTask，直接调用其 run 方法或者放入线程池执行，之后可以在外部通过 FutureTask 的 get 方法异步获取执行结果，因此，FutureTask 非常适合用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。</p><ol start="4"><li>定时器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatingThread05</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line"> <span class="comment">// 每隔1秒执行一次</span></span><br><span class="line">        timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> System.out.println(Thread.currentThread().getName() + <span class="string">" is running"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;, <span class="number">0</span> , <span class="number">1000</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用定时器 java.util.Timer 可以快速地实现定时任务，TimerTask 实际上实现了 Runnable 接口。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上文我们讲到了创建线程的几种方法，其中最常见的是继承 Thread 类与实现 Runable 接口，其实 Thread 类的源码也是实现 Runnbale，所以 Runnale 是基础的作业。</p><p>相比 Thread,使用 Runnale 创建线程，由以下好处：</p><ul><li>java 不允许多继承，因此实现了 Runnable 接口的类可以再继承其他类。</li><li>松耦合，将真正处理线程的操作交给一个个 Thread 对象操作。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA并发——死锁（四）</title>
      <link href="/2020/03/19/%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E6%AD%BB%E9%94%81%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2020/03/19/%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E6%AD%BB%E9%94%81%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>如果一个进程集合中的每个进程都在等待只能由此集合中的其他进程才能引发的事件，而无限期陷入僵持的局面称为死锁。</p><h1 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h1><ol><li><p>互斥条件</p><p>临界资源是独占资源，进程应互斥且排他的使用这些资源。</p></li><li><p>占有和等待条件</p><p>进程在请求资源得不到满足而等待时，不释放已占有资源。</p></li><li><p>不剥夺条件</p><p>又称不可抢占，已获资源只能由进程自愿释放，不允许被其他进程剥夺。</p></li><li><p>循环等待条件</p><p>又称环路条件，存在循环等待链，其中，每个进程都在等待链中等待下一个进程所持有的资源，造成这组进程处于永远等待状态。</p></li></ol><h1 id="死锁产生的原因"><a href="#死锁产生的原因" class="headerlink" title="死锁产生的原因"></a>死锁产生的原因</h1><ul><li>当前线程拥有其他线程需要的资源</li><li>当前线程等待其他线程已拥有的资源</li><li>都不放弃自己拥有的资源</li></ul><h1 id="死锁又有哪几种？"><a href="#死锁又有哪几种？" class="headerlink" title="死锁又有哪几种？"></a>死锁又有哪几种？</h1><ol><li>锁顺序死锁</li></ol><p>最简单最常见的死锁：</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E6%AD%BB%E9%94%81_2020-03-19-16-22-13.png" alt="JAVA并发——死锁_2020-03-19-16-22-13.png"></p><ul><li>线程 A 调用 leftRight()方法，得到 left 锁</li><li>同时线程 B 调用 rightLeft()方法，得到 right 锁</li><li>线程 A 和线程 B 都继续执行，此时线程 A 需要 right 锁才能继续往下执行。此时线程 B 需要 left 锁才能继续往下执行。</li><li>但是：线程 A 的 left 锁并没有释放，线程 B 的 right 锁也没有释放。</li><li>所以他们都只能等待，而这种等待是无期限的–&gt;永久等待–&gt;死锁</li></ul><ol start="2"><li>动态锁顺序死锁</li></ol><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E6%AD%BB%E9%94%81_2020-03-19-16-25-07.png" alt="JAVA并发——死锁_2020-03-19-16-25-07.png"></p><p>上面的代码看起来是没有问题的：锁定两个账户来判断余额是否充足才进行转账！</p><p>但是，同样有可能会发生死锁：</p><ul><li>如果两个线程同时调用 transferMoney()</li><li>线程 A 从 X 账户向 Y 账户转账</li><li>线程 B 从账户 Y 向账户 X 转账</li><li>那么就会发生死锁。</li></ul><ol start="3"><li>协作对象之间发生死锁</li></ol><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E6%AD%BB%E9%94%81_2020-03-19-16-26-40.png" alt="JAVA并发——死锁_2020-03-19-16-26-40.png"></p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E6%AD%BB%E9%94%81_2020-03-19-16-26-53.png" alt="JAVA并发——死锁_2020-03-19-16-26-53.png"></p><p>上面的 <code>getImage()</code> 和 <code>setLocation(Point location)</code> 都需要获取两个锁的</p><p>并且在操作途中是没有释放锁的<br>这就是隐式获取两个锁(对象之间协作)..</p><p>这种方式也很容易就造成死锁…..</p><h1 id="死锁解决的方法"><a href="#死锁解决的方法" class="headerlink" title="死锁解决的方法"></a>死锁解决的方法</h1><p>主要有一下三种方法：</p><ul><li>固定加锁的顺序(针对锁顺序死锁)</li><li>开放调用(针对对象之间协作造成的死锁)</li><li>使用定时锁–&gt;tryLock()</li><li>如果等待获取锁时间超时，则抛出异常而不是一直等待！</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>发生死锁的原因主要由于：</p><ul><li><p>线程之间交错执行</p><ul><li>解决：以固定的顺序加锁</li></ul></li><li><p>执行某方法时就需要持有锁，且不释放</p><ul><li>解决：缩减同步代码块范围，最好仅操作共享变量时才加锁</li></ul></li><li><p>永久等待</p><ul><li>解决：使用 tryLock()定时锁，超过时限则返回错误信息</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 死锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程安全——ReetrantLock（九）</title>
      <link href="/2020/03/16/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94ReetrantLock%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
      <url>/2020/03/16/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94ReetrantLock%EF%BC%88%E4%B9%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>synchronized 属于隐式锁，即锁的持有与释放都是隐式的，我们无需干预，而本篇我们要讲解的是显式锁，即锁的持有和释放都必须由我们手动编写。</p><h1 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h1><p>在 Java 1.5 中，官方在 concurrent 并发包中加入了 Lock 接口，该接口中提供了 lock()方法和 unLock()方法对显式加锁和显式释放锁操作进行支持。</p><p>加锁和解锁，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//临界区......</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前线程使用 lock()方法与 unlock()对临界区进行包围，其他线程由于无法持有锁将无法进入临界区直到当前线程释放锁，注意 unlock()操作必须在 finally 代码块中，这样可以确保即使临界区执行抛出异常，线程最终也能正常释放锁。</p><p>Lock 接口还提供了锁以下相关方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可中断获取锁，与lock()不同之处在于可响应中断操作，即在获</span></span><br><span class="line">    <span class="comment">//取锁的过程中可中断，注意synchronized在获取锁时是不可中断的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试非阻塞获取锁，调用该方法后立即返回结果，如果能够获取则返回true，否则返回false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据传入的时间段获取锁，在指定时间内没有获取锁则返回false，如果在指定时间内当前线程未被中并断获取到锁则返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取等待通知组件，该组件与当前锁绑定，当前线程只有获得了锁</span></span><br><span class="line">    <span class="comment">//才能调用该组件的wait()方法，而调用后，当前线程将释放锁。</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>可见 Lock 对象锁还提供了 synchronized 所不具备的其他同步特性：</p><ul><li>如可中断锁的获取</li><li>超时中断锁的获取</li><li>等待唤醒机制的多条件变量 Condition 等</li></ul><p>这也使得 Lock 锁在使用上具有更大的灵活性。</p><h1 id="ReetrantLook"><a href="#ReetrantLook" class="headerlink" title="ReetrantLook"></a>ReetrantLook</h1><p>JDK 1.5 新增的类，实现了 Lock 接口，是一个基于 AQS 并发组件的并发控制类。ReetrantLock 本身也是一种支持重进入的锁，即该锁可以支持一个线程对资源重复加锁，同时也支持公平锁与非公平锁。</p><p>注意： ReetrantLock 支持对同一线程重加锁，但是加锁多少次，就必须解锁多少次，这样才可以成功释放锁。</p><h2 id="并发基础组件-AQS"><a href="#并发基础组件-AQS" class="headerlink" title="并发基础组件 AQS"></a>并发基础组件 AQS</h2><p>主要为两个类：</p><ul><li><p><code>AbstractOwnableSynchronizer</code>：抽象类，定义了存储独占当前锁的线程和获取的方法</p></li><li><p><code>AbstractQueuedSynchronizer</code>：抽象类，AQS 框架核心类，其内部以虚拟队列的方式管理线程的锁获取与锁释放，其中获取锁(tryAcquire 方法)和释放锁(tryRelease 方法)并没有提供默认实现，需要子类重写这两个方法实现具体逻辑，目的是使开发人员可以自由定义获取锁以及释放锁的方式。</p></li></ul><p>AbstractQueuedSynchronizer 又称为队列同步器(后面简称 AQS)，我们来看看它的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AQS抽象类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span>&#123;</span><br><span class="line"><span class="comment">//指向同步队列队头</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指向同步的队尾</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步状态，0代表锁未被占用，1代表锁已被占用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略其他代码......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractQueuedSynchronizer 内部通过 state 来控制同步状态</p><ul><li>当 <code>state=0</code> 时，则说明没有任何线程占有共享资源的锁。</li><li>当 <code>state=1</code> 时，则说明有线程目前正在使用共享变量，其他线程必须加入同步队列进行等待。</li></ul><p>AQS 内部通过内部类 Node 构成双向链表完成 FIFO 的同步队列，同时利用内部类 ConditionObject 构建等待队列。 当 Condition 调用 <code>wait()</code> 方法后，线程将会加入等待队列中，而当 Condition 调用 <code>signal()</code> 方法后，线程将从等待队列转移动同步队列中进行锁竞争。</p><p>同步模型如下：</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94ReetrantLock_2020-03-17-17-13-50.png" alt="JAVA并发——ReetrantLock_2020-03-17-17-13-50.png"></p><p>Node 是 AQS 的内部类，其数据结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">//共享模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">//独占模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标识线程已处于结束状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//等待被唤醒状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//条件状态，</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//在共享模式中使用表示获得的同步状态会被传播</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待状态,存在CANCELLED、SIGNAL、CONDITION、PROPAGATE 4种</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同步队列中前驱结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同步队列中后继结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求锁的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待队列中的后继结点，这个与Condition有关，稍后会分析</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否为共享模式</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取前驱结点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要包含了需要同步的线程本身 以及 线程的状态，如是否被阻塞，是否等待唤醒，是否已经被取消等。每个 Node 结点内部关联其前继结点 prev 和后继结点 next，这样可以方便线程释放锁后快速唤醒下一个在等待的线程。</p><p>SHARED 和 EXCLUSIVE 常量分别代表<strong>共享模式和独占模式</strong>，</p><ul><li>共享模式是一个锁允许多条线程同时操作，如信号量 Semaphore</li><li>独占模式则是同一个时间段只能有一个线程对共享资源进行操作，多余的请求线程需要排队等待，如 ReentranLock。</li></ul><h2 id="基于-ReetrantLock-分析-AQS-独占模式实现过程"><a href="#基于-ReetrantLock-分析-AQS-独占模式实现过程" class="headerlink" title="基于 ReetrantLock 分析 AQS 独占模式实现过程"></a>基于 ReetrantLock 分析 AQS 独占模式实现过程</h2><p>ReentrantLock 内部存在 3 个实现类，分别是 <code>Sync</code>、 <code>NonfairSync</code>、 <code>FairSync</code>。</p><p>其中 <code>Sync</code> 继承自 AQS 实现了解锁 <code>tryRelease()</code> 方法，</p><p>而 <code>NonfairSync</code>(非公平锁)、 <code>FairSync</code>(公平锁)则继承自 Sync，实现了获取锁的 <code>tryAcquire()</code> 方法</p><p>ReentrantLock 的所有方法调用都通过间接调用 AQS 和 Sync 类及其子类来完成的。</p><h3 id="非公平锁实现"><a href="#非公平锁实现" class="headerlink" title="非公平锁实现"></a>非公平锁实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非公平锁实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//执行CAS操作，获取同步状态</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">       <span class="comment">//成功则将独占锁线程设置为当前线程</span></span><br><span class="line">          setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//否则再次请求同步状态</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，通过 CAS 机制保证并发的情况下只有一个线程可以成功将 state 设置为 1，获取到锁；</p><p>此时，其它线程在执行 <code>compareAndSetState</code> 时，因为 state 此时不是 0，所以会失败并返回 false，执行 <code>acquire(1)</code>;再次请求同步：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//再次尝试获取同步状态</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里传入参数 arg 是 state 的值，因为要获取锁，所以这里一般传递参数为 1，进入方法后首先会执行 <code>tryAcquire(1)</code> 方法，在前面分析过该方法在 AQS 中并没有具体实现，而是交由子类实现，因此该方法是由 ReetrantLock 类内部类实现的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NonfairSync类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94ReetrantLock_2020-03-17-17-41-52.png" alt="JAVA并发——ReetrantLock_2020-03-17-17-41-52.png"></p><p>假设有三个线程：线程 1 已经获得到了锁，线程 2 正在同步队列中排队，此时线程 3 执行 lock 方法尝试获取锁的时，线程 1 正好释放了锁，将 state 更新为 0，那么线程 3 就可能在线程 2 还没有被唤醒之前去获取到这个锁。</p><p>如果此时还没有获取到锁（nonfairTryAcquire 返回 false），那么接下来会把该线程封装成 node 去同步队列里排队，代码层面上执行的是 <code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code></p><p>ReetrantLock 为独占锁，所以传入的参数为 <code>Node.EXCLUSIVE</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将请求同步状态失败的线程封装成结点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line"></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">//如果是第一个结点加入肯定为空，跳过。</span></span><br><span class="line">    <span class="comment">//如果非第一个结点则直接执行CAS入队操作，尝试在尾部快速添加</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">//使用CAS执行尾部结点替换，尝试在尾部快速添加</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果第一次加入或者CAS操作没有成功执行enq入队操作</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步队列中的结点会进入一个自旋过程，自旋的意思就是原地转圈圈：即结点都在观察时机准备获取同步状态,自旋过程是在 acquireQueued(addWaiter(Node.EXCLUSIVE), arg))方法中执行的，先看前半部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//自旋，死循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取前结点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            当且仅当p为头结点才尝试获取同步状态,FIFO</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">//此时当前node前驱节点为head且已经tryAcquire获取到了锁，正在执行了它的相关信息</span></span><br><span class="line">                <span class="comment">//已经没有任何用处了，所以现在需要考虑将它GC掉</span></span><br><span class="line">                <span class="comment">//将node设置为头结点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">//清空原来头结点的引用便于GC</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果前驱结点不是head，判断是否挂起线程</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            <span class="comment">//最终都没能获取同步状态，结束该线程的请求</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置为头结点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        head = node;</span><br><span class="line">        <span class="comment">//清空结点数据以便于GC</span></span><br><span class="line">        node.thread = <span class="keyword">null</span>;</span><br><span class="line">        node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然如果前驱结点不是 head 而它又没有获取到锁，那么执行如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果前驱结点不是head，判断是否挂起线程</span></span><br><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;parkAndCheckInterrupt())</span><br><span class="line"></span><br><span class="line">      interrupted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前结点的等待状态</span></span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">        <span class="comment">//如果为等待唤醒（SIGNAL）状态则返回true</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//如果ws&gt;0 则说明是结束状态，</span></span><br><span class="line">        <span class="comment">//遍历前驱结点直到找到没有结束状态的结点</span></span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果ws小于0又不是SIGNAL状态，</span></span><br><span class="line">            <span class="comment">//则将其设置为SIGNAL状态，代表该结点的线程正在等待唤醒。</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将当前线程挂起,线程会阻塞住</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//获取线程中断状态,interrupted()是判断当前中断状态，</span></span><br><span class="line">        <span class="comment">//并非中断线程，因此可能true也可能false,并返回</span></span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常我们在设计队列时，我们需要考虑如何最大化的减少后续排队节点对于 CPU 的消耗，而在 AQS 中，只要当前节点的前驱节点不是头结点，再把当前节点加到队列后就会执行 LockSupport.park(this);将当前线程挂起，这样可以最大程度减少 CPU 消耗。</p><p>AQS 通过最简单的 CAS 和 LockSupport 的 park，设计出了高效的队列模型和机制：</p><ol><li><p>AQS 结构其实是在第二个线程获取锁的时候再初始化的，就是 lazy-Init 的思想，最大程度减少不必要的代码执行的开销</p></li><li><p>为了最大程度上提升效率，尽量避免线程间的通讯，采用了双向链表的 Node 结构去存储线程</p></li><li><p>为了最大程度上避免 CPU 上下文切换执行的消耗，在设计排队线程时，只有头结点的下一个的线程在一直重复执行获取锁，队列后面的线程会通过 LockSupport 进行休眠。</p></li></ol><p>非公平锁的释放：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReentrantLock类的unlock</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AQS类的release()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//尝试释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//唤醒后继结点的线程</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ReentrantLock类中的内部类Sync实现的tryRelease(int releases)</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">      <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">      <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">//判断状态是否为0，如果是则说明已释放同步状态</span></span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">          free = <span class="keyword">true</span>;</span><br><span class="line">          <span class="comment">//设置Owner为null</span></span><br><span class="line">          setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//设置更新同步状态</span></span><br><span class="line">      setState(c);</span><br><span class="line">      <span class="keyword">return</span> free;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>一句话总结：释放锁首先就是把 volatile 类型的变量 state 减 1。state 从 1 变成 0.</p><p>unparkSuccessor(h)的作用的唤醒后续的节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里，node是head节点。</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)<span class="comment">//置零当前线程所在的结点状态，允许失败。</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Node s = node.next;<span class="comment">//找到下一个需要唤醒的结点s</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;<span class="comment">//如果为空或已取消</span></span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)<span class="comment">//从这里可以看出，&lt;=0的结点，都是还有效的结点。</span></span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);<span class="comment">//唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码执行操作来看，这里主要作用是用 unpark()唤醒同步队列中最前边未放弃线程(也就是状态为 CANCELLED 的线程结点 s)。</p><h3 id="公平锁实现"><a href="#公平锁实现" class="headerlink" title="公平锁实现"></a>公平锁实现</h3><p>非公平锁与公平锁最大的区别，即公平锁在线程请求到来时先会判断同步队列是否存在结点，如果存在先执行同步队列中的结点线程，当前线程将封装成 node 加入同步队列等待。</p><p>而非公平锁呢，当线程请求到来时，不管同步队列是否存在线程结点，直接上去尝试获取同步状态，获取成功直接访问共享资源。</p><p>请注意在绝大多数情况下，非公平锁才是我们理想的选择，毕竟从效率上来说非公平锁总是胜于公平锁。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>重入锁 ReentrantLock，是一个基于 AQS 并发框架的并发控制类，其内部实现了 3 个类，分别是 Sync、NoFairSync 以及 FairSync 类，其中 Sync 继承自 AQS，实现了释放锁的模板方法 tryRelease(int)，而 NoFairSync 和 FairSync 都继承自 Sync，实现各种获取锁的方法 tryAcquire(int)。</p><p>ReentrantLock 的所有方法实现几乎都间接调用了这 3 个类，因此当我们在使用 ReentrantLock 时，大部分使用都是在间接调用 AQS 同步器中的方法。</p><p>AQS 在设计时将性能优化到了极致，具体体现在同步队列的 park 和 unpark，初始化 AQS 时的懒加载，以及线程之间通过 Node 这样的数据结构从而避免线程间通讯造成的额外开销，这种由释放锁的线程主动唤醒后续线程的方式也是我们再实际过程中可以借鉴的。</p>]]></content>
      
      
      <categories>
          
          <category> 线程安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程安全 ReetrantLock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程安全——synchronized（八）</title>
      <link href="/2020/03/16/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94synchronized%EF%BC%88%E5%85%AB%EF%BC%89/"/>
      <url>/2020/03/16/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94synchronized%EF%BC%88%E5%85%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>synchronized 是 Java 中的一个关键字，它是一个重量级锁，用于保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块，同时也可以保证可见性，即一个线程的变化可以被其他线程所见。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>synchronized 关键字最主要有以下 3 种应用方式，下面分别介绍</p><ol><li><p>修饰实例方法</p><p>修饰实例方法即为为当前实例加锁。当一个线程正在访问一个对象的 synchronized 实例方法时，其他线程不能访问该对象的其他 synchronized 方法，因为一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他 synchronized 实例方法。</p><p>但是其他线程还是可以访问该实例对象的其他非 synchronized 方法。</p></li><li><p>修饰静态方法</p><p>需要注意的是如果一个线程 A 调用一个实例对象的非 static synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的 class 对象，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。</p></li><li><p>修饰代码块</p><p>如 Synchronized（obj） 这里的 obj 可以为类中的一个属性、也可以是当前的对象，它的同步效果和修饰普通方法一样；Synchronized 方法 （obj.class）静态代码块它的同步效果和修饰静态方法类似。</p></li></ol><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><ol><li><p>原子性</p><p>被 synchronized 修饰的类或对象的所有操作都是原子的，因为在执行操作之前必须先获得类或对象的锁，直到执行完才能释放，这中间的过程无法被中断（除了已经废弃的 stop()方法），确保了同一时刻只有一个线程操作类和对象。</p></li><li><p>可见性</p><p>synchronized 对一个类或对象加锁时，一个线程如果要访问该类或对象必须先获得它的锁，而这个锁的状态对于其他任何线程都是可见的，并且在释放锁之前会将对变量的修改刷新到主存当中，保证资源变量的可见性。</p></li><li><p>有序性</p><p>synchronized 保证了每个时刻都只有一个线程访问同步代码块，也就确定了线程执行同步代码块是分先后顺序的，保证了有序性。</p></li><li><p>可重入性</p><p>synchronized 和 ReentrantLock 都是可重入锁。当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁。通俗一点讲就是说一个线程拥有了锁仍然还可以重复申请锁。</p></li></ol><h1 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h1><p>在 JVM 中，对象是分成三部分存在的：对象头、实例数据、对其填充。</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94synchronized_2020-03-16-21-22-59.png" alt="JAVA并发——synchronized_2020-03-16-21-22-59.png"></p><p>实例数据和对其填充与 synchronized 无关。</p><p>对象头是我们需要关注的重点，它是 synchronized 实现锁的基础，因为 synchronized 申请锁、上锁、释放锁都与对象头有关。</p><p>对象头主要结构是由 <code>Mark Word</code> 和 <code>Class Metadata Address</code>组成，其中 <code>Mark Word</code> 存储对象的 <code>hashCode</code>、锁信息或分代年龄或 GC 标志等信息, <code>Class Metadata Address</code> 是类型指针指向对象的类元数据，JVM 通过该指针确定该对象是哪个类的实例。</p><ol><li>锁状态</li></ol><p>JDK6 之前只有两个状态：无锁、有锁（重量级锁），而在 JDK6 之后对 synchronized 进行了优化，新增了两种状态，总共就是四个状态：<strong>无锁状态、偏向锁、轻量级锁、重量级锁。</strong></p><p>锁的类型和状态在对象头 <code>Mark Word</code> 中都有记录，在申请锁、锁升级等过程中 JVM 都需要读取对象的 <code>Mark Word</code> 数据。</p><ol start="2"><li>Monitor</li></ol><p>每一个锁都对应一个 monitor 对象，在 HotSpot 虚拟机中它是由 ObjectMonitor 实现的（C++实现）。</p><p>每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如 monitor 可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = NULL;</span><br><span class="line">    _count        = <span class="number">0</span>;  <span class="comment">//锁计数器</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = NULL;</span><br><span class="line">    _owner        = NULL;</span><br><span class="line">    _WaitSet      = NULL; <span class="comment">//处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = NULL ;</span><br><span class="line">    _succ         = NULL ;</span><br><span class="line">    _cxq          = NULL ;</span><br><span class="line">    FreeNext      = NULL ;</span><br><span class="line">    _EntryList    = NULL ; <span class="comment">//处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里有几个比较重要的字段:</p><ol><li><p>_owner 指向持有 ObjectMonitor 对象的线程地址。</p></li><li><p>_WaitSet 存放调用 wait 方法，而进入等待状态的线程的队列。</p></li><li><p>_EntryList 这里是等待锁 block 状态的线程的队列。</p></li><li><p>_recursions 锁的重入次数。</p></li><li><p>_count 线程获取锁的次数。</p></li></ol><p>对象监视器会设置几种状态用来区分请求的线程：</p><ul><li>Contention List：所有请求锁的线程将被首先放置到该竞争队列</li><li>Entry List：Contention List 中那些有资格成为候选人的线程被移到 Entry List</li><li>Wait Set：那些调用 wait 方法被阻塞的线程被放置到 Wait Set</li><li>OnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为 OnDeck</li><li>Owner：获得锁的线程称为 Owner</li><li>!Owner：释放锁的线程</li></ul><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94synchronized_2020-03-16-22-00-59.png" alt="JAVA并发——synchronized_2020-03-16-22-00-59.png"></p><h1 id="上锁"><a href="#上锁" class="headerlink" title="上锁"></a>上锁</h1><ol><li><p>线程获取资源对象的锁，判断_owner 是否为空。这里操作是通过 CAS 操作：比较和交换（Conmpare And Swap），比较新值和旧值的不同，替换，这里会发生 ABA 问题，接下来文章会详细说明。</p></li><li><p>如果 _owner 为 null ，直接把其赋值，指向自己， _owner = self ,同时把重入次数 _recursions = 1， 获取锁成功。</p></li><li><p>如果 _self == cur 和当前线程一致，说明是重入了， _recursions++ 即可</p></li><li><p>线程进入对象资源，处理。 同时等待当前线程的释放信号，期间一致持有对象资源的锁。</p></li></ol><h1 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h1><ol><li><p>通过 ObjectMonitor::exit 退出</p></li><li><p>把线程插入到_EntryList 中 _recursions–</p></li><li><p>再次从 _EntryList 中取出线程</p></li><li><p>调用 unpark 退出</p></li></ol><h1 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h1><p>jdk6后，JVM对锁进行了优化，会因实际情况进行膨胀升级，其膨胀方向是：无锁——&gt;偏向锁——&gt;轻量级锁——&gt;重量级锁，并且膨胀方向不可逆。</p><ol><li><p>偏向锁</p><p>如果一个线程获得了锁，那么锁就进入偏向模式，此时 Mark Word 的结构也就变为偏向锁结构，当该线程再次请求锁时，无需再做任何同步操作，即获取锁的过程只需要检查 Mark Word 的锁标记位为偏向锁以及当前线程 ID 等于 Mark Word 的 ThreadID 即可，这样就省去了大量有关锁申请的操作。</p></li><li><p>轻量级锁</p><p>轻量级锁是由偏向锁升级而来，当存在第二个线程申请同一个锁对象时，偏向锁就会立即升级为轻量级锁。注意这里的第二个线程只是申请锁，不存在两个线程同时竞争锁，可以是一前一后地交替执行同步块。</p></li><li><p>重量级锁</p><p>重量级锁是由轻量级锁升级而来，当同一时间有多个线程竞争锁时，锁就会被升级成重量级锁，此时其申请锁带来的开销也就变大。</p></li></ol><h1 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h1><p>消除锁是虚拟机另外一种锁的优化，这种优化更彻底，在 JIT 编译时，对运行上下文进行扫描，去除不可能存在竞争的锁。</p><h1 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h1><p>锁粗化是虚拟机对另一种极端情况的优化处理，通过扩大锁的范围，避免反复加锁和释放锁。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>synchronized 本身并不是锁，只是一个 JVM 定义的关键字。</p><p>被 synchronized 修饰的对象都有一个对应的监视器对象，多个线程同时访问对象的一系列加锁、释放锁的操作，都是通过对监视器对象的变量进行操作实现的。</p><p>synchronized的底层也是一个基于CAS操作的等待队列，但JVM实现的更精细，把等待队列分为ContentionList和EntryList，目的是为了降低线程的出列速度；当然也实现了偏向锁，从数据结构来说二者设计没有本质区别。但synchronized还实现了自旋锁，并针对不同的系统和硬件体系进行了优化，而Lock则完全依靠系统阻塞挂起等待线程。</p>]]></content>
      
      
      <categories>
          
          <category> 线程安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程安全 synchronized </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程安全——锁</title>
      <link href="/2020/03/16/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E9%94%81%EF%BC%88%E4%B8%83%EF%BC%89/"/>
      <url>/2020/03/16/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E9%94%81%EF%BC%88%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是锁？"><a href="#什么是锁？" class="headerlink" title="什么是锁？"></a>什么是锁？</h1><p>锁是在执行多线程时用于强行限制资源访问的同步机制，即用于在并发控制中保证对互斥要求的满足。</p><h1 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h1><ul><li>从线程是否需要对资源加锁可以分为 <code>悲观锁</code> 和 <code>乐观锁</code></li><li>从资源已被锁定，线程是否阻塞可以分为 <code>自旋锁</code></li><li>从多个线程并发访问资源，也就是 Synchronized 可以分为 <code>无锁</code>、<code>偏向锁</code>、 <code>轻量级锁</code> 和 <code>重量级锁</code></li><li>从锁的公平性进行区分，可以分为 <code>公平锁</code> 和 <code>非公平锁</code></li><li>从根据锁是否重复获取可以分为 <code>可重入锁</code> 和 <code>不可重入锁</code></li><li>从那个多个线程能否获取同一把锁分为 <code>共享锁</code> 和 <code>排他锁</code></li></ul><h1 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h1><p><code>悲观锁</code> 是一种悲观思想，它总认为最坏的情况可能会出现，它认为数据很可能会被其他人所修改，所以悲观锁在持有数据的时候总会把 <code>资源</code> 或者 <code>数据</code> 锁住，这样其他线程想要请求这个资源的时候就会阻塞，直到等到悲观锁把资源释放为止。传统的关系型数据库里边就用到了很多这种锁机制，<strong>比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</strong> 悲观锁的实现往往依靠数据库本身的锁功能实现。</p><p>Java 中的 <code>Synchronized</code> 和 <code>ReentrantLock</code> 等独占锁(排他锁)也是一种悲观锁思想的实现，因为 Synchronzied 和 ReetrantLock 不管是否持有资源，它都会尝试去加锁，生怕自己心爱的宝贝被别人拿走。</p><h1 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h1><p>乐观锁的思想与悲观锁的思想相反，它总认为资源和数据不会被别人所修改，所以读取不会上锁，但是乐观锁在进行写入操作的时候会判断当前数据是否被修改过(具体如何判断我们下面再说)。</p><ol><li><p>乐观锁的实现方式</p><p> 乐观锁的实现方案一般来说有两种： <code>版本号机制</code> 和 <code>CAS实现</code> 。乐观锁多适用于多度的应用类型，这样可以提高吞吐量。</p><p> 在 Java 中 <code>java.util.concurrent.atomic</code> 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。</p><p> <code>版本号机制</code>: 版本号机制是在数据表中加上一个 version 字段来实现的，表示数据被修改的次数，当执行写操作并且写入成功后，version = version + 1，当线程 A 要更新数据时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。</p><p> <code>CAS 算法</code>: CAS 即 <code>compare and swap</code>（比较与交换），是一种有名的无锁算法。即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization) java 的 cas 利用的的是 unsafe 这个类提供的 cas 操作。</p></li><li><p>CAS 的骚操作</p><p><code>CAS 中涉及三个要素</code>：</p><ul><li><p>需要读写的内存值 V</p></li><li><p>进行比较的值 A</p></li><li><p>拟写入的新值 B</p><p>当一个线程从内存中读取的值为 V,将当前值 A 与 V 比较，如果相等，则将 B 写入内存；如果不相等，则代表中间由线程修改过这个值，这样我们就要去重复一开始的操作。</p><p><code>java8 对 CAS 的优化</code>：</p><p>线程太多，就会出现一个问题：V 的值老是被修改了，所以线程要一值重复操作。白白着在那里循环消耗资源。</p><p>为了解决这个问题，Java8 引入了一个 cell[] 数组，它的工作机制是这样的：假如有 5 个线程要对 i 进行自增操作，由于 5 个线程的话，不是很多，起冲突的几率较小，那就让他们按照以往正常的那样，采用 CAS 来自增吧。</p><p>但是，</p><p>如果有 100 个线程要对 i 进行自增操作的话，这个时候，冲突就会大大增加，系统就会把这些线程分配到不同的 cell 数组元素去，假如 cell[10] 有 10 个元素吧，且元素的初始化值为 0，那么系统就会把 100 个线程分成 10 组，每一组对 cell 数组其中的一个元素做自增操作，这样到最后，cell 数组 10 个元素的值都为 10，系统在把这 10 个元素的值进行汇总，进而得到 100，二这，就等价于 100 个线程对 i 进行了 100 次自增操作。</p></li></ul></li><li><p>乐观锁的缺点</p><p> <code>ABA 问题</code>：</p><p> ABA 问题说的是，如果一个变量第一次读取的值是 A，准备好需要对 A 进行写操作的时候，发现值还是 A，那么这种情况下，能认为 A 的值没有被改变过吗？</p><p> JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><p> 也可以采用 CAS 的一个变种 DCAS 来解决这个问题。 DCAS，是对于每一个 V 增加一个引用的表示修改次数的标记符。对于每个 V，如果引用修改了一次，这个计数器就加 1。然后再这个变量需要 update 的时候，就同时检查变量的值和计数器的值。</p><p> <code>循环开销大</code>:</p><p> 我们知道乐观锁在进行写操作的时候会判断是否能够写入成功，如果写入不成功将触发等待 -&gt; 重试机制，这种情况是一个自旋锁，简单来说就是适用于短期内获取不到，进行等待重试的锁，它不适用于长期获取不到锁的情况，另外，自旋循环对于性能开销比较大。</p></li></ol><h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><p>自旋锁的定义：当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别人获取(占用)，那么此线程就无法获取到这把锁，该线程将会等待，间隔一段时间后会再次尝试获取。这种采用循环加锁 -&gt; 等待的机制被称为 <code>自旋锁(spinlock)</code>。</p><ol><li><p>自旋锁的原理</p><p> 如果持有锁的线程能在短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞状态，它们只需要等一等(自旋)，等到持有锁的线程释放锁之后即可获取，这样就避免了用户进程和内核切换的消耗。</p></li><li><p>自旋锁的缺点</p><p> 如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX；同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 cpu 的线程又不能获取到 cpu，造成 cpu 的浪费。</p></li></ol><h1 id="适应性自旋锁"><a href="#适应性自旋锁" class="headerlink" title="适应性自旋锁"></a>适应性自旋锁</h1><pre><code>解决上面这种情况一个很好的方式是给自旋锁设定一个自旋时间，等时间一到立即释放自旋锁。但是如何去选择自旋时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！JDK 在 1.6 引入了适应性自旋锁，适应性自旋锁意味着自旋时间不是固定的了，而是由前一次在同一个锁上的自旋时间以及锁拥有的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间。</code></pre><h1 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h1><p>无锁即没有对资源进行锁定，所有的线程都可以对同一个资源进行访问，但是只有一个线程能够成功修改资源，这很像我们在之前文章中介绍的 CAS 实现，CAS 的原理和应用就是无锁的实现。</p><h1 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h1><p>大多数情况下，锁不仅不存在多线程竞争，还存在锁由同一线程多次获得的情况，偏向锁就是在这种情况下出现的，它的出现是为了解决只有在一个线程执行同步时提高性能。</p><h1 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h1><p>轻量级锁是指当前锁是偏向锁的时候，资源被另外的线程所访问，那么偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能，下面是详细的获取过程。</p><h1 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h1><p>轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止 CPU 空转。</p><h1 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h1><p>表示线程获取锁的顺序是按照线程加锁的顺序来分配的，即先来先得的 FIFO 先进先出顺序。公平锁可以由 ReentrantLook 实现。</p><h1 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h1><p>就是一种获取锁的抢占机制，是随机获得锁的，和公平锁不一样的就是先来的不一定先得到锁，这个方式可能造成某些线程一直拿不到锁，结果也就是不公平的了。</p><h1 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h1><p>可重入锁又称为递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者 class），不会因为之前已经获取过还没释放而阻塞。Java 中 ReentrantLock 和 synchronized 都是可重入锁，可重入锁的一个优点是在一定程度上可以避免死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"doSomething..."</span>);</span><br><span class="line">  doSomethingElse();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomethingElse</span><span class="params">()</span></span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"doSomethingElse..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这段代码中，我们对 doSomething() 和 doSomethingElse() 分别使用了 synchronized 进行锁定，doSomething() 方法中调用了 doSomethingElse() 方法，因为 synchronized 是可重入锁，所以同一个线程在调用 doSomething() 方法时，也能够进入 doSomethingElse() 方法中。</p><h1 id="不可重入锁"><a href="#不可重入锁" class="headerlink" title="不可重入锁"></a>不可重入锁</h1><p>如果 synchronized 是不可重入锁的话，那么在调用 doSomethingElse() 方法的时候，必须把 doSomething() 的锁丢掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</p><p>也就是说，不可重入锁会造成死锁</p><h1 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h1><p>独占锁又叫做排他锁，是指锁在同一时刻只能被一个线程拥有，其他线程想要访问资源，就会被阻塞。JDK 中 synchronized 和 JUC 中 Lock 的实现类就是互斥锁。</p><h1 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h1><p>共享锁指的是锁能够被多个线程所拥有，如果某个线程对资源加上共享锁后，则其他线程只能对资源再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p><p>我们看到 ReentrantReadWriteLock 有两把锁：ReadLock 和 WriteLock，也就是一个读锁一个写锁，合在一起叫做读写锁。</p>]]></content>
      
      
      <categories>
          
          <category> 线程安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程安全 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程安全——并发容器（六）</title>
      <link href="/2020/03/14/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%EF%BC%88%E5%85%AD%EF%BC%89/"/>
      <url>/2020/03/14/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%EF%BC%88%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是并发容器？"><a href="#什么是并发容器？" class="headerlink" title="什么是并发容器？"></a>什么是并发容器？</h1><p>因为同步容器将所有对容器状态的访问都串行化了，这样保证了线程的安全性，所以这种方法的代价就是严重降低了并发性，当多个线程竞争容器时，吞吐量严重降低。</p><p>相对同步容器而言，并发容器通过一些机制改进了并发性能。</p><h1 id="并发容器类型"><a href="#并发容器类型" class="headerlink" title="并发容器类型"></a>并发容器类型</h1><ol><li><p>ConcurrentHashMap</p><p> ConcurrentHashMap 在 JDK7 加锁的时候根据散列值锁住了散列值锁对应的那段，因此提高了并发性能。</p><p> 当然 ConcurrentHashMap 在 JDK8 以后不在使用分段储存，而是使用类似乐观锁的方式（<code>CAS + synchronized</code>）来达到多线程安全的目的。</p></li><li><p>CopyOnWriteArrayList 和 CopyOnWriteArraySet</p><p> 分别代替 List 和 Set，主要是在遍历操作为主的情况下来代替同步的 List 和同步的 Set，这也就是上面所述的思路：迭代过程要保证不出错，除了加锁，另外一种方法就是”克隆”容器对象。</p></li><li><p>ConcurrentLinkedQuerue</p><p> 是一个先进先出的队列。它是非阻塞队列。</p></li><li><p>ConcurrentSkipListMap</p></li></ol><p>可以在高效并发中替代 SoredMap（例如用 Collections.synchronzedMap 包装的 TreeMap）。</p><ol start="5"><li>ConcurrentSkipListSet</li></ol><p>可以在高效并发中替代 SoredSet（例如用 Collections.synchronzedSet 包装的 TreeMap）。</p><h1 id="CopyOnWrite"><a href="#CopyOnWrite" class="headerlink" title="CopyOnWrite"></a>CopyOnWrite</h1><ol><li>什么是 CopyOnWrite 容器？</li></ol><p>CopyOnWrite 容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行 Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。</p><p>这样做的好处是我们可以对 CopyOnWrite 容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以 CopyOnWrite 容器也是一种读写分离的思想，读和写不同的容器。</p><p>CopyOnWrite 并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景。</p><ol start="3"><li><p>CopyOnWrite 容器存在的问题？</p><p> <code>内存占用问题</code>：因为 CopyOnWrite 的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象。如果这些对象占用的内存比较大，比如说 200M 左右，那么再写入 100M 数据进去，内存就会占用 300M，那么这个时候很有可能造成频繁的 Yong GC 和 Full GC。</p><p> <code>数据一致性问题</code>：CopyOnWrite 容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用 CopyOnWrite 容器。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 线程安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程安全 并发容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程安全——同步容器（五）</title>
      <link href="/2020/03/14/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2020/03/14/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>像 ArrayList、LinkedList、HashMap 这些容器都是非线程安全的，如果有多个线程并发地访问这些容器时，就会出现问题。因此，在编写程序时，必须要求程序员手动地在任何访问到这些容器的地方进行同步处理，这样导致在使用这些容器的时候非常地不方便。</p><p>所以，Java 提供了同步容器供用户使用。</p><h1 id="同步容器分为以下几类"><a href="#同步容器分为以下几类" class="headerlink" title="同步容器分为以下几类"></a>同步容器分为以下几类</h1><ul><li>List -&gt; Vector,Stack</li><li>Map -&gt; HashTable</li><li>Collections.synchronizedXXX(List、Set、Map)</li></ul><h1 id="同步容器的缺陷"><a href="#同步容器的缺陷" class="headerlink" title="同步容器的缺陷"></a>同步容器的缺陷</h1><ol><li><p>性能问题</p><p> 锁粒度大，进行同样多的插入操作，Vector 的耗时是 ArrayList 的两倍。</p><p> 另外，由于 Vector 中的 add 方法和 get 方法都进行了同步，因此，在有多个线程进行访问时，如果多个线程都只是进行读取操作，那么每个时刻就只能有一个线程进行读取，其他线程便只能等待，这些线程必须竞争同一把锁。。</p></li><li><p>线程不是绝对安全（list集合）</p><p> 例如有两个线程，线程A根据size的值循环执行remove操作，而线程B根据size的值循环执行执行get操作。它们都需要调用size获取容器大小，当循环到最后一个元素时，若线程A先remove了线程B需要get的元素，那么就会报越界错误。</p><p> 单线程环境下的解决方法：Itr 类中给出了一个 remove()方法。但是在多线程并不适用，因为 Iterator.remove()并不是安全的。</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由上文可知，同步容器存在性能问题，又难做到完全的线程安全。这个时候我们就需要使用并发容器。</p>]]></content>
      
      
      <categories>
          
          <category> 线程安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程安全 同步容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程安全——线程封闭（四）</title>
      <link href="/2020/03/14/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2020/03/14/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是线程封闭？"><a href="#什么是线程封闭？" class="headerlink" title="什么是线程封闭？"></a>什么是线程封闭？</h1><p>实现好的并发是一件困难的事情，所以很多时候我们都想躲避并发。避免并发最简单的方法就是线程封闭。</p><p>就是把对象封装到一个线程里，只有这一个线程能看到此对象。那么这个对象就算不是线程安全的也不会出现任何安全问题。</p><h1 id="实现线程封闭的方法？"><a href="#实现线程封闭的方法？" class="headerlink" title="实现线程封闭的方法？"></a>实现线程封闭的方法？</h1><ol><li><p>栈封闭</p><p> 什么是栈封闭呢？简单的说就是局部变量。</p></li><li><p>ThreadLocal 封闭</p><p> ThreadLocal 翻译成中文比较准确的叫法应该是：线程局部变量。</p><p> 其实 ThreadLocal 内部维护了一个 Map，Map 的 key 是每个线程的名称，value 就是我们要封闭的对象。每个线程中的对象都对应着 Map 中一个值，也就是 ThreadLocal 利用 Map 实现了对象的线程封闭。</p><p> 比如说 DAO 的数据库连接，我们知道 DAO 是单例的，那么他的属性 Connection 就不是一个线程安全的变量。而我们每个线程都需要使用他，并且各自使用各自的。这种情况，ThreadLocal 就比较好的解决了这个问题。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ConnectionUtil</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Connection&gt; conn = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection con = conn.get();</span><br><span class="line">        <span class="keyword">if</span> (con == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">                con = DriverManager.getConnection(<span class="string">"url"</span>, <span class="string">"userName"</span>, <span class="string">"password"</span>);</span><br><span class="line">                conn.set(con);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> con;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这样子，都是用同一个连接，但是每个连接都是新的，是同一个连接的副本。</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ThreadLocal并不是去解决多线程共享变量的问题，而是为每一个线程在本地维护一个与其他线程隔离的实例。</p>]]></content>
      
      
      <categories>
          
          <category> 线程安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程安全 线程封闭 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程安全——不可变对象（三）</title>
      <link href="/2020/03/13/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2020/03/13/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有一种对象发布了就是安全的，即不可变对象。</p><h1 id="不可变对象需要满足的条件"><a href="#不可变对象需要满足的条件" class="headerlink" title="不可变对象需要满足的条件"></a>不可变对象需要满足的条件</h1><ul><li>对象创建以后其状态就不可修改</li><li>对象所有域都是 final 类型</li><li>对象都是正确创建的（安全发布）</li></ul><h1 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h1><ul><li>修饰类：不能被继承，final 类中的变量可以根据需要设置为 final，final 类中的方法隐式的被设置为 final 方法。</li><li>修饰方法：不能被继承类修改，一个类的 private 方法会被隐式的指定为 final 方法。</li><li>修饰变量：<ul><li>基本数据类型变量：初始化之后，值不会改变。</li><li>引用数据类型变量：初始化之后，不能指向另外的引用。</li></ul></li></ul><h1 id="Collections-unmodifiableXXX"><a href="#Collections-unmodifiableXXX" class="headerlink" title="Collections.unmodifiableXXX"></a>Collections.unmodifiableXXX</h1><p>被这个类方法修饰的 Collection、List、Set、Map…为不可变对象。</p><h1 id="Guava-InmutableXXX"><a href="#Guava-InmutableXXX" class="headerlink" title="Guava:InmutableXXX"></a>Guava:InmutableXXX</h1><p>初始化方法包含的 Collection、List、Set、Map…为不可变对象。</p>]]></content>
      
      
      <categories>
          
          <category> 线程安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程安全 不可变对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程安全——安全发布对象（二）</title>
      <link href="/2020/03/13/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/03/13/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="对象发布和溢出"><a href="#对象发布和溢出" class="headerlink" title="对象发布和溢出"></a>对象发布和溢出</h1><ul><li>对象发布：使对象能够被当前范围之外的代码所使用。</li><li>对象溢出：一种错误的发布，使对象还未构造完成就被其他线程看见。</li></ul><p>不正确的发布可变对象导致的两种错误：</p><ol><li>发布线程意外的所有线程都可以看到被发布对象的过期的值</li><li>线程看到的被发布对象的引用是最新的，然而被发布对象的状态却是过期的</li></ol><h1 id="安全发布对象的四种方式"><a href="#安全发布对象的四种方式" class="headerlink" title="安全发布对象的四种方式"></a>安全发布对象的四种方式</h1><ol><li>在静态初始化函数中初始化一个对象引用</li><li>将对象的应用保存到 volatile 类型的域或者 AtomicReferance 对象中</li><li>将对象的引用保存到某个正确构造对象的 final 类型域中</li><li>将对象的引用保存到一个由锁保护的域中。</li></ol><p>以上所提到的几种方法都可以应用到单例模式中。</p><h1 id="懒汉式单例"><a href="#懒汉式单例" class="headerlink" title="懒汉式单例"></a>懒汉式单例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉模式 -》 双重同步锁单例模式</span></span><br><span class="line"><span class="comment"> * 单例实例在第一次使用时进行创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample4</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、memory = allocate() 分配对象的内存空间</span></span><br><span class="line">    <span class="comment">// 2、ctorInstance() 初始化对象</span></span><br><span class="line">    <span class="comment">// 3、instance = memory 设置instance指向刚分配的内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// JVM和cpu优化，发生了指令重排（多线程 ）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、memory = allocate() 分配对象的内存空间</span></span><br><span class="line">    <span class="comment">// 3、instance = memory 设置instance指向刚分配的内存</span></span><br><span class="line">    <span class="comment">// 2、ctorInstance() 初始化对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象 volatile + 双重检测机制 -&gt; 禁止指令重排</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">volatile</span>  <span class="keyword">static</span> SingletonExample4 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 双重检测机制        // B</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonExample4<span class="class">.<span class="keyword">class</span>) </span>&#123; <span class="comment">// 同步锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonExample4(); <span class="comment">// A - 3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="饿汉模式单例"><a href="#饿汉模式单例" class="headerlink" title="饿汉模式单例"></a>饿汉模式单例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉模式</span></span><br><span class="line"><span class="comment"> * 单例实例在类装载时进行创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample2 instance = <span class="keyword">new</span> SingletonExample2();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="静态内部类单例"><a href="#静态内部类单例" class="headerlink" title="静态内部类单例"></a>静态内部类单例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用静态内部类实现的单例模式-线程安全</span></span><br><span class="line"><span class="comment"> * 实例在第一次使用的时候创建</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample8</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态工厂方法-获取实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> instance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample8 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用静态内部类创建单例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonExample8 INSTANCE = <span class="keyword">new</span> SingletonExample8();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="枚举模式"><a href="#枚举模式" class="headerlink" title="枚举模式"></a>枚举模式</h1><p>上面实现的单例模式不是完全安全的，我们都可以通过反射机制去获取私有构造器更改其访问级别从而实例化多个不同的对象。<br>这时我们就需要使用到内部枚举类了，因为JVM可以阻止反射获取枚举类的私有构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举模式：最安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="meta">@Recommend</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample7</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample7</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample7 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> SingletonExample7 singleton;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// JVM保证这个方法绝对只调用一次</span></span><br><span class="line">        Singleton() &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> SingletonExample7();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SingletonExample7 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 线程安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程安全 安全发布对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程安全——概念及三要素（一）</title>
      <link href="/2020/03/13/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%B8%89%E8%A6%81%E7%B4%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/03/13/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%B8%89%E8%A6%81%E7%B4%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>当多个线程同时访问某个类时，不管运行时环境采用何种调用方式，或者这些进程如何交替执行，并且在主调代码中不需要额外的同步和协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。</p><h1 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h1><ol><li>原子性：提供了互斥访问，同一时刻只能有一个线程对他进行操作。</li><li>可见性：一个线程对主内存的修改可以及时的被其他线程观察到。</li><li>有序性：一个线程观察其他线程的指令执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序。</li></ol><h1 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h1><ol><li><p>什么是原子操作？</p><p> 原子是世界上的最小单位，具有不可分割性。比如 a=0；（a 非 long 和 double 类型）这个操作是不可分割的，那么我们说这个操作时原子操作。再比如：a++；这个操作实际是 a = a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。</p></li><li><p>如何保证原子性？</p><p><code>原子类</code>: 比如：AtomicInteger、AtomicLong、AtomicReference 等。 原子类底层实现通常借助于本地方法 Unsafe 及 CAS 实现，每次执行计算之前都会拿当前工作内存中的值和主内存的值比较，如果不相同就会从新从主内存中获取最新值赋值给当前对象，直到相同执行对应操作。</p><p><code>同步锁</code>: synchronsized、lock等。</p></li><li><p>原子类的不足（ABA问题）</p><p> 我们知道原子操作都是基于 cas 来保障原子性，但同时在 cas 中又会存在 ABA 问题，当一个线程对一个对象的值进行 cas 操作时，另外一个线程对值进行了两次修改，值最后改为旧值，此时就无法判断对象是否会被修改。</p><p> 为了解决 ABA 问题，伟大的 java 为我们提供了 AtomicMarkableReference 和 AtomicStampedReference 类，为我们解决了问题。<br> AtomicStampedReference 是利用版本戳的形式记录了每次改变以后的版本号，这样的话就不会存在 ABA 问题了。</p></li></ol><h1 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h1><ol><li><p>什么是可见性?</p><p> 可见性是指，当多个线程并发访问共享变量时，一个线程对共享变量的修改，其它线程能够立即看到。可见性问题是好多人忽略或者理解错误的一点。</p><p> CPU 从主内存中读数据的效率相对来说不高，现在主流的计算机中，都有几级缓存。每个线程读取共享变量时，都会将该变量加载进其对应 CPU 的高速缓存里，修改该变量后，CPU 会立即更新该缓存，但并不一定会立即将其写回主内存（实际上写回主内存的时间不可预期）。此时其它线程（尤其是不在同一个 CPU 上执行的线程）访问该变量时，从主内存中读到的就是旧的数据，而非第一个线程更新后的数据。</p></li><li><p>怎么保证可见性？</p><p> volatile 关键字，java 使用 volatile 关键字来保证可见性，通过加入 <code>内存屏障</code> 来实现。</p><p> <code>内存屏障</code> 是一个 CPU 指令。编译器和 CPU 可以在保证输出结果一样的情况下对指令重排序，使性能得到优化。插入一个内存屏障， 相当于告诉 CPU 和编译器先于这个命令的必须先执行，后于这个命令的必须后执行；另一个作用是强制更新一次不同 CPU 的缓存。例如，一个写屏障会 把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个 cpu 核心或者哪颗 CPU 执行的。</p><p> 注：volatile并不能保证原子性</p></li></ol><h1 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h1><ol><li><p>什么是有序性？</p><p> 处理器为了提高程序整体的执行效率，可能会对代码进行优化，其中的一项优化方式就是调整代码顺序，按照更高效的顺序执行代码。</p></li><li><p>如何保证有序性？</p><p> Java 中可通过 volatile 在一定程序上保证顺序性，另外还可以通过 synchronized 和锁来保证顺序性。</p><p> synchronized 和锁保证顺序性的原理和保证原子性一样，都是通过保证同一时间只会有一个线程执行目标代码段来实现的。</p><p> 除了从应用层面保证目标代码段执行的顺序性外，JVM 还通过被称为 <code>happens-before</code> 原则隐式地保证顺序性。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 线程安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程安全 三要素 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发——并发模拟（三）</title>
      <link href="/2020/03/13/%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E6%A8%A1%E6%8B%9F%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2020/03/13/%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E6%A8%A1%E6%8B%9F%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="并发模拟工具"><a href="#并发模拟工具" class="headerlink" title="并发模拟工具"></a>并发模拟工具</h1><ol><li><p>Postman : Http 请求模拟工具</p></li><li><p>Apache Bench(AB) : Apache 附带的工具,测试网站性能</p></li><li><p>Jmeter : Apache 组织开发的压力测试工具</p></li></ol><h1 id="并发模拟代码"><a href="#并发模拟代码" class="headerlink" title="并发模拟代码"></a>并发模拟代码</h1><ol><li>CountDownLatch</li></ol><p>CountDownLatch 能够使一个线程在等待另外一些线程完成各自工作之后，再继续执行。使用一个计数器进行实现。计数器初始值为线程的数量。当每一个线程完成自己任务后，计数器的值就会减一。当计数器的值为 0 时，表示所有的线程都已经完成了任务，然后在 CountDownLatch 上等待的线程就可以恢复执行任务。</p><ol start="2"><li>Semaphore</li></ol><p>Semaphore 是一种基于计数的信号量。它可以设定一个阈值，也可称作并发数，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。</p><p>Semaphore 可以用来构建一些对象池，资源池之类的，比如数据库连接池，我们也可以创建计数为 1 的 Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。</p><h2 id="并发代码"><a href="#并发代码" class="headerlink" title="并发代码"></a>并发代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> modules;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//信号量，此处用于控制并发的线程数</span></span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="comment">//闭锁，可实现计数器递减</span></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//执行此方法用于获取执行许可，当总计未释放的许可数不超过200时，</span></span><br><span class="line">                <span class="comment">//允许通行，否则线程阻塞等待，直到获取到许可。</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    <span class="comment">//释放许可</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">//log.error("exception", e);</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//闭锁减一</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();<span class="comment">//线程阻塞，直到闭锁值为0时，阻塞才释放，继续往下执行</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"count:&#123;&#125;"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果安装以上代码执行，并不一定是线程安全的，原因是 count++操作在并发环境下不能保证数据一致性问题，这就涉及到线程安全的问题，请看<a href="JAVA并发——线程安全">下一章</a></p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发——原理（一）</title>
      <link href="/2020/03/11/%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/03/11/%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>如果程序在单核处理器上运行，多个线程将交替地换入或者换出内存，这些线程是同时“存在”的，每个线程都处于执行过程中的某个状态，高速切换感觉同时执行。</p><p>如果运行多核处理器上，此时，程序中的每个线程将分配到一个处理器核上，因此可以真正的同时运行。</p><p>我们在讨论并发时主要考虑以下几点：</p><ul><li>多线程操作相同的资源</li><li>保证线程安全</li><li>合理分配和使用资源</li></ul><h1 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h1><p>高并发（High Cuncurrency）是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并发处理很多请求。</p><p>我们在讨论高并发时主要考虑以下几点？</p><ul><li>服务器能同时处理很多个请求</li><li>提高程序性能</li></ul><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>我们知道，计算机系统中运行速度最快就是 CPU，其他部件例如：内存、磁盘、网络等等都是及其缓慢的，同时这些操作在目前的计算机体系中是很难消除的，因为我们不可能仅仅靠寄存器就完成所有的计算任务。</p><p>面对高速 CPU 和低速存储之间的鸿沟，如果想要实现高效数据通讯，一个良好的解决方案就是在它们之间添加一个 cache 层，这个 cache 层的速度和整体的速度关系如下：</p><blockquote><p>CPU –&gt; cache –&gt; 存储</p></blockquote><p>这是计算机和软件领域通用的一个问题解决方案：增加中间层。没有什么问题是一个中间层解决不了的，如果有，那就两层。在运算的时候，CPU 将需要使用到的数据复制到 Cache 中，以后每次获取数据都从较为快速的 cache 中获取，加快访问速度。</p><h1 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h1><p>所谓理想很丰面，现实很骨感。这种计算体系有一个重要的问题需要解决，那就是：缓存一致性（cache coherence）问题。</p><p>因此，当多个处理器同时需要访问同一个内存区域的数据时，首先回去访问 CPU 的 cache 区域中的数据，但是 cache 中的数据也是从共享内存中获取的，此时如果别的 CPU 修改了 cache 中的数据，那么就造成了数据不一致的问题了。</p><h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><p>在现代的计算机系统中，主要都是多核系统为主。在这些计算机系统中，每一个 CPU 都拥有自己独立的高速缓存，但是因为主存只有一个，因此它们之间只能共享，这种系统也称为：共享内存多核系统（Shared-Memory multiprocessors System），如下图所示：</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80_2020-03-11-20-08-57.png" alt="JAVA并发——基础_2020-03-11-20-08-57.png"></p><h1 id="一致性协议"><a href="#一致性协议" class="headerlink" title="一致性协议"></a>一致性协议</h1><p>各个 CPU 在操作的时候都需要遵守缓存一致性协议来进行操作，这类型的协议有很多，例如：MSI、MESI、MOSI、Synapse、Firefly 以及 Dragon Protocol 等等。所以，通常情况下，共享内存多核系统的架构如下所示：</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80_2020-03-11-20-12-11.png" alt="JAVA并发——基础_2020-03-11-20-12-11.png"></p><h1 id="指令集重排"><a href="#指令集重排" class="headerlink" title="指令集重排"></a>指令集重排</h1><p>为了能够充分利用多核 CPU 的处理性能，处理在实际执行机器指令时并不一定会按照程序设定的指令顺序执行，可能存在代码乱序执行（Out-Of-Order Execution）优化。注意，这里虽然乱序执行了，但是系统会保证执行的结果逻辑上的正确的，从宏观上看就好像是顺序执行一样。</p><h1 id="java-内存模型"><a href="#java-内存模型" class="headerlink" title="java 内存模型"></a>java 内存模型</h1><p>Java 在 1.5 版本中引入了 JSR 133 标准，在 JSR 133 标准中，定义了如下的 Java 并发内存模型：</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80_2020-03-11-20-36-45.png" alt="JAVA并发——基础_2020-03-11-20-36-45.png"></p><h2 id="工作内存"><a href="#工作内存" class="headerlink" title="工作内存"></a>工作内存</h2><p>这里需要注意的是，工作内存和 Java 内存区域中的堆、栈或者方法区（java 和 native）等并不是一个层面上的东西，它们之间也没有直接的对应关系。如果说主内存存放的是 java 堆中的一些实例对象，那么工作内存应该位于 Java 虚拟机栈。但实际上为了获得更好的运行速度，jvm 和硬件系统可能会让工作内存储存于高速缓存和寄存器中。</p><h2 id="同步操作与规则"><a href="#同步操作与规则" class="headerlink" title="同步操作与规则"></a>同步操作与规则</h2><p>从上面的模拟中我们知道线程间通信可能会出现数据一致性问题，从上面的图中，可以看出每个线程的工作内存和主存之间的一致性保证是通过 save 和 load 等等一系列的操作完成的。</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80_2020-03-11-20-44-01.png" alt="JAVA并发——基础_2020-03-11-20-44-01.png"></p><p>由上面的交互关系可知，关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java 内存模型定义了以下八种操作来完成：</p><p>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。</p><p>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</p><p>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的 load 动作使用</p><p>load（载入）：作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。</p><p>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</p><p>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</p><p>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的 write 的操作。</p><p>write（写入）：作用于主内存的变量，它把 store 操作从工作内存中一个变量的值传送到主内存的变量中。</p><h1 id="并发的优势和风险"><a href="#并发的优势和风险" class="headerlink" title="并发的优势和风险"></a>并发的优势和风险</h1><ul><li>优势<ul><li>速度：同时处理多个请求，响应更快。复杂的请求可以分为多个进程同时执行。</li><li>设计：程序设计在某些情况下更简单，也可以有更多的选择。</li><li>资源利用：CPU 能够在等待 IO 的时候做一些其他的事情。</li></ul></li><li>劣势<ul><li>安全性：多个线程共享数据时可能产生于期望不同的结果。</li><li>活跃性：某个操作无法继续进行下去时，就会发生活跃性问题，如死锁、饥饿等。</li><li>性能：线程过多，CPU 频繁切换，调度时间增多，同步机制消耗更多内存。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容器——ConcurrentHashMap—1.7</title>
      <link href="/2020/03/04/%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ConcurrentHashMap%E2%80%941.7/"/>
      <url>/2020/03/04/%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ConcurrentHashMap%E2%80%941.7/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>HashMap</code> 在多线程环境下存在线程安全问题，一般在多线程的场景，我都会使用好几种不同的方式去代替：</p><ul><li>使用 <code>Collections.synchronizedMap(Map)</code> 创建线程安全的 <code>map</code> 集合；</li><li><code>Hashtable</code></li><li><code>ConcurrentHashMap</code></li></ul><p>但是仔细研究过源码的同学都知道，前两者保证线程安全的操作 <code>synchronized</code> 修饰方法，锁住整个 <code>hash</code> 表，效率低下。</p><p><code>ConcurrentHashMap</code> 对锁的粒度和锁的方式进行了优化，<code>jdk1.7</code> 采用了分段锁，将容器的数据分段存储,每一段数据分配一个 Segment,当线程占用一个 Segment 时,其他线程可以访问其他段的数据。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>是由 Segment 数组、HashEntry 组成，和 HashMap 一样，仍然是 <strong>数组加链表</strong>。</p><p>CurrentHashMap 包含一个 <code>Segment</code>数组，每个 <code>Segment</code> 包含一个<code>HashEntry</code> 数组并且守护它。</p><p>Segment 类继承于 ReentrantLock 类，从而使得 Segment 对象能充当锁的角色。</p><p>当修改 <code>HashEntry</code> 数组数据时，需要先获取它对应的 <code>Segment</code> 锁；而 <code>HashEntry</code> 数组采用开链法处理冲突，所以它的每个 <code>HashEntry</code> 元素又是链表结构的元素。</p><p>HashEntry跟在HashMap中差不多，但是不同点是，他使用volatile去修饰了他的数据Value还有下一个节点next。保证了内存可见性，所以每次获取时都是最新值。ConcurrentHashMap 的 get 方法是非常高效的，因为整个过程都不需要加锁。</p><p>如图：</p><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ConcurrentHashMap_2020-03-04-17-11-30.png" alt="JAVA容器——ConcurrentHashMap_2020-03-04-17-11-30.png"></p><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ConcurrentHashMap_2020-03-04-17-23-51.png" alt="JAVA容器——ConcurrentHashMap_2020-03-04-17-23-51.png"></p><h1 id="需知"><a href="#需知" class="headerlink" title="需知"></a>需知</h1><ol><li><p>初始默认容量16，可以自定义，最终计算为2的幂。</p></li><li><p>初始默认分段数量16，无法扩容，可以自定义，最终计算为2的幂。</p></li><li><p>默认负载因子大小 0.75</p></li><li><p>最大容量 1&lt;&lt;30</p></li><li><p>最大分段数量 1&lt;&lt;16。</p></li><li><p>每个 segment 分段中哈希表的最小容量2</p></li><li><p>最大分段数量 1&lt;&lt;16</p></li><li><p>containsValue 方法不锁表的情况下尝试的次数 2</p></li></ol><p>注：默认构造函数会初始化一个segment数组大小为16的hashMap,并初始化一个hashEntry[]容量为2的segment，其他的segment延迟初始化。</p><p>segment：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自旋等待尝试加锁次数，单核为1，多核为64，Runtime.getRuntime().availableProcessors()方法获取CPU核心数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SCAN_RETRIES =</span><br><span class="line">            Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span> ? <span class="number">64</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表，即HashEntry数组（每个segment中都有一个table）</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//segment中元素个数，如put，remove等，此变量都会自增</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改次数</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扩容阀值</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//负载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 构造函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Segment(<span class="keyword">float</span> lf, <span class="keyword">int</span> threshold, HashEntry&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">            <span class="keyword">this</span>.loadFactor = lf;</span><br><span class="line">            <span class="keyword">this</span>.threshold = threshold;</span><br><span class="line">            <span class="keyword">this</span>.table = tab;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hashEntry：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"> <span class="comment">//每个key通过哈希运算后的结果，用的是 Wang/Jenkins hash 的变种算法，此处不细讲，感兴趣的可自行查阅相关资料</span></span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"> <span class="keyword">final</span> K key;</span><br><span class="line"> <span class="comment">//value和next都用 volatile 修饰，用于保证内存可见性和禁止指令重排序</span></span><br><span class="line"> <span class="keyword">volatile</span> V value;</span><br><span class="line"> <span class="comment">//指向下一个节点</span></span><br><span class="line"> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line"> HashEntry(<span class="keyword">int</span> hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123;</span><br><span class="line">  <span class="keyword">this</span>.hash = hash;</span><br><span class="line">  <span class="keyword">this</span>.key = key;</span><br><span class="line">  <span class="keyword">this</span>.value = value;</span><br><span class="line">  <span class="keyword">this</span>.next = next;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="hash方法"><a href="#hash方法" class="headerlink" title="hash方法"></a>hash方法</h1><p>4次key的hashCode与16位右移异或得到hash值</p><p>计算 Segment 下标：</p><pre><code>(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask </code></pre><p>计算 HashEntry 数组下标：</p><pre><code>(tab.length - 1) &amp; hash</code></pre><h1 id="定位segment"><a href="#定位segment" class="headerlink" title="定位segment"></a>定位segment</h1><ol><li><p>首先对 key 的 hashCode 进行 hash 操作</p></li><li><p>运用散列算法定位 segment 的位置</p><ul><li><code>segmentMask</code>：段掩码，假如 segments 数组长度为 16，则段掩码为 16-1=15；segments 长度为 32，段掩码为 32-1=31。这样得到的所有 bit 位都为 1，可以更好地保证散列的均匀性</li><li><code>segmentShift</code>：2 的 sshift 次方等于 ssize，segmentShift=32-sshift。若 segments 长度为 16，segmentShift=32-4=28;若 segments 长度为 32，segmentShift=32-5=27。</li></ul></li><li><p>而计算得出的 hash 值最大为 32 位，无符号右移 segmentShift位，则意味着只保留高几位（其余位是没用的），然后与段掩码 segmentMask 位运算来定位 Segment。</p></li><li><p>用Unsafe类的原子操作找到Segment数组中j下标的 Segment 对象（segment为空的，需要初始化）。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = hash(key);</span><br><span class="line"><span class="comment">//上边我们计算出的 segmentShift为28，因此hash值右移28位，说明此时用的是hash的高4位，</span></span><br><span class="line"><span class="comment">//然后把它和掩码15进行与运算，得到的值一定是一个 0000 ~ 1111 范围内的值，即 0~15 。</span></span><br><span class="line"><span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line"><span class="comment">//这里是用Unsafe类的原子操作找到Segment数组中j下标的 Segment 对象</span></span><br><span class="line"><span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">  (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line"> <span class="comment">//初始化j下标的Segment</span></span><br><span class="line"> s = ensureSegment(j);</span><br></pre></td></tr></table></figure><h1 id="put"><a href="#put" class="headerlink" title="put"></a>put</h1><ol><li><p>先尝试获取锁，如果加锁失败，则 scanAndLockForPut 自旋等待。</p></li><li><p>获取锁之后，根据key计算出在数组中的定位，</p></li><li><p>新增或变更节点，超出最大阈值则 rehash。</p></li></ol><h1 id="scanAndLockForPut"><a href="#scanAndLockForPut" class="headerlink" title="scanAndLockForPut"></a>scanAndLockForPut</h1><ol><li><p>该方法先计算 hash 值在 table 中的位置，循环该位置上的链表查找 key 值。如果不存在则新建节点。</p></li><li><p>之后尝试加锁 MAX_SCAN_RETRIES 次，如果一直失败则改为阻塞锁获取，保证能获取成功。</p></li><li><p>期间如果链表头被修改，则重新开始该过程,主要为了在等待锁的过程中预知key。</p></li></ol><h1 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h1><ol><li><p>对当前 segment的 <code>table</code> 进行扩容操作，每个Segment只管它自己的扩容，大小变为原来的 2 倍，其中的元素会被重新分配位置。</p></li><li><p><code>oldTable[idx]</code> 上的链表上的元素可能会重新 <code>hash</code> 到 <code>newTable[idx]</code> 和 <code>newTbale[idx+n]</code> 的链表上,<code>n</code> 为 <code>oldTable</code> 的大小。其实扩容时 hash 值并没有重新计算，变化的只是它们所在的下标而已。</p></li></ol><h1 id="get"><a href="#get" class="headerlink" title="get"></a>get</h1><ol><li><p>首先找到对应的segment</p></li><li><p>然后找到segment中对应HashEntry链表</p></li><li><p>遍历链表即可</p></li></ol><p>注：由于hashEntry的value和指向下一个节点的元素用volatile修饰，所以在整个segment内部的操作不用加锁，效率很高。</p><h1 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h1><ol><li><p>先尝试获取锁，如果加锁失败，则 scanAndLock 自旋等待（和上面的 put 方法相似）。</p></li><li><p>获取锁之后，(tab.length - 1) &amp; hash 计算删除节点在 table 中的下标，如果 table 中该位置的链表不为空，循环判断链表中节点是否和删除节点相等（value 为 null 时，key 相等即可，否则 key 和 value 均需相等）。</p></li><li><p>如果删除节点存在，设置 pre 节点的 next 指针指向 next 节点即可。</p></li></ol><h1 id="size"><a href="#size" class="headerlink" title="size"></a>size</h1><p>并发情况下，有可能在统计期间，数组元素个数不停的变化，而且，整个表还被分成了 N个 Segment，怎样统计才能保证结果的准确性呢？</p><p>1、第一种方案他会使用不加锁的模式去尝试多次计算ConcurrentHashMap的size，最多三次，比较前后两次计算的结果，结果一致就认为当前没有元素加入，计算的结果是准确的</p><p>2、第二种方案是如果第一种方案不符合，他就会给每个Segment加上锁，然后计算ConcurrentHashMap的size返回</p><h1 id="1-7-的问题"><a href="#1-7-的问题" class="headerlink" title="1.7 的问题"></a>1.7 的问题</h1><p>底层基本上还是数组加链表的方式，我们去查询的时候，还得遍历链表，会导致效率很低。</p><p>虽然分段加锁，但锁粒度还是有些高。</p>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 ConcurrentHashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容器——HashMap</title>
      <link href="/2020/02/25/%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94HashMap/"/>
      <url>/2020/02/25/%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94HashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>基于 Map 接口实现的一种键-值对&lt;key,value&gt;的存储结构，允许 null 值，同时非有序，非同步(即线程不安全)。</p><p>底层实现是数组 + 链表 + 红黑树（JDK1.8 增加了红黑树部分。</p><p>它存储和查找数据时，是根据键 key 的 hashCode 的值计算出具体的存储位置。</p><p>增删改查等常规操作都有不错的执行效率，是 ArrayList 和 LinkedList 等数据结构的一种折中实现。</p><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><ol><li><p>核心组成部分</p><ul><li><code>int size</code>： HashMap 实际存储元素的个数；</li><li><code>float loadFactor</code>：负载因子（默认是 0.75，此属性后面详细解释）。</li><li><code>int threshold</code>: 下一次扩容时的阈值，达到阈值便会触发扩容机制 resize（阈值 threshold = 容器容量 capacity * 负载因子 load factor）。</li><li><code>Node&lt;K,V&gt;[] table</code>: 底层数组，充当哈希表的作用(1.7使用的是Entry数组)，用于存储对应 hash 位置的元素 Node&lt;K,V&gt;，此数组长度总是 2 的 N 次幂。（具体原因后面详细解释）</li></ul></li><li><p>哈希表结构</p></li></ol><ul><li><p><code>final int hash</code>: 元素的哈希值，决定元素存储在 哈希表中位置;</p></li><li><p><code>final K key</code>: 键，由 final 修饰可知，当 key 的值确定后，就不能再修改。</p></li><li><p><code>V value</code>: 值</p></li><li><p><code>Node&lt;K,V&gt; next</code>: 记录下一个元素结点(单链表结构，用于解决 hash 冲突)</p></li></ul><h1 id="hash值的计算？"><a href="#hash值的计算？" class="headerlink" title="hash值的计算？"></a>hash值的计算？</h1><p>对于key的hashCode：Java7 做了 4 次 16 位右位移异或混合，Java 8 中这步已经简化了，只做一次 16 位右位移异或混合，而不是四次，但原理是不变的。</p><h1 id="hash冲突？"><a href="#hash冲突？" class="headerlink" title="hash冲突？"></a>hash冲突？</h1><p>得到的hash值与哈希表长度取模，得到具体的存储位置，而多个元素取模运算的值可能相同，这种现象称为hash冲突或hash碰撞。</p><h1 id="hash冲突的避免？"><a href="#hash冲突的避免？" class="headerlink" title="hash冲突的避免？"></a>hash冲突的避免？</h1><p>右位移 16 位，正好是 32bit 的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。</p><h1 id="hash冲突的解决？"><a href="#hash冲突的解决？" class="headerlink" title="hash冲突的解决？"></a>hash冲突的解决？</h1><p><code>HashMap</code>是使用链地址法解决<code>hash</code>冲突的，当有冲突元素放进来时，会将此元素插入至此位置链表的最后一位，形成单链表。但是由于是单链表的缘故，每当通过<code>hash % length</code>找到该位置的元素时，均需要从头遍历链表，通过逐一比较<code>hash</code>值，找到对应元素。如果此位置元素过多，造成链表过长，遍历时间会大大增加，最坏情况下的时间复杂度为<code>O(N)</code>，造成查找效率过低。所以当存在位置的链表长度 大于等于 <code>8</code> 时，<code>HashMap</code>会将链表 转变为 红黑树，红黑树最坏情况下的时间复杂度为<code>O(logn)</code>。以此提高查找效率。</p><h1 id="HashMap-的容量为什么一定要是-2-的-n-次方？"><a href="#HashMap-的容量为什么一定要是-2-的-n-次方？" class="headerlink" title="HashMap 的容量为什么一定要是 2 的 n 次方？"></a>HashMap 的容量为什么一定要是 2 的 n 次方？</h1><ol><li><p>运算效率高？</p><p> 具体确定此元素的位置是通过 <code>hash</code>值 <code>%</code> 模上 哈希表<code>Node&lt;K,V&gt;[] table</code>的长度 <code>hash % length</code> 计算的。但是”模”运算的消耗相对较大，通过位运算<code>h &amp; (length-1)</code>也可以得到取模后的存放位置，而位运算的运行效率高，但只有 length 的长度是 2 的 n 次方时，<code>h &amp; (length-1)</code> 才等价于 <code>h % length</code>。</p></li><li><p>分布均匀？</p><p> 而且当数组长度为 2 的 n 次幂的时候，不同的<code>key</code>算出的<code>index</code>相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。</p></li></ol><h1 id="HashMap里的size属性到底指的是数组实际长度还是键值总数"><a href="#HashMap里的size属性到底指的是数组实际长度还是键值总数" class="headerlink" title="HashMap里的size属性到底指的是数组实际长度还是键值总数?"></a>HashMap里的size属性到底指的是数组实际长度还是键值总数?</h1><p>HashMap里的size属性指的就是键值总数，因为哪怕新加的元素和旧元素hash值相等而equals结果不同，会处于同一链表中，size一样会加一，而size大小最终决定了是否要进行扩容。</p><h1 id="HashMap的负载因子初始值为什么是0-75？"><a href="#HashMap的负载因子初始值为什么是0-75？" class="headerlink" title="HashMap的负载因子初始值为什么是0.75？"></a>HashMap的负载因子初始值为什么是0.75？</h1><p>负载因子过大，哈希冲突增加，虽然空间利用率上去了，但是时间效率降低了。<br>负载因子过小，虽然时间效率提升了，但是空间利用率降低了。</p><p>负载因子是0.75的时候，空间利用率比较高，而且避免了相当多的Hash冲突，使得底层的链表或者是红黑树的高度比较低，提升了空间效率。</p><h1 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h1><h2 id="put"><a href="#put" class="headerlink" title="put"></a>put</h2><ol><li><p>判断哈希表 <code>Node&lt;K,V&gt;[] table</code> 是否为空或者 <code>null</code>，是则执行 <code>resize()</code>方法进行扩容（初始化）。</p></li><li><p>计算储存位置，如果存储位置没有元素存放，则将新增结点存储在此位置 <code>table[i]</code>。</p></li><li><p>如果存储位置已经有键值对元素存在，则判断该位置元素的 <code>hash</code> 值和 <code>key</code> 值是否和当前操作元素一致，一致则证明是修改 <code>value</code> 操作，覆盖 <code>value</code> 即可。</p></li><li><p>当前存储位置即有元素，又不和当前操作元素一致，则证明此位置 <code>table[i]</code>已经发生了 <code>hash</code> 冲突，则通过判断头结点是否是 <code>treeNode</code>，如果是 <code>treeNode</code> 则证明此位置的结构是红黑树，已红黑树的方式新增结点。</p><ul><li>如果不是红黑树，则证明是单链表，将新增结点插入至链表的最后位置，随后判断当前链表长度是否 大于等于 8，是则将当前存储位置的链表转化为红黑树。遍历过程中如果发现 <code>key</code> 已经存在，则直接覆盖 <code>value</code>。</li><li>插入成功后，判断当前存储键值对的数量 大于 阈值 <code>threshold</code> 是则扩容。</li></ul></li></ol><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><ol><li><p>计算储存位置，判断储存位置是否有元素存在。</p><ul><li>如果存储位置有元素存放，则首先比较头结点元素，如果头结点的<code>key</code>的<code>hash</code>值 和 要获取的<code>key</code>的<code>hash</code>值相等，并且 头结点的<code>key</code>本身 和要获取的 <code>key</code> 相等，则返回该位置的头结点。</li><li>如果存储位置没有元素存放，则返回<code>null</code>。</li><li>如果存储位置有元素存放，但是头结点元素不是要查找的元素，则需要遍历该位置进行查找。</li></ul></li><li><p>先判断头结点是否是<code>treeNode</code>，如果是<code>treeNode</code>则证明此位置的结构是红黑树，以红色树的方式遍历查找该结点，没有则返回<code>null</code>。</p></li><li><p>如果不是红黑树，则证明是单链表。遍历单链表，逐一比较链表结点，链表结点的<code>key</code>的<code>hash</code>值 和 要获取的<code>key</code>的<code>hash</code>值相等，并且 链表结点的<code>key</code>本身 和要获取的 <code>key</code> 相等，则返回该结点，遍历结束仍未找到对应<code>key</code>的结点，则返回<code>null</code>。</p></li></ol><h2 id="删除-remove"><a href="#删除-remove" class="headerlink" title="删除 remove"></a>删除 remove</h2><ol><li><p>计算储存位置，判断储存位置是否有元素存在。</p><ul><li>如果存储位置有元素存放，则首先比较头结点元素，如果头结点的 key 的 hash 值 和 要获取的 key 的 hash 值相等，并且 头结点的 key 本身 和要获取的 key 相等，则该位置的头结点即为要删除的结点，记录此结点至变量 node 中。</li><li>如果存储位置没有元素存放，则没有找到对应要删除的结点，则返回 null。</li><li>如果存储位置有元素存放，但是头结点元素不是要删除的元素，则需要遍历该位置进行查找。</li></ul></li><li><p>先判断头结点是否是<code>treeNode</code>，如果是<code>treeNode</code>则证明此位置的结构是红黑树，以红色树的方式遍历查找并删除该结点，没有则返回<code>null</code>。</p></li><li><p>如果不是红黑树，则证明是单链表。遍历单链表，逐一比较链表结点，链表结点的<code>key</code>的<code>hash</code>值 和 要获取的<code>key</code>的<code>hash</code>值相等，并且 链表结点的<code>key</code>本身 和要获取的<code>key</code>相等，则此为要删除的结点，记录此结点至变量 <code>node</code> 中，遍历结束仍未找到对应<code>key</code>的结点，则返回<code>null</code>。</p></li><li><p>如果找到要删除的结点 <code>node</code>，则判断是否需要比较 <code>value</code> 也是否一致，如果 <code>value</code> 值一致或者不需要比较 <code>value</code> 值，则执行删除结点操作，删除操作根据不同的情况与结构进行不同的处理。</p><ul><li>如果当前结点是树结点，则证明当前位置的链表已变成红黑树结构，通过红黑树结点的方式删除对应结点。</li><li>如果不是红黑树，则证明是单链表。如果要删除的是头结点，则当前存储位置 <code>table[i]</code> 的头结点指向删除结点的下一个结点。</li><li>如果要删除的结点不是头结点，则将要删除的结点的后继结点 <code>node.next</code> 赋值给要删除结点的前驱结点的 <code>next</code> 域，即 <code>p.next = node.next;</code>。</li></ul></li><li><p><code>HashMap</code> 当前存储键值对的数量 <code>- 1</code>，并返回删除结点。</p></li></ol><h2 id="替换-replace"><a href="#替换-replace" class="headerlink" title="替换 replace"></a>替换 replace</h2><ol><li><p>先调用 <code>hash(key)</code>方法计算出 <code>key</code> 的 <code>hash</code>值</p></li><li><p>随后调用<code>getNode</code>方法获取对应<code>key</code>所映射的<code>value</code>值 。</p></li><li><p>记录元素旧值，将新值赋值给元素，返回元素旧值，如果没有找到元素，则返回<code>null</code>。</p></li></ol><h1 id="java7-和-java8"><a href="#java7-和-java8" class="headerlink" title="java7 和 java8"></a>java7 和 java8</h1><ol><li><p>链表成环</p><p> java7使用头插,java8使用尾插。</p><ul><li>Java7 在多线程操作 HashMap 时可能引起死循环，原因是扩容转移后前后链表顺序倒置，在转移过程中修改了原来链表中节点的引用关系。</li><li>Java8 在同样的前提下并不会引起死循环，原因是扩容转移后前后链表顺序不变，保持之前节点的引用关系。</li></ul></li><li><p>Entry数组和Node数组</p><p> 其实这两者没有多大区别，叫Node可能更准确，也与红黑树的加入（TreeNode)相呼应。</p></li><li><p>红黑树</p><p> JDK7中HashMap采用的是位桶+链表的方式。而JDK8中采用的是位桶+链表/红黑树的方式，当某个位桶的链表的长度超过8的时候，这个链表就将转换成红黑树。</p><p> 默认链表长度大于8时，转为红黑树。红黑树桶数量小于6时，转为链表。</p><p> 当哈希表中的容量大于64时，表中的桶才能进行树形化，否则只是扩容解决。</p></li><li><p>扩容</p><p> jdk7里hashmap resize时对每个位桶的链表的处理方式（transfer方法），整体过程就是先新建两倍的新数组，然后遍历旧数组的每一个entry，直接重新计算新的索引位置然后头插法往拉链里填坑。</p><p> jdk8又不一样，因为我们使用的是 2 次幂的扩展(指长度扩为原来 2 倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动 2 次幂的位置。我们在扩充 <code>HashMap</code> 的时候，不需要重新计算 <code>hash</code>，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就好了，是 0 的话索引没变，是 1 的话索引变成“原索引+oldCap”。</p><p> 这个设计确实非常的巧妙，既省去了重新计算 <code>hash</code> 值的时间，而且同时，由于新增的 1bit 是 0 还是 1 可以认为是随机的，因此 <code>resize</code> 的过程，均匀的把之前的冲突的节点分散到新的 <code>bucket</code> 了。</p></li></ol><h1 id="您能说说-HashMap-和-HashTable-的区别吗？"><a href="#您能说说-HashMap-和-HashTable-的区别吗？" class="headerlink" title="您能说说 HashMap 和 HashTable 的区别吗？"></a>您能说说 HashMap 和 HashTable 的区别吗？</h1><ul><li>Hashtable 继承了 Dictionary 类，而 HashMap 继承的是 AbstractMap 类。</li><li>HashMap允许null键null值，hashTablle的key和value都不能为null。</li><li>hashMap初始容量为16，hashTable初始容量为11。</li><li>hashTable线程安全，hashMap不是线程安全的。</li></ul><p>注：<code>Hashtable</code>是一个遗留容器，如果我们不需要线程同步，则建议使用<code>HashMap</code>，如果需要线程同步，则建议使用<code>ConcurrentHashMap</code>。</p><ol><li><p>容器整体结构</p><ul><li><code>HashMap</code>的<code>key</code>和<code>value</code>都允许为<code>null</code>，<code>HashMap</code>遇到<code>key</code>为<code>null</code>的时候，调用<code>putForNullKey</code>方法进行处理，而对<code>value</code>没有处理。</li><li><code>Hashtable</code> 的 <code>key</code> 和 <code>value</code> 都不允许为 <code>null</code>。<code>Hashtable</code> 遇到 <code>null</code>，直接返回 <code>NullPointerException</code>。</li></ul></li><li><p>初始化容量和扩容机制</p></li></ol><ul><li><code>HashMap</code>默认初始化容量为 16，并且容器容量一定是 2 的 n 次方，扩容时，是以原容量 2 倍 的方式 进行扩容。</li><li><code>Hashtable</code>默认初始化容量为 11，扩容时，是以原容量 2 倍 再加 1 的方式进行扩容。即<code>int newCapacity = (oldCapacity &lt;&lt; 1) + 1</code>;。</li></ul><ol start="3"><li>迭代方式不同</li></ol><p>HashMap 中的 Iterator 迭代器是 fail-fast 的，而 Hashtable 的 Enumerator 不是 fail-fast 的。</p><ol start="4"><li>线程安全（最重要）</li></ol><ul><li><code>HashMap</code> 不是线程安全，如果想线程安全，可以通过调用<code>synchronizedMap(Map&lt;K,V&gt; m)</code>使其线程安全。但是使用时的运行效率会下降，所以建议使用<code>ConcurrentHashMap</code>容器以此达到线程安全。</li><li><code>Hashtable</code>则是线程安全的，每个操作方法前都有<code>synchronized</code>修饰使其同步，但运行效率也不高，所以还是建议使用<code>ConcurrentHashMap</code>容器以此达到线程安全。</li></ul><p>因此，</p><h1 id="谈谈-HashMap-线程不安全的体现"><a href="#谈谈-HashMap-线程不安全的体现" class="headerlink" title="谈谈 HashMap 线程不安全的体现"></a>谈谈 HashMap 线程不安全的体现</h1><ol><li><p>put丢失数据。</p></li><li><p>put和get并发时，可能导致get为null。</p></li><li><p>jdk7 resize方法可能造成死循环。</p></li></ol><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://juejin.im/post/6844903796225605640" target="_blank" rel="noopener">hashMap线程不安全的体现</a></p>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容器——LinkedList</title>
      <link href="/2020/02/25/%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94LinkedList/"/>
      <url>/2020/02/25/%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94LinkedList/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>LinkedList 底层是双向链表，同时实现了<code>List</code>接口和<code>Deque</code>接口，所以它既可以看作是一个顺序容器，也可以看作是一个队列(Queue)，同时也可以看作是一个栈(Stack)，</p><p>但如果想使用栈或队列等数据结构的话，推荐使用 ArrayDeque，它作为栈或队列会比 LinkedList 有更好的使用性能。</p><h1 id="获取元素，修改元素，新增元素与删除元素，并分析这些操作对应的时间复杂度。"><a href="#获取元素，修改元素，新增元素与删除元素，并分析这些操作对应的时间复杂度。" class="headerlink" title="获取元素，修改元素，新增元素与删除元素，并分析这些操作对应的时间复杂度。"></a>获取元素，修改元素，新增元素与删除元素，并分析这些操作对应的时间复杂度。</h1><ol><li><p>获取元素</p><p> LinkedList 提供了三种获取元素的方法，分别是：</p><ul><li><p>getFirst()：获取第一个元素，直接返回 Node<E> first 指向的结点即可，所以时间复杂度为 O(1)。</p></li><li><p>getLast()：获取最后一个元素，直接返回 Node<E> last 指向的结点即可，所以时间复杂度也为 O(1)。</p></li><li><p>get(int i): 获取指定索引 index 位置的元素，由于结点在内存中存储的空间不是连续存储的，所以需要先遍历，首先判断位置在链表的前半部分或后半部分，再遍历查找数据，最坏的情况需要n/2次遍历，所以时间复杂度位 O(n)。</p><p>综上所述，LinkedList 获取元素的时间复杂度为 O(n)。</p></li></ul></li><li><p>修改元素</p><p> LinkedList 提供了一种修改元素数据的方法:</p><p> set(int index, E element): 折半查询找到元素，赋予新值，返回旧元素。故时间复杂度为 O(n);</p></li><li><p>新增元素</p><p> LinkedList 提供了四种新增元素的方法，分别是：</p><ul><li><p>addFirst(E e): 只需将头结点 first 指向新元素结点，将原第一结点的前驱指针指向新元素结点即可。所以时间复杂度为 O(1)。</p></li><li><p>addLast(E e): 只需将尾结点 last 指向新元素结点，将原最后一个结点的后继指针指向新元素结点即可。所以时间复杂度也为 O(1)。</p></li><li><p>add(E e): 等价于 addLast(E e)。</p></li><li><p>add(int index, E element)，需要先根据位置 index 调用 node(index)遍历链表获取该位置的原结点，然后将新结点插入至原该位置结点的前面，不需要移动原数据存储位置，只需交换一下相关结点的指针域信息即可。所以时间复杂度也为 O(1)。</p><p>综上所述，LinkedList 新增元素的时间复杂度为 O(1)，单纯论插入新元素，操作是非常高效的，特别是插入至头部或插入到尾部。但如果是通过索引 index 的方式插入，插入的位置越靠近链表中间所费时间越长，因为需要对链表进行遍历查找。</p></li></ul></li><li><p>删除元素</p><p> LinkedList 提供了四种删除元素的方法，分别是：</p><ul><li><p>removeFirst(): 只需将头结点<code>first</code>指向删除元素结点的后继结点并将其前驱结点指针信息<code>prev</code>清空即可。不需要移动原数据存储位置，只需操作相关结点的指针域信息即可。所以时间复杂度为 O(1)。</p></li><li><p>removeLast(): 只需将尾结点<code>last</code>指向删除元素结点的前驱结点并将其后继结点指针信息<code>next</code>清空即可。不需要移动原数据存储位置，只需操作相关结点的指针域信息即可，所以时间复杂度也为 O(1)。</p></li><li><p>remove(int index)，需要先根据位置 index 调用遍历链表获取该位置的原结点，然后将删除元素结点的前驱结点的 next 后继结点指针域指向删除元素结点的后继结点，删除元素结点的后继结点的 prev 前驱结点指针域指向删除元素结点的前驱结点即可，不需要移动原数据存储位置，只需交换一下相关结点的指针域信息即可。所以时间复杂度也为 O(1)。</p></li><li><p>remove(Object o): 比较对象是否一致通过<code>o.equals</code>方法比较<code>remove(Object o)</code>，和 3.的思路基本差不多，关键是比较对象是通过<code>o.equals</code>方法，记住这点即可。</p><p>综上所述，LinkedList 删除元素的时间复杂度为 O(1)，单纯论删除元素，操作是非常高效的，特别是删除第一个结点或删除最后一个结点。但如果是通过索引 index 的方式或者 object 对象的方式删除，则需要对链表进行遍历查找对应 index 索引的对象或者利用 equals 方法判断对象。</p></li></ul></li></ol><h1 id="ArrayList-和-LinkedList"><a href="#ArrayList-和-LinkedList" class="headerlink" title="ArrayList 和 LinkedList"></a>ArrayList 和 LinkedList</h1><ol><li><p>更占内存</p><p> LinkedList 内部存储的是 Node<E>，不仅要维护数据域，还要维护 prev 和 next，如果 LinkedList 中的结点特别多，则 LinkedList 比 ArrayList 更占内存。</p></li><li><p>插入删除效率高?</p><p> 对于linkedList头部和尾部插入和删除，效率都很高，操作要靠近中间的位置，需要遍历的操作越多，效率就越低。</p><p> 对于ArrayList而言，尾部插入，效率很高，否则都需要进行拷贝，效率降低。</p><p> 但越靠近中间位置的插入、删除，ArrayList效率要高于LinkedList的。</p><p> 可以这么说，ArrayList快在遍历查找，慢在位置移动。</p></li><li><p>循环遍历效率低</p><p> 论遍历 ArrayList 要比 LinkedList 快得多，ArrayList 遍历最大的优势在于内存的连续性，CPU 的内部缓存结构会缓存连续的内存片段，可以大幅降低读取内存的性能开销。</p><p> 注：ArryayList遍历for循环比用迭代器要快，LinkedList用迭代器遍历又要快于for循环。 ArrayList实现了 RandomAccess 接口，官网还特意说明了，如果是实现了这个接口的 List，那么使用for循环的方式获取数据会优于用迭代器获取数据。 </p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容器——ArrayList</title>
      <link href="/2020/02/24/%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ArrayList/"/>
      <url>/2020/02/24/%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ArrayList/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ArrayList 就是数组列表,相比数组，可以装载各种类型的数据。</p><p>底层实现主要依靠 Object[] elementData。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul><li>ArrayList 底层是用数组实现的存储。</li><li>查询效率高，增删效率低，线程不安全。使用频率很高。</li><li>可以通过构造方法在初始化的时候指定底层数组的大小；</li><li>无参构造方法1.7初始化，默认为调用有参构造方法，创造10容量的数组。</li><li>无参构造1.8初始化，默认为空数组，只有真正<code>add</code>时，才分配初始10的容量。</li><li>初始化容量为 10，超过10，会创建一个容量 <code>1.5</code> 倍的空数组，将原有数据拷贝过去。</li></ul><h1 id="增删为啥慢"><a href="#增删为啥慢" class="headerlink" title="增删为啥慢"></a>增删为啥慢</h1><ol><li><p>扩容：</p><p> 当数组的容量超过限制，会扩容1.5倍，数组的扩容是将原数组的数据复制到一个1.5倍容量新数组上。</p></li><li><p>add()有两种：</p><ul><li>add(E e): 和数组一样，会在有数据的索引后一位添加数据，只是设及到临界扩容问题</li><li>add(int i,E e): 在指定位置新增数据，如涉及到数据位置的移动，这里与数组的实现方式不同，是在原有数据的基础上拷贝黏贴。</li></ul></li><li><p>remove()有四种：</p><ul><li>remove(): 删除最后一位有数据的元素</li><li>remove(int i): 指定位置删除，如涉及到元素的移动，需要拷贝到新数组。</li><li>remove(Object o): 先遍历定位位置，如涉及到元素的移动，需要拷贝到新数组。</li><li>removeAll(Collection&lt;?&gt; c): 遍历确定位置，涉及到元素的移动，需拷贝的新数组。</li></ul></li></ol><p>由此我们可以知道，在末端添加或删除数组，效率不错；但只要涉及到元素的移动，就会触发数组的拷贝，效率低下。</p>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 ArrayList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容器——概述</title>
      <link href="/2020/02/24/%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/02/24/%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>Java 的容器是前人为我们设计好的一套存储对象和数据的一套轮子，通过使用 Java 中写好的容器 API 我们可以很方便的存储、操作我们的数据。</p><h1 id="容器的分类"><a href="#容器的分类" class="headerlink" title="容器的分类"></a>容器的分类</h1><p>容器主要包括 Collection 和 Map 两种：</p><p>Collection:</p><p>主要是单个元素的集合，由 List、Queue、Set 三个接口区分不同的集合特征，然后由下面的具体的类来实现对应的功能。</p><p>Map:</p><p>有一组键值对的存储形式来保存，可以用键对象来查找值。</p><p>关系图:</p><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0_2020-02-24-14-44-33.png" alt="JAVA容器——概述_2020-02-24-14-44-33.png"></p><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0_2020-02-24-14-45-06.png" alt="JAVA容器——概述_2020-02-24-14-45-06.png"></p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>List 的特点就是所有的元素是可以重复的。</p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><ul><li>底层由 Object 数组实现。</li><li>默认长度为 10，每次扩容 1.5 倍，也可以自定义初始长度。</li><li>元素存放数据为遍历顺序。</li><li>访问与查找速度快，删除与插入速度慢。</li><li>toArray：把 LinkedList 转化为 Array</li></ul><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><ul><li>底层由链表（双向链表）实现。</li><li>在列表中插入和删除速度快，但是查找需要遍历整个链表。</li><li>可以通过它实现队列和栈。</li><li>动态改变大小（链表特性）</li></ul><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><ul><li>底层由数组实现</li><li>synchronized 进行同步，线程安全</li><li>插入、删除、访问速度慢</li></ul><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p>队列是一个满足“先进先出”的数据结构。<br>LinkedList 提供了方法支持队列操作，并且实现了 Queue 接口，所以 LinkedList 是队列的一种实现，可以通过 LinkedList 向上转型为 Queue</p><h2 id="FIFO-队列"><a href="#FIFO-队列" class="headerlink" title="FIFO 队列"></a>FIFO 队列</h2><p>   Queue<Integer> q=new LinkedList<Integer>();</p><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>   Queue<Integer> q=new PriorityQueue<Integer>();</p><p>   默认升序，底层为堆，初始容量 11</p><p>   Queue<Student> q=new PriorityQueue<Student>((e1,e2)-&gt;(e1.id-e2.id));</p><p>   传入对象时需要指定比较器；</p><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>   阻塞队列，在 java.util.concurrent 包下，在线程安全中介绍。</p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>不可重复</p><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><ul><li>基于哈希表实现，支持快速查找，但不支持有序性操作。</li><li>通过 HashMap 实现。</li><li>HashSet添加的元素是存放在HashMap的key位置上，而value取了默认常量PRESENT</li></ul><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><ul><li><p>基于红黑树实现，支持有序性操作，查找效率 O(logN)。</p></li><li><p>通过 NavigableMap 实现</p><p>private transient NavigableMap&lt;E,Object&gt; m;</p></li><li><p>数据类型为对象数据时须指定比较方法。</p><p>public TreeSet(Comparator&lt;? super E&gt; comparator)</p></li></ul><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><ul><li>Map 是使用键值对存储的一种结构，所以在处理列如单词统计等方面是杀手锏</li><li>Map 的键值对都可以为 null</li><li>Map 可以多维扩展。例如一个人拥有多个宠物，你可以这样定义：Map&lt; Person, List&lt; pet&gt;&gt;</li></ul><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>基于红黑树实现。有序</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ul><li>基于哈希表实现。</li><li>由数组和链表，红黑树共同完成：</li><li>键可以是 null，而且键值不可以重复，如果重复了以后就会对第一个进行键值进行覆盖。</li><li>初始容量为 16，最大容量 1073741824</li><li>默认负载因子 0.75,扩容 2 倍。</li><li>链表转红黑树的阈值 8，红黑树转链表的阈值 6</li></ul><h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><ul><li>和 HashMap 类似，但它是线程安全的</li><li>它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</li><li>HashMap 的默认初始容量为 16，Hashtable 为 11。</li><li>HashMap 的扩容为原来的 2 倍，Hashtable 的扩容为原来的 2 倍加 1。</li></ul><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</p><h1 id="线程安全的容器"><a href="#线程安全的容器" class="headerlink" title="线程安全的容器"></a>线程安全的容器</h1><h2 id="同步容器类（使用了-synchronized）"><a href="#同步容器类（使用了-synchronized）" class="headerlink" title="同步容器类（使用了 synchronized）"></a>同步容器类（使用了 synchronized）</h2><p>Vector、Stack、HashTable</p><p>缺点：</p><p>通过同步方法将访问操作串行化，导致并发环境下效率低下</p><p>复合操作（迭代、条件运算如没有则添加等）非线程安全，需要客户端代码来实现加锁。</p><h2 id="并发容器："><a href="#并发容器：" class="headerlink" title="并发容器："></a>并发容器：</h2><ol><li>CopyOnWriteArrayList</li></ol><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p><p>写操作需要加锁，防止并发写入时导致写入数据丢失。</p><p>写操作结束之后需要把原始数组指向新的复制数组。</p><p>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；<br>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。<br>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景</p><ol start="2"><li>CopyOnWriteArraySet</li></ol><p>CopyOnWriteArraySet 基于 CopyOnWriteArrayList 实现，其唯一的不同是在 add 时调用的是 CopyOnWriteArrayList 的 addIfAbsent 方法，其遍历当前 Object 数组，如 Object 数组中已有了当前元素，则直接返回，如果没有则放入 Object 数组的尾部，并返回。</p><ol start="3"><li>ConcurrentHashMap</li></ol><p>采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。<br>默认的并发级别为 16，也就是说默认创建 16 个 Segment。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>Java 容器深入剖析</p>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 概述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（九）——搜素</title>
      <link href="/2020/02/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A0/"/>
      <url>/2020/02/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h1><h2 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h2><p>顺序查找对序列本身没有要求（比如不需要是已经排序好的），也不仅限于数字、字符，也可以用于前缀，对象信息的关键信息的匹配（比如查找指定 id 的相应信息）。</p><p>衡量查找性能的一个指标是————ASL(Average Search Length)，ASL=Pi 乘 Ci，Pi 是查找第 i 个元素的概率，Ci 是找到第 i 个已经比较过次数。</p><p>哨兵方式的顺序查找相比较基础的顺序查找在循环的比较部分减少了一般。</p><h2 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 顺序查找</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequentialSearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SequentialSearch</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 哨兵方式顺序查找</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Search2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Search2</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(key == array[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = array[<span class="number">0</span>];</span><br><span class="line">        array[<span class="number">0</span>] = key;</span><br><span class="line">        <span class="keyword">int</span> index = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(array[index] != key) &#123;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        array[<span class="number">0</span>] = temp;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="设计理念-1"><a href="#设计理念-1" class="headerlink" title="设计理念"></a>设计理念</h2><p>如果是顺序查找，7 个数最多可能会比较 7 次，但用二分查找，最多只要 3 次就能 OK。</p><p>时间复杂度是 O（logn）(底数为 2)。</p><p>二分查找的优化————插值查找</p><p>如果数据范围是 1<del>100000,让你找 10,那么就不一定要从中间找起了。可以三分之一，四分之一处查找，比如 1</del>10，待查为 3，那可以从前面三分之一为划分点。对于要查找的位置有个精确的计算公式 P=low+（key-a[low])/(a[high]-a[low])*(high-low)</p><h2 id="java-实现-1"><a href="#java-实现-1" class="headerlink" title="java 实现"></a>java 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 二分查找递归与非递归的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchRecursion</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  searchRecursion(target, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; array[mid]) &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">searchRecursion</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(array[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &lt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> searchRecursion(target, mid + <span class="number">1</span>, end);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> searchRecursion(target, start, mid -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 二分插入排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryInsertSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryInsertSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = array.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = array[i];</span><br><span class="line">            <span class="keyword">int</span> insertIndex = binarySearch(i - <span class="number">1</span>, temp);</span><br><span class="line">            <span class="keyword">if</span>(insertIndex != i) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; insertIndex; j--) &#123;</span><br><span class="line">                    array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                array[insertIndex] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.println(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> end, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">            mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid] &gt; target) &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果相等，也插入到后面</span></span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="杨氏矩阵的的查找"><a href="#杨氏矩阵的的查找" class="headerlink" title="杨氏矩阵的的查找"></a>杨氏矩阵的的查找</h1><h2 id="设计理念-2"><a href="#设计理念-2" class="headerlink" title="设计理念"></a>设计理念</h2><p>杨氏矩阵就是行列递增的矩阵。</p><p>杨氏矩阵的操作</p><p>插入。插入一个数，需要移动其他元素<br>删除。给定 x,y 坐标，删除那个数，伴随其他元素移动，怎样移动操作最少？<br>查找 t 是否存在于矩阵中。这也是这篇博客里所要关注的。<br>返回第 k 大的数。涉及到堆查找，后续博客再细说。<br>关于查找 t 是否存在于矩阵，书中给了几种实现的方法：</p><p>递归实现和非递归实现</p><p>优化：<br>每次不都从每行的第一个数开始查找，左右上下进行比较然后查找。<br>分治法。杨氏矩阵行列是递增的，那么对角线也是递增的，可以利用对角线划分的区域来缩小要查找数的范围。（实现略）<br>定位查找法。先定位到第一行最右的数，然后只需要往下走，往左走两种操作即可，相比方法 2 省掉了往右走。</p><h2 id="java-实现-2"><a href="#java-实现-2" class="headerlink" title="java 实现"></a>java 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YoungSearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">YoungSearch</span><span class="params">(<span class="keyword">int</span>[][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recursionSearch</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == array.length || y == array[<span class="number">0</span>].length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; array[x][y]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target == array[x][y]) &#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"x: %d, y: %d"</span>, x, y));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> recursionSearch(x + <span class="number">1</span>, y, target) || recursionSearch(x, y + <span class="number">1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array[<span class="number">0</span>].length &amp;&amp; target &gt;= array[i][j]; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(target == array[i][j]) &#123;</span><br><span class="line">                    System.out.println(String.format(<span class="string">"x: %d y: %d"</span>, i, j));</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.简单优化（向左/右/下走）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search2</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> width = array[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> height = array.length;</span><br><span class="line">        <span class="keyword">if</span>(target &gt;= array[<span class="number">0</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; width &amp;&amp; target &gt;= array[<span class="number">0</span>][i]; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(target == array[<span class="number">0</span>][i]) &#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">"x: %d, y: %d"</span>, <span class="number">0</span>, i));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; width - <span class="number">1</span>) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环向下查找</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; height; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(target == array[j][i]) &#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">"x: %d, y: %d"</span>, j, i));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; array[j][i]) &#123;</span><br><span class="line">                <span class="keyword">for</span>(; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(target == array[j][i]) &#123;</span><br><span class="line">                        System.out.println(String.format(<span class="string">"x: %d, y: %d"</span>, j, i));</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &gt; array[j][i]) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &gt; array[j][i]) &#123;</span><br><span class="line">                <span class="keyword">for</span>(; i &lt; width; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(target == array[j][i])&#123;</span><br><span class="line">                        System.out.println(String.format(<span class="string">"x: %d, y: %d"</span>, j, i));</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; array[j][i]) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; width - <span class="number">1</span>) &#123;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.进一步优化（从第一行最右边的数开始，只需要向下和向左两个操作）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search3</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = array[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = array[i][j];</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(target == temp) &#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">"x: %d, y: %d"</span>, i, j));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">0</span> &amp;&amp; target &lt; temp)&#123;</span><br><span class="line">                temp = array[i][--j];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i &lt; array.length - <span class="number">1</span> &amp;&amp; target &gt; temp) &#123;</span><br><span class="line">                temp = array[++i][j];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h1><h2 id="设计理念-3"><a href="#设计理念-3" class="headerlink" title="设计理念"></a>设计理念</h2><p>对于待查找的数据列表来说，如果元素变动很少，那么可以先进行排序再查找。但如果这个数据经常需要添加元素，那么每次查找前都需要排序，这并不是一个好的选择。</p><p>就有了分块查找，这个概念再学数据库的时候听过。分块查找里有索引表和分块这两个概念。索引表就是帮助分块查找的一个分块依据，就是一个数组，用来存储每块最大的存储值（范围上限）；分块就是通过索引表把数据分为几块。</p><p>原理</p><p>当需要增加一个元素的时候，先根据索引表，获取这个元素应该在那一块，然后直接把元素加入到相应的块里，而块内的元素直接不需要有序。</p><p>从上面可知，分块查找只需要索引表有序，每一个块里的元素可以是无序的，但第 i 块的每个元素一定比第 i-1 块的每一个元素大（小）。当索引表很大的时候，可以对索引表进行二分查找，锁定块的位置，然后对块内的元素进行顺序查找。总性能不如二分查找，但强过顺序查找，更好的是不需要数列完全有序。<br>举个例子，比如索引表为【10，20，30】,分块一【2，1，4，2】分块二【19，15，18，】分块三【22，27，23】，现在要增加 22 这个数，直接根据索引表把 22 放到分块三最后就行了【22,27,23,22】。</p><p>可以看出，分块查找同时有顺序查找和二分查找的有点————不需要有序、速度快。</p><p>应用场景<br>视频网站对用户观看行为记录，每个用户分别观看了一个视频多久，如果对每条这样的记录都放到一个表里，那太多了，可以根据具体业务做分表，一天一个表，表名如 t_user_watch_xxx_20180806，存储查询的时候就可以根据时间去做一个表的分块，在查询详细的记录。</p><h2 id="java-实现-3"><a href="#java-实现-3" class="headerlink" title="java 实现"></a>java 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分块查找</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockSearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] index;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlockSearch</span><span class="params">(<span class="keyword">int</span>[] index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index.length; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = binarySearch(value);</span><br><span class="line">        list.get(i).add(value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = binarySearch(data);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; list.get(i).size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(data == list.get(i).get(j)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; l = list.get(i);</span><br><span class="line">            System.out.println(<span class="string">"ArrayList: "</span> + i +  <span class="string">":"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; l.size(); j++) &#123;</span><br><span class="line">                System.out.println(l.get(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = index.length - <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">int</span> mid = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">            mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target == index[mid]) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; index[mid]) &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（八）——排序算法</title>
      <link href="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="常见的排序算法总结"><a href="#常见的排序算法总结" class="headerlink" title="常见的排序算法总结"></a>常见的排序算法总结</h1><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95_2020-02-20-16-44-05.png" alt="数据结构与算法（八）——排序算法_2020-02-20-16-44-05.png"></p><h1 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h1><p>因为待排序的记录序列中可能存在两个或两个以上的关键字相等的记录， 排序结果可能会存在不唯一的情况。所以就有稳定与不稳定的定义。</p><p>假设 ki=kj( 1 =&lt; i &lt;= n,1 =&lt; j &lt;= n, i != j)，且在排序前的序列中 ri 领先于 rj。如果排序后 ri 仍领先于 rj，则称所用的排序方法是稳定的；反之，若可能使得排序后的序列中 rj 领先于 ri，则称所用的排序方法是不稳定的。只要有一组关键字发生类似情况，就可认为此排序方法是不稳定的。</p><h1 id="内排序和外排序"><a href="#内排序和外排序" class="headerlink" title="内排序和外排序"></a>内排序和外排序</h1><p>根据在排序过程中待排序记录是否全部放在内存中，排序分为内排序和外排序。</p><ul><li>内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。</li><li>外排序是由于排序的记录个数太多，不能同时放置在内存中，整个排序过程需要在内外存之间多次交换数据才能进行。</li></ul><p>内排序，排序算法的性能主要有 3 个影响因素：</p><ul><li>时间性能<br>排序算法的时间开销是衡量其好坏的最重要的标志。<br>在内排序中，主要进行两种操作：比较和移动。<br>高效率的内排序算法应该具有尽可能少的关键字比较次数和尽可能少的记录移动次数。</li><li>辅助空间<br>评估算法的另一个主要标准是执行算法所需要的辅助存储空间。<br>辅助存储空间是除了存放待排序所占用的存储空间外，执行算法所需要的其他存储空间。</li><li>算法的复杂性<br>指算法本身的复杂性，过于复杂的算法也会影响排序的性能。</li></ul><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p><strong>两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。</strong></p><h2 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h2><ul><li>最好：仅需要 n - 1 次比较，时间复杂度为 O(n)；</li><li>最坏：需要 n(n - 1)/2 次比较和交换；</li><li>平均：复杂度为 O(n2)。</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 最简单交换排序，非冒泡排序,比较的不是相邻关键字，但便于理解</span></span><br><span class="line">   <span class="comment">// 比较次数n(n + 1)/2，交换次数会很多，仔细分析下，会把小的数字放到最后去，而冒泡则不会，原因就是比较的是相邻关键字</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">simpleSwapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array.length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = array.length; i &lt; size; ++i) &#123;</span><br><span class="line">           <span class="comment">//for (int j = 0; j &lt; size; j++) &#123; //这种效率更低 n^2</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; size; ++j) &#123;</span><br><span class="line">               <span class="keyword">if</span> (array[j] &lt; array[i]) &#123;</span><br><span class="line">                   CommonUtil.swap(array, i, j);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 正宗的冒泡排序，从最底下开始冒泡，两两比较,每次都将小的往上冒一点</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array.length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, size = array.length; i &lt; size; ++i) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = size - <span class="number">1</span>; j &gt;= i; --j) &#123;</span><br><span class="line">               <span class="keyword">if</span> (array[j] &lt; array[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                   CommonUtil.swap(array, j, j - <span class="number">1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//CommonUtil.printArray(array);</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 冒泡排序优化，如果经过一轮发现已经是有序的，就不再进行排序</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSortBetter</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array.length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, size = array.length; i &lt; size &amp;&amp; flag; ++i) &#123;</span><br><span class="line">           flag = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = size - <span class="number">1</span>; j &gt;= i; --j) &#123;<span class="comment">//经过一轮循环，发现两两已经是有序的了，就置为false</span></span><br><span class="line">               <span class="keyword">if</span> (array[j] &lt; array[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                   CommonUtil.swap(array, j, j - <span class="number">1</span>);</span><br><span class="line">                   flag = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//CommonUtil.printArray(array);</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h1><h2 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h2><p>每一次遍历时选取关键字最小的记录作为有序序列的第 i 个记录。</p><h2 id="算法复杂度分析-1"><a href="#算法复杂度分析-1" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h2><ul><li>最好最差的情况，都要进行 n(n-1)/2 次比较；在最好的情况下，不需要进行交换，在最坏的情况下，进行 n-1 次交换。</li><li>平均：复杂度为 O(n2)。</li></ul><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleSelectionSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">simpleSelectionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array.length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = array.length; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; size; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &lt; array[minIndex]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">                CommonUtil.swap(array, i, minIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><h2 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h2><p>将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录递增 1 的有序表。插入排序是进行值移动，而非值交换。所以在量较小的情况下插入排序性能要优于冒泡和简单选择排序。</p><h2 id="算法复杂度分析-2"><a href="#算法复杂度分析-2" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h2><ul><li>最好，只需进行比较 n - 1 次，无需进行移动；</li><li>最坏的情况下，比较(n + 2)(n - 1)/2 次，交换(n + 4)(n - 1)/2 次。</li><li>平均：复杂度 O(n2)</li></ul><h2 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StraightInsertionSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//for循环</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">straightInsertionSort2</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array.length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j, temp, size = array.length; i &lt; size; ++i) &#123;</span><br><span class="line">            temp = array[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; temp; --j) &#123;</span><br><span class="line">                array[j + <span class="number">1</span>] = array[j];<span class="comment">//移动而非交换</span></span><br><span class="line">            &#125;</span><br><span class="line">            array[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a>二分插入排序</h1><h2 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h2><p>二分（折半）插入排序是一种在直接插入排序算法上进行小改动的排序算法。其与直接排序算法最大的区别在于查找插入位置时使用的是二分查找的方式，在速度上有一定提升。</p><h2 id="算法复杂度分析-3"><a href="#算法复杂度分析-3" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h2><p>插入每个记录需要 O(log i)比较，最多移动 i+1 次，最少 2 次。</p><ul><li>最佳： O(n log n)，</li><li>最差：O(n^2)</li><li>平均: O(n^2)。</li><li></li></ul><p>总排序码比较次数比直接插入排序的最差情况好得多，但比最好情况要差，所元素初始序列已经按排序码接近有序时，直接插入排序比二分插入排序比较次数少</p><h2 id="java-实现-1"><a href="#java-实现-1" class="headerlink" title="java 实现"></a>java 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryInsertionSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binaryInsertionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array.length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp, left, right, middle;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, size = array.length; i &lt; size; i++) &#123;</span><br><span class="line">            temp = array[i];</span><br><span class="line">            left = <span class="number">0</span>;</span><br><span class="line">            right = i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//寻找合适的位置</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">                middle = (left + right) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (array[middle] &gt; temp) &#123;</span><br><span class="line">                    right = middle - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = middle + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= left; j--) &#123;</span><br><span class="line">                array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            array[left] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="基本思想-4"><a href="#基本思想-4" class="headerlink" title="基本思想"></a>基本思想</h2><ol><li><p>对一个未排序序列，假设从该序列中的元素中取一个基准值 pivotkey，将小于 pivotkey 放左边，大于 pivotkey 放右边；</p></li><li><p>接着以该 k 为中间，左右两边的分割作为新的序列，重新进行 1 操作。 快排因为用到了递归操作，所以在简单排序中性能不如直接插入排序， 而在大量数据排序时，递归产生的性能影响对于算法的整体性能优势可以忽略。</p></li></ol><h2 id="算法复杂度分析-4"><a href="#算法复杂度分析-4" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h2><ul><li>最坏：待排序为正序或逆序，这样每次分割后的子序列一个之比上一次序列少一个元素，一个为空。如 1 2 3 4 5 pivotkey=1;分割后一个序列为 2 3 4 5 一个为空，最终 O(n^2)</li><li>最好：每一次分割都能平分，很均匀 O(nlogn)</li><li>平均：O(n*logn) 数学归纳法</li></ul><h2 id="java-实现-2"><a href="#java-实现-2" class="headerlink" title="java 实现"></a>java 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuickSortWhile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_LIMIT = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array.length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        quick_sort_recursive(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick_sort_recursive</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= MAX_LIMIT) &#123;</span><br><span class="line">            <span class="comment">// 到达一定程度的小数组时使用插入排序</span></span><br><span class="line">            insertSort(arr, start, end);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123; <span class="comment">//尾递归优化</span></span><br><span class="line">            <span class="keyword">int</span> pivot = partition(arr, start, end);</span><br><span class="line"></span><br><span class="line">            quick_sort_recursive(arr, start, pivot - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            start = pivot + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       分区操作：将arr[end]作为中轴，比它小的放在前面，比它大的放在后面</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivotKey = arr[end];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = start, right = end - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (arr[left] &lt;= pivotKey &amp;&amp; left &lt; right) left++;</span><br><span class="line">            <span class="keyword">while</span> (arr[right] &gt;= pivotKey &amp;&amp; left &lt; right) right--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                CommonUtil.swap(arr, left, right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr[left] &gt;= pivotKey) &#123;</span><br><span class="line">            CommonUtil.swap(arr, left, end);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入排序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>, j, temp; i &lt;= end; ++i) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            j = i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= start &amp;&amp; arr[j] &gt; temp) &#123;</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li></ul><h2 id="基本思想-5"><a href="#基本思想-5" class="headerlink" title="基本思想"></a>基本思想</h2><p>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。</p><p>假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为 O(n2)的排序（冒泡排序或插入排序），可能会进行 n 次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。</p><p>一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用 i += step_size 而不是 i++ ）。</p><p>例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为 5 开始进行排序，我们可以通过将这列表放在有 5 列的表中来更好地描述算法，这样他们就应该看起来是这样：</p><p>13 14 94 33 82<br>25 59 94 65 23<br>45 27 73 25 39<br>10</p><p>然后我们对每列进行排序：</p><pre><code>10 14 73 25 2313 27 94 33 3925 59 94 65 8245</code></pre><p>将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时 10 已经移至正确位置了，然后再以 3 为步长进行排序：</p><pre><code>10 14 7325 23 1327 94 3339 25 5994 65 8245</code></pre><p>排序之后变为：</p><pre><code>10 14 1325 23 3327 25 5939 65 7345 94 8294</code></pre><p>最后以 1 步长进行排序（此时就是简单的插入排序了）。</p><h2 id="步长选择及复杂度"><a href="#步长选择及复杂度" class="headerlink" title="步长选择及复杂度"></a>步长选择及复杂度</h2><p>步长的选择是希尔排序的重要部分。只要最终步长为 1 任何步长序列都可以工作。<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95_2020-02-23-23-05-25.png" alt="数据结构与算法（八）——排序算法_2020-02-23-23-05-25.png"></p><ul><li><p>最优时间复杂度<br>O(n)</p></li><li><p>不稳定</p></li></ul><h2 id="java-实现-3"><a href="#java-实现-3" class="headerlink" title="java 实现"></a>java 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellsort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = a.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> d=n/<span class="number">2</span>;d&gt;<span class="number">0</span>;d/=<span class="number">2</span>) &#123;<span class="comment">/* 希尔增量序列 */</span></span><br><span class="line">            <span class="comment">/* 插入排序 */</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> p=d;p&lt;n;p++) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[p];</span><br><span class="line">                <span class="keyword">for</span>(j=p;j&gt;=d &amp;&amp; a[j-<span class="number">1</span>] &gt; temp;j=j-d)</span><br><span class="line">                    a[j] = a[j-d];</span><br><span class="line">                a[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><pre><code>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</code></pre><h2 id="基本思想-6"><a href="#基本思想-6" class="headerlink" title="基本思想"></a>基本思想</h2><p>归并过程</p><pre><code>比较a[i]和b[j]的大小，若a[i]≤b[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素b[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。</code></pre><p>原理</p><p>第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</p><pre><code>第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置重复步骤3直到某一指针超出序列尾将另一序列剩下的所有元素直接复制到合并序列尾</code></pre><h2 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h2><p>上述我们讲了归并排序的原理，将两个有序数组进行归并排序，但现实中可能不会给我们从上面的演算我们就直到，归并排序的前提是需要两个已经排好顺序的数组，那往往不会有两个已经排好顺序的数组给我们的呀<strong>(一般是杂乱无章的一个数组)</strong>，那这个算法是不是很鸡肋的呢？？</p><p>其实并不是的，首先假设题目给出的数组是这样子的：int[] arr = {2, 7, 8, 1, 4, 9};<br>当我们要做归并的时候就以 arr[3]也就元素为 1 的那个地方分开。是然后用一个指针 L 指向 arr[0]，一个指针 M 指向 arr[3]，用一个指针 R 指向 arr<a href="数组最后一位">5</a>。有了指针的帮助，我们就可以将这个数组切割成是两个有序的数组了（操作的方式就可以和上面一样了）<br>可是上面说了，一般给出的是杂乱无章的一个数组，现在还是达不到要求。比如给出的是这样一个数组：int[] arrays = {9, 2, 5, 1, 3, 2, 9, 5, 2, 1, 8};<br>此时，我们就得用到分治的思想了：</p><p>那么我们也可以这样想将 int[] arr = {2, 7, 8, 1, 4, 9};数组分隔成一份一份的，arr[0]它是一个有序的”数组”,arr[1]它也是一个有序的”数组”,利用指针(L,M,R)又可以像操作两个数组一样进行排序。最终合成{2,7}…….再不断拆分合并，最后又回到了我们的 arr = {1,2,4,7,8,9}，因此归并排序是可以排序杂乱无章的数组的</p><p>这就是我们的分治法—&gt;将一个大问题分成很多个小问题进行解决，最后重新组合起来</p><h2 id="算法复杂度分析-5"><a href="#算法复杂度分析-5" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h2><p>归并排序的时间复杂度为 O(nlogn)</p><h2 id="java-实现-4"><a href="#java-实现-4" class="headerlink" title="java 实现"></a>java 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arrays = &#123;<span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    mergeSort(arrays, <span class="number">0</span>, arrays.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"公众号：Java3y"</span> + arrays);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arrays</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> L      指向数组第一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> R      指向数组最后一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arrays, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果只有一个元素，那就不用排序了</span></span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取中间的数，进行拆分</span></span><br><span class="line">        <span class="keyword">int</span> M = (L + R) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左边的数不断进行拆分</span></span><br><span class="line">        mergeSort(arrays, L, M);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右边的数不断进行拆分</span></span><br><span class="line">        mergeSort(arrays, M + <span class="number">1</span>, R);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//合并</span></span><br><span class="line">        merge(arrays, L, M + <span class="number">1</span>, R);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arrays</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> L      指向数组第一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> M      指向数组分隔的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> R      指向数组最后的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arrays, <span class="keyword">int</span> L, <span class="keyword">int</span> M, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左边的数组的大小</span></span><br><span class="line">    <span class="keyword">int</span>[] leftArray = <span class="keyword">new</span> <span class="keyword">int</span>[M - L];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//右边的数组大小</span></span><br><span class="line">    <span class="keyword">int</span>[] rightArray = <span class="keyword">new</span> <span class="keyword">int</span>[R - M + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//往这两个数组填充数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt; M; i++) &#123;</span><br><span class="line">        leftArray[i - L] = arrays[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = M; i &lt;= R; i++) &#123;</span><br><span class="line">        rightArray[i - M] = arrays[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// arrays数组的第一个元素</span></span><br><span class="line">    <span class="keyword">int</span>  k = L;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//比较这两个数组的值，哪个小，就往数组上放</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; leftArray.length &amp;&amp; j &lt; rightArray.length) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//谁比较小，谁将元素放入大数组中,移动指针，继续比较下一个</span></span><br><span class="line">        <span class="keyword">if</span> (leftArray[i] &lt; rightArray[j]) &#123;</span><br><span class="line">            arrays[k] = leftArray[i];</span><br><span class="line"></span><br><span class="line">            i++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arrays[k] = rightArray[j];</span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果左边的数组还没比较完，右边的数都已经完了，那么将左边的数抄到大数组中(剩下的都是大数字)</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; leftArray.length) &#123;</span><br><span class="line">        arrays[k] = leftArray[i];</span><br><span class="line"></span><br><span class="line">        i++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果右边的数组还没比较完，左边的数都已经完了，那么将右边的数抄到大数组中(剩下的都是大数字)</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; rightArray.length) &#123;</span><br><span class="line">        arrays[k] = rightArray[j];</span><br><span class="line"></span><br><span class="line">        k++;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结及参考资料"><a href="#总结及参考资料" class="headerlink" title="总结及参考资料"></a>总结及参考资料</h1><p>除了以上常见的排序算法，还有堆排序、桶排序、基数排序、计数排序等。<br>常见的排序算法</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（七）——堆、哈希表、图</title>
      <link href="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E5%A0%86%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E3%80%81%E5%9B%BE/"/>
      <url>/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E5%A0%86%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E3%80%81%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h1><ul><li>堆(也被称为优先队列(队列+排序规则)，图一最大堆，图二最小堆)</li><li>堆是一种特殊的基于树的满足某些特性的数据结构，整个堆中的所有父子节点的键值都会满足相同的排序条件。堆更准确地可以分为最大堆与最小堆，在最大堆中，父节点的键值永远大于或者等于子节点的值，并且整个堆中的最大值存储于根节点；而最小堆中，父节点的键值永远小于或者等于其子节点的键值，并且整个堆中的最小值存储于根节点。</li></ul><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度:"></a>时间复杂度:</h1><ul><li>访问最大值 / 最小值: O(1)</li><li>插入: O(log(n))</li><li>移除最大值 / 最小值: O(log(n))</li></ul><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E5%A0%86%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E3%80%81%E5%9B%BE_2020-02-20-16-33-06.png" alt="数据结构与算法（七）——堆、哈希表、图_2020-02-20-16-33-06.png"></p><h1 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h1><ul><li>哈希能够将任意长度的数据映射到固定长度的数据。哈希函数返回的即是哈希值，如果两个不同的键得到相同的哈希值，即将这种现象称为碰撞。</li><li>Hash Map: Hash Map 是一种能够建立起键与值之间关系的数据结构，Hash Map 能够使用哈希函数将键转化为桶或者槽中的下标，从而优化对于目标值的搜索速度。</li></ul><p>碰撞解决</p><ul><li>链地址法（Separate Chaining）: 链地址法中，每个桶是相互独立的，包含了一系列索引的列表。搜索操作的时间复杂度即是搜索桶的时间（固定时间）与遍历列表的时间之和。</li><li>开地址法（Open Addressing）: 在开地址法中，当插入新值时，会判断该值对应的哈希桶是否存在，如果存在则根据某种算法依次选择下一个可能的位置，直到找到一个尚未被占用的地址。所谓开地址法也是指某个元素的位置并不永远由其哈希值决定。</li></ul><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E5%A0%86%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E3%80%81%E5%9B%BE_2020-02-20-16-35-27.png" alt="数据结构与算法（七）——堆、哈希表、图_2020-02-20-16-35-27.png"></p><h1 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h1><ul><li>图是一种数据元素间为多对多关系的数据结构，加上一组基本操作构成的抽象数据类型。<ul><li>无向图（Undirected Graph）: 无向图具有对称的邻接矩阵，因此如果存在某条从节点 u 到节点 v 的边，反之从 v 到 u 的边也存在。</li><li>有向图（Directed Graph）: 有向图的邻接矩阵是非对称的，即如果存在从 u 到 v 的边并不意味着一定存在从 v 到 u 的边。</li></ul></li></ul><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E5%A0%86%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E3%80%81%E5%9B%BE_2020-02-20-16-37-36.png" alt="数据结构与算法（七）——堆、哈希表、图_2020-02-20-16-37-36.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 堆、哈希表、图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（六）——树</title>
      <link href="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91/"/>
      <url>/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="树的介绍"><a href="#树的介绍" class="headerlink" title="树的介绍"></a>树的介绍</h1><p>树是一种非线性的数据结构，将它命名为“树”是因为它看起来像一颗倒挂的树，根朝上，页朝下。</p><p>当然计算机的树模型，是由现实中的树抽象来的，它指的是 N 个有父子关系的节点的有限集合。对于这个有限的节点集合而言，它满足如下条件：</p><ul><li>当 N=0 时，改节点集合为空，这课树也被称为空树</li><li>在任意的非空树中，有且仅有一个根(root)节点</li><li>当 N&gt;1 时，除根节点以外的其余节点可分为 M 个互为相交的有限集合 T1,T2,…,Tm，其中的每个集合本身又是一棵树，并称其为根的子树（subtree）。</li></ul><h1 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h1><ul><li>节点：树的最基本组成单元，通常包括一个数据元素及若干指针用于指向其他节点。</li><li>节点的度：节点拥有的子树的个数被称为节点的度（degree）</li><li>树的度：树中所有节点的度的最大值就是该树的度</li><li>叶子节点：度为 0 的节点被称为叶子节点或终端节点</li><li>分支节点：度不为 0 的节点被称为分支节点或非终端节点</li><li>子节点,父节点，兄弟节点：节点的子树的根被称为该节点的子节点，而该节点称为子节点的父节点(parent).具有相同父节点的子节点之间互称为兄弟节点。</li><li>节点的层次(level):节点的层次从根开始算起，根的层次值为 1，其余节点的层次值为父节点层次值加 l。</li><li>树的深度(depth):树中节点的最大层次值称为树的深度或高度。</li><li>有序树与无序树:如果将树中节点的各棵子树看成从左到右是有序的(即不能互换),则称该树为有序树,否则称为无序树。</li><li>祖先节点(ancestor)：从根到该节点所经分支上的所有节点</li><li>后代节点(descendant):以某节点为根的子树中任一节点都称为该节点的后代节点。</li><li>森林(forest):森林是两颗或两颗以上互不相交的树的集合，删去一棵树的根，就得到一个森林。</li></ul><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉树指的是每个节点最多只能有两个子树的有序树。通常左边的子树被称作“左子树”(left subtree)，右边的子树被称为“右子树”(right subtree).由此可见，二叉树依然是树，它是一种特殊的树。</p><h2 id="树与二叉树的区别"><a href="#树与二叉树的区别" class="headerlink" title="树与二叉树的区别"></a>树与二叉树的区别</h2><ul><li>树中节点的最大度数没有限制，而二叉树节点的最大度数为 2，也就是说，二叉树是节点的最大度数为 2 的树。</li><li>无序树的节点无左右之分，而二叉树的节点有左，右之分，也就是说，二叉树是有序树。</li></ul><h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><p>一棵深度为 k 的二叉树，如果它包含了 2^k-1 个节点，就把这棵二叉树称为满二叉树。满二叉树的特点是。每一层上的节点数都是最大节点数，即各层节点数分别为 1,2,4,8, 16,…,满二叉树下图所示：<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91_2020-02-20-14-59-36.png" alt="数据结构与算法（六）——树_2020-02-20-14-59-36.png"></p><h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>如果一颗二叉树除最后一层外，其余层的所有节点都是满的，并且最后一层或者是满的，或者仅在右边缺少若干连续的节点，则此二叉树就是完全二叉树。</p><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>哈夫曼树又被称为最优二叉树，是一种带权路径最短的二叉树。哈夫曼树是二叉树的一种应用，在信息检索中很常用.</p><p>对于哈夫曼树，有一个很重要的定理:对于具有对 n 个叶子节点的哈夫曼树，一共需要 2 乘以 n-1 个节点。因为对于二叉树来说，有三种类型节点，即度数为 2 的节点、度数为 1 的节点和度数为 0 的叶子节点，而哈夫曼树的非叶子节点都是由两个节点合并产生的，所以不会出现度 数为 1 的节点。而生成的非叶子节点的个数为叶子节点个数-1 因此 n 个叶子节点的哈夫曼树，一共需要 Z 乘以 n-1 个节点。</p><h2 id="二叉树的特点"><a href="#二叉树的特点" class="headerlink" title="二叉树的特点"></a>二叉树的特点</h2><ul><li>二叉树第 i 层上的节点数据至多为 2 的 i-1 次方</li><li>深度为 k 的二叉树至多有 2 的 k 次方-1 个节点.满二叉树的每层节点的数量依次为 1, 2, 4,8,…,因此深度为 k 的满二叉树包含的节点数为公比为 2 的等比数列的前 k 项总和，即 2 的 k 次方一 1。</li><li>在任何一棵二叉树中，如果其叶子节点的数量为 n0,度为 2 的子节点数量为 n2，则 n0=n2 + 1。这是因为:如果为任意叶子节点增加一个子节点，则原有叶子节点变成非叶子节点，新增节点变成叶子节点，上述等式不变;如果为任意叶子节点增加两个子节点，则原有叶子节点变成度为 2 的非叶子 lto 点，新增的两个节点变成叶子节点，上述等式依然不变。</li><li>具有 n 个节点的完全二叉树的深度为 log2(n+1)</li></ul><h2 id="二叉树的储存"><a href="#二叉树的储存" class="headerlink" title="二叉树的储存"></a>二叉树的储存</h2><ul><li>顺序存储:采用数组来记录二叉树的所有节点。（可能会造成空间浪费）</li><li>二叉链表存储:每个节点保留一个 left,right 域，分别指向其左、右子节点。</li><li>三叉链表存储:每个节点保留一个 left, right,parent 域，分别指向其左、右子节点和父节点。</li></ul><h2 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h2><p>遍历二叉树指的是按某种规律依次访问二叉树的每个节点，对二叉树的遍历过程就是将非线性结构的二叉树的节点排列成线性序列的过程。<br>如果采用顺序结构来保存二叉树，程序遍历二叉树非常容易，无须进行任何思考，直接遍历底层数组即可。如果采用链表来保存二叉树的节点，则有以下两种遍历方式。</p><ul><li>深度优先遍历：这种遍历算法将先访问到树中最深层次的节点<ul><li>先序遍历</li><li>中序遍历</li><li>后序遍历</li></ul></li><li>广度优先遍历：这种遍历算法将逐层访问每层的节点，先访问根（第一层）节点，然后访问第二层的节点…..一次类推。因此，广度优先遍历方法又被称为按层遍历。</li></ul><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>先序遍历指先处理根节点，其处理顺序如下：</p><ol><li>访问根节点</li><li>递归遍历左子树</li><li>递归遍历右子树</li></ol><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>中序遍历指其次处理根节点.其处理顺序如下。</p><ol><li>递归遍历左子树</li><li>访问根节点</li><li>递归遍历右子树</li></ol><h4 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h4><p>后序遍历指最后处理根节点，其处理顺序如下。</p><ol><li>递归遍历左子树</li><li>递归遍历右子树</li><li>访问根节点</li></ol><h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><p>广度优先遍历又称为按层遍历，整个遍历算法是先遍历几叉树的第一层(根节点)，再遍历根节点的两个子’节点(第二层)……依此类推，逐层遍历二叉树的所有节点。</p><p>为了实现广度优先遍历，可以借助于具有 FIFO 特征的队列来实现。如下所示。</p><ul><li>建一个队列(先进先出)，把树的根节点压入队列。</li><li>从队列中弹出一个节点(第一个弹出的就是根节点)，然后把改节点的左，右节点压入队列，如果没有子节点，则说明已经达到叶子节点了。</li><li>用循环重复执行 2 步，知道队列为空。当队列为空时，说明所有的叶子节点(深度最深的层)都已经经过了队列，也就完成了遍历。</li></ul><h4 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h4><p>用栈储存二叉树，栈代替我们完成了递归。</p><h4 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h4><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91_2020-02-20-15-45-37.png" alt="数据结构与算法（六）——树_2020-02-20-15-45-37.png"></p><p>前序遍历：1 2 4 5 7 8 3 6</p><p>中序遍历：4 2 7 5 8 1 3 6</p><p>后序遍历：4 7 8 5 2 6 3 1</p><p>层次遍历：1 2 3 4 5 6 7 8</p><h2 id="二叉树的初始化"><a href="#二叉树的初始化" class="headerlink" title="二叉树的初始化"></a>二叉树的初始化</h2><h4 id="链式储存"><a href="#链式储存" class="headerlink" title="链式储存"></a>链式储存</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by engineer on 2017/10/23.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 二叉树结点定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据域</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="comment">// 左子树</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode&lt;T&gt; leftChild;</span><br><span class="line">    <span class="comment">// 右子树</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode&lt;T&gt; rightChild;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, data, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(TreeNode&lt;T&gt; leftChild, T data, TreeNode&lt;T&gt; rightChild)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.leftChild = leftChild;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.rightChild = rightChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode&lt;T&gt; <span class="title">getLeftChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> leftChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode&lt;T&gt; <span class="title">getRightChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rightChild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建二叉树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 树根</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">TreeNode <span class="title">CreateTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeNode&lt;String&gt; nodeH = <span class="keyword">new</span> TreeNode&lt;&gt;(<span class="string">"H"</span>);</span><br><span class="line">        TreeNode&lt;String&gt; nodeG = <span class="keyword">new</span> TreeNode&lt;&gt;(<span class="string">"G"</span>);</span><br><span class="line"></span><br><span class="line">        TreeNode&lt;String&gt; nodeF = <span class="keyword">new</span> TreeNode&lt;&gt;(nodeH, <span class="string">"F"</span>, <span class="keyword">null</span>);</span><br><span class="line">        TreeNode&lt;String&gt; nodeE = <span class="keyword">new</span> TreeNode&lt;&gt;(nodeG, <span class="string">"E"</span>, <span class="keyword">null</span>);</span><br><span class="line">        TreeNode&lt;String&gt; nodeD = <span class="keyword">new</span> TreeNode&lt;&gt;(<span class="string">"D"</span>);</span><br><span class="line"></span><br><span class="line">        TreeNode&lt;String&gt; nodeC = <span class="keyword">new</span> TreeNode&lt;&gt;(<span class="keyword">null</span>, <span class="string">"C"</span>, nodeF);</span><br><span class="line">        TreeNode&lt;String&gt; nodeB = <span class="keyword">new</span> TreeNode&lt;&gt;(nodeD, <span class="string">"B"</span>, nodeE);</span><br><span class="line">        TreeNode&lt;String&gt; nodeA = <span class="keyword">new</span> TreeNode&lt;&gt;(nodeB, <span class="string">"A"</span>, nodeC);</span><br><span class="line">        <span class="keyword">return</span> nodeA;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问每个结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">visitNode</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        System.out.print(node.getData().toString());</span><br><span class="line">        System.out.print(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序遍历-递归实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preTraversal</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            visitNode(node);</span><br><span class="line">            preTraversal(node.getLeftChild());</span><br><span class="line">            preTraversal(node.getRightChild());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序遍历-递归实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            traversal(node.getLeftChild());</span><br><span class="line">            visitNode(node);</span><br><span class="line">            traversal(node.getRightChild());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后序遍历-递归实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postTraversal</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            postTraversal(node.getLeftChild());</span><br><span class="line">            postTraversal(node.getRightChild());</span><br><span class="line">            visitNode(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="排序二叉树"><a href="#排序二叉树" class="headerlink" title="排序二叉树"></a>排序二叉树</h2><p>排序二叉树是一种特殊结构的二叉树，通过它可以非常方便地对树中的所有节点进行排序和检索</p><p>排序二叉树要么是一颗空二叉树，要么是具有下列性质的二叉树</p><ul><li>若它的左子树不空，则左子树上所有的节点的值均小于它的根节点的值</li><li>若它的右子树不空，则右子树上所有的节点均大于它的根节点的值</li><li>它的左右子树分别为排序二叉树。</li></ul><p>下图显示了一棵排序二叉树. 对于排序二叉树，若按中序遍历就可以得到由小到大的有序序列。中序遍历得:<br>{2,3,4,8,9,9,10,13,15,18)<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91_2020-02-20-15-57-44.png" alt="数据结构与算法（六）——树_2020-02-20-15-57-44.png"></p><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>排序二叉树虽然可以快速检索，但在最坏的情况下，如果插入的节点集本身就是有序的，要么是由小到大排列，要么是由大到小排列，那么最后得到的排序二义树将变成链表:在这种情况下，排序二叉树就变成了普通链表，其检索效率就会很低。<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91_2020-02-20-16-07-33.png" alt="数据结构与算法（六）——树_2020-02-20-16-07-33.png"></p><p>为了改变排序二叉树存在的不足，对二叉树进行改进————红黑树，他将这种排序二叉树称为“对称二叉 B 树”。</p><p>红黑树的应用非常广泛，常见的函数库，如 C++中的 map，multimap,以及 Java 中的 TreeMap，TreeSet， Java8 中的 HashMap 的实现也采用了红黑树。</p><p>红黑树从本质上来说就是一颗二叉查找树，但是在二叉树的基础上增加了着色相关的性质，使得红黑树可以保证相对平衡，从而保证红黑树的增删改查的时间复杂度最坏也能达到 O(log N)。</p><p>红黑树是一个更高效的检索二叉树，因此常常用来实现关联数组。典型的，JDK 提供的集合类 TreeMap 本身就是一颗红黑树的实现。 红黑树在原有的排序二叉树上增加如下几个要求：</p><ul><li>性质 l:每个节点要么是红色，要么是黑色。</li><li>性质 2:根节点永远是黑色的。</li><li>除质 3:所有的叶子节点都是空节点(即 null)，并且是黑色的。</li><li>性质 4:每个红色节点的两个子节点都是黑色的。(从每个叶子到根的路径上不会有两个连续的红色节点。)</li><li>性质 5:从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。</li></ul><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91_2020-02-20-16-09-08.png" alt="数据结构与算法（六）——树_2020-02-20-16-09-08.png"></p><p>上图是一棵典型的红黑树，红黑树的 5 条特性确保了从根到叶子的最长的可能路径不多于最短的可能路径的两倍长，使得整棵树大致上是平衡的。树上的增删改查操作的最坏情况时间都与树的高度成正比，所以红黑树在最坏情况下也是高效的。</p><p>在红黑树中一般用黑的 NIL 节点表示叶节点，不包含值，只是标志该分支结束，有时候绘图中会直接省略。</p><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>当在含 n 个关键字的红黑树上进行 insert 和 delete 操作时，修改后的树可能不满足上面给出的 5 个红黑树的基本特性，所以需要改变树中的某些节点的颜色以及指针结构。 这些指针结构的修改是通过旋转完成的，旋转分为左旋和右旋:</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91_2020-02-20-16-16-55.png" alt="数据结构与算法（六）——树_2020-02-20-16-16-55.png"></p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p>疯狂 java 笔记之树和二叉树</p><p>图解红黑树</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（五）——队列</title>
      <link href="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/"/>
      <url>/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="队列介绍"><a href="#队列介绍" class="headerlink" title="队列介绍"></a>队列介绍</h1><p>队列是一种线性表，它支持 先进先出（FIFO），</p><p>尾部添加、头部删除，跟我们生活中的排队类似。</p><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><ul><li>索引: O(n)</li><li>搜索: O(n)</li><li>插入: O(1)</li><li>移除: O(1)</li></ul><h1 id="队列类型"><a href="#队列类型" class="headerlink" title="队列类型"></a>队列类型</h1><ol><li>单队列</li></ol><p>单队列就是常见的队列, 每次添加元素时，都是添加到队尾：</p><p>单队列会出现“假溢出”现象，每次从队首删除元素，元素都要上前移动一个位置，能放的空位就相对减少了。</p><ol start="2"><li>循环队列</li></ol><p>我们可以将队列看成一个首位相连的环。当一个元素从队列删除后，新空余出来的空间可以作为队列的尾部。</p><p>插入的时候，根据实际数据量count与数组长度比较，未满根据数组新增标志putIndex插入数据，如果数组下标临界，设为0重新开始，count++;</p><p>删除的时候，判断有无实际数据count，有的话根据取数据删除标志takeIndex,若takeIndex走到最后，从0开始，count–;</p><h1 id="队列应用"><a href="#队列应用" class="headerlink" title="队列应用"></a>队列应用</h1><ol><li>模拟现实世界中的队列，如售票柜台的队列以及其他先到先服务的场景。</li><li>计算客户在呼叫中心等待的时间。</li><li>异步数据的传输（文件输入输出、管道、嵌套字）。</li><li>操作系统中的优先级任务执行。</li><li>短信群体发送 应用的发布订阅模式</li></ol><h1 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 1.单向队列（Queue）：只能在一端插入数据，另一端删除数据。</span></span><br><span class="line"><span class="comment">     * 2.双向队列（Deque）：每一端都可以进行插入数据和删除数据操作。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  与栈不同的是，队列中的数据不总是从数组的0下标开始的</span></span><br><span class="line"><span class="comment">     *  选择的做法是移动队头和队尾的指针。</span></span><br><span class="line"><span class="comment">     *  为了避免队列不满却不能插入新的数据，我们可以让队尾指针绕回到数组开始的位置，这也称为“循环队列”。</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="comment">// 单向循环队列，顺序存储结构实现</span></span><br><span class="line">    <span class="keyword">private</span> Object[] objQueue;</span><br><span class="line">    <span class="comment">//队列大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="comment">//顶部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top;</span><br><span class="line">    <span class="comment">//底部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bottom;</span><br><span class="line">    <span class="comment">//实际元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> item;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        maxSize = size;</span><br><span class="line">        objQueue = <span class="keyword">new</span> Object[maxSize];</span><br><span class="line">        top = <span class="number">0</span>;</span><br><span class="line">        bottom = -<span class="number">1</span>;</span><br><span class="line">        item = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入队</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(item == maxSize)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(obj+<span class="string">" add error, queue is full"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环队列，首尾结合，下标控制队首和队尾位置</span></span><br><span class="line">        <span class="keyword">if</span>(bottom == maxSize-<span class="number">1</span>)&#123;</span><br><span class="line">            bottom = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        objQueue[++bottom] = obj;</span><br><span class="line">        item++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出对</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(item == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"queue is null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Object obj = objQueue[top];</span><br><span class="line">        <span class="comment">//声明原顶栈可以回收空间(GC)</span></span><br><span class="line">        objQueue[top] = <span class="keyword">null</span>;</span><br><span class="line">        top++;</span><br><span class="line">        <span class="comment">//重置下标</span></span><br><span class="line">        <span class="keyword">if</span>(top == maxSize)&#123;</span><br><span class="line">            top = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        item--;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//链式存储结构实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeQueue</span>&lt;<span class="title">Object</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> NodeQueue next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NodeQueue</span><span class="params">(Object data, NodeQueue next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队列头 出</span></span><br><span class="line">    <span class="keyword">private</span> NodeQueue queueTop;</span><br><span class="line">    <span class="comment">//队列尾 进</span></span><br><span class="line">    <span class="keyword">private</span> NodeQueue queueBottom;</span><br><span class="line">    <span class="comment">//队列大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queueTop = <span class="keyword">null</span>;</span><br><span class="line">        queueBottom = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入队</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNodeQueue</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            queueTop = <span class="keyword">new</span> NodeQueue(obj,<span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//指向同一存储地址</span></span><br><span class="line">            queueBottom = queueTop;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            NodeQueue&lt;Object&gt; nodeQueue = <span class="keyword">new</span> NodeQueue(obj,<span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//让尾节点的next指向新增的节点</span></span><br><span class="line">            queueBottom.next = nodeQueue;</span><br><span class="line">            <span class="comment">//以新节点作为尾节点</span></span><br><span class="line">            queueBottom = nodeQueue;</span><br><span class="line">        &#125;</span><br><span class="line">        size ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出队</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">removeNodeQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"queue is null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        NodeQueue nodeQueue = queueTop;</span><br><span class="line">        queueTop = queueTop.next;</span><br><span class="line">        <span class="comment">//声明原队列头next可以回收空间(GC)</span></span><br><span class="line">        nodeQueue.next = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> nodeQueue.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"&#123; "</span>);</span><br><span class="line">        <span class="keyword">for</span>(NodeQueue nodeQueue = queueTop ; nodeQueue != <span class="keyword">null</span> ; nodeQueue = nodeQueue.next)&#123;</span><br><span class="line">            sb.append(nodeQueue.data.toString()+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString()+<span class="string">"&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue queue = <span class="keyword">new</span> Queue();</span><br><span class="line">        queue.addNodeQueue(<span class="string">"123"</span>);</span><br><span class="line">        queue.addNodeQueue(<span class="string">"abc"</span>);</span><br><span class="line">        queue.addNodeQueue(<span class="string">"ddd"</span>);</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">        queue.removeNodeQueue();</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">        queue.removeNodeQueue();</span><br><span class="line">        queue.removeNodeQueue();</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（四）——栈</title>
      <link href="/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88/"/>
      <url>/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="栈介绍"><a href="#栈介绍" class="headerlink" title="栈介绍"></a>栈介绍</h1><p>栈作为一种数据结构，它按照先进后出（LIFO）的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶。</p><p>栈是元素的集合，其包含了两个基本操作：push 操作可以用于将元素压入栈，pop 操作可以将栈顶元素移除。</p><p>栈是一种特殊的线性表，其入栈和出栈只允许在一端进行。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>数据结构中，栈是一种线性数据结构，遵从 LIFO（后进先出）的操作顺序，所有操作都是在顶部进行。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88_2020-02-17-17-16-10.png" alt="数据结构与算法（四）——栈_2020-02-17-17-16-10.png"></p><p>有点像羽毛球桶。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88_2020-02-17-17-17-12.png" alt="数据结构与算法（四）——栈_2020-02-17-17-17-12.png"></p><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><ul><li>索引: O(n)</li><li>搜索: O(n)</li><li>插入: O(1)</li><li>移除: O(1)</li></ul><h1 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h1><ul><li>符号匹配</li><li>中缀表达式转换为后缀表达式</li><li>计算后缀表达式</li><li>实现函数的嵌套调用</li><li>HTML 和 XML 文件中的标签匹配</li><li>网浏览器中已访问页面的历史记录</li></ul><h1 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h1><h2 id="数组实现-Stack-本是用数组实现的"><a href="#数组实现-Stack-本是用数组实现的" class="headerlink" title="数组实现( Stack 本是用数组实现的)"></a>数组实现( Stack 本是用数组实现的)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="comment">//小贴士：通常可以利用栈实现字符串逆序，还可以利用栈判断分隔符是否匹配，如&lt;a[b&#123;c&#125;]&gt;，可以正进反出，栈为空则成功。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**基于数组实现的顺序栈，连续存储的线性实现，需要初始化容量**/</span></span><br><span class="line">    <span class="comment">//固定数据类型</span></span><br><span class="line">    <span class="comment">//private int[] array;</span></span><br><span class="line">    <span class="comment">//动态数据类型</span></span><br><span class="line">    <span class="keyword">private</span> Object[] objArray;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(maxSize &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            objArray = <span class="keyword">new</span> Object[maxSize];</span><br><span class="line">            <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">            top = -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"初始化大小错误：maxSize="</span> + maxSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入栈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">objPush</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="comment">//扩容</span></span><br><span class="line">        grow();</span><br><span class="line">        <span class="comment">//++在前表示先运算再赋值，优先级高，在后表示先赋值再运算，优先级低</span></span><br><span class="line">        objArray[++top] = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出栈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">objPop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object obj = peekTop();</span><br><span class="line">        <span class="comment">//声明原顶栈可以回收空间(GC)</span></span><br><span class="line">        objArray[top--] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看栈顶</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">peekTop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(top != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> objArray[top];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"stack is null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态扩容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// &lt;&lt; 左移运算符，1表示乘以2的1次方</span></span><br><span class="line">        <span class="keyword">if</span>(top == maxSize-<span class="number">1</span>)&#123;</span><br><span class="line">            maxSize = maxSize&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            objArray = Arrays.copyOf(objArray,maxSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**基于链式存储，不连续存储的非线性实现**/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">Object</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object data, Node next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node nodeTop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nodePush</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="comment">//栈顶指向新元素，新元素的next指向原栈顶元素</span></span><br><span class="line">        nodeTop = <span class="keyword">new</span> Node(obj,nodeTop);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">nodePop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node old = nodeTop;</span><br><span class="line">        <span class="comment">//声明原顶栈可以回收空间(GC)</span></span><br><span class="line">        old.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//栈顶指向下一个元素</span></span><br><span class="line">        nodeTop = nodeTop.next;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> old.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"[ "</span>);</span><br><span class="line">        <span class="keyword">for</span>(Node&lt;Object&gt; node = nodeTop; node != <span class="keyword">null</span>; node = node.next)&#123;</span><br><span class="line">            sb.append(node.data.toString() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString()+<span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Stack stack = new Stack(1);</span></span><br><span class="line"><span class="comment">//        stack.objPush("abc");</span></span><br><span class="line"><span class="comment">//        stack.objPush(123);</span></span><br><span class="line"><span class="comment">//        stack.objPush("de");</span></span><br><span class="line"><span class="comment">//        stack.objPush("cd");</span></span><br><span class="line"><span class="comment">//        stack.objPush("er");</span></span><br><span class="line"><span class="comment">//        stack.objPush("hello");</span></span><br><span class="line"><span class="comment">//        stack.objPush(666);</span></span><br><span class="line"><span class="comment">//        stack.objPush(545);</span></span><br><span class="line"><span class="comment">//        stack.objPush("word");</span></span><br><span class="line"><span class="comment">//        while (stack.top != -1)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(stack.objPop());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println(stack.peekTop());</span></span><br><span class="line">        Stack stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        stack.nodePush(<span class="string">"111"</span>);</span><br><span class="line">        stack.nodePush(<span class="string">"222"</span>);</span><br><span class="line">        stack.nodePush(<span class="string">"aaa"</span>);</span><br><span class="line">        stack.nodePush(<span class="string">"bbb"</span>);</span><br><span class="line">        System.out.println(stack);</span><br><span class="line">        <span class="keyword">while</span> (stack.size &gt; <span class="number">1</span>)</span><br><span class="line">        System.out.println(stack.nodePop());</span><br><span class="line">        System.out.println(stack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * description:LinkedList 模拟 Stack</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * author: shixinzhang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * data: 10/23/2016</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListStack</span> <span class="keyword">extends</span> <span class="title">LinkedList</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedListStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.push(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">调用：</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPush</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    LinkedListStack stack = <span class="keyword">new</span> LinkedListStack();</span><br><span class="line">    System.out.println(<span class="string">"栈是否为空: "</span> + stack.isEmpty());</span><br><span class="line"></span><br><span class="line">    stack.push(<span class="string">"shixin"</span>);</span><br><span class="line">    stack.push(<span class="string">"好帅"</span>);</span><br><span class="line">    stack.push(<span class="string">"技巧一流"</span>);</span><br><span class="line">    stack.push(<span class="string">"haha"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"栈中元素: "</span> + stack);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"获取顶端元素 peek :"</span> + stack.peek());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"顶端元素出栈 pop :"</span> + stack.pop());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"出栈后栈内元素:"</span> + stack);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"search(好帅) 的位置:"</span> + stack.search(<span class="string">"好帅"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（三）——链表</title>
      <link href="/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="链表介绍"><a href="#链表介绍" class="headerlink" title="链表介绍"></a>链表介绍</h1><p>链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。</p><p>每个结点包括存储数据元素的数据域和存储下一个结点地址的指针域两个部分。 </p><p>数据元素的逻辑顺序也是通过链表中的指针链接次序实现的。</p><h1 id="物理储存"><a href="#物理储存" class="headerlink" title="物理储存"></a>物理储存</h1><p>链表的分布式没有顺序的，非连续的，也就是随心所欲，想在哪在哪，那怎么找到下一个的，就是靠指针连接的。以单向链表为例，如下图：<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8_2020-02-14-16-43-24.png" alt="数据结构与算法（三）——链表_2020-02-14-16-43-24.png"></p><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><ul><li>索引: O(n)</li><li>搜索: O(n)</li><li>插入: O(1)</li><li>移除: O(1)</li></ul><h1 id="链表的优缺点"><a href="#链表的优缺点" class="headerlink" title="链表的优缺点"></a>链表的优缺点</h1><ul><li>优点：空间没有限制 插入删除元素很快</li><li>缺点：存取速度很慢</li></ul><h1 id="链表的分类"><a href="#链表的分类" class="headerlink" title="链表的分类"></a>链表的分类</h1><ul><li>单向链表<br>链表中的节点仅指向下一个节点，并且最后一个节点指向空。<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8_2020-02-14-16-46-29.png" alt="数据结构与算法（三）——链表_2020-02-14-16-46-29.png"></li><li>双向链表<br>其中每个节点具有两个指针 p、n，使得 p 指向先前节点并且 n 指向下一个节点；最后一个节点的 n 指针指向 null。<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8_2020-02-14-16-47-56.png" alt="数据结构与算法（三）——链表_2020-02-14-16-47-56.png"></li><li>循环链表<br>每个节点指向下一个节点并且最后一个节点指向第一个节点的链表。<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8_2020-02-14-16-49-21.png" alt="数据结构与算法（三）——链表_2020-02-14-16-49-21.png"></li></ul><h1 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h1><h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLink</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Node head = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Object data;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Node next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        Node addNode = <span class="keyword">new</span> Node(data); <span class="comment">//实例化一个节点</span></span><br><span class="line">        <span class="comment">//判断是不是第一个节点,如果是的话，我就把这个加入到头节点,因为是头节点所有就没有前驱节点了</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = addNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果不是第一个节点 得找到当前链表的最后一个节点 把要加入的节点的当做最后一个节点的后继节点</span></span><br><span class="line">            Node temp = head; <span class="comment">//定义一个临时节点 把头节点赋值给他 然后一直找，直到找到最后一个节点</span></span><br><span class="line">            <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到当前链表最后一个节点，然后把要加入的这个节点当做尾节点的后继</span></span><br><span class="line">            temp.next = addNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == head) &#123;</span><br><span class="line">            System.out.println(<span class="string">"链表的长度为0"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 说明不是只有一个元素</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Node temp = head;</span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(temp.data);</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取链表的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先需要判断指定位置是否正确</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertNode</span><span class="params">(<span class="keyword">int</span> index, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">1</span> || index &gt; length() + <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"下标校验不通过。"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//临时节点，从头节点开始</span></span><br><span class="line">        Node temp = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录遍历的当前位置</span></span><br><span class="line">        <span class="keyword">int</span> currentPos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化要插入的节点</span></span><br><span class="line">        Node insertNode = <span class="keyword">new</span> Node(value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//找到上一个节点的位置了</span></span><br><span class="line">            <span class="keyword">if</span> ((index - <span class="number">1</span>) == currentPos) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//temp表示的是上一个节点</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//将原本由上一个节点的指向交由插入的节点来指向</span></span><br><span class="line">                insertNode.next = temp.next;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//将上一个节点的指针域指向要插入的节点</span></span><br><span class="line">                temp.next = insertNode;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            currentPos++;</span><br><span class="line">            temp = temp.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定位置的节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//首先需要判断指定位置是否正确，</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">1</span> || index &gt; length() + <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"下标校验不通过。"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//临时节点，从头节点开始</span></span><br><span class="line">        Node temp = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录遍历的当前位置</span></span><br><span class="line">        <span class="keyword">int</span> currentPos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//先找到要删除节点 上一个节点的位置</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index - <span class="number">1</span> == currentPos) &#123;</span><br><span class="line">                <span class="comment">//temp 表示要删除的节点</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//temp.next表示的是想要删除的节点</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//将想要删除的节点存储一下</span></span><br><span class="line">                Node deleteNode = temp.next;</span><br><span class="line">                <span class="comment">//把想要删除的下一个节点由上一个节点交互</span></span><br><span class="line">                temp.next = deleteNode.next;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            currentPos++;</span><br><span class="line">            temp = temp.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getOne</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">//首先需要判断指定位置是否正确，</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">1</span> || index &gt; length()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"下标校验不通过"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//临时节点</span></span><br><span class="line">        Node temp = head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录遍历的当前位置</span></span><br><span class="line">        <span class="keyword">int</span> currentPos = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index==currentPos)&#123;</span><br><span class="line">                <span class="keyword">return</span> temp.data;</span><br><span class="line">            &#125;</span><br><span class="line">            currentPos++;</span><br><span class="line">            temp=temp.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyLink myLink = <span class="keyword">new</span> MyLink();</span><br><span class="line">        myLink.addNode(<span class="string">"1"</span>);</span><br><span class="line">        myLink.addNode(<span class="string">"aaaa"</span>);</span><br><span class="line">        myLink.traverse();</span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">        myLink.delete(<span class="number">1</span>);</span><br><span class="line">        myLink.addNode(<span class="string">"333"</span>);</span><br><span class="line">        myLink.traverse();</span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">        Object one = myLink.getOne(<span class="number">1</span>);</span><br><span class="line">        System.out.println(one);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 链表通常由一连串节点组成，每个节点包含任意的实例数据（data fields）和一或两个用来指向上一个/或下一个节点的位置的链接（"links"）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node head; <span class="comment">//链表头</span></span><br><span class="line">    <span class="keyword">private</span> Node tail; <span class="comment">//链表尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size; <span class="comment">//节点数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双端链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object data;</span><br><span class="line">        <span class="keyword">private</span> Node prev; <span class="comment">//上一个</span></span><br><span class="line">        <span class="keyword">private</span> Node next; <span class="comment">//下一个</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向链表头添加数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addHead</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(object);</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            head = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            head.prev = node;</span><br><span class="line">            node.next = head;</span><br><span class="line">            head = node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//头部指向下一个，prev值为null则说明是链表的头部</span></span><br><span class="line">        <span class="keyword">if</span>(size != <span class="number">0</span>)&#123;</span><br><span class="line">            head.prev = <span class="keyword">null</span>;</span><br><span class="line">            head = head.next;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *向链表尾添加数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTail</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(object);</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            head = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node.prev = tail;</span><br><span class="line">            tail.next = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除尾部</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteTail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//尾部指向上一个，next值为null则说明是链表的尾部</span></span><br><span class="line">        <span class="keyword">if</span>(size != <span class="number">0</span>)&#123;</span><br><span class="line">            tail.next = <span class="keyword">null</span>;</span><br><span class="line">            tail = tail.prev;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node node = head;</span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.print(<span class="string">"["</span>+node.data+<span class="string">"-&gt;"</span>);</span><br><span class="line">            node = node.next;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList linkedList = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        linkedList.addHead(<span class="string">"123"</span>);</span><br><span class="line"><span class="comment">//        linkedList.addHead("abc");</span></span><br><span class="line"><span class="comment">//        linkedList.addHead("%$$");</span></span><br><span class="line"><span class="comment">//        linkedList.addTail("+_+");</span></span><br><span class="line"><span class="comment">//        linkedList.addTail("hello");</span></span><br><span class="line">        linkedList.addTail(<span class="string">"word"</span>);</span><br><span class="line">        linkedList.deleteHead();</span><br><span class="line">        linkedList.deleteTail();</span><br><span class="line">        linkedList.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（二）——数组</title>
      <link href="/2020/02/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/"/>
      <url>/2020/02/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数组介绍"><a href="#数组介绍" class="headerlink" title="数组介绍"></a>数组介绍</h1><p>数组——数据结构的鼻祖。数组几乎能表示一切的数据结构。</p><p>在 Java 中，数组是用来存放同一种数据类型的集合，注意只能存放同一种数据类型(Object 类型数组除外)。</p><h1 id="物理储存"><a href="#物理储存" class="headerlink" title="物理储存"></a>物理储存</h1><p>数组的内存空间都是连续的，如下图：<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84_2020-02-14-16-41-07.png" alt="数据结构与算法（二）——数组_2020-02-14-16-41-07.png"></p><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><ul><li>查找: O(n)</li><li>插入: O(1)</li><li>删除: O(n)</li></ul><h1 id="数组特点"><a href="#数组特点" class="headerlink" title="数组特点"></a>数组特点</h1><ol><li>插入快：无序数组只需要在数组末尾插入；有序数组需要在指定的位置插入</li><li>查找慢：根据下标取值是很快的，但根据元素查找的话，如果是无序数组，需要一个个遍历，是很慢的。有序数组，根据特定的算法会快一些（各种排序算法）。</li><li>删除慢：根据元素值删除，我们要先找到该元素所处的位置，然后将元素后面的值整体向前面移动一个位置。也需要比较多的时间。</li></ol><p>缺点：</p><p>大小固定，连续内存</p><h1 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a>数组的声明</h1><ol><li>第一种方式<br>数据类型 [] 数组名称 = new 数据类型[数组长度];</li><li>第二种方式<br>数据类型 [] 数组名称 = {数组元素 1，数组元素 2，……}</li></ol><h1 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ys.array;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> </span>&#123;</span><br><span class="line">     <span class="comment">//定义一个数组</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> [] intArray;</span><br><span class="line">     <span class="comment">//定义数组的实际有效长度</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> elems;</span><br><span class="line">     <span class="comment">//定义数组的最大长度</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//默认构造一个长度为50的数组</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">MyArray</span><span class="params">()</span></span>&#123;</span><br><span class="line">         elems = <span class="number">0</span>;</span><br><span class="line">         length = <span class="number">50</span>;</span><br><span class="line">         intArray = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//构造函数，初始化一个长度为length 的数组</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">MyArray</span><span class="params">(<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">         elems = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">this</span>.length = length;</span><br><span class="line">         intArray = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//获取数组的有效长度</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> elems;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 遍历显示元素</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; elems ; i++)&#123;</span><br><span class="line">             System.out.print(intArray[i]+<span class="string">" "</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 添加元素</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> value,假设操作人是不会添加重复元素的，如果有重复元素对于后面的操作都会有影响。</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span>添加成功返回true,添加的元素超过范围了返回false</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(elems == length)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             intArray[elems] = value;</span><br><span class="line">             elems++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 根据下标获取元素</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span>查找下标值在数组下标有效范围内，返回下标所表示的元素</span></span><br><span class="line"><span class="comment">      * 查找下标超出数组下标有效值，提示访问下标越界</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;elems)&#123;</span><br><span class="line">             System.out.println(<span class="string">"访问下标越界"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> intArray[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 查找元素</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> searchValue</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span>查找的元素如果存在则返回下标值，如果不存在，返回 -1</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> searchValue)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> i ;</span><br><span class="line">         <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; elems ;i++)&#123;</span><br><span class="line">             <span class="keyword">if</span>(intArray[i] == searchValue)&#123;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(i == elems)&#123;</span><br><span class="line">             <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> i;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 删除元素</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span>如果要删除的值不存在，直接返回 false;否则返回true，删除成功</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> k = find(value);</span><br><span class="line">         <span class="keyword">if</span>(k == -<span class="number">1</span>)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">if</span>(k == elems-<span class="number">1</span>)&#123;</span><br><span class="line">                 elems--;</span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i&lt; elems-<span class="number">1</span> ; i++)&#123;</span><br><span class="line">                     intArray[i] = intArray[i+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                 &#125;</span><br><span class="line">                  elems--;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 修改数据</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> oldValue原值</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> newValue新值</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span>修改成功返回true，修改失败返回false</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> oldValue,<span class="keyword">int</span> newValue)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> i = find(oldValue);</span><br><span class="line">         <span class="keyword">if</span>(i == -<span class="number">1</span>)&#123;</span><br><span class="line">             System.out.println(<span class="string">"需要修改的数据不存在"</span>);</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             intArray[i] = newValue;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构和算法（一）——简介</title>
      <link href="/2020/02/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E7%AE%80%E4%BB%8B/"/>
      <url>/2020/02/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习数据结构与算法能够让你了解该用什么数据结构储存数据，这涉及到编程中关键的性能和效率问题。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>数据结构是计算机存储、组织数据的方式，指相互之间存在一种或多种特定关系的数据元素的集合。 </p><p>数据结构的基本功能，可归纳为增删改查及遍历。</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>算法简单来说就是解决问题的步骤。</p><p>在 Java 中，算法通常都是由类的方法来实现的。前面的数据结构，比如链表为啥插入、删除快，而查找慢，平衡的二叉树插入、删除、查找都快，这都是实现这些数据结构的算法所造成的。后面我们讲的各种排序实现也是算法范畴的重要领域。</p><p>算法的五个要素：</p><ul><li>有穷性：对于任意一组合法输入值，在执行又穷步骤之后一定能结束，即：算法中的每个步骤都能在有限时间内完成。</li><li>确定性：在每种情况下所应执行的操作，在算法中都有确切的规定，使算法的执行者或阅读者都能明确其含义及如何执行。并且在任何条件下，算法都只有一条执行路径。</li><li>可行性：算法中的所有操作都必须足够基本，都可以通过已经实现的基本操作运算有限次实现之。</li><li>有输入：作为算法加工对象的量值，通常体现在算法当中的一组变量。有些输入量需要在算法执行的过程中输入，而有的算法表面上可以没有输入，实际上已被嵌入算法之中。</li><li>有输出：它是一组与“输入”有确定关系的量值，是算法进行信息加工后得到的结果，这种确定关系即为算法功能。</span></li></li></ul><p>算法的设计原则：</p><ul><li>正确性：首先，算法应当满足以特定的“规则说明”方式给出的需求。</li><li>可读性：算法为了人的阅读与交流，其次才是计算机执行。因此算法应该易于人的理解；另一方面，晦涩难懂的程序易于隐藏较多的错误而难以调试。</li><li>健壮性：当输入的数据非法时，算法应当恰当的做出反应或进行相应处理，而不是产生莫名其妙的输出结果。并且，处理出错的方法不应是中断程序执行，而是应当返回一个表示错误或错误性质的值，以便在更高的抽象层次上进行处理。</li><li>高效率与低存储量需求：通常算法效率值得是算法执行时间；存储量是指算法执行过程中所需要的最大存储空间，两者都与问题的规模有关。</li></ul><h1 id="复杂度及分析"><a href="#复杂度及分析" class="headerlink" title="复杂度及分析"></a>复杂度及分析</h1><p>如何度量一个算法的执行速度并评价其效率？</p><ul><li>渐进复杂度： 在评价算法的运行时间时，我们往往可以忽略其在处理小规模问题时的性能，转而关注其在处理足够大规模问题时的性能，即所谓的渐进复杂度。原因不难理解，小规模的问题所需的处理时间相对更少，不同算法在效率方面的差异并不明显；只有在处理大规模的问题时，这方面的差异才有质的区别。</li><li>基本操作次数： 即便是同一算法、同一输入，在不同的硬件平台上、使用不同的操作系统所需要的计算时间都不相同。然而实际上，无论在何种计算环境中，每一次基本操作都可以在常数时间内完成，因此如果根据算法所需执行的基本操作次数来表示，就可以更加客观地反映算法的效率。</li><li>实测统计： 而有些算法的时间复杂度极难从理论上作出分析，此时我们可以采用实验的方法，随机选择足够多规模不同的输入，通过实测统计得出运行时间随输入规模而增长的趋势。</li></li><li>只关注时间复杂度</em>： 就渐进复杂度的意义而言，在任何一个算法的任何一次运行过程中，其实际占用的存储空间都不会多于其间执行的基本操作次数。从这个意义上说，时间复杂度本身就是空间复杂度的一个上界。</li></ul><p>注：当然，空间复杂度本身也有其存在的意义，尤其是在对空间效率非常在乎的应用场合，或者是当问题的输入规模极为庞大时。</p><p>表示算法复杂度的度量记号大 O 级别</p><ul><li>O(1)：最低的复杂度，无论数据量大小，耗时都不变，都可以在一次计算后获得。哈希算法就是典型的 O(1)</li><li>O(n)：线性，n 表示数据的量，当量增大，耗时也增大，常见有遍历算法</li><li>O(n²)：平方，表示耗时是 n 的平方倍，当看到循环嵌循环的时候，基本上这个算法就是平方级的，如：冒泡排序等</li><li>O(log n)：对数，通常 ax=n,那么数 x 叫做以 a 为底 n 的对数,也就是 x=logan，这里是 a 通常是 2，如：数量增大 8 倍，耗时只增加了 3 倍，二分查找就是对数级的算法，每次剔除一半</li><li>O(n log n)：线性对数，就是 n 乘以 log n,按照上面说的数据增大 8 倍，耗时就是 8*3=24 倍，归并排序就是线性对数级的算法。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 简介 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维——CPU飙升到100%的原因</title>
      <link href="/2020/01/08/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E7%BB%B4%E2%80%94%E2%80%94CPU%E9%A3%99%E5%8D%87%E5%88%B0100-%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
      <url>/2020/01/08/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E7%BB%B4%E2%80%94%E2%80%94CPU%E9%A3%99%E5%8D%87%E5%88%B0100-%E7%9A%84%E5%8E%9F%E5%9B%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是-cpu-使用率？"><a href="#什么是-cpu-使用率？" class="headerlink" title="什么是 cpu 使用率？"></a>什么是 cpu 使用率？</h3><p>CPU％= 1 - idleTime / sysTime * 100<br>idleTime：CPU 空闲的时间<br>sysTime：CPU 处于用户模式和内核模式的时间总和</p><h3 id="与-cpu-有关的是什么？"><a href="#与-cpu-有关的是什么？" class="headerlink" title="与 cpu 有关的是什么？"></a>与 cpu 有关的是什么？</h3><p><strong>计算密集型程序的 CPU 密集程度更高</strong>。<br>那么，JAVA 应用程序中的哪些操作更加 CPU 密集？<br>以下列出了常见的 CPU 密集型操作：</p><ol><li>频繁的 GC; 如果访问量很高，可能会导致频繁的 GC 甚至 FGC。当调用量很大时，内存分配将如此之快以至于 GC 线程将连续执行，这将导致 CPU 飙升。</li><li>序列化和反序列化。稍后将给出一个示例：当程序执行 xml 解析时，调用量会增加，从而导致 CPU 变满。</li><li>序列化和反序列化;</li><li>正则表达式。我遇到了正则表达式使 CPU 充满的情况; 原因可能是 Java 正则表达式使用的引擎实现是 NFA 自动机，它将在字符匹配期间执行回溯。</li><li>线程上下文切换; 有许多已启动的线程，这些线程的状态在 Blocked（锁定等待，IO 等待等）和 Running 之间发生变化。当锁争用激烈时，这种情况很容易发生。</li><li>有些线程正在执行非阻塞操作，例如 while(true)语句。如果在程序中计算需要很长时间，则可以使线程休眠。</li></ol><h3 id="cpu-是否与进程和线程有关？"><a href="#cpu-是否与进程和线程有关？" class="headerlink" title="cpu 是否与进程和线程有关？"></a>cpu 是否与进程和线程有关？</h3><p>线程的等待及阻塞不会使用 CPU 资源，线程的频繁的上下文切换（锁竞争激烈）容易造成 CPU 飙升。</p><h3 id="一问一答"><a href="#一问一答" class="headerlink" title="一问一答"></a>一问一答</h3><ol><li><p>while 的无限循环会导致 CPU 使用率飙升吗？<br>会。<br>首先，无限循环将调用 CPU 寄存器进行计数，此操作将占用 CPU 资源。那么，如果线程始终处于无限循环状态，CPU 是否会切换线程？<br>除非操作系统时间片到期，否则无限循环不会放弃占用的 CPU 资源，并且无限循环将继续向系统请求时间片，直到系统没有空闲时间来执行任何其他操作。<br>stackoverflow 中也提出了这个问题：<a href="https://stackoverflow.com/questions/2846165/why-does-an-infinite-loop-of-the-unintended-kind-increase-the-cpu-use" target="_blank" rel="noopener">为什么无意的无限循环增加了 CPU 的使用？</a></p></li><li><p>频繁的 Young GC 会导致 CPU 占用率飙升吗？<br>会。<br>Young GC 本身就是 JVM 用于垃圾收集的操作，它需要计算内存和调用寄存器。因此，频繁的 Young GC 必须占用 CPU 资源。<br>让我们来看一个现实世界的案例。for 循环从数据库中查询数据集合，然后再次封装新的数据集合。如果内存不足以存储，JVM 将回收不再使用的数据。因此，如果所需的存储空间很大，您可能会收到 CPU 使用率警报。</p></li><li><p>对于 CPU 占用率高的应用程序，线程数是否较大？<br>不是。<br>高 CPU 使用率的关键因素是计算密集型操作。如果一个线程中有大量计算，则 CPU 使用率也可能很高。这也是数据脚本任务需要在大规模集群上运行的原因。</p></li><li><p>如果分时操作系统中 CPU 的值 us 或 sy 值很高，这意味着什么？<br>您可以使用命令查找 CPU 的值 us 和 sy 值 top<br>us：用户空间占用 CPU 的百分比。简单来说，高我们是由程序引起的。通过分析线程堆栈很容易找到有问题的线程。整编：微信公众号，搜云库技术团队，ID：souyunku<br>sy：内核空间占用 CPU 的百分比。当 sy 为高时，如果它是由程序引起的，那么它基本上是由于线程上下文切换。</p></li></ol><h3 id="如何找出-CPU-使用率高的原因"><a href="#如何找出-CPU-使用率高的原因" class="headerlink" title="如何找出 CPU 使用率高的原因"></a>如何找出 CPU 使用率高的原因</h3><p>如果发现应用程序服务器的 CPU 使用率很高，请首先检查线程数，JVM，系统负载等参数，然后使用这些参数来证明问题的原因。其次，使用 jstack 打印堆栈信息并使用工具分析线程使用情况</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzA3MTUzOTcxOQ==&mid=2452969215&idx=1&sn=1dc1a52231895d8cd15f0f33f774a8ef&scene=21#wechat_redirect" target="_blank" rel="noopener">这六种原因，真能让 Java 应用 CPU 使用率飙升至 100% 吗？</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux——定时任务（一）</title>
      <link href="/2019/12/16/Linux%E2%80%94%E2%80%94%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/12/16/Linux%E2%80%94%E2%80%94%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>crontab 命令常见于 Unix 和类 Unix 的操作系统之中，用于设置周期性被执行的指令。</li><li>该命令从标准输入设备读取指令，并将其存放于 crontab 文件中</li><li>crontab 储存的指令被守护进程激活，crond 常常在后台运行，每一分钟检查是否有预定的作业需要执行。这类作业一般称为 cron jobs。</li></ul><h2 id="安装-cron-docker-ubuntu"><a href="#安装-cron-docker-ubuntu" class="headerlink" title="安装 cron(docker ubuntu)"></a>安装 cron(docker ubuntu)</h2><h3 id="确认是否安装"><a href="#确认是否安装" class="headerlink" title="确认是否安装"></a>确认是否安装</h3><p>一般 linux 版本都已经安装了 crontab，我们可以执行 crontab 确认：</p><blockquote><p>-bash: crontab: command not found</p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote><p>apt-get install cron</p></blockquote><p>如果报出这个错误：Unable to locate package，这个错误一般是因为软件源未更新造成的，于是采用命令：sudo apt-get update 来更新软件源</p><h3 id="确认-cron-安装成功"><a href="#确认-cron-安装成功" class="headerlink" title="确认 cron 安装成功"></a>确认 cron 安装成功</h3><blockquote><p>crontab -l</p></blockquote><h3 id="设置定时任务"><a href="#设置定时任务" class="headerlink" title="设置定时任务"></a>设置定时任务</h3><blockquote><p>crontab -e</p></blockquote><p>_/1 _ * * * cd /home/qn/shell&amp;&amp;sh test.sh &gt; time.log</p><h3 id="启动定时任务"><a href="#启动定时任务" class="headerlink" title="启动定时任务"></a>启动定时任务</h3><blockquote><p>service cron start</p></blockquote><h2 id="安装日志服务-rsyslog"><a href="#安装日志服务-rsyslog" class="headerlink" title="安装日志服务 rsyslog"></a>安装日志服务 rsyslog</h2><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><blockquote><p>vi /etc/rsyslog.d/50-default.conf</p></blockquote><p>cron.* /var/log/cron.log #将 cron 前面的注释符去掉</p><h3 id="启动日志服务"><a href="#启动日志服务" class="headerlink" title="启动日志服务"></a>启动日志服务</h3><blockquote><p>service rsyslog start</p></blockquote><h3 id="重启-cron"><a href="#重启-cron" class="headerlink" title="重启 cron"></a>重启 cron</h3><blockquote><p>service cron restart</p></blockquote><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><blockquote><p>tail -f /var/log/cron.log</p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>时程表的格式如下:</p><blockquote><p>f1 f2 f3 f4 f5 program</p></blockquote><p>其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执行的程式。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux 定时任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件——Kafka——基础（一）</title>
      <link href="/2019/12/05/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Kafka%E2%80%94%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/12/05/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94Kafka%E2%80%94%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Kafka 是最初由 Linkedin 公司开发，是一个分布式（多节点）、支持多分区、多副本的，基于 zookeeper 协调的分布式消息系统，它的最大的特性就是可以实时的处理大量数据。</p><h1 id="kafka-特性"><a href="#kafka-特性" class="headerlink" title="kafka 特性"></a>kafka 特性</h1><ol><li><p><code>高吞吐量、低延迟</code>：kafka 每秒可以处理几十万条消息，它的延迟最低只有几毫秒。</p></li><li><p><code>可扩展性</code>：kafka 支持热扩展，水平扩展。</p></li><li><p><code>持久性、可靠性</code>：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失。</p></li><li><p><code>容错性</code>：允许集群中节点失败。</p></li><li><p><code>高并发</code>：支持数千个客户端同时读写。</p></li></ol><h1 id="kafka-使用场景"><a href="#kafka-使用场景" class="headerlink" title="kafka 使用场景"></a>kafka 使用场景</h1><ul><li>日志收集</li><li>消息系统</li><li>监控</li><li>运营指标</li><li>流式处理</li><li>事件源</li></ul><h1 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h1><p>Kafka的Producer、Broker和Consumer之间采用的是一套自行设计的基于TCP层的协议。以NIO作为网络通信的基础,把多条Message放在一起做压缩，提高压缩比率，从而在网络上传输的数据量会少一些。</p><h1 id="主要结构"><a href="#主要结构" class="headerlink" title="主要结构"></a>主要结构</h1><ol><li><p>Broker</p><p>kafka 集群节点,也可称为代理，在集群中每个 broker 都有一个唯一 brokerid，不得重复。如果我们想扩展kafka集群，只需引入新节点，分配一个不同的broker.id即可。</p></li><li><p>Topic</p><ul><li>在 Kafka 中的每一条消息都有一个 Topic。一般来说在我们应用中产生不同类型的数据，都可以设置不同的主题。</li><li>一个主题一般会有多个消息的订阅者，当生产者发布消息到某个主题时，订阅了这个主题的消费者都可以接收到生产者写入的新消息。</li></ul></li><li><p>Partition</p><p>kafka 是面对分布式系统的，同时一个 topic 对应 partition，一个 partition 有对个副本,会从所有的副本中选取一个 leader 出来。所有读写操作都是通过 leader 来进行的。一个 partition 是个有序队列。</p></li><li><p>offset</p><p>在分区中的每条消息都会按照时间顺序分配到一个单调递增的顺序编号，也就是我们的 Offset。Offset 是一个 Long 型的数字。</p></li><li><p>Producer</p><p>负责发布消息到 Kafka broker。</p></li><li><p>Consumer</p><p>消息消费者，向 Kafka broker 读取消息的客户端。</p></li><li><p>Consumer Group</p><p>各个 consumer（consumer 线程）可以组成一个组（Consumer group），partition 中的每个 message 只能被组（Consumer group）中的一个 consumer（consumer 线程）消费。</p></li></ol><h1 id="kafka消费模型"><a href="#kafka消费模型" class="headerlink" title="kafka消费模型"></a>kafka消费模型</h1><p>消息由生产者发送到 Kafka 集群后，会被消费者消费。一般来说我们的消费模型有两种：推送模型（push）、拉取模型（pull）</p><ol><li><p>推送模型</p><p>基于推送模型的消息系统，由消息代理记录消费状态。消息代理将消息推送到消费者后，标记这条消息为已经被消费，但是这种方式无法很好地保证消费的处理语义。</p><p>比如当我们已经把消息发送给消费者之后，由于消费进程挂掉或者由于网络原因没有收到这条消息，如果我们在消费代理将其标记为已消费，这个消息就永久丢失了。</p><p>如果我们利用生产者收到消息后回复这种方法，消息代理需要记录消费状态，这种不可取。<br>如果采用 Push，消息消费的速率就完全由消费代理控制，一旦消费者发生阻塞，就会出现问题。</p></li><li><p>拉取模型</p><p>Kafka 采取拉取模型(Pull)，由自己控制消费速度，以及消费的进度，消费者可以按照任意的偏移量进行消费。比如消费者可以消费已经消费过的消息进行重新处理，或者消费最近的消息等等。</p></li></ol><h1 id="关联zookeeper"><a href="#关联zookeeper" class="headerlink" title="关联zookeeper"></a>关联zookeeper</h1><p>kafka 用 zk 做 meta 信息存储。</p><p>低版本时主要储存consumer 的消费状态，group 的管理以及 offset 的值。以及配合broker的选举。</p><p>后来考虑到 zk 本身的一些因素以及整个架构较大概率存在单点问题，且zk的读取效率低下，新版本中确实逐渐弱化了 zookeeper 的作用。新的 consumer 使用了 kafka 内部的 group coordination 协议，也减少了对 zookeeper 的依赖。</p><h1 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h1><p>在Kafka集群中会有一个或者多个broker，其中有一个broker会被选举为控制器（Kafka Controller），它负责管理整个集群中所有分区和副本的状态。当某个分区的leader副本出现故障时，由控制器负责为该分区选举新的leader副本。当检测到某个分区的ISR集合发生变化时，由控制器负责通知所有broker更新其元数据信息。</p><h1 id="控制器选举"><a href="#控制器选举" class="headerlink" title="控制器选举"></a>控制器选举</h1><p>Kafka中的控制器选举工作依赖于Zookeeper，成功竞选成为控制器的broker会在Zookeeper中创建/controller临时（Ephemeral）节点，此临时节点的内容参考如下：</p><blockquote><p>{“version”:1,”brokerid”:0,”timestamp”:”1593330804078”}</p></blockquote><p>每个broker启动的时候会去尝试读取/controller节点的brokerid的值，如果读取到的brokerid的值不为-1，表示已经有其他broker节点成功竞选为控制器，所以当前broker就会放弃竞选；如果Zookeeper中不存在/controller节点，或者这个节点的数据异常，那么就会尝试去创建/controller节点。</p><p>Zookeeper中还有一个与控制器有关的/controller_epoch节点，这个节点是持久（Persistent）节点，节点中存放的是一个整型的controller_epoch值。controller_epoch值用于记录控制器发生变更的次数，即记录当前的控制器是第几代控制器，我们也可以称之为“控制器纪元”。</p><p>每个和控制器交互的请求都会携带controller_epoch这个字段，如果请求的controller_epoch值小于内存中的controller_epoch值，则认为这个请求是向已经过期的控制器发送的请求，那么这个请求会被认定为无效的请求。</p><h1 id="分区副本"><a href="#分区副本" class="headerlink" title="分区副本"></a>分区副本</h1><p>kafka有三层形式，kafka有多个主题，每个主题有多个分区，每个分区有多个副本。每个分区在不同的broker节点上，分区的副本又会分布在不同的broker节点上。</p><ol><li><p>分区个数选择</p><p>分区的好处显而易见，提高了消息的可靠性；那是不是分区越多越好那？</p><p>分区越多，所需要消耗的资源就越多。</p><p>比较无脑的确定分区数的方式就是broker机器数量的2~3倍。有时间可以自己测。。。</p></li><li><p>follower副本和leader副本</p><p>副本的目的就是冗余备份，且仅仅是冗余备份，所有的读写请求都是由leader副本进行处理的。follower副本仅有一个功能，那就是从leader副本拉取消息，尽量让自己跟leader副本的内容一致。</p><p>所以也就分为leader副本与follower副本。</p></li><li><p>LEO和HW</p><p>Kafka所有副本都有的两个重要属性：LEO和HW：</p><ul><li>LEO：即日志末端位移(log end offset)，记录了该副本底层日志(log)中下一条消息的位移值。注意是下一条消息！也就是说，如果LEO=10，那么表示该副本保存了10条消息，位移值范围是[0, 9]。</li><li>High Watermark（高水位线）以下简称HW，表示消息被leader和ISR内的follower都确认commit写入本地log，所以在HW位置以下的消息都可以被消费（不会丢失）。</li></ul></li></ol><h1 id="副本选举"><a href="#副本选举" class="headerlink" title="副本选举"></a>副本选举</h1><p>zookeeper每次leader节点挂掉时，都会通过内置id，来选举处理了最新事务的那个follower节点。</p><p>实际上它是通过<code>ISR</code>副本集合实现,kafka会将与leader副本保持同步的副本放到ISR副本集合中。当然，leader副本是一直存在于ISR副本集合中的，在某些特殊情况下，ISR副本中甚至只有leader一个副本。</p><p>当leader挂掉时，kakfa通过zookeeper感知到这一情况，在ISR副本中选取新的副本成为leader，对外提供服务。</p><p>同步的标准是什么？跟一个参数有关：replica.lag.time.max.ms。</p><p>前面说到follower副本的任务，就是从leader副本拉取消息，如果持续拉取速度慢于leader副本写入速度，慢于时间超过replica.lag.time.max.ms后，它就变成“非同步”副本，就会被踢出ISR副本集合中。但后面如何follower副本的速度慢慢提上来，那就又可能会重新加入ISR副本集合中了。</p><p>而对于ISR副本的观测，是由控制器节点所观测的，当ISR集合发生变化，控制器会通知其他broker节点更新元数据。</p><h1 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a>消费者组</h1><ol><li><p>消息引擎处理模型</p><p>传统的消息引擎处理模型主要有两种，队列模型，和发布-订阅模型。</p><ul><li>队列模型：生产者产生消息，就是入队，消费者接收消息就是出队，并删除队列中数据，消息只能被消费一次。但这种模型有一个问题，那就是只能由一个消费者消费，无法直接让多个消费者消费数据。基于这个缺陷，后面又演化出发布-订阅模型。</li><li>发布-订阅模型：发布订阅模型中，多了一个主题。消费者会预先订阅主题，生产者写入消息到主题中，只有订阅了该主题的消费者才能获取到消息。这样一来就可以让多个消费者消费数据。</li></ul><p>kafka的消费者组机制，可以同时实现这两种模型。同时还能够对消费组进行动态扩容，让消费变得易于伸缩。</p></li><li><p>消费者组消费者数量</p><p>所谓消费者组，那自然是由消费者组成的，组内可以有一个或多个消费者实例，而这些消费者实例共享一个id，称为group id。</p><p>消费者组内的所有成员一起订阅某个主题的所有分区，注意一个消费者组中，每一个分区只能由组内的一消费者订阅。</p><p>消费者组内消费者小于或等于分区数，以及topic分区数刚好是消费者组内成员数的倍数。</p></li><li><p>重平衡</p><p>重平衡其实就是一个协议，它规定了如何让消费者组下的所有消费者来分配topic中的每一个分区。比如一个topic有100个分区，一个消费者组内有20个消费者，在协调者的控制下让组内每一个消费者分配到5个分区，这个分配的过程就是重平衡。</p><p>触发条件：</p><ul><li>消费者组内成员发生变更，这个变更包括了增加和减少消费者。注意这里的减少有很大的可能是被动的，就是某个消费者崩溃退出了</li><li>主题的分区数发生变更，kafka目前只支持增加分区，当增加的时候就会触发重平衡</li><li>订阅的主题发生变化，当消费者组使用正则表达式订阅主题，而恰好又新建了对应的主题，就会触发重平衡</li></ul><p>重平衡过程中，消费者无法从kafka消费消息，这对kafka的TPS影响极大，而如果kafka集内节点较多，比如数百个，那重平衡可能会耗时极多。数分钟到数小时都有可能，而这段时间kafka基本处于不可用状态。所以在实际环境中，应该尽量避免重平衡发生。</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文大致了解了kafka的一些主要结构，实际的执行过程还是要通过生产者和消费者来进行。</p>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot——kafka（二十五）</title>
      <link href="/2019/12/05/Springboot%E2%80%94%E2%80%94kafka%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%94%EF%BC%89/"/>
      <url>/2019/12/05/Springboot%E2%80%94%E2%80%94kafka%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-idea-创建一个-maven-项目"><a href="#使用-idea-创建一个-maven-项目" class="headerlink" title="使用 idea 创建一个 maven 项目"></a>使用 idea 创建一个 maven 项目</h1><h1 id="kafka-安装"><a href="#kafka-安装" class="headerlink" title="kafka 安装"></a>kafka 安装</h1><p>详见</p><h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--参数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8089</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">kafka</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">bootstrap-servers</span>: <span class="string">localhost:9092</span></span><br><span class="line">    <span class="attr">producer</span>:<span class="string"></span></span><br><span class="line">      <span class="meta">key-serializer</span>: <span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line">      <span class="meta">value-serializer</span>: <span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line">    <span class="attr">consumer</span>:<span class="string"></span></span><br><span class="line">      <span class="meta">group-id</span>: <span class="string">myGroup</span></span><br><span class="line">      <span class="meta">key-deserializer</span>: <span class="string">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class="line">      <span class="meta">value-deserializer</span>: <span class="string">org.apache.kafka.common.serialization.StringDeserializer</span></span><br></pre></td></tr></table></figure><h2 id="消息体"><a href="#消息体" class="headerlink" title="消息体"></a>消息体</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.kafka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">private</span> Date sendTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getSendTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sendTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSendTime</span><span class="params">(Date sendTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sendTime = sendTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.kafka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.GsonBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.kafka.core.KafkaTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaSender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String,String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Gson gson = <span class="keyword">new</span> GsonBuilder().create();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Message message = <span class="keyword">new</span> Message();</span><br><span class="line">        message.setId(System.currentTimeMillis());</span><br><span class="line">        message.setMsg(UUID.randomUUID().toString());</span><br><span class="line">        message.setSendTime(<span class="keyword">new</span> Date());</span><br><span class="line">        kafkaTemplate.send(<span class="string">"test"</span>, gson.toJson(message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.kafka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line"><span class="keyword">import</span> org.springframework.kafka.annotation.KafkaListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConsumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@KafkaListener</span>(topics = &#123;<span class="string">"test"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(ConsumerRecord&lt;?, ?&gt; record)</span> </span>&#123;</span><br><span class="line">        Optional&lt;?&gt; kafkaMessage = Optional.ofNullable(record.value());</span><br><span class="line">        <span class="keyword">if</span> (kafkaMessage.isPresent()) &#123;</span><br><span class="line">            Object message = kafkaMessage.get();</span><br><span class="line">            System.out.println(<span class="string">"接收信息"</span>+message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.qn.kafka.KafkaSender;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ConfigurableApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">        KafkaSender sender = context.getBean(KafkaSender<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            sender.send();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3_000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>直接运行启动类：<br><img src="/images/springboot%E5%AE%9E%E6%88%98%E4%B9%8Bkafka_2019-12-05-14-54-28.png" alt="springboot实战之kafka_2019-12-05-14-54-28.png"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/c16350e88abe" target="_blank" rel="noopener">Spring Boot 集成 Kafka</a></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker——Kafka的安装使用</title>
      <link href="/2019/12/04/%E6%9C%8D%E5%8A%A1%E5%99%A8docker%E2%80%94%E2%80%94Kafka%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/12/04/%E6%9C%8D%E5%8A%A1%E5%99%A8docker%E2%80%94%E2%80%94Kafka%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><blockquote><p>docker pull wurstmeister/zookeeper</p></blockquote><blockquote><p>docker pull wurstmeister/kafka</p></blockquote><h3 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h3><blockquote><p>docker run -d –name zookeeper -p 2181 -t wurstmeister/zookeeper</p></blockquote><blockquote><p>docker run -d –name kafka –publish 9092:9092 –link zookeeper –env KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181 –env KAFKA_ADVERTISED_HOST_NAME=127.0.0.1 –env KAFKA_ADVERTISED_PORT=9092 –volume /etc/localtime:/etc/localtime wurstmeister/kafka:latest</p></blockquote><h3 id="查看启动镜像"><a href="#查看启动镜像" class="headerlink" title="查看启动镜像"></a>查看启动镜像</h3><blockquote><p>docker ps</p></blockquote><p><img src="/images/docker%E4%BD%BF%E7%94%A8%E4%B9%8BKafka%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8_2019-12-04-16-04-31.png" alt="docker使用之Kafka的安装使用_2019-12-04-16-04-31.png"></p><h2 id="测试消息发送"><a href="#测试消息发送" class="headerlink" title="测试消息发送"></a>测试消息发送</h2><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><blockquote><p>docker exec -it 83156456fb03 /bin/bash</p></blockquote><h3 id="进入-kafka-默认目录"><a href="#进入-kafka-默认目录" class="headerlink" title="进入 kafka 默认目录"></a>进入 kafka 默认目录</h3><blockquote><p>cd /opt/kafka_2.12-2.3.0/</p></blockquote><h3 id="创建-topic"><a href="#创建-topic" class="headerlink" title="创建 topic"></a>创建 topic</h3><blockquote><p>bin/kafka-topics.sh –create –zookeeper zookeeper:2181 –replication-factor 1 –partitions 1 –topic test</p></blockquote><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><blockquote><p>bin/kafka-console-producer.sh –broker-list localhost:9092 –topic test</p></blockquote><p><img src="/images/docker%E4%BD%BF%E7%94%A8%E4%B9%8BKafka%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8_2019-12-04-16-11-42.png" alt="docker使用之Kafka的安装使用_2019-12-04-16-11-42.png"></p><h3 id="接受消息"><a href="#接受消息" class="headerlink" title="接受消息"></a>接受消息</h3><blockquote><p>bin/kafka-console-consumer.sh –bootstrap-server localhost:9092 –topic test –from-beginning</p></blockquote><p><img src="/images/docker%E4%BD%BF%E7%94%A8%E4%B9%8BKafka%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8_2019-12-04-16-13-40.png" alt="docker使用之Kafka的安装使用_2019-12-04-16-13-40.png"></p><h2 id="java-生产者与消费者"><a href="#java-生产者与消费者" class="headerlink" title="java 生产者与消费者"></a>java 生产者与消费者</h2><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.kafka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.KafkaProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.Producer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafKaProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//broker地址</span></span><br><span class="line">        props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//请求时候需要验证</span></span><br><span class="line">        props.put(<span class="string">"acks"</span>, <span class="string">"all"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//请求失败时候需要重试</span></span><br><span class="line">        props.put(<span class="string">"retries"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//内存缓存区大小</span></span><br><span class="line">        props.put(<span class="string">"buffer.memory"</span>, <span class="number">33554432</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定消息key序列化方式</span></span><br><span class="line">        props.put(<span class="string">"key.serializer"</span>,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定消息本身的序列化方式</span></span><br><span class="line">        props.put(<span class="string">"value.serializer"</span>,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line"></span><br><span class="line">        Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">                <span class="comment">// 生产一条消息的时间有点长</span></span><br><span class="line">                producer.send(<span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"test"</span>, <span class="string">"测试用例"</span>+Integer.toString(i)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Message sent successfully"</span>);</span><br><span class="line">        producer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.kafka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecords;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.KafkaConsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafKaConsumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123; <span class="string">"deprecation"</span>, <span class="string">"resource"</span> &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">        props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);   <span class="comment">// "localhost:9092"</span></span><br><span class="line">        <span class="comment">//每个消费者分配独立的组号</span></span><br><span class="line">        props.put(<span class="string">"group.id"</span>, <span class="string">"test1"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果value合法，则自动提交偏移量</span></span><br><span class="line">        props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"true"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置多久一次更新被消费消息的偏移量</span></span><br><span class="line">        props.put(<span class="string">"auto.commit.interval.ms"</span>, <span class="string">"1000"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置会话响应的时间，超过这个时间kafka可以选择放弃消费或者消费下一条消息</span></span><br><span class="line">        props.put(<span class="string">"session.timeout.ms"</span>, <span class="string">"30000"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//props.put("auto.offset.reset", "earliest");</span></span><br><span class="line"></span><br><span class="line">        props.put(<span class="string">"key.deserializer"</span>,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">        props.put(<span class="string">"value.deserializer"</span>,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line"></span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">        System.out.println(<span class="string">"建立消费者"</span>);</span><br><span class="line">        consumer.subscribe(Collections.singletonList(<span class="string">"test"</span>));  <span class="comment">//核心函数1：订阅topic</span></span><br><span class="line">        System.out.println(<span class="string">"订阅成功"</span>);</span><br><span class="line">        <span class="comment">//消费轮询</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                ConsumerRecords&lt;String,String&gt; records = consumer.poll(<span class="number">100000</span>);</span><br><span class="line">                <span class="keyword">for</span>(ConsumerRecord&lt;String,String&gt; record : records) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"取出数据："</span>+ record.value());</span><br><span class="line">                    System.out.printf(<span class="string">"offset = %d ,key = %s, value = %s%n"</span>,record.offset(),record.key(),record.value());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            consumer.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://johng.cn/install-kafka-with-docker/" target="_blank" rel="noopener">使用 docker 安装 kafka</a></p><p><a href="https://blog.51cto.com/59465168/2319494" target="_blank" rel="noopener">Kafka 的使用和错误解决</a></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker kafka安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud实战之Config（4）</title>
      <link href="/2019/12/02/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%884%EF%BC%89/"/>
      <url>/2019/12/02/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%884%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>在<a href="/2019/11/29/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%882%EF%BC%89/" title="springcloud实战之Config（2）">springcloud实战之Config（2）</a> ，我们简单的实现了动态刷新。但如果有大量的微服务，就需要为每个 client 去 refresh,明显是不合理的。而 Spring Cloud Bus 可以完美解决这一问题。</p><h1 id="通过消息总线-Spring-Cloud-Bus-更新客户端配置文件（使用-Kafka）"><a href="#通过消息总线-Spring-Cloud-Bus-更新客户端配置文件（使用-Kafka）" class="headerlink" title="通过消息总线 Spring Cloud Bus 更新客户端配置文件（使用 Kafka）"></a>通过消息总线 Spring Cloud Bus 更新客户端配置文件（使用 Kafka）</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h4 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h4><p>Spring bus 的一个核心思想是通过分布式的启动器对 spring boot 应用进行扩展，也可以用来建立一个多个应用之间的通信频道。目前唯一实现的方式是用 AMQP 消息代理作为通道，同样特性的设置（有些取决于通道的设置）在更多通道的文档中。其实本质是利用了 MQ 的广播机制在分布式的系统中传播消息，目前常用的有 Kafka 和 RabbitMQ。</p><h4 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h4><p><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%884%EF%BC%89_2019-12-04-16-28-26.png" alt="springcloud实战之Config（4）_2019-12-04-16-28-26.png"></p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ul><li>提交代码触发 post 请求给 bus/refresh</li><li>server 端接收到请求并发送给 Spring Cloud Bus</li><li>Spring Cloud bus 接到消息并通知给其它客户端</li><li>其它客户端接收到通知，请求 Server 端获取最新配置</li><li>全部客户端均获取到最新的配置</li></ul><h2 id="安装-kafka"><a href="#安装-kafka" class="headerlink" title="安装 kafka"></a>安装 kafka</h2><p>详见</p><h4 id="server-模块整合"><a href="#server-模块整合" class="headerlink" title="server 模块整合"></a>server 模块整合</h4><h5 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8769</span></span><br><span class="line"><span class="comment">#避免配置中心向自己发布服务导致程序报错服务启动不了。</span></span><br><span class="line"><span class="comment">#如果不加项目启动时报错：Cannot execute request on any known server</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://localhost:9999/eureka</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">spring-cloud-config-server</span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">config</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">server</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">git</span>:<span class="string"></span></span><br><span class="line">          <span class="attr">uri</span>: <span class="string">https://github.com/qn101630/qn101630.github.io.git # 配置git仓库的地址</span></span><br><span class="line">          <span class="meta">search-paths</span>: <span class="string">config-repo # git仓库地址下的相对地址，可以配置多个，用,分割。</span></span><br><span class="line">          <span class="attr">username</span>: <span class="string">qn101630                               # git仓库的账号</span></span><br><span class="line">          <span class="attr">password</span>: <span class="string">qn192837QN</span></span><br><span class="line">          <span class="meta">default-label</span>: <span class="string">code</span></span><br><span class="line"><span class="comment">    # bus消息总线</span></span><br><span class="line">    <span class="attr">stream</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">kafka</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">binder</span>:<span class="string"></span></span><br><span class="line">          <span class="attr">brokers</span>: <span class="string">localhost:9092</span></span><br><span class="line">    <span class="attr">bus</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">trace</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">enabled</span>: <span class="string">true</span></span><br><span class="line"><span class="comment">#          skip-ssl-validation: true</span></span><br><span class="line"><span class="comment"># 暴露服务端端口 以便客户端刷新</span></span><br><span class="line"><span class="attr">management</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">endpoints</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">web</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">exposure</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">include</span>: <span class="string">"*"</span></span><br></pre></td></tr></table></figure><h4 id="client-整合"><a href="#client-整合" class="headerlink" title="client 整合"></a>client 整合</h4><p>与 server 整合一致，添加同样的配置与依赖</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ul><li>运行 Eureka、server、client(8771)、client(8772);直接访问<code>http://localhost:8771/testConfig</code>，返回配置信息</li><li>修改配置项，push 到 Git,这时候我们需要在 server 端 post<blockquote><p>curl -X POST <a href="http://localhost:8769/actuator/bus-refresh" target="_blank" rel="noopener">http://localhost:8769/actuator/bus-refresh</a></p></blockquote></li><li>再次访问<code>http://localhost:8771/testConfig</code>，返回修改后的配置</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/qqxx6661/article/details/88701051" target="_blank" rel="noopener">通过消息总线 Spring Cloud Bus 实现配置文件刷新</a></p>]]></content>
      
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> config实战 动态刷新（Bus） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud实战之Config（3）</title>
      <link href="/2019/12/02/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%883%EF%BC%89/"/>
      <url>/2019/12/02/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%883%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>我们在前文中，完成了</p><ul><li>利用<code>springcloud config</code>与<code>git</code>完成了统一的配置，即配置中心</li><li>开启了<code>rehash</code>，完成了初步的动态刷新</li></ul><h1 id="高可用问题及方案"><a href="#高可用问题及方案" class="headerlink" title="高可用问题及方案"></a>高可用问题及方案</h1><h2 id="多个-server"><a href="#多个-server" class="headerlink" title="多个 server"></a>多个 server</h2><p>前文中我们实现<code>client</code>对配置中心配置的读取，是通过直连的方式（写死的 url）,这显然不符合要求，因为我们的配置中心的<code>server</code>需要有多个（高可用）。</p><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>将配置中心<code>server</code>与<code>client</code>作为微服务处理，在<code>Eureka</code>中注册,通过服务化的方式进行访问，同时开启多个指向同一个 git 地址的 server，就可以实现高可用。</p><h2 id="代码改造"><a href="#代码改造" class="headerlink" title="代码改造"></a>代码改造</h2><h4 id="服务端改造"><a href="#服务端改造" class="headerlink" title="服务端改造"></a>服务端改造</h4><h5 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h5><p>添加对 Eureka 的依赖，父 pom 已经添加，此处省略。</p><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://localhost:9999/eureka</span></span><br></pre></td></tr></table></figure><h4 id="客户端改造"><a href="#客户端改造" class="headerlink" title="客户端改造"></a>客户端改造</h4><h5 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h5><p>同上</p><h5 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h5><p>bootstrap.yml</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://localhost:9999/eureka</span></span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ul><li>测试服务化：启动 Eureka、server(8769)、server(8770)、client，访问<code>http://localhost:8771/testConfig</code>，得到配置信息;</li><li>测试高可用：关闭 server(8769),再次访问以上地址，得到配置信息;</li><li>测试动态刷新，修改配置，上传 git,post 请求<code>curl -v -X POST http://localhost:8771/actuator/refresh</code>，再次访问以上地址，得到修改后的配置信息。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://windmt.com/2018/04/19/spring-cloud-8-config-with-eureka/" target="_blank" rel="noopener">配置中心（服务化与高可用）</a></p>]]></content>
      
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> condig实战 服务化与高可用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis—— # 和 $ 的区别（四）</title>
      <link href="/2019/12/02/Mybatis%E2%80%94%E2%80%94%20#%20%E5%92%8C%20$%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2019/12/02/Mybatis%E2%80%94%E2%80%94%20#%20%E5%92%8C%20$%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是动态-SQL"><a href="#什么是动态-SQL" class="headerlink" title="什么是动态 SQL"></a>什么是动态 SQL</h1><p>动态 SQL 是 <code>mybatis</code> 的强大特性之一，也是它优于其他 ORM 框架的一个重要原因。<code>mybatis</code> 在对 sql 语句进行预编译之前，会对 sql 进行动态解析，解析为一个 BoundSql 对象，也是在此处对动态 SQL 进行处理的。在动态 SQL 解析阶段， <code>#{ }</code> 和 <code>${ }</code> 会有不同的表现</p><h1 id="讲解下-和-的异同点"><a href="#讲解下-和-的异同点" class="headerlink" title="讲解下#和$的异同点"></a>讲解下#和$的异同点</h1><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>都可以获取对象中的属性值,<code>$[name]</code> 和<code>#[name]</code>相同</p><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><p><code>#</code> 可以防止 sql 注入，先把 sql 中使用#的地方变成?占位，再设置参数值,会把传入的参数使用引号包起来，参数值?: ‘name’，如下：</p><blockquote><p>SELECT * FROM user WHERE name = #{name} AND password = #{password}</p></blockquote><blockquote><p>SELECT * FROM user WHERE name = ? AND password = ?</p></blockquote><p><code>$</code> 在动态解析的时候，会将我们传入的参数当做 String 字符串填充到我们的语句中，进行预编译，此时的<code>SQL</code>语句已经不包含变量了，完全已经是常量数据了。相当于我们普通没有变量的 sql 了。如下：</p><blockquote><p>select * from user where name = “xxx”;</p></blockquote><p>由于预编译的存在，<code>$</code>的使用会导致<strong>sql 注入</strong>，可以拼接 sql，如下：</p><blockquote><p>SELECT * FROM user WHERE name = $[name] AND password  = $[password]</p></blockquote><p>但如果 name = OR 1 = 1 OR，sql 注入就会影响到 sql 语句的原意，如下：</p><blockquote><p>SELECT * FROM user WHERE name = OR 1 = 1 OR AND password =</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>#</code>方式能够很大程度防止 sql 注入，<code>$</code>方式无法防止 Sql 注入。<br><code>$</code>方式一般用于传入数据库对象，例如传入表名.<br>一般能用<code>#</code>的就别用<code>$</code>.</p>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> $和# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud实战之Config（2）</title>
      <link href="/2019/11/29/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%882%EF%BC%89/"/>
      <url>/2019/11/29/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Refresh"><a href="#Refresh" class="headerlink" title="Refresh"></a>Refresh</h1><h2 id="依赖（父-pom-已经添加过）"><a href="#依赖（父-pom-已经添加过）" class="headerlink" title="依赖（父 pom 已经添加过）"></a>依赖（父 pom 已经添加过）</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="对需要刷新的类加上注解-RefreshScope"><a href="#对需要刷新的类加上注解-RefreshScope" class="headerlink" title="对需要刷新的类加上注解@RefreshScope"></a>对需要刷新的类加上注解@RefreshScope</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span> <span class="comment">//不配置这个注解刷新的时候会报错</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个@Value会根据配置的配置中心地址找到git仓库对应的配置和本地服务的配置文件</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;config.hello&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String hello;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"testConfig"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"读取到配置中心："</span> + hello;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="client-端配置，将端口暴露"><a href="#client-端配置，将端口暴露" class="headerlink" title="client 端配置，将端口暴露"></a>client 端配置，将端口暴露</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">endpoints</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">web</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">exposure</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">include</span>: <span class="string">refresh</span></span><br></pre></td></tr></table></figure><h2 id="Server-端配置，将端口暴露"><a href="#Server-端配置，将端口暴露" class="headerlink" title="Server 端配置，将端口暴露"></a>Server 端配置，将端口暴露</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">endpoints</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">web</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">exposure</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">include</span>: <span class="string">"*"</span></span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>启动 server 与 client,修改 git 上的 dev 配置属性，通过 post 请求的方式更新配置文件：<br><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%882%EF%BC%89_2019-12-02-14-18-14.png" alt="springcloud实战之Config（2）_2019-12-02-14-18-14.png"><br><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%882%EF%BC%89_2019-12-02-14-18-50.png" alt="springcloud实战之Config（2）_2019-12-02-14-18-50.png"><br>再次访问 <code>http://localhost:8771/testConfig</code>就可以得到最新的配置结果。</p><h1 id="Webhook"><a href="#Webhook" class="headerlink" title="Webhook"></a>Webhook</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>WebHook 是当某个事件发生时，通过发送 http post 请求的方式来通知信息接收方。Webhook 来监测你在 Github.com 上的各种事件，最常见的莫过于 push 事件。如果你设置了一个监测 push 事件的 Webhook，那么每当你的这个项目有了任何提交，这个 Webhook 都会被触发，这时 Github 就会发送一个 HTTP POST 请求到你配置好的地址。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>如此一来，你就可以通过这种方式去自动完成一些重复性工作，比如，你可以用 Webhook 来自动触发一些持续集成（CI）工具的运作，比如 Travis CI；又或者是通过 Webhook 去部署你的线上服务器。下图就是 github 上面的 webhook 配置。</p><p><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%882%EF%BC%89_2019-12-03-13-59-00.png" alt="springcloud实战之Config（2）_2019-12-03-13-59-00.png"></p><ul><li>Payload URL ：触发后回调的 URL</li><li>Content type ：数据格式，两种一般使用 json</li><li>Secret ：用作给 POST 的 body 加密的字符串。采用 HMAC 算法</li><li>events ：触发的事件列表。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果项目少配置少的情况可以通过/refresh 来手动刷新配置，可以利用 Webhook 的机制每次提交代码发送请求来刷新客户端，当客户端越来越多的时候，需要每个客户端都执行一遍；如果项目比较复杂的情况呢这种肯定是行不通的，Spring Cloud Bus 消息总线可以解决配置修改的真正的动态刷新。详见<a href="/2019/12/02/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%884%EF%BC%89/" title="springcloud实战之Config（4）">springcloud实战之Config（4）</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/qqxx6661/article/details/88604499" target="_blank" rel="noopener">配置中心 Spring Cloud Config 初体验</a></p>]]></content>
      
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> config实战 动态刷新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker——简单介绍与安装（win10）</title>
      <link href="/2019/11/28/%E6%9C%8D%E5%8A%A1%E5%99%A8docker%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85%EF%BC%88win10%EF%BC%89/"/>
      <url>/2019/11/28/%E6%9C%8D%E5%8A%A1%E5%99%A8docker%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85%EF%BC%88win10%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="环境配置的难题"><a href="#环境配置的难题" class="headerlink" title="环境配置的难题"></a>环境配置的难题</h2><p>软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？</p><p>用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。</p><p>如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说：”它在我的机器可以跑了”（It works on my machine），言下之意就是，其他机器很可能跑不了。</p><p>环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，<strong>安装的时候，把原始环境一模一样地复制过来。</strong></p><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>资源占用多<br>虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。</li><li>冗余步骤多<br>虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。</li><li>启动慢<br>启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。</li></ol><h2 id="Linux-容器"><a href="#Linux-容器" class="headerlink" title="Linux 容器"></a>Linux 容器</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><ol><li>由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。</li><li>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</li><li>容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。</li></ol><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>启动快<br>容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。</li><li>资源占用少<br>容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。</li><li>体积小<br>容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。</li></ol><h2 id="Docker-是什么？"><a href="#Docker-是什么？" class="headerlink" title="Docker 是什么？"></a>Docker 是什么？</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><ol><li>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。</li><li>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</li></ol><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ol><li>提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</li><li>提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</li><li>组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</li></ol><h2 id="Docker-的安装"><a href="#Docker-的安装" class="headerlink" title="Docker 的安装"></a>Docker 的安装</h2><p>详见———&gt; <a href="https://www.runoob.com/docker/windows-docker-install.html" target="_blank" rel="noopener">菜鸟教程 Docker 安装</a></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 介绍 安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务——Eureka与Zookeeper的区别（二）</title>
      <link href="/2019/11/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E2%80%94%E2%80%94Eureka%E4%B8%8EZookeeper%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2019/11/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E2%80%94%E2%80%94Eureka%E4%B8%8EZookeeper%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="生态"><a href="#生态" class="headerlink" title="生态"></a>生态</h1><p>在微服务的开发过程中，如果使用的是 Dubbo 那就必须使用到 Zookeeper ，在使用 Spring Cloud Eureka 时，自然其功能更强大得多。Spring Cloud Eureka 后来者居上，Dubbo 早在几年前停止了维护，在其停止了维护的几年里正是互联网发展的大好时期，Eureka 借机快速发展，夺得了一大片市场，可以说已经超越了 Dubbo 了，17 年的时候，阿里巴巴又突然宣布重启对 Dubbo 的维护，在其重启的发布会上，其主导维护者也表示，将希望加入 Eureka 的生态…</p><h1 id="CAP-定理"><a href="#CAP-定理" class="headerlink" title="CAP 定理"></a>CAP 定理</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>一个系统不可能同时满足一致性（C）、可用性(A)、分区容错性（P）</p><p><img src="/images/Eureka%E4%B8%8EZookeeper%E7%9A%84%E5%8C%BA%E5%88%AB_2019-11-28-10-31-07.png" alt="Eureka与Zookeeper的区别_2019-11-28-10-31-07.png"></p><h2 id="三个指标"><a href="#三个指标" class="headerlink" title="三个指标"></a>三个指标</h2><ul><li>一致性：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）。</li><li>可用性：在一个分布式系统的集群中一部分节点故障后，该集群是否还能够正常响应客户端的读写请求。（对数据更新具备高可用性）。</li><li>分区容错性：大多数的分布式系统都分布在多个子网络中，而每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。在一个分布式系统中一般分区容错是无法避免的，因此可以认为 CAP 中的 P 总是成立的。CAP 理论告诉我们，在 C 和 A 之间是无法同时做到。</li></ul><h1 id="Zookeeper-保证-CP"><a href="#Zookeeper-保证-CP" class="headerlink" title="Zookeeper 保证 CP"></a>Zookeeper 保证 CP</h1><ul><li>任何时候对 Zookeeper 的访问请求能得到一致的数据结果，同时系统对网络分割具备容错性</li><li>在使用 Zookeeper 获取服务列表时，如果此时的 Zookeeper 集群中的 Leader 宕机了，该集群就要进行 Leader 的选举，又或者 Zookeeper 集群中半数以上服务器节点不可用（例如有三个节点，如果节点一检测到节点三挂了 ，节点二也检测到节点三挂了，那这个节点才算是真的挂了），那么将无法处理该请求。所以说，Zookeeper 不能保证服务可用性。</li></ul><h1 id="Eureka-保证-AP"><a href="#Eureka-保证-AP" class="headerlink" title="Eureka 保证 AP"></a>Eureka 保证 AP</h1><ul><li>各个节点是平等的，几个节点挂掉，其他节点依然可以提供服务，首先报证可用性。</li><li>每个 Eureka Client 本地都有一份它最新获取到的服务注册表的缓存信息，即使所有的 Eureka Server 都挂掉了，依然可以根据本地缓存的服务信息正常工作。</li><li>如果 Eureka 服务节点在短时间里丢失了大量的心跳连接（注：可能发生了网络故障），那么这个 Eureka 节点会进入<strong>自我保护模式</strong>。 此时，这个 Eureka 节点对于新的服务还能提供注册服务，对于”死亡“的仍然保留，以防还有客户端向其发起请求。当网络故障恢复后，这个 Eureka 节点会退出自我保护模式。</li><li>Eureka 不能保证每次获取的服务列表都是最新的</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于服务发现来讲，保证服务的高可用尤为重要，哪怕返回前几分钟的服务信息，也比出现网络故障要好。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://dockone.io/article/78" target="_blank" rel="noopener">为什么不应该使用 Zookeeper 做服务发现</a></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 服务发现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud实战之Config（1）</title>
      <link href="/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%881%EF%BC%89/"/>
      <url>/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="创建一个远程仓库（本地建立一个配置仓库由-idea-提交给-git"><a href="#创建一个远程仓库（本地建立一个配置仓库由-idea-提交给-git" class="headerlink" title="创建一个远程仓库（本地建立一个配置仓库由 idea 提交给 git)"></a>创建一个远程仓库（本地建立一个配置仓库由 idea 提交给 git)</h1><h2 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h2><p><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%881%EF%BC%89_2019-11-22-21-48-43.png" alt="springcloud实战之Config（1）_2019-11-22-21-48-43.png"></p><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p><a href="https://github.com/qn101630/qn101630.github.io/tree/code/config-repo" target="_blank" rel="noopener">我的配置仓库</a></p><h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><h2 id="创建一个-config-server-组件"><a href="#创建一个-config-server-组件" class="headerlink" title="创建一个 config-server 组件"></a>创建一个 config-server 组件</h2><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8769</span></span><br><span class="line"><span class="comment">#避免配置中心向自己发布服务导致程序报错服务启动不了。</span></span><br><span class="line"><span class="comment">#如果不加项目启动时报错：Cannot execute request on any known server</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">register-with-eureka</span>: <span class="string">false</span></span><br><span class="line">    <span class="meta">fetch-registry</span>: <span class="string">false</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">spring-cloud-config-server</span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">config</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">server</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">git</span>:<span class="string"></span></span><br><span class="line">          <span class="attr">uri</span>: <span class="string">https://github.com/qn101630/qn101630.github.io.git # 配置git仓库的地址，这是我的公开git,可以不用登录密码</span></span><br><span class="line">          <span class="meta">search-paths</span>: <span class="string">config-repo # git仓库地址下的相对地址，可以配置多个，用,分割。</span></span><br><span class="line">          <span class="attr">username</span>: <span class="string">qn101630                               # git仓库的账号</span></span><br><span class="line">          <span class="attr">password</span>: <span class="string">qn192837QN</span></span><br><span class="line">          <span class="meta">default-label</span>: <span class="string">code</span></span><br></pre></td></tr></table></figure><h4 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span> <span class="comment">//启用配置中心服务，作为一个接口对外提供</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigServerApp<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问远程配置"><a href="#访问远程配置" class="headerlink" title="访问远程配置"></a>访问远程配置</h4><p>访问地址：<a href="http://localhost:8769/spring-cloud-config-dev.properties" target="_blank" rel="noopener">http://localhost:8769/spring-cloud-config-dev.properties</a></p><h2 id="创建一个-config-client-组件"><a href="#创建一个-config-client-组件" class="headerlink" title="创建一个 config-client 组件"></a>创建一个 config-client 组件</h2><h4 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>config-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--无法引入：spring-cloud-config-server--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><h5 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8771</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">register-with-eureka</span>: <span class="string">false</span></span><br><span class="line">    <span class="meta">fetch-registry</span>: <span class="string">false</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">spring-cloud-config-client</span></span><br></pre></td></tr></table></figure><h5 id="bootstrap-yml"><a href="#bootstrap-yml" class="headerlink" title="bootstrap.yml"></a>bootstrap.yml</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">config</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">name</span>: <span class="string">spring-cloud-config</span></span><br><span class="line">      <span class="attr">profile</span>: <span class="string">dev</span></span><br><span class="line">      <span class="attr">uri</span>: <span class="string">http://localhost:8769/</span></span><br><span class="line">      <span class="attr">label</span>: <span class="string">code</span></span><br></pre></td></tr></table></figure><h4 id="启动类-1"><a href="#启动类-1" class="headerlink" title="启动类"></a>启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ClientApp<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="业务类"><a href="#业务类" class="headerlink" title="业务类"></a>业务类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个@Value会根据配置的配置中心地址找到git仓库对应的配置和本地服务的配置文件</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;config.hello&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String hello;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"testConfig"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"读取到配置中心："</span> + hello;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最终测试"><a href="#最终测试" class="headerlink" title="最终测试"></a>最终测试</h1><p>启动项目后访问：<a href="http://localhost:8769/hello" target="_blank" rel="noopener">http://localhost:8769/hello</a></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>目前我们的配置信息是由 client 去拉取，但是 git 上的配置发生了改变，client 无法及时的获取更改后的配置，必须重新启动 client 才可以，这显然是不合适的，所以我们还要实现动态获取配置，详情请见<a href="/2019/11/29/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%882%EF%BC%89/" title="springcloud实战之Config（2）">springcloud实战之Config（2）</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/qqxx6661/article/details/88604499" target="_blank" rel="noopener">配置中心 Spring Cloud Config 初体验</a></p>]]></content>
      
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> config实战 初体验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud解析之Config</title>
      <link href="/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BConfig/"/>
      <url>/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BConfig/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么需要配置中心？"><a href="#为什么需要配置中心？" class="headerlink" title="为什么需要配置中心？"></a>为什么需要配置中心？</h1><p>微服务架构没有配置中心：</p><ul><li>配置文件分散在各个项目里，不方便维护</li><li>配置内容安全与权限，实际开发中，开发人员是不知道线上环境的配置的</li><li>更新配置后，项目需要重启</li></ul><h1 id="描述下配置中心原理"><a href="#描述下配置中心原理" class="headerlink" title="描述下配置中心原理"></a>描述下配置中心原理</h1><p>把原本放在本地文件的配置抽取出来放在中心服务器，本质是配置信息从本地迁移到云端。从而能够提供更好的管理、发布能力。</p><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="/images/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BConfig_2019-11-22-21-30-17.png" alt="springcloud解析之Config_2019-11-22-21-30-17.png"></p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ul><li>Config-Client : 提供了基于 Spring 的客户端</li><li>Config-Server : 负责将远程的配置返回给客户端</li><li>Remote Repository : 远程仓库（svn/git)</li><li>Local Repository : 将远程仓库的配置 clone 到本地的临时目录</li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>提供服务端和客户端支持</li><li>集中管理各环境的配置文件</li><li>配置文件修改之后，可以快速的生效</li><li>可以进行版本管理</li><li>支持大的并发查询</li><li>支持各种语言</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>动态配置能力弱</li><li>调整配置需要重新部署，添加代码比较多</li><li>治理能力弱</li><li>安全审计能力弱</li><li>不算严格企业级</li><li>适用于小型项目</li></ul>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> config 配置中心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud实战之Zuul</title>
      <link href="/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BZuul/"/>
      <url>/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BZuul/</url>
      
        <content type="html"><![CDATA[<h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><p>新建 Zuul 子模块</p><h2 id="Zuul-服务网关体验"><a href="#Zuul-服务网关体验" class="headerlink" title="Zuul 服务网关体验"></a>Zuul 服务网关体验</h2><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">zuul</span></span><br><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8773</span></span><br><span class="line"><span class="comment">#服务中心注册</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">serviceUrl</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://localhost:9999/eureka/</span></span><br><span class="line"><span class="comment">#自定义负载均衡策略</span></span><br><span class="line"><span class="meta">provider-user</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">ribbon</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName</span>: <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br><span class="line"><span class="comment"># 服务网关设置</span></span><br><span class="line"><span class="attr">zuul</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">routes</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">hello</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">path</span>: <span class="string">/producer/**</span></span><br><span class="line">      <span class="attr">serviceId</span>: <span class="string">provider-user</span></span><br></pre></td></tr></table></figure><h4 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//启用服务网关</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ZuulApp<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="熔断器-Filter"><a href="#熔断器-Filter" class="headerlink" title="熔断器 Filter"></a>熔断器 Filter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiFallbackProvider</span> <span class="keyword">implements</span> <span class="title">FallbackProvider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRoute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置熔断的服务名</span></span><br><span class="line">        <span class="comment">//如果是所有服务则设置为*</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"provider-user"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">fallbackResponse</span><span class="params">(String route, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClientHttpResponse() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> HttpStatus <span class="title">getStatusCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> HttpStatus.OK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRawStatusCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getStatusText</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"&#123;code:0,message:service error =_=&#125;"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> InputStream <span class="title">getBody</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ByteArrayInputStream(getStatusText().getBytes()</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> HttpHeaders <span class="title">getHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">                headers.setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line">                <span class="keyword">return</span> headers;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ol><li>启动 Eureka 客户端、三个提供者服务（不同端口）、Zuul 网关模块，访问地址：<a href="http://localhost:8773/producer/user/1" target="_blank" rel="noopener">http://localhost:8773/producer/user/1</a></li><li>访问 15 次，发现请求是随机访问到三个提供者服务（说明自定义的负载均衡策略生效了，zuul 默认的负载均衡策略是轮询）。</li><li>关掉两个提供者服务，再次请求以上地址，发现可能返回服务降级内容（不超过两次）。</li><li>关掉最后一个提供者，再次请求会返回服务降级内容（说明熔断器生效）。</li></ol><p><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8Bzuul%EF%BC%88%E4%BA%8C%EF%BC%89_2019-11-20-15-57-24.png" alt="springcloud实战之zuul（二）_2019-11-20-15-57-24.png"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/qqxx6661/article/details/88767696" target="_blank" rel="noopener">[菜鸟 SpringCloud 实战入门]第九章：服务网关 Zuul 体验</a></p>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zuul实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud解析之Zuul</title>
      <link href="/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BZuul/"/>
      <url>/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BZuul/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-Zuul"><a href="#什么是-Zuul" class="headerlink" title="什么是 Zuul?"></a>什么是 Zuul?</h2><ul><li>服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供 REST API 的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。</li><li>Spring Cloud Netflix 中的 Zuul 就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。</li></ul><h2 id="为什么需要-Zuul"><a href="#为什么需要-Zuul" class="headerlink" title="为什么需要 Zuul?"></a>为什么需要 Zuul?</h2><ul><li>客户端直接与微服务通信：</li></ul><ol><li>客户端会多次请求不同的微服务，增加了客户端的复杂性。</li><li>存在跨域请求，在一定场景下处理相对复杂。</li><li>认证复杂，每个服务都需要独立认证。</li><li>难以重构，随着项目的迭代，可能需要重新划分微服务。</li><li>某些微服务可能使用了防火墙/浏览器不友好的协议，直接访问会有一定困难。</li></ol><ul><li>使用网关优点：</li></ul><ol><li>易于监控。可在微服务网关收集监控数据并将其推送到外部系统进行分析。</li><li>易于认证。可在微服务网关上进行认证。然后再将请求转发到后端的微服务，而无须在每个微服务中进行认证。</li><li>减少了客户端与各个微服务之间的交互次数。</li></ol><ul><li>Zuul 提供了不同类型的 filter 用于处理请求，这些 filter 可以让我们实现以下功能：</li></ul><ol><li>权限控制和安全性：可以识别认证需要的信息和拒绝不满足条件的请求</li><li>监控：监控请求信息</li><li>动态路由：根据需要动态地路由请求到后台的不同集群</li><li>压力测试</li><li>负载均衡</li><li>静态资源处理：直接在 zuul 处理静态资源的响应而不需要转发这些请求到内部集群中</li></ol><h2 id="Zuul-的执行过程"><a href="#Zuul-的执行过程" class="headerlink" title="Zuul 的执行过程"></a>Zuul 的执行过程</h2><p><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BZuul%EF%BC%88%E4%B8%80%EF%BC%89_2019-11-20-13-55-29.png" alt="springcloud实战之Zuul（一）_2019-11-20-13-55-29.png"></p><hr><ul><li>Zuul 内部的处理使用 ZuulServlet 完成，ZuulServlet 继承 HttpServlet，重写了 service 方法，service 方法内部分别是 pre、route、post 和 error 类型的 filter 进行调用。</li><li>filter 的执行顺序：先执行 pre 类型的 filter；如果 pre filter 执行失败那么执行 error 和 post 类型的 filter，pre filter 执行成功的话执行 route 类型的 filter；如果 route filter 执行失败那么执行 error 和 post 类型的 filter，route filter 执行成功的话执行 post filter；如果 post filter 执行失败那么执行 error 类型的 filter，post filter 执行成功的话，结束。上述过程中执行失败指的是 ZuulException 被 catch，如果是其他 Exception 的话，那么执行 error 类型的 filter，然后结束。</li><li>要在 SpringCloud 中使用 Zuul，需要加上<code>@EnableZuulProxy</code>注解。加上这个注解之后 SpringCloud 会构造一些 bean，比如 ZuulHandlerMapping、DiscoveryClientRouteLocator、各种 filter 等。其中<code>DiscoveryClientRouteLocato</code>r 是一个基于服务发现的路由规则生成器，它会基于 zuul 的配置构造路由规则。<code>ZuulHandlerMapping</code>是一个 HandlerMapping 的实现，它跟基于路由规则注册 handler，其中 key 为路由规则对应的路径，handler 都是 ZuulController，ZuulController 内部使用 ZuulServlet 进行请求的处理。</li><li>Zuul 把真正的服务调用放在了 filter 中实现。它提供了<code>SimpleHostRoutingFilter</code>和<code>RibbonRoutingFilter</code>这 2 个 route 类型的 filter 用于执行服务。从名字也可以看出来，SimpleHostRoutingFilter 用于执行基于 host 方式的调用 url 接口，RibbonRoutingFilter 基于服务发现的方式调用服务。<strong>一般我们都建议使用 RibbonRoutingFilter，因为它内部使用 ribbon，更加健壮。</strong></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://fangjian0423.github.io/2017/02/22/springcloud-zuul/" target="_blank" rel="noopener">SpringCloud 网关服务 zuul 介绍</a></p><p><a href="https://www.cnblogs.com/duanxz/p/7527765.html" target="_blank" rel="noopener">服务网关 zuul 之一：入门介绍</a></p>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ribbon服务网关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud实战之Hystrix（2）</title>
      <link href="/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BHystrix%EF%BC%882%EF%BC%89/"/>
      <url>/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BHystrix%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><p>多应用监控</p><h2 id="新建一个子模块-hystrix-dashboard-turbine"><a href="#新建一个子模块-hystrix-dashboard-turbine" class="headerlink" title="新建一个子模块 hystrix-dashboard-turbine"></a>新建一个子模块 hystrix-dashboard-turbine</h2><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hystrix-dashboard-turbine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring boot 1.X：spring-cloud-starter-hystrix-dashboard--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-netflix-turbine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line"><span class="comment">  # 服务端口号</span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8767</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line"><span class="comment">    # 服务名，即serviceId</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">hystrix-dashboard-turbine</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">serviceUrl</span>:<span class="string"></span></span><br><span class="line"><span class="comment">      # 安全认证的服务注册中心地址</span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://localhost:9999/eureka</span></span><br><span class="line"><span class="comment"># 熔断器turbine</span></span><br><span class="line"><span class="attr">turbine</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">aggregator</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">cluster-config</span>: <span class="string">default</span></span><br><span class="line">  <span class="meta">cluster-name-expression</span>: <span class="string">new String("default")</span></span><br><span class="line">  <span class="meta">app-config</span>: <span class="string">consumer-feign, consumer-feign-2</span></span><br></pre></td></tr></table></figure><h4 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableTurbine</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TurbineApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(TurbineApp<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复制一个提供者服务"><a href="#复制一个提供者服务" class="headerlink" title="复制一个提供者服务"></a>复制一个提供者服务</h2><h4 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span><br><span class="line">         xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;springcloud&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.qn&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;provider-user-2&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">7901 #自定义boot项目访问端口</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">provider-user-2</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">instance</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">hostname</span>: <span class="string">localhost</span></span><br><span class="line"><span class="comment">    # 发呆时间，即服务失效时间（缺省为90s）,就是超过15秒没有续约就会从注册表中剔除</span></span><br><span class="line">    <span class="meta">lease-expiration-duration-in-seconds</span>: <span class="string">15</span></span><br><span class="line"><span class="comment">    # 心跳时间，即服务续约间隔时间（缺省为30s）</span></span><br><span class="line">    <span class="meta">lease-renewal-interval-in-seconds</span>: <span class="string">5</span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://localhost:9999/eureka</span></span><br></pre></td></tr></table></figure><h2 id="复制一个-Feign-客户端"><a href="#复制一个-Feign-客户端" class="headerlink" title="复制一个 Feign 客户端"></a>复制一个 Feign 客户端</h2><h4 id="依赖-2"><a href="#依赖-2" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>consumer-feign-2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring boot 1.X：spring-cloud-starter-hystrix--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring boot 1.X：spring-cloud-starter-hystrix-dashboard--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8901</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">consumer-feign-2</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">instance</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">hostname</span>: <span class="string">localhost</span></span><br><span class="line"><span class="comment">    # 发呆时间，即服务失效时间（缺省为90s）,就是超过15秒没有续约就会从注册表中剔除</span></span><br><span class="line">    <span class="meta">lease-expiration-duration-in-seconds</span>: <span class="string">15</span></span><br><span class="line"><span class="comment">    # 心跳时间，即服务续约间隔时间（缺省为30s）</span></span><br><span class="line">    <span class="meta">lease-renewal-interval-in-seconds</span>: <span class="string">5</span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://localhost:9999/eureka</span></span><br><span class="line"><span class="meta">PROVIDER-USER</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">ribbon</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName</span>: <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br><span class="line"><span class="comment"># 在feign使用hystrix</span></span><br><span class="line"><span class="attr">feign</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">hystrix</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">enabled</span>: <span class="string">true</span></span><br><span class="line"><span class="comment"># 熔断器DashBoard: actuator在boot2.0调整后开关web端点的配置，*代表开启所有</span></span><br><span class="line"><span class="attr">management</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">endpoints</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">web</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">exposure</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">include</span>: <span class="string">"*"</span></span><br></pre></td></tr></table></figure><h4 id="Service-接口"><a href="#Service-接口" class="headerlink" title="Service 接口"></a>Service 接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个feign接口，通过@ FeignClient（“服务名”），来指定调用哪个服务</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value =<span class="string">"PROVIDER-USER-2"</span>,fallback = ServiceHystrixImpl<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">getUser2</span><span class="params">(@PathVariable Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>fallback 服务降级</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHystrixImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser2</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">12345l</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="查看监控"><a href="#查看监控" class="headerlink" title="查看监控"></a>查看监控</h1><ol><li>启动 hystrix-dashboard-turbine、俩个 Feign 客户端、两个提供者服务、eureka 客户端。</li><li>访问网址<a href="http://localhost:8767/hystrix" target="_blank" rel="noopener">http://localhost:8767/hystrix</a> ，输入输入： <a href="http://localhost:8767/turbine.stream" target="_blank" rel="noopener">http://localhost:8767/turbine.stream</a> ，然后点击 Monitor Stream ,可以看到出现了监控列表，分别访问<a href="http://localhost:8900/order/1、http://localhost:8901/order/1，显示界面如下：" target="_blank" rel="noopener">http://localhost:8900/order/1、http://localhost:8901/order/1，显示界面如下：</a><br><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BHystrix%EF%BC%88%E4%B8%89%EF%BC%89_2019-11-19-17-19-13.png" alt="springcloud实战之Hystrix（三）_2019-11-19-17-19-13.png"></li></ol>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多应用监控 turbine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud实战之Hystrix（1）</title>
      <link href="/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BHystrix%EF%BC%881%EF%BC%89/"/>
      <url>/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BHystrix%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><p>使用上一章建立的 Feign 客户端</p><h2 id="添加配置文件"><a href="#添加配置文件" class="headerlink" title="添加配置文件"></a>添加配置文件</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">hystrix</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">enabled</span>: <span class="string">true</span></span><br></pre></td></tr></table></figure><h2 id="fallback-类"><a href="#fallback-类" class="headerlink" title="fallback 类"></a>fallback 类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHystrixImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">12345l</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改-Service-接口"><a href="#修改-Service-接口" class="headerlink" title="修改 Service 接口"></a>修改 Service 接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个feign接口，通过@ FeignClient（“服务名”），来指定调用哪个服务，fallback定义服务降级</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value =<span class="string">"PROVIDER-USER"</span>,fallback = ServiceHystrixImpl<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">getUser</span><span class="params">(@PathVariable Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">启动Feign客户端，访问提供者服务，url地址同上，停止服务提供者，再次访问，会返回服务降级内容。</span><br></pre></td></tr></table></figure><h1 id="熔断器监控-Hystrix-Dashboard-单一应用"><a href="#熔断器监控-Hystrix-Dashboard-单一应用" class="headerlink" title="熔断器监控 Hystrix Dashboard(单一应用)"></a>熔断器监控 Hystrix Dashboard(单一应用)</h1><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>consumer-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring boot 1.X：spring-cloud-starter-hystrix--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring boot 1.X：spring-cloud-starter-hystrix-dashboard--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="添加配置文件内容"><a href="#添加配置文件内容" class="headerlink" title="添加配置文件内容"></a>添加配置文件内容</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 熔断器DashBoard: actuator在boot2.0调整后开关web端点的配置，*代表开启所有</span></span><br><span class="line"><span class="attr">management</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">endpoints</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">web</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">exposure</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">include</span>: <span class="string">"*"</span></span><br></pre></td></tr></table></figure><h2 id="启动类添加注解"><a href="#启动类添加注解" class="headerlink" title="启动类添加注解"></a>启动类添加注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//通过注解@EnableEurekaClient 表明自己是一个eurekaclient.</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="comment">//开启Feign的功能</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="comment">//注解开启Hystrix仪表盘</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="comment">//注解开启Hystrix</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerFeignApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConsumerFeignApp<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h1><ol><li>启动 Feign 客户端，访问网址<a href="http://localhost:8900/hystrix/，显示界面如下：" target="_blank" rel="noopener">http://localhost:8900/hystrix/，显示界面如下：</a><br><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BHystrix%EF%BC%88%E4%BA%8C%EF%BC%89_2019-11-19-15-36-15.png" alt="springcloud实战之Hystrix（二）_2019-11-19-15-36-15.png"></li><li>输入<a href="http://localhost:8900/actuator/hystrix.stream,点击monitor,显示界面如下：" target="_blank" rel="noopener">http://localhost:8900/actuator/hystrix.stream,点击monitor,显示界面如下：</a><br><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BHystrix%EF%BC%88%E4%BA%8C%EF%BC%89_2019-11-19-15-39-54.png" alt="springcloud实战之Hystrix（二）_2019-11-19-15-39-54.png"></li><li>只使用 Hystrix Dashboard 的话, 你只能看到单个应用内的服务信息, 这明显不够. 我们需要一个工具能让我们汇总系统内多个服务的数据并显示到 Hystrix Dashboard 上,这个工具就是 Turbine.详见<a href="/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BHystrix%EF%BC%882%EF%BC%89/" title="springcloud实战之Hystrix（2）">springcloud实战之Hystrix（2）</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hystrix实战 单应用监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud解析之Hystrix</title>
      <link href="/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BHystrix/"/>
      <url>/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BHystrix/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么需要熔断器？"><a href="#为什么需要熔断器？" class="headerlink" title="为什么需要熔断器？"></a>为什么需要熔断器？</h1><ul><li>传统分布式系统面临一些性能上的问题，当复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败。这时可能会出现<strong>服务雪崩</strong>。</li><li>对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。</li></ul><h1 id="什么是服务雪崩？"><a href="#什么是服务雪崩？" class="headerlink" title="什么是服务雪崩？"></a>什么是服务雪崩？</h1><p>多个微服务之间调用的时候，假设微服务 A 调用微服务 B 和微服务 C，微服务 B 和微服务 C 又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务 A 的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”。</p><h1 id="什么是熔断器-Hystrix？"><a href="#什么是熔断器-Hystrix？" class="headerlink" title="什么是熔断器 Hystrix？"></a>什么是熔断器 Hystrix？</h1><ul><li>Hystrix 是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix 能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。</li><li>“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。</li></ul><h1 id="Hystrix-能做什么"><a href="#Hystrix-能做什么" class="headerlink" title="Hystrix 能做什么"></a>Hystrix 能做什么</h1><p><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BHystrix%EF%BC%88%E4%B8%80%EF%BC%89_2019-11-19-14-44-07.png" alt="springcloud实战之Hystrix（一）_2019-11-19-14-44-07.png"></p><h2 id="断路器"><a href="#断路器" class="headerlink" title="断路器"></a>断路器</h2><p>当 Hystrix Command 请求后端服务失败数量超过一定比例(默认 50%), 断路器会切换到开路状态(Open). 这时所有请求会直接失败而不会发送到后端服务. 断路器保持在开路状态一段时间后(默认 5 秒), 自动切换到半开路状态(HALF-OPEN). 这时会判断下一次请求的返回情况, 如果请求成功, 断路器切回闭路状态(CLOSED), 否则重新切换到开路状态(OPEN). Hystrix 的断路器就像我们家庭电路中的保险丝, 一旦后端服务不可用, 断路器会直接切断请求链, 避免发送大量无效请求影响系统吞吐量, 并且断路器有自我检测并恢复的能力。</p><h2 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h2><p>对于查询操作, 我们可以实现一个 fallback 方法, 当请求后端服务出现异常的时候, 可以使用 fallback 方法返回的值. fallback 方法的返回值一般是设置的默认值或者来自缓存。</p><h2 id="资源隔离"><a href="#资源隔离" class="headerlink" title="资源隔离"></a>资源隔离</h2><p>在 Hystrix 中, 主要通过线程池来实现资源隔离. 通常在使用的时候我们会根据调用的远程服务划分出多个线程池. 例如调用产品服务的 Command 放入 A 线程池, 调用账户服务的 Command 放入 B 线程池. 这样做的主要优点是运行环境被隔离开了. 这样就算调用服务的代码存在 bug 或者由于其他原因导致自己所在线程池被耗尽时, 不会对系统的其他服务造成影响. 但是带来的代价就是维护多个线程池会对系统带来额外的性能开销. 如果是对性能有严格要求而且确信自己调用服务的客户端代码不会出问题的话, 可以使用 Hystrix 的信号模式(Semaphores)来隔离资源.</p><h2 id="服务监控-hystrixDashboard"><a href="#服务监控-hystrixDashboard" class="headerlink" title="服务监控 hystrixDashboard"></a>服务监控 hystrixDashboard</h2><p>除了隔离依赖服务的调用以外，Hystrix 还提供了准实时的调用监控（Hystrix Dashboard），Hystrix 会持续地记录所有通过 Hystrix 发起的请求的执行信息，并以统计报表和图形的形式展示给用户，包括每秒执行多少请求多少成功，多少失败等。Netflix 通过 hystrix-metrics-event-stream 项目实现了对以上指标的监控。Spring Cloud 也提供了 Hystrix Dashboard 的整合，对监控内容转化成可视化界面。</p>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hystrix 熔断器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud实战之Euraka</title>
      <link href="/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BEuraka/"/>
      <url>/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BEuraka/</url>
      
        <content type="html"><![CDATA[<h1 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h1><ul><li>jdk1.8</li><li>maven 3.6.2</li><li>IntelliJ IDEA</li><li>springCloud Finchley.RELEASE</li><li>springBoot 2.0.3</li></ul><h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><h2 id="project-依赖"><a href="#project-依赖" class="headerlink" title="project 依赖"></a>project 依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--子项目--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>consumer-order<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>provider-user<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>appEureka<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>consumer-order-ribbon<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--参数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--springBoot--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--springCloud版本序列配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Finchley.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Spring Cloud 基础--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Spring Cloud 服务注册组件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--此处的依赖是SpringBoot2.0以后专用的，如果您使用的SpringBoot版本低于2.0请使用spring-cloud-starter-eureka-server--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring boot 2.0.3版本解决方案：spring-cloud-starter-feign--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--Spring Boot 执行器组件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="eureka-客户端依赖、启动类、配置"><a href="#eureka-客户端依赖、启动类、配置" class="headerlink" title="eureka 客户端依赖、启动类、配置"></a>eureka 客户端依赖、启动类、配置</h2><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xmlversion="1.0"encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">projectxmlns="http:</span>//<span class="attr">maven.apache.org</span>/<span class="attr">POM</span>/<span class="attr">4.0.0</span>"</span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>appEureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span><span class="comment">//开启Eurekaserver</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Eureka</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">    SpringApplication.run(Eureka<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 端口号</span></span><br><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">9999</span></span><br><span class="line"><span class="comment"># 服务注册相关配置</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line"><span class="comment">  # 服务实例主机名</span></span><br><span class="line">  <span class="attr">instance</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">hostname</span>: <span class="string">localhost</span></span><br><span class="line"><span class="comment">  # 服务提供者配置</span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line"><span class="comment">    # 不进行注册（当服务注册中心是单点而非高可用时的配置方式）</span></span><br><span class="line">    <span class="attr">registerWithEureka</span>: <span class="string">false</span></span><br><span class="line"><span class="comment">    # 不获取注册信息（当服务注册中心是单点而非高可用时的配置方式）</span></span><br><span class="line">    <span class="attr">fetchRegistry</span>: <span class="string">false</span></span><br><span class="line"><span class="comment">    # 服务注册中心地址</span></span><br><span class="line">    <span class="attr">serviceUrl</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure><h4 id="消费者依赖、启动类、配置、bean、业务类"><a href="#消费者依赖、启动类、配置、bean、业务类" class="headerlink" title="消费者依赖、启动类、配置、bean、业务类"></a>消费者依赖、启动类、配置、bean、业务类</h4><h5 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xmlversion="1.0"encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">projectxmlns="http:</span>//<span class="attr">maven.apache.org</span>/<span class="attr">POM</span>/<span class="attr">4.0.0</span>"</span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>consumer-order<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="启动类-1"><a href="#启动类-1" class="headerlink" title="启动类"></a>启动类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerApp</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">    SpringApplication.run(ConsumerApp<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line"><span class="attr">port</span>:<span class="string">8900</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line"><span class="attr">application</span>:<span class="string"></span></span><br><span class="line"><span class="attr">name</span>:<span class="string">consumer-order</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line"><span class="attr">instance</span>:<span class="string"></span></span><br><span class="line">   <span class="attr">hostname</span>: <span class="string">localhost</span></span><br><span class="line"><span class="comment">   # 发呆时间，即服务失效时间（缺省为90s）,就是超过15秒没有续约就会从注册表中剔除</span></span><br><span class="line">   <span class="meta">lease-expiration-duration-in-seconds</span>: <span class="string">15</span></span><br><span class="line"><span class="comment">   # 心跳时间，即服务续约间隔时间（缺省为30s）</span></span><br><span class="line">   <span class="meta">lease-renewal-interval-in-seconds</span>: <span class="string">5</span></span><br><span class="line"><span class="attr">client</span>:<span class="string"></span></span><br><span class="line"><span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line"><span class="attr">defaultZone</span>:<span class="string">http://localhost:9999/eureka</span></span><br></pre></td></tr></table></figure><h5 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"><span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id=id;</span><br><span class="line"><span class="keyword">this</span>.date=newDate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Longget <span class="title">Id</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id=id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getDate</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(Datedate)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.date=date;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="业务类"><a href="#业务类" class="headerlink" title="业务类"></a>业务类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span></span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> EurekaClient eurekaClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/order/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Userget <span class="title">Order</span><span class="params">(@PathVariableLongid)</span></span>&#123;</span><br><span class="line">InstanceInfo nextServerFromEureka=eurekaClient.getNextServerFromEureka(<span class="string">"PROVIDER-USER"</span>,<span class="keyword">false</span>);</span><br><span class="line">Stringurl=nextServerFromEureka.getHomePageUrl();</span><br><span class="line">Useruser=restTemplate.getForObject(url+<span class="string">"/user/"</span>+id,User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="提供者依赖、配置、启动类、bean、业务类"><a href="#提供者依赖、配置、启动类、bean、业务类" class="headerlink" title="提供者依赖、配置、启动类、bean、业务类"></a>提供者依赖、配置、启动类、bean、业务类</h4><h5 id="依赖-2"><a href="#依赖-2" class="headerlink" title="依赖"></a>依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xmlversion="1.0"encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">projectxmlns="http:</span>//<span class="attr">maven.apache.org</span>/<span class="attr">POM</span>/<span class="attr">4.0.0</span>"</span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>provider-user<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line"><span class="attr">port</span>:<span class="string">7900#自定义boot项目访问端口</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line"><span class="attr">application</span>:<span class="string"></span></span><br><span class="line"><span class="attr">name</span>:<span class="string">provider-user</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line"><span class="attr">instance</span>:<span class="string"></span></span><br><span class="line">   <span class="attr">hostname</span>: <span class="string">localhost</span></span><br><span class="line"><span class="comment">   # 发呆时间，即服务失效时间（缺省为90s）,就是超过15秒没有续约就会从注册表中剔除</span></span><br><span class="line">   <span class="meta">lease-expiration-duration-in-seconds</span>: <span class="string">15</span></span><br><span class="line"><span class="comment">   # 心跳时间，即服务续约间隔时间（缺省为30s）</span></span><br><span class="line">   <span class="meta">lease-renewal-interval-in-seconds</span>: <span class="string">5</span></span><br><span class="line"><span class="attr">client</span>:<span class="string"></span></span><br><span class="line"><span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line"><span class="attr">defaultZone</span>:<span class="string">http://localhost:9999/eureka</span></span><br></pre></td></tr></table></figure><h5 id="启动类-2"><a href="#启动类-2" class="headerlink" title="启动类"></a>启动类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span><span class="comment">//启用eureka客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderApp</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">SpringApplication.run(ProviderApp<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="bean-1"><a href="#bean-1" class="headerlink" title="bean"></a>bean</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"><span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id=id;</span><br><span class="line"><span class="keyword">this</span>.date=newDate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Longget <span class="title">Id</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id=id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getDate</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(Datedate)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.date=date;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="业务类-1"><a href="#业务类-1" class="headerlink" title="业务类"></a>业务类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> EurekaClient eurekaClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">publicUsergetUser(<span class="meta">@PathVariableLongid</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> User(id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ul><li>启动 eureka、消费者、提供者，访问 eureka 客户端<br><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8Beureka%EF%BC%88%E4%BA%8C%EF%BC%89_2019-11-14-10-26-57.png" alt="springcloud实战之eureka（二）_2019-11-14-10-26-57.png"></li><li>消费者通过 eureka 访问提供者<br><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8Beureka%EF%BC%88%E4%BA%8C%EF%BC%89_2019-11-14-10-31-56.png" alt="springcloud实战之eureka（二）_2019-11-14-10-31-56.png"></li></ul>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eureka实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud解析之Eureka</title>
      <link href="/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BEureka/"/>
      <url>/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BEureka/</url>
      
        <content type="html"><![CDATA[<h1 id="Eureka-是什么？"><a href="#Eureka-是什么？" class="headerlink" title="Eureka 是什么？"></a>Eureka 是什么？</h1><ul><li><code>Netflix</code>提供的一种高可用的服务发现解决方案。</li><li>基于 REST 的服务，主要用于定位运行在 AWS 域中的中间层服务，以达到负载均衡和中间层服务故障转移的目的。SpringCloud 将它集成在其子项目<code>spring-cloud-netflix</code>中，实现 SpringCloud 的服务发现功能。</li></ul><h1 id="介绍下-Eureka-的工作原理"><a href="#介绍下-Eureka-的工作原理" class="headerlink" title="介绍下 Eureka 的工作原理"></a>介绍下 Eureka 的工作原理</h1><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ul><li>Eureka 服务器和 Eureka 客户端。Eureka 服务器用作服务注册服务器。</li><li>Eureka 客户端是一个 java 客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。</li></ul><h2 id="Eureka-架构图"><a href="#Eureka-架构图" class="headerlink" title="Eureka 架构图"></a>Eureka 架构图</h2><p><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8Beureka%EF%BC%88%E4%B8%80%EF%BC%89_2019-11-18-13-35-14.png" alt="springcloud实战之eureka（一）_2019-11-18-13-35-14.png"></p><h2 id="心跳监测"><a href="#心跳监测" class="headerlink" title="心跳监测"></a>心跳监测</h2><p>在应用启动后，将会向 Eureka Server 发送心跳,默认周期为 30 秒，如果 Eureka Server 在多个心跳周期内没有接收到某个节点的心跳，Eureka Server 将会从服务注册表中把这个服务节点移除(默认 90 秒)。</p><h2 id="心跳保护"><a href="#心跳保护" class="headerlink" title="心跳保护"></a>心跳保护</h2><p>如果 Eureka 服务节点在短时间里丢失了大量的心跳连接（注：可能发生了网络故障），那么这个 Eureka 节点会进入<strong>自我保护模式</strong>。 此时，这个 Eureka 节点对于新的服务还能提供注册服务，对于”死亡“的仍然保留，以防还有客户端向其发起请求。当网络故障恢复后，这个 Eureka 节点会退出自我保护模式。</p><h2 id="客户端缓存"><a href="#客户端缓存" class="headerlink" title="客户端缓存"></a>客户端缓存</h2><ul><li>Eureka 集群中所有节点都失效，或者发生网络分割故障导致客户端不能访问任何一台 Eureka 服务器；Eureka 服务的消费者仍然可以通过 Eureka 客户端缓存来获取现有的服务注册信息。</li><li>甚至最极端的环境下，所有正常的 Eureka 节点都不对请求产生相应，也没有更好的服务器解决方案来解决这种问题时；得益于 Eureka 的客户端缓存技术，消费者服务仍然可以通过 Eureka 客户端查询与获取注册服务信息，这点很重要。</li></ul><h2 id="服务同步"><a href="#服务同步" class="headerlink" title="服务同步"></a>服务同步</h2><p>如果某台服务器宕机，Eureka 不会有类似于 ZooKeeper 的选举 leader 的过程；客户端请求会自动切换到新的 Eureka 节点；当宕机的服务器重新恢复后，Eureka 会再次将其纳入到服务器集群管理之中；而对于它来说，所有要做的无非是同步一些新的服务注册信息而已。所以，再也不用担心有“掉队”的服务器恢复以后，会从 Eureka 服务器集群中剔除出去的风险了。</p><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><ul><li>服务发现有<strong>客户端发现模式</strong>和<strong>服务端发现模式</strong>两种。区别在于服务发现 Balance 策略是由使用方自己实现还是作为一项服务来供使用方调用。</li><li>服务发现依赖于服务注册表，系统中每个服务实例启动时，会将自己的网络位置信息发送到服务注册表，服务注册表利用<strong>心跳机制</strong>即时更新。实例关闭或者服务注册表检测到实例心跳超时情况下，实例信息就会从服务注册表移出。</li></ul><h2 id="两种服务发现模式"><a href="#两种服务发现模式" class="headerlink" title="两种服务发现模式"></a>两种服务发现模式</h2><ul><li>客户端发现模式是由服务请求方负责发现所有可用实例在网络中的具体位置，并根据具体的 Balance 策略将请求路由到具体的实例处理。</li><li>服务端发现模式则是请求方把请求经由 Load Balancer，Load Balancer 查询服务注册表后根据自己的 Balance 策略将请求路由到目标服务的一台具体实例上进行处理。</li></ul>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eureka 服务发现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud实战之Feign</title>
      <link href="/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BFeign/"/>
      <url>/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BFeign/</url>
      
        <content type="html"><![CDATA[<h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>consumer-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8900</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">consumer-order-ribbon</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">instance</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">hostname</span>: <span class="string">localhost</span></span><br><span class="line"><span class="comment">    # 发呆时间，即服务失效时间（缺省为90s）,就是超过15秒没有续约就会从注册表中剔除</span></span><br><span class="line">    <span class="meta">lease-expiration-duration-in-seconds</span>: <span class="string">15</span></span><br><span class="line"><span class="comment">    # 心跳时间，即服务续约间隔时间（缺省为30s）</span></span><br><span class="line">    <span class="meta">lease-renewal-interval-in-seconds</span>: <span class="string">5</span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://localhost:9999/eureka</span></span><br></pre></td></tr></table></figure><h2 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//通过注解@EnableEurekaClient 表明自己是一个eurekaclient.</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="comment">//开启Feign的功能</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerFeignApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConsumerFeignApp<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务接口"><a href="#服务接口" class="headerlink" title="服务接口"></a>服务接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个feign接口，通过@ FeignClient（“服务名”），来指定调用哪个服务</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value =<span class="string">"provider-user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">getUser</span><span class="params">(@PathVariable Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="业务类（数据类同上省略）"><a href="#业务类（数据类同上省略）" class="headerlink" title="业务类（数据类同上省略）"></a>业务类（数据类同上省略）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/order/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getOrder</span><span class="params">(@PathVariable Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUser(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">启动eureka、同时启动两个提供者、启动Feign客户端，访问地址http://localhost:8900/order/1，可以看到，轮流访问两个提供者服务。说明 Feign 默认是集成了 Ribbon 的轮询方案。</span><br></pre></td></tr></table></figure><h1 id="Feign-如何结合-Ribbon-切换均衡算法"><a href="#Feign-如何结合-Ribbon-切换均衡算法" class="headerlink" title="Feign 如何结合 Ribbon 切换均衡算法"></a>Feign 如何结合 Ribbon 切换均衡算法</h1><p>可以在 application.yml 中指定，如下:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">PROVIDER-USER</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">ribbon</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName</span>: <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br></pre></td></tr></table></figure><h1 id="测试均衡算法"><a href="#测试均衡算法" class="headerlink" title="测试均衡算法"></a>测试均衡算法</h1><p>重启 Feign 客户端，访问上面那个 url，可以发现随机访问负载策略是生效的。</p>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> feign实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud解析之Feign</title>
      <link href="/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BFeign/"/>
      <url>/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BFeign/</url>
      
        <content type="html"><![CDATA[<h1 id="Feign-是什么？"><a href="#Feign-是什么？" class="headerlink" title="Feign 是什么？"></a>Feign 是什么？</h1><ul><li>Feign 是一个声明式 WebService 客户端。</li><li>使用 Feign 能让编写的 WebService 客户端更加简洁。</li><li>它的使用方法式定义一个接口，然后在上面添加注解</li><li>Spring Cloud 对 Feign 进行了封装，使其支持了 Spring MVC 标准注解和 HttpMessageConverters。</li><li>Feign 可以与 Eureka 和 Ribbon 组合使用以支持负载均衡。</li></ul><h1 id="为什么要使用-Feign"><a href="#为什么要使用-Feign" class="headerlink" title="为什么要使用 Feign?"></a>为什么要使用 Feign?</h1><ul><li>Feign 旨在使编写 Java Http 客户端变得更容易。</li><li>让我们的服务接口化，改变前面的 Ribben+RestTemplate 的模板化的调用方式。</li><li>Feign 封装了 Ribbon，可以结合 Ribbon 自定义负载均衡策略</li><li><strong>但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用</strong>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> feign 服务接口化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud实战之Ribbon</title>
      <link href="/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BRibbon/"/>
      <url>/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BRibbon/</url>
      
        <content type="html"><![CDATA[<h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><p>创建一个消费者</p><h2 id="默认简单轮询负载均衡策略"><a href="#默认简单轮询负载均衡策略" class="headerlink" title="默认简单轮询负载均衡策略"></a>默认简单轮询负载均衡策略</h2><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>consumer-order-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8900</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">consumer-order-ribbon</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://localhost:9999/eureka</span></span><br><span class="line">  <span class="attr">instance</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">prefer-ip-address</span>: <span class="string">true</span></span><br></pre></td></tr></table></figure><h4 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConsumerApp<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 向程序的ioc注入一个bean: restTemplate;</span></span><br><span class="line"><span class="comment">    * 并通过<span class="doctag">@LoadBalanced</span>注解表明这个restRemplate开启负载均衡的功能。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.date = <span class="keyword">new</span> Date();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.date = date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="业务类"><a href="#业务类" class="headerlink" title="业务类"></a>业务类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/order/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getOrder</span><span class="params">(@PathVariable Long id)</span></span>&#123;</span><br><span class="line">        User user = restTemplate.getForObject(<span class="string">"http://PROVIDER-USER/user/"</span>+ id, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><hr><p>启动消费者（ribbon）、提供者（7900，7901）、eureka 客户端，访问如下界面刷新 10 次<br><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8Bribbon%EF%BC%88%E4%BA%8C%EF%BC%89_2019-11-14-17-21-44.png" alt="springcloud实战之ribbon（二）_2019-11-14-17-21-44.png"></p><hr><p>两个提供者服务各被访问 5 次</p><h2 id="自定义负载均衡策略"><a href="#自定义负载均衡策略" class="headerlink" title="自定义负载均衡策略"></a>自定义负载均衡策略</h2><h4 id="负载均衡策略类"><a href="#负载均衡策略类" class="headerlink" title="负载均衡策略类"></a>负载均衡策略类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonConfigration</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置负载均衡策略为 随机，默认是轮训</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">ribbonRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomRule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="负载均衡配置类"><a href="#负载均衡配置类" class="headerlink" title="负载均衡配置类"></a>负载均衡配置类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RibbonClient</span>(name = <span class="string">"PROVIDER-USER"</span>, configuration = RibbonConfigration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Component</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">RibbonConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h1><p>如上，访问 20 次，可以看到负载策略是随机访问的</p><h1 id="配置文件的方式"><a href="#配置文件的方式" class="headerlink" title="配置文件的方式"></a>配置文件的方式</h1><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">PROVIDER-USER</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">ribbon</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName</span>: <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br></pre></td></tr></table></figure><p>此方式配置轮询策略，会优先于第二种配置类的方式。</p>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ribbon实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud解析之Ribbon</title>
      <link href="/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BRibbon/"/>
      <url>/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BRibbon/</url>
      
        <content type="html"><![CDATA[<h1 id="Ribbon-是什么？"><a href="#Ribbon-是什么？" class="headerlink" title="Ribbon 是什么？"></a>Ribbon 是什么？</h1><p>springcloud 的客户端负载均衡组件</p><h1 id="什么是负载均衡？"><a href="#什么是负载均衡？" class="headerlink" title="什么是负载均衡？"></a>什么是负载均衡？</h1><p>负载均衡又分为服务端负载均衡和客户端负载均衡。</p><h2 id="服务端负载均衡"><a href="#服务端负载均衡" class="headerlink" title="服务端负载均衡"></a>服务端负载均衡</h2><p>硬件负载均衡和软件负载均衡</p><ul><li>硬件负载均衡主要通过在服务器节点之间按照专门用于负载均衡的设备，比如 F5 等</li><li>软件负载均衡则是通过在服务器上安装一些用于负载均衡功能或模块等软件来完成请求分发工作，比如 Nginx 等</li><li>服务端负载均衡架构图<br><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8Bribbon%EF%BC%88%E4%B8%80%EF%BC%89_2019-11-14-11-01-18.png" alt="springcloud实战之ribbon（一）_2019-11-14-11-01-18.png"></li></ul><h2 id="客户端负载均衡"><a href="#客户端负载均衡" class="headerlink" title="客户端负载均衡"></a>客户端负载均衡</h2><ul><li>客户端负载均衡和服务端负载均衡最大的不同点在于上面所提到<strong>服务清单所存储的位置</strong>。</li><li>在客户端负载均衡中，所有客户端节点都维护着自己要访问的服务端清单，而这些服务端端清单来自于服务注册中心，比如上一章我们介绍的 Eureka 服务端。同服务端负载均衡的架构类似，在客户端负载均衡中也需要心跳去维护服务端清单的健康性，默认会创建针对各个服务治理框架的 Ribbon 自动化整合配置。</li></ul><h1 id="讲解下-Ribbon-的工作原理"><a href="#讲解下-Ribbon-的工作原理" class="headerlink" title="讲解下 Ribbon 的工作原理"></a>讲解下 Ribbon 的工作原理</h1><h2 id="Ribbon-架构图"><a href="#Ribbon-架构图" class="headerlink" title="Ribbon 架构图"></a>Ribbon 架构图</h2><p><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8Bribbon%EF%BC%88%E4%B8%80%EF%BC%89_2019-11-18-10-30-38.png" alt="springcloud实战之ribbon（一）_2019-11-18-10-30-38.png"></p><h2 id="Ribbon-实现软负载均衡主要有这三点"><a href="#Ribbon-实现软负载均衡主要有这三点" class="headerlink" title="Ribbon 实现软负载均衡主要有这三点"></a>Ribbon 实现软负载均衡主要有这三点</h2><ol><li>服务发现：就是发现依赖服务的列表，通俗来说就是依据服务的名字把它的所有服务实例找出来</li><li>服务选择规则：依据指定的服务规则，从多个有效服务中选择一个服务发起请求</li><li>服务监听：定时检测服务存活情况，及时高效剔除不可用的服务。</li></ol><h2 id="Ribbon-主要组件"><a href="#Ribbon-主要组件" class="headerlink" title="Ribbon 主要组件"></a>Ribbon 主要组件</h2><p><code>ServerList</code>、<code>IRule</code>、<code>ServerListFilter</code>;<br>首先通过 <code>ServerList</code> 获取所有可用服务列表，再通过 <code>ServerListFilter</code> 过滤掉一部分服务，最后 <code>IRule</code> 从过滤后的服务中选择一个实例进行 <code>http</code> 请求</p><h2 id="Ribbon-负载均衡策略"><a href="#Ribbon-负载均衡策略" class="headerlink" title="Ribbon 负载均衡策略"></a>Ribbon 负载均衡策略</h2><ul><li>简单轮询负载均衡（RoundRobin）</li><li>随机负载均衡 （Random）</li><li>随机选择状态为 UP 的 Server</li><li>加权响应时间负载均衡 （WeightedResponseTime）</li><li>区域感知轮询负载均衡（ZoneAware）</li></ul><h2 id="Ribbon-配置"><a href="#Ribbon-配置" class="headerlink" title="Ribbon 配置"></a>Ribbon 配置</h2><p>连接超时、重试、重试算法</p><h2 id="Ribbon-功能"><a href="#Ribbon-功能" class="headerlink" title="Ribbon 功能"></a>Ribbon 功能</h2><ul><li>易于与服务发现组件（比如 Netflix 的 Eureka）集成</li><li>使用 Archaius 完成运行时配置</li><li>使用 JMX 暴露运维指标，使用 Servo 发布</li><li>多种可插拔的序列化选择</li><li>异步和批处理操作</li><li>自动 SLA 框架</li><li>系统管理/指标控制台</li></ul>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ribbon 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务——概述（一）</title>
      <link href="/2019/11/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/11/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是微服务架构"><a href="#什么是微服务架构" class="headerlink" title="什么是微服务架构"></a>什么是微服务架构</h1><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%98%AF%E4%BB%80%E4%B9%88_2019-11-20-13-53-42.png" alt="微服务是什么_2019-11-20-13-53-42.png"></p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间相互协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务和服务之间采用轻量级的通信机制相互沟通（通常是基于 HTTP 的 Restful API).每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境、类生产环境等</p><h1 id="单体应用-VS-微服务架构"><a href="#单体应用-VS-微服务架构" class="headerlink" title="单体应用 VS 微服务架构"></a>单体应用 VS 微服务架构</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>提升开发交流，每个服务足够内聚，足够小，代码容易理解；</li><li>服务独立测试、部署、升级、发布；</li><li>按需定制的 DFX，资源利用率，每个服务可以各自进行 x 扩展和 z 扩展，而且，每个服务可以根据自己的需要部署到合适的硬件服务器上；每个服务按</li><li>需要选择 HA 的模式，选择接受服务的实例个数；</li><li>容易扩大开发团队，可以针对每个服务（service）组件开发团队；</li><li>提高容错性（fault isolation），一个服务的内存泄露并不会让整个系统瘫痪；</li><li>新技术的应用，系统不会被长期限制在某个技术栈上；</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>没有银弹，微服务提高了系统的复杂度；</li><li>开发人员要处理分布式系统的复杂性；</li><li>服务之间的分布式通信问题；</li><li>服务的注册与发现问题；</li><li>服务之间的分布式事务问题；</li><li>数据隔离再来的报表处理问题；</li><li>服务之间的分布式一致性问题；</li><li>服务管理的复杂性，服务的编排；</li><li>不同服务实例的管理。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.zhihu.com/question/65502802" target="_blank" rel="noopener">什么是微服务架构？</a></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务介绍 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
