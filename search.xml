<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JAVA并发——线程池</title>
      <link href="/2020/03/27/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2020/03/27/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>现在 CPU 都是有多个核心，并行已经成为事实，一方面我们希望最大限度利用机器性能（利用多线程提高吞吐率），另一方面机器的硬件资源是有限的，我们也不能无限制的去申请，这时候我们就需要线程池。</p><p>幸运的是，JDK 已经为我们提供了 ExecutorService 的实现，还提供了 Executors 工厂类方便我们生成模板线程池。</p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><ul><li>它帮我们管理线程，避免增加创建线程和销毁线程的资源损耗。因为线程其实也是一个对象，创建一个对象，需要经过类加载过程，销毁一个对象，需要走 GC 垃圾回收流程，都是需要资源开销的。</li><li>提高响应速度。 如果任务到达了，相对于从线程池拿线程，重新去创建一条线程执行，速度肯定慢很多。</li><li>重复利用。 线程用完，再放回池子，可以达到重复利用的效果，节省资源。</li></ul><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h2><p>在 JDK 1.5 之后推出了相关的 api，常见的创建线程池方式有以下几种：</p><ul><li>Executors.newCachedThreadPool()：无限线程池。</li><li>Executors.newFixedThreadPool(nThreads)：创建固定大小的线程池。</li><li>Executors.newSingleThreadExecutor()：创建单个线程的线程池。</li></ul><p>其实看这三种方式创建的源码就会发现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上还是利用 <code>ThreadPoolExecutor</code> 类实现的。</p><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li><p><code>corePoolSize</code>:<br>指定线程池线程的数量</p></li><li><p><code>maximumPoolSize</code>:<br>指定线程池中线程的最大数量</p></li><li><p><code>keepAliveTime</code>:<br>当线程池线程的数量超过 corePoolSize 的时候，多余的空闲线程存活的时间，如果超过了 corePoolSize，在 keepAliveTime 的时间之后，销毁线程</p></li><li><p><code>unit</code>:<br>keepAliveTime 的单位</p></li><li><p><code>workQueue</code>:<br>工作队列，将被提交但尚未执行的任务缓存起来</p></li><li><p><code>threadFactory</code>:<br>线程工厂，用于创建线程，不指定为默认线程工厂 DefaultThreadFactory</p></li><li><p><code>handler</code>:<br>拒绝策略</p></li></ul><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0_2020-03-27-19-20-23.png" alt="JAVA并发——线程池_2020-03-27-19-20-23.png"></p><p>上图就是线程池的一个基本运行过程，但是线程池的原理并不是看上去这么简单。我们要想清楚以下两个问题：</p><ol><li>线程池的线程是如何做到复用的。</li><li>线程池是如何做到高效并发的。</li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="成员变量-clt"><a href="#成员变量-clt" class="headerlink" title="成员变量 clt"></a>成员变量 clt</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CAS，无锁并发</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">//表示线程池线程数的bit数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">//最大的线程数量，数量是完全够用了</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="comment">//1110 0000 0000 0000 0000 0000 0000 0000（很耿直的我）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//0000 0000 0000 0000 0000 0000 0000 0000（很耿直的我）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//0010 0000 0000 0000 0000 0000 0000 0000（很耿直的我）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//0100 0000 0000 0000 0000 0000 0000 0000（很耿直的我）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//0110 0000 0000 0000 0000 0000 0000 0000（很耿直的我）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="comment">//获取线程池的状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">//获取线程的数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="comment">//组装状态和数量，成为ctl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Bit field accessors that don't require unpacking ctl.</span></span><br><span class="line"><span class="comment"> * These depend on the bit layout and on workerCount being never negative.</span></span><br><span class="line"><span class="comment"> * 判断状态c是否比s小，下面会给出状态流转图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateLessThan</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断状态c是否不小于状态s</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateAtLeast</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断线程是否在运行</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员变量 ctl 是由 AtomicInteger 这个类定义的，可以通过 CAS 达到无锁并发，效率比较高。</p><p><strong>这个变量有双重身份，它的高三位表示线程池的状态，低 29 位表示线程池中现有的线程数</strong>，这也是 Doug Lea 一个天才的设计，用最少的变量来减少锁竞争，提高并发效率。</p><h4 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h4><p>关于线程池的状态，有 5 种，</p><ol><li><code>RUNNING</code>: 运行状态，值也是最小的，刚创建的线程池就是此状态。</li><li><code>SHUTDOWN</code>: 停工状态，不再接收新任务，已经接收的会继续执行</li><li><code>STOP</code>: 停止状态，不再接收新任务，已经接收正在执行的，也会中断</li><li><code>TIDYING</code>: 清空状态，所有任务都停止了，工作的线程也全部结束了</li><li><code>TERMINATED</code>: 终止状态，线程池已销毁</li></ol><p>用图表示：</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0_2020-03-27-19-34-26.png" alt="JAVA并发——线程池_2020-03-27-19-34-26.png"></p><h4 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//第一步，获取ctl</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">//检查当前线程数是否达到核心线程数的限制，注意线程本身是不区分核心还是非核心，后面会进一步验证</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">//如果核心线程数未达到，会直接添加一个核心线程，也就是说在线程池刚启动预热阶段，</span></span><br><span class="line">        <span class="comment">//提交任务后，会优先启动核心线程处理</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//如果添加任务失败，刷新ctl，进入下一步</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查线程池是否是运行状态，然后将任务添加到等待队列，注意offer是不会阻塞的</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">       <span class="comment">//任务成功添加到等待队列，再次刷新ctl</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">       <span class="comment">//如果线程池不是运行状态，则将刚添加的任务从队列移除并执行拒绝策略</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">//判断当前线程数量，如果线程数量为0，则添加一个非核心线程，并且不指定首次执行任务</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//添加非核心线程，指定首次执行任务，如果添加失败，执行异常策略</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * addWorker方法申明</span></span><br><span class="line"><span class="comment"> * @param core if true use corePoolSize as bound, else</span></span><br><span class="line"><span class="comment"> * maximumPoolSize. (A boolean indicator is used here rather than a</span></span><br><span class="line"><span class="comment"> * value to ensure reads of fresh values after checking other pool</span></span><br><span class="line"><span class="comment"> * state).</span></span><br><span class="line"><span class="comment"> * @return true if successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line"><span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的源码基本可以和上面的线程池的运行过程对上了，但是还有两个问题不明白？</p><ol><li>可以看到 execute 方法中没有用到重量级锁，ctl 虽然可以保证本身变化的原子性，但是不能保证方法内部的代码块的原子性，是否会有并发问题？</li><li>上面提到过，addWorker 方法可以添加工作线程（核心或者非核心），线程本身没有核心或者非核心的标识，core 参数只是用来确定当前线程数的比较对象是线程池设置的核心线程数还是最大线程数，真实情况是不是这样？</li></ol><h4 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//相当于goto，虽然不建议滥用，但这里使用又觉得没一点问题</span></span><br><span class="line">        retry:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">            <span class="comment">//如果线程池的状态到了SHUTDOWN或者之上的状态时候，只有一种情况还需要继续添加线程，</span></span><br><span class="line">            <span class="comment">//那就是线程池已经SHUTDOWN，但是队列中还有任务在排队,而且不接受新任务（所以firstTask必须为null）</span></span><br><span class="line">           <span class="comment">//这里还继续添加线程的初衷是，加快执行等待队列中的任务，尽快让线程池关闭</span></span><br><span class="line">            <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                   firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                   ! workQueue.isEmpty()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">               <span class="comment">//传入的core的参数，唯一用到的地方，如果线程数超过理论最大容量，如果core是true跟最大核心线程数比较，否则跟最大线程数比较</span></span><br><span class="line">                <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//通过CAS自旋，增加线程数+1，增加成功跳出双层循环，继续往下执行</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">break</span> retry;</span><br><span class="line">               <span class="comment">//检测当前线程状态如果发生了变化，则继续回到retry，重新开始循环</span></span><br><span class="line">                c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">                <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">                <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//走到这里，说明我们已经成功的将线程数+1了，但是真正的线程还没有被添加</span></span><br><span class="line">        <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">        Worker w = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//添加线程，Worker是继承了AQS，实现了Runnable接口的包装类</span></span><br><span class="line">            w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">            <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">//到这里开始加锁</span></span><br><span class="line">                <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">                mainLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                    <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                    <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                    <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                    <span class="comment">//检查线程状态，还是跟之前一样，只有当线程池处于RUNNING，或者处于SHUTDOWN并且firstTask==null的时候，这时候创建Worker来加速处理队列中的任务</span></span><br><span class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                       <span class="comment">//线程只能被start一次</span></span><br><span class="line">                        <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                      <span class="comment">//workers是一个HashSet，添加我们新增的Worker</span></span><br><span class="line">                        workers.add(w);</span><br><span class="line">                        <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                        workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                  <span class="comment">//启动Worker</span></span><br><span class="line">                    t.start();</span><br><span class="line">                    workerStarted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> workerStarted;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Worker 本身实现了 Runnable 接口，自然也实现了 run()方法，我们提交的任务实际上也是交给 Worker 来执行。</p><p>Workers 是一个 HashSet 结构的容器，用来存放要执行的线程。</p><p>分析完 addWorker 的源码实现，我们可以回答上面留下的二个疑问：</p><ol><li>execute 方法虽然没有加锁，但是在 addWorker 方法内部，加锁了，这样可以保证不会创建超过我们预期的线程数，大师在设计的时候，做到了在最小的范围内加锁，尽量减少锁竞争，</li><li>可以看到，core 参数，只是用来判断当前线程数是否超量的时候跟 corePoolSize 还是 maxPoolSize 比较，Worker 本身无核心或者非核心的概念。 嗯， 继续看 Worker 是怎么工作的</li></ol><h4 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Worker的run方法调用的是ThreadPoolExecutor的runWorker方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">        Thread wt = Thread.currentThread();</span><br><span class="line">        <span class="comment">//取出需要执行的任务，</span></span><br><span class="line">        Runnable task = w.firstTask;</span><br><span class="line">        w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">        w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">        <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如果task不是null，或者去队列中取任务，注意这里会阻塞，后面会分析getTask方法</span></span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">//这个lock在这里是为了如果线程被中断，那么会抛出InterruptedException，而退出循环，结束线程</span></span><br><span class="line">                w.lock();</span><br><span class="line">                <span class="comment">//判断线程是否需要中断</span></span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">//任务开始执行前的hook方法</span></span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                       <span class="comment">////任务开始执行后的hook方法</span></span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//Worker退出</span></span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">           <span class="comment">//检查线程池的状态，如果已经是STOP及以上的状态，或者已经SHUTDOWN，队列也是空的时候，直接return null，并将Worker数量-1</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">                decrementWorkerCount();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 注意这里的allowCoreThreadTimeOut参数，字面意思是否允许核心线程超时，即如果我们设置为false，那么只有当线程数wc大于corePoolSize的时候才会超时</span></span><br><span class="line">           <span class="comment">//更直接的意思就是，如果设置allowCoreThreadTimeOut为false，那么线程池在达到corePoolSize个工作线程之前，不会让闲置的工作线程退出</span></span><br><span class="line">            <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">          <span class="comment">//确认超时，将Worker数-1，然后返回</span></span><br><span class="line">            <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">                &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//从队列中取任务，根据timed选择是有时间期限的等待还是无时间期限的等待</span></span><br><span class="line">                Runnable r = timed ?</span><br><span class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                    workQueue.take();</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                timedOut = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">                timedOut = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>看到这里我们可以回答一开始提出的 2 个问题了：</p><ol><li><p><strong>线程池的线程是如何做到复用的</strong>: 线程池中的线程在循环中尝试取任务执行，这一步会被阻塞，如果设置了 allowCoreThreadTimeOut 为 true，则线程池中的所有线程都会在 keepAliveTime 时间超时后还未取到任务而退出。或者线程池已经 STOP，那么所有线程都会被中断，然后退出。</p></li><li><p><strong>线程池是如何做到高效并发的</strong>:看整个线程池的工作流程，有以下几个需要特别关注的并发点.</p><ol><li>线程池状态和工作线程数量的变更。这个由一个 AtomicInteger 变量 ctl 来解决原子性问题。</li><li>向工作 Worker 容器 workers 中添加新的 Worker 的时候。这个线程池本身已经加锁了。</li><li>工作线程 Worker 从等待队列中取任务的时候。这个由工作队列本身来保证线程安全，比如 LinkedBlockingQueue 等。</li></ol></li></ol><h4 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h4><p>具体结合以上几个方法：</p><h5 id="execute-运行原理："><a href="#execute-运行原理：" class="headerlink" title="execute 运行原理："></a>execute 运行原理：</h5><ol><li><p>当我们提交任务到线程池：通过 <code>workerCountOf(c)</code> 提取 Workers 里的 Worker 的数量。如果小于核心线程数，则会尝试进行 <code>addWorker</code> 操作,否则执行步骤 2。</p></li><li><p>如果 worker 数量大于等于核心线程数根据 c（c 就是 ctl 的值）判断线程池是否还在运行，并且尝试添加任务到队列中。成功则执行 3，失败则执行 4。</p></li><li><p>再次检查线程池的状态，如果线程池没有 RUNNING，且成功从阻塞队列中删除任务，则执行 <code>reject</code> 方法处理任务；</p></li><li><p>那么如果把任务放入阻塞队列失败，即队列已满呢（workQueue.offer(command)返回 false），这时候，直接尝试增加一个 worker，如果失败，则执行拒绝策略处理该条任务。</p></li></ol><h5 id="addWorker-运行原理："><a href="#addWorker-运行原理：" class="headerlink" title="addWorker 运行原理："></a>addWorker 运行原理：</h5><ol><li><p>判断线程池的状态，如果线程池的状态值大于或等 SHUTDOWN，则不处理提交的任务，直接返回；</p></li><li><p>通过参数 core 判断当前需要创建的线程是否为核心线程，如果 core 为 true，且当前线程数小于 corePoolSize，则跳出循环，开始创建新的线程。</p></li></ol><h5 id="Worker-的设计："><a href="#Worker-的设计：" class="headerlink" title="Worker 的设计："></a>Worker 的设计：</h5><ol><li><p>继承了 AQS 类，可以方便的实现工作线程的中止操作；</p></li><li><p>实现了 Runnable 接口，可以将自身作为一个任务在工作线程中执行；</p></li><li><p>当前提交的任务 firstTask 作为参数传入 Worker 的构造方法；</p></li></ol><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0_2020-03-27-20-42-34.png" alt="JAVA并发——线程池_2020-03-27-20-42-34.png"></p><p>注意：这里有一个 Worker 的参数 <code>firsttask</code>，这里为什么第一个任务呢，因为一个 worker 创建处来，一开始会有个任务，这个任务执行完了呢，就会执行 <code>getTask</code> 方法，从队列中去获取任务。</p><h5 id="runWorker-的实现："><a href="#runWorker-的实现：" class="headerlink" title="runWorker 的实现："></a>runWorker 的实现：</h5><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0_2020-03-27-20-42-47.png" alt="JAVA并发——线程池_2020-03-27-20-42-47.png"></p><p>runWorker 方法是线程池的核心：</p><ol><li><p>线程启动之后，通过 unlock 方法释放锁，设置 AQS 的 state 为 0，表示运行中断；</p></li><li><p>获取第一个任务 firstTask，执行任务的 run 方法，不过在执行任务之前，会进行加锁操作，任务执行完会释放锁；</p></li><li><p>在执行任务的前后，可以根据业务场景自定义 beforeExecute 和 afterExecute 方法；</p></li><li><p>firstTask 执行完成之后，通过 getTask 方法从阻塞队列中获取等待的任务，如果队列中没有任务，getTask 方法会被阻塞并挂起，不会占用 cpu 资源；</p></li></ol><h5 id="getTask-实现"><a href="#getTask-实现" class="headerlink" title="getTask 实现"></a>getTask 实现</h5><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0_2020-03-27-20-44-24.png" alt="JAVA并发——线程池_2020-03-27-20-44-24.png"></p><p>整个 getTask 操作在自旋下完成：</p><ol><li><p>workQueue.take：如果阻塞队列为空，当前线程会被挂起等待；当队列中有任务加入时，线程被唤醒，take 方法返回任务，并执行；</p></li><li><p>workQueue.poll：如果在 keepAliveTime 时间内，阻塞队列还是没有任务，则返回 null；</p></li></ol><p>所以，线程池中实现的线程可以一直执行由用户提交的任务。</p><h3 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h3><p>线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了 4 种策略：</p><ol><li><p><code>AbortPolicy</code>：直接抛出异常，默认策略；</p></li><li><p><code>CallerRunsPolicy</code>：用调用者所在的线程来执行任务；</p></li><li><p><code>DiscardOldestPolicy</code>：丢弃阻塞队列中靠最前的任务，并执行当前任务；</p></li><li><p><code>DiscardPolicy</code>：直接丢弃任务； 当然也可以根据应用场景实现 RejectedExecutionHandler 接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>线程池对于线程的复用很重要，避免了频繁创建线程造成的内存和 CPU 调度的消耗。</li><li>线程池、队列大小要设计的合理，尽量的让任务从队列中获取执行。</li><li>如果任务多，线程执行时间短可以调大 keepalive 值，使得线程尽量不被回收从而可以复用线程。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java并发 线程安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA并发——线程</title>
      <link href="/2020/03/19/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/03/19/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>想了解线程首先要知道进程。</p><p><strong>进程</strong> 是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。</p><p>可以这样理解，我们在电脑上打开的 eclipse 软件，就会创建一个进程去执行它。</p><p><strong>线程</strong> 是指进程中的一个执行流程，一个进程中可以运行多个线程。</p><p>线程没有自己的虚拟地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。</p><h2 id="啥是多线程？-串行，并行，并发"><a href="#啥是多线程？-串行，并行，并发" class="headerlink" title="啥是多线程？ 串行，并行，并发"></a>啥是多线程？ 串行，并行，并发</h2><p><strong>多线程</strong> 指的是这个程序（一个进程）运行时产生了不止一个线程。</p><p><strong>并发</strong>：是指同一个时间段内多个任务同时都在执行，并且都没有执行结束。并发任务强调在一个时间段内同时执行，而一个时间段由多个单位时间累积而成，所以说并发的多个任务在单位时间内不一定同时在执行。</p><p><strong>并行</strong>：是说在单位时间内多个任务同时在执行 。<br>在多线程编程实践中，线程的个数往往多于 CPU 的个数，所以一般都称多线程并发编程而不是多线程并行编程。</p><p>多线程的作用要分着看：</p><ul><li>单核 CPU：多线程的调用实际上是一种高速切换，并不是真正的并发。</li><li>多核 CPU：多个线程真正的共同完成一个进程的多个工作。</li></ul><p>这样理解比较晦涩，举个例子：</p><p>一个程序员一天的工作：看文档 发邮件 摸鱼 写代码 ，正常来说这几件事不可能顺序执行，我们通常都是开会文档摸会鱼，写会代码摸会鱼。</p><p>单核 CPU 处理多线程的调度也是一样，只是看上去让你认为它在同时执行多个任务，实际上只是<strong>串行</strong>执行。</p><p>多核 CPU 处理多线程的调度，就像多个程序员协同工作，有的在看文档，有的在写代码，有的在摸鱼。这时候哪怕有人啥事不干，也比一个人工作效率高。</p><p>那单核 CPU 下还有多线程的必要吗？有的，比如我们写代码时遇到了问题，暂时解决不了，我们不至于停在那儿，可以先去看看文档，找找解决方法。 单核 CPU 下多线程也是如此，有一个任务被堵塞住了，我们可以先执行其他任务。</p><p>所以多核 CPU 下的多线程调度才是真正的并行，也是多线程开发的真正目的。</p><h1 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h1><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B_2020-03-19-17-36-41.png" alt="JAVA并发——线程_2020-03-19-17-36-41.png"></p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B_2020-03-19-17-38-13.png" alt="JAVA并发——线程_2020-03-19-17-38-13.png"></p><ol><li><p>初始化状态：新建一个线程对象</p></li><li><p>可运行状态：其他线程调用了该线程对象的 start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取 CPU 的使用权</p></li><li><p>运行状态：可运行状态的线程获得了 cpu 时间片（timeslice），执行程序代码</p></li><li><p>阻塞状态：线程因为某种原因放弃 CPU 使用权，暂时停止运行。直到线程再次进入可运行状态，才有机会转到运行状态。如图所示，会有三种不同类型的阻塞状态：</p><ul><li>等待阻塞：运行中的线程执行 wait()方法，线程会进入等待队列中。等待 notify()、notifyAll()或 interrupt()对其唤醒或中断</li><li>同步阻塞：运行中的线程执行在获取同步锁（注：只有 synchronized 这种方式的锁（monitor 锁）才会让线程出现 BLOCKED 状态，等待 ReentrantLock 则不会）时，若该锁已被其他线程占用，线程则会进入锁池队列。等待获取到锁</li><li>其他阻塞：运行的线程执行 sleep()、join()，或触发了 I/O 请求，该该线程被置为阻塞状态。当 sleep()状态超时、join()等待线程终止或超时、I/O 处理完成，线程会重新进入可运行状态。</li></ul></li><li><p>死亡状态：线程执行完或因异常退出 run()方法，线程生命周期结束</p></li></ol><h1 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h1><ol><li><p><code>Thread.sleep(long millis)</code> 静态方法。当前线程调用此方法，使当前线程进入阻塞状态（其他阻塞），但不释放任何锁资源，一定时间后线程自动进入 runnable 状态。给其它线程执行机会的最佳方式。</p></li><li><p><code>obj.wait()</code> 或 <code>obj.wait(long timeout)</code> 当前线程调用某对象的 wait()方法，当前线程释放对象锁（wait 一定在 synchronized 代码块/方法中，故一定得到了锁，才进来的此方法），进入阻塞状态（等待队列）。等待 notify 或 wait 设置的 timeout 到期，方可进入另外一个阻塞状态（锁池）。</p></li><li><p><code>t.join()</code> 或 <code>t.join(long millis)</code> 非静态方法。当前线程 A 执行过程中，调用 B 线程的 join 方法，使当前线程进入阻塞状态（其他阻塞），但不释放对象锁，等待 B 线程执行完后或一定时间 millis 后，A 线程进入 runnable 状态。</p></li><li><p><code>Thread.yield()</code> 静态方法。当前线程调用此方法，使线程由 running 态进入 runnable 态，放弃 cpu 使用权，让 cpu 再次选择要执行的线程。 注：实际过程中，yield 仅仅是让其它具有同等优先级的 runnable 线程获取执行权，但并不能保证其它具有同等优先级的线程就一定能获得 cpu 执行权。因为做出让步的当前线程，可能会被 cpu 再次选中，进入 running 状态。yield()不会导致阻塞。</p></li></ol><h1 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h1><h2 id="继承-Thread"><a href="#继承-Thread" class="headerlink" title="继承 Thread"></a>继承 Thread</h2><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B_2020-03-19-17-42-47.png" alt="JAVA并发——线程_2020-03-19-17-42-47.png"></p><p>在这里我们思考一下为什么不直接调用 <code>run（）</code>方法而是去调用 <code>start（）</code>方法？</p><p>线程的 <code>run()</code>方法是由 java 虚拟机直接调用的</p><p>如果我们没有启动线程（没有调用线程的 <code>start()</code>方法）而是在应用代码中直接调用 <code>run()</code>方法，那么这个线程的 <code>run()</code>方法其实运行在当前线程（即 <code>run()</code>方法的调用方所在的线程）之中，而不是运行在其自身的线程中。</p><p>所以就是先访问 start 创建线程 jvm 去调用 <code>run（）</code>方法！</p><p>这种方式的弊端是一个类只能继承一个父类，如果这个类本身已经继承了其它类，就不能使用这种方式了。</p><h2 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h2><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B_2020-03-19-17-48-06.png" alt="JAVA并发——线程_2020-03-19-17-48-06.png"></p><p>实现 Runnable 接口，这种方式的好处是一个类可以实现多个接口，不影响其继承体系。</p><h2 id="实现-Callabe-接口"><a href="#实现-Callabe-接口" class="headerlink" title="实现 Callabe 接口"></a>实现 Callabe 接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatingThread04</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"> System.out.println(Thread.currentThread().getId() + <span class="string">" is running"</span>);</span><br><span class="line"> <span class="keyword">return</span> Thread.currentThread().getId();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"> FutureTask&lt;Long&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> CreatingThread04());</span><br><span class="line"> <span class="keyword">new</span> Thread(task).start();</span><br><span class="line"> System.out.println(<span class="string">"等待完成任务"</span>);</span><br><span class="line"> Long result = task.get();</span><br><span class="line"> System.out.println(<span class="string">"任务结果："</span> + result);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FutureTask 可用于异步获取执行结果或取消执行任务的场景。通过传入 Runnable 或者 Callable 的任务给 FutureTask，直接调用其 run 方法或者放入线程池执行，之后可以在外部通过 FutureTask 的 get 方法异步获取执行结果，因此，FutureTask 非常适合用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。</p><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatingThread05</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line"> <span class="comment">// 每隔1秒执行一次</span></span><br><span class="line">        timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> System.out.println(Thread.currentThread().getName() + <span class="string">" is running"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;, <span class="number">0</span> , <span class="number">1000</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用定时器 java.util.Timer 可以快速地实现定时任务，TimerTask 实际上实现了 Runnable 接口。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上文我们讲到了创建线程的几种方法，其中最常见的是继承 Thread 类与实现 Runable 接口，其实 Thread 类的源码也是实现 Runnbale，所以 Runnale 是基础的作业。</p><p>相比 Thread,使用 Runnale 创建线程，由以下好处：</p><ul><li>java 不允许多继承，因此实现了 Runnable 接口的类可以再继承其他类。</li><li>松耦合，将真正处理线程的操作交给一个个 Thread 对象操作。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java并发 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA并发——死锁</title>
      <link href="/2020/03/19/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E6%AD%BB%E9%94%81/"/>
      <url>/2020/03/19/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E6%AD%BB%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>在许多应用中进程需要以<strong>独占</strong>的方式访问资源，当操作系统允许多个进程并发执行时可能会出现进程永远被阻塞现象，如两个进程分别等待对方所占的资源，于是两者都不能执行而处于永远等待状态，此现象称为<strong>死锁</strong>。</p><blockquote><p>死锁通常被定义为：如果一个进程集合中的每个进程都在等待只能由此集合中的其他进程才能引发的事件，而无限期陷入僵持的局面称为死锁。</p></blockquote><h1 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h1><ol><li><p>互斥条件</p><p>临界资源是独占资源，进程应互斥且排他的使用这些资源。</p></li><li><p>占有和等待条件</p><p>进程在请求资源得不到满足而等待时，不释放已占有资源。</p></li><li><p>不剥夺条件</p><p>又称不可抢占，已获资源只能由进程自愿释放，不允许被其他进程剥夺。</p></li><li><p>循环等待条件</p><p>又称环路条件，存在循环等待链，其中，每个进程都在等待链中等待下一个进程所持有的资源，造成这组进程处于永远等待状态。</p></li></ol><h1 id="死锁产生的原因"><a href="#死锁产生的原因" class="headerlink" title="死锁产生的原因"></a>死锁产生的原因</h1><p>死锁产生的原因有很多，如：</p><ul><li>进程顺序不当</li><li>PV 操作使用不妥</li><li>同类资源分配不均</li><li>对某些资源的使用未加限制</li></ul><p>看的云里雾里，从开发角度上讲，可以概括成以下三句话：</p><ul><li>当前线程拥有其他线程需要的资源</li><li>当前线程等待其他线程已拥有的资源</li><li>都不放弃自己拥有的资源</li></ul><h1 id="死锁又有哪几种？"><a href="#死锁又有哪几种？" class="headerlink" title="死锁又有哪几种？"></a>死锁又有哪几种？</h1><h2 id="锁顺序死锁"><a href="#锁顺序死锁" class="headerlink" title="锁顺序死锁"></a>锁顺序死锁</h2><p>最简单最常见的死锁：</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E6%AD%BB%E9%94%81_2020-03-19-16-22-13.png" alt="JAVA并发——死锁_2020-03-19-16-22-13.png"></p><ul><li>线程 A 调用 leftRight()方法，得到 left 锁</li><li>同时线程 B 调用 rightLeft()方法，得到 right 锁</li><li>线程 A 和线程 B 都继续执行，此时线程 A 需要 right 锁才能继续往下执行。此时线程 B 需要 left 锁才能继续往下执行。</li><li>但是：线程 A 的 left 锁并没有释放，线程 B 的 right 锁也没有释放。</li><li>所以他们都只能等待，而这种等待是无期限的–&gt;永久等待–&gt;死锁</li></ul><h2 id="动态锁顺序死锁"><a href="#动态锁顺序死锁" class="headerlink" title="动态锁顺序死锁"></a>动态锁顺序死锁</h2><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E6%AD%BB%E9%94%81_2020-03-19-16-25-07.png" alt="JAVA并发——死锁_2020-03-19-16-25-07.png"></p><p>上面的代码看起来是没有问题的：锁定两个账户来判断余额是否充足才进行转账！</p><p>但是，同样有可能会发生死锁：</p><ul><li>如果两个线程同时调用 transferMoney()</li><li>线程 A 从 X 账户向 Y 账户转账</li><li>线程 B 从账户 Y 向账户 X 转账</li><li>那么就会发生死锁。</li></ul><h2 id="协作对象之间发生死锁"><a href="#协作对象之间发生死锁" class="headerlink" title="协作对象之间发生死锁"></a>协作对象之间发生死锁</h2><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E6%AD%BB%E9%94%81_2020-03-19-16-26-40.png" alt="JAVA并发——死锁_2020-03-19-16-26-40.png"></p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E6%AD%BB%E9%94%81_2020-03-19-16-26-53.png" alt="JAVA并发——死锁_2020-03-19-16-26-53.png"></p><p>上面的 <code>getImage()</code> 和 <code>setLocation(Point location)</code> 都需要获取两个锁的</p><p>并且在操作途中是没有释放锁的<br>这就是隐式获取两个锁(对象之间协作)..</p><p>这种方式也很容易就造成死锁…..</p><h1 id="死锁解决的方法"><a href="#死锁解决的方法" class="headerlink" title="死锁解决的方法"></a>死锁解决的方法</h1><p>主要有一下三种方法：</p><ul><li>固定加锁的顺序(针对锁顺序死锁)</li><li>开放调用(针对对象之间协作造成的死锁)</li><li>使用定时锁–&gt;tryLock()</li><li>如果等待获取锁时间超时，则抛出异常而不是一直等待！</li></ul><h2 id="固定加锁顺序"><a href="#固定加锁顺序" class="headerlink" title="固定加锁顺序"></a>固定加锁顺序</h2><p>如果所有线程以固定的顺序来获得锁，那么程序中就不会出现锁顺序死锁问题！</p><p>针对两个特定的锁，开发者可以尝试按照锁对象的 <code>hashCode</code> 值大小的顺序，分别获得两个锁，这样锁总是会以特定的顺序获得锁，那么死锁也不会发生。问题变得更加复杂一些，如果此时有多个线程，都在竞争不同的锁，简单按照锁对象的 <code>hashCode</code> 进行排序（单纯按照 <code>hashCode</code> 顺序排序会出现“环路等待”），可能就无法满足要求了，这个时候开发者可以使用银行家算法，所有的锁都按照特定的顺序获取，同样可以防止死锁的发生。</p><p>银行家算法：首先需要定义状态和安全状态的概念。系统的状态是当前给进程分配的资源情况。因此，状态包含两个向量 Resource（系统中每种资源的总量）和 Available（未分配给进程的每种资源的总量）及两个矩阵 Claim（表示进程对资源的需求）和 Allocation（表示当前分配给进程的资源）。安全状态是指至少有一个资源分配序列不会导致死锁。当进程请求一组资源时，假设同意该请求，从而改变了系统的状态，然后确定其结果是否还处于安全状态。如果是，同意这个请求；如果不是，阻塞该进程知道同意该请求后系统状态仍然是安全的。</p><p>那么上面的例子我们就可以改造成这样子：</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E6%AD%BB%E9%94%81_2020-03-19-16-31-10.png" alt="JAVA并发——死锁_2020-03-19-16-31-10.png"></p><h2 id="开发调用"><a href="#开发调用" class="headerlink" title="开发调用"></a>开发调用</h2><p>在协作对象之间发生死锁的例子中，主要是因为在调用某个方法时就需要持有锁，并且在方法内部也调用了其他带锁的方法！</p><p>如果在调用某个方法时不需要持有锁，那么这种调用被称为开放调用！</p><p>同步代码块最好仅被用于保护那些涉及共享状态的操作！</p><h2 id="使用定时锁-超时放弃"><a href="#使用定时锁-超时放弃" class="headerlink" title="使用定时锁(超时放弃)"></a>使用定时锁(超时放弃)</h2><p>当使用 synchronized 关键词提供的内置锁时，只要线程没有获得锁，那么就会永远等待下去，然而 Lock 接口提供了 boolean tryLock(long time, TimeUnit unit) throws InterruptedException 方法，该方法可以按照固定时长等待锁，因此线程可以在获取锁超时以后，主动释放之前已经获得的所有的锁。通过这种方式，也可以很有效地避免死锁。</p><h1 id="死锁监测"><a href="#死锁监测" class="headerlink" title="死锁监测"></a>死锁监测</h1><p>Jstack 是 JDK 自带的命令行工具，主要用于线程 Dump 分析。</p><p>1.我们先用 Jps 来查看 java 进程 id(或者 Linux 的 ps 命令)</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E6%AD%BB%E9%94%81_2020-03-19-16-41-53.png" alt="JAVA并发——死锁_2020-03-19-16-41-53.png"></p><p>2.看一下 jstack 的使用</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E6%AD%BB%E9%94%81_2020-03-19-16-42-15.png" alt="JAVA并发——死锁_2020-03-19-16-42-15.png"></p><p>3.jstack 输出线程 dump 信息到文件</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E6%AD%BB%E9%94%81_2020-03-19-16-42-54.png" alt="JAVA并发——死锁_2020-03-19-16-42-54.png"></p><p>4.查看 dump 文件，然后进行分析</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E6%AD%BB%E9%94%81_2020-03-19-16-43-18.png" alt="JAVA并发——死锁_2020-03-19-16-43-18.png"></p><p>其中有一行是 at DeadThread.run（DeadThread.java:37），说明 Thread-1 实在 DeadThread 类的 37 行处发生死锁，其中 at DeadThread.run(DeadThread.java:21)，说明 Thread-0 是在 DeadThread 类的 21 行处发生死锁。详细的 jstack dump 文件分析请参看：<a href="http://www.cnblogs.com/flyingeagle/articles/6853454.html" target="_blank" rel="noopener">http://www.cnblogs.com/flyingeagle/articles/6853454.html</a></p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E6%AD%BB%E9%94%81_2020-03-19-16-43-58.png" alt="JAVA并发——死锁_2020-03-19-16-43-58.png"></p><p>从而定位到死锁发生的原因，及具体位置：Thread-0 获得了锁 lock1，接下来期望获得锁 lock2，（第 20 行），但是此时 Thread-1 获得了锁 lock2，接下来期望获得锁 lock2,（第 37 行），因而发生了死锁。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>发生死锁的原因主要由于：</p><ul><li>线程之间交错执行<ul><li>解决：以固定的顺序加锁</li></ul></li></ul><ul><li>执行某方法时就需要持有锁，且不释放<ul><li>解决：缩减同步代码块范围，最好仅操作共享变量时才加锁</li></ul></li></ul><ul><li>永久等待<ul><li>解决：使用 tryLock()定时锁，超过时限则返回错误信息</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java并发 线程安全 死锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA并发——ReetrantLock</title>
      <link href="/2020/03/16/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94ReetrantLock/"/>
      <url>/2020/03/16/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94ReetrantLock/</url>
      
        <content type="html"><![CDATA[<h1 id="Lock-接口"><a href="#Lock-接口" class="headerlink" title="Lock 接口"></a>Lock 接口</h1><h2 id="显示锁"><a href="#显示锁" class="headerlink" title="显示锁"></a>显示锁</h2><p>synchronized 属于隐式锁，即锁的持有与释放都是隐式的，我们无需干预，而本篇我们要讲解的是显式锁，即锁的持有和释放都必须由我们手动编写。</p><h2 id="锁方法"><a href="#锁方法" class="headerlink" title="锁方法"></a>锁方法</h2><p>在 Java 1.5 中，官方在 concurrent 并发包中加入了 Lock 接口，该接口中提供了 lock()方法和 unLock()方法对显式加锁和显式释放锁操作进行支持，简单了解一下代码编写，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//临界区......</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前线程使用 lock()方法与 unlock()对临界区进行包围，其他线程由于无法持有锁将无法进入临界区直到当前线程释放锁，注意 unlock()操作必须在 finally 代码块中，这样可以确保即使临界区执行抛出异常，线程最终也能正常释放锁，Lock 接口还提供了锁以下相关方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可中断获取锁，与lock()不同之处在于可响应中断操作，即在获</span></span><br><span class="line">    <span class="comment">//取锁的过程中可中断，注意synchronized在获取锁时是不可中断的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试非阻塞获取锁，调用该方法后立即返回结果，如果能够获取则返回true，否则返回false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据传入的时间段获取锁，在指定时间内没有获取锁则返回false，如果在指定时间内当前线程未被中并断获取到锁则返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取等待通知组件，该组件与当前锁绑定，当前线程只有获得了锁</span></span><br><span class="line">    <span class="comment">//才能调用该组件的wait()方法，而调用后，当前线程将释放锁。</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>可见 Lock 对象锁还提供了 synchronized 所不具备的其他同步特性：</p><ul><li>如可中断锁的获取</li><li>超时中断锁的获取</li><li>等待唤醒机制的多条件变量 Condition 等</li></ul><p>这也使得 Lock 锁在使用上具有更大的灵活性。</p><h1 id="ReetrantLook"><a href="#ReetrantLook" class="headerlink" title="ReetrantLook"></a>ReetrantLook</h1><p>JDK 1.5 新增的类，实现了 Lock 接口，作用与 synchronized 关键字相当，但比 synchronized 更加灵活。</p><h2 id="可重入锁、公平锁和非公平锁"><a href="#可重入锁、公平锁和非公平锁" class="headerlink" title="可重入锁、公平锁和非公平锁"></a>可重入锁、公平锁和非公平锁</h2><p>ReetrantLock 本身也是一种支持重进入的锁，即该锁可以支持一个线程对资源重复加锁，同时也支持公平锁与非公平锁。</p><p>所谓的公平与非公平指的是在请求先后顺序上，先对锁进行请求的就一定先获取到锁，那么这就是公平锁，反之，如果对于锁的获取并没有时间上的先后顺序，如后请求的线程可能先获取到锁，这就是非公平锁</p><p><strong>注意 ReetrantLock 支持对同一线程重加锁，但是加锁多少次，就必须解锁多少次，这样才可以成功释放锁。</strong></p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReenterLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10000000</span>;j++)&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">//支持重入锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                <span class="comment">//执行两次解锁</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ReenterLock tl=<span class="keyword">new</span> ReenterLock();</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(tl);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(tl);</span><br><span class="line">        t1.start();t2.start();</span><br><span class="line">        t1.join();t2.join();</span><br><span class="line">        <span class="comment">//输出结果：20000000</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码非常简单，我们使用两个线程同时操作临界资源 i，执行自增操作，使用 ReenterLock 进行加锁，解决线程安全问题，这里进行了两次重复加锁，由于 ReenterLock 支持重入，因此这样是没有问题的，需要注意的是在 finally 代码块中，需执行两次解锁操作才能真正成功地让当前执行线程释放锁。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询当前线程保持此锁的次数。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//返回目前拥有此锁的线程，如果此锁不被任何线程拥有，则返回 null。</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span>  Thread   <span class="title">getOwner</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个 collection，它包含可能正等待获取此锁的线程，其内部维持一个队列，这点稍后会分析。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span>  Collection&lt;Thread&gt;   <span class="title">getQueuedThreads</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回正等待获取此锁的线程估计数。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getQueueLength</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个 collection，它包含可能正在等待与此锁相关给定条件的那些线程。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span>  Collection&lt;Thread&gt;   <span class="title">getWaitingThreads</span><span class="params">(Condition condition)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回等待与此锁相关的给定条件的线程估计数。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getWaitQueueLength</span><span class="params">(Condition condition)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询给定线程是否正在等待获取此锁。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasQueuedThread</span><span class="params">(Thread thread)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询是否有些线程正在等待获取此锁。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询是否有些线程正在等待与此锁有关的给定条件。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasWaiters</span><span class="params">(Condition condition)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果此锁的公平设置为 true，则返回 true。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isFair</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//查询当前线程是否保持此锁。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isHeldByCurrentThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//查询此锁是否由任意线程保持。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h2 id="并发基础组件-AQS"><a href="#并发基础组件-AQS" class="headerlink" title="并发基础组件 AQS"></a>并发基础组件 AQS</h2><h3 id="队列同步器"><a href="#队列同步器" class="headerlink" title="队列同步器"></a>队列同步器</h3><p>首先介绍两个类：</p><ul><li><p><code>AbstractOwnableSynchronizer</code>：抽象类，定义了存储独占当前锁的线程和获取的方法</p></li><li><p><code>AbstractQueuedSynchronizer</code>：抽象类，AQS 框架核心类，其内部以虚拟队列的方式管理线程的锁获取与锁释放，其中获取锁(tryAcquire 方法)和释放锁(tryRelease 方法)并没有提供默认实现，需要子类重写这两个方法实现具体逻辑，目的是使开发人员可以自由定义获取锁以及释放锁的方式。</p></li></ul><p>AbstractQueuedSynchronizer 又称为队列同步器(后面简称 AQS)，我们来看看它的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AQS抽象类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span>&#123;</span><br><span class="line"><span class="comment">//指向同步队列队头</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指向同步的队尾</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步状态，0代表锁未被占用，1代表锁已被占用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略其他代码......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractQueuedSynchronizer 内部通过 states 来控制同步状态，当 <code>state=0</code> 时，则说明没有任何线程占有共享资源的锁，当 <code>state=1</code> 时，则说明有线程目前正在使用共享变量，其他线程必须加入同步队列进行等待。</p><p>AQS 内部通过内部类 Node 构成双向链表完成 FIFO 的同步队列，同时利用内部类 ConditionObject 构建等待队列。</p><p>当 Condition 调用 <code>wait()</code> 方法后，线程将会加入等待队列中，而当 Condition 调用 <code>signal()</code> 方法后，线程将从等待队列转移动同步队列中进行锁竞争。</p><p>同步模型如下：</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94ReetrantLock_2020-03-17-17-13-50.png" alt="JAVA并发——ReetrantLock_2020-03-17-17-13-50.png"></p><h3 id="Node-节点"><a href="#Node-节点" class="headerlink" title="Node 节点"></a>Node 节点</h3><p>Node 是 AQS 的内部类，其数据结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">//共享模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">//独占模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标识线程已处于结束状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//等待被唤醒状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//条件状态，</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//在共享模式中使用表示获得的同步状态会被传播</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待状态,存在CANCELLED、SIGNAL、CONDITION、PROPAGATE 4种</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同步队列中前驱结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同步队列中后继结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求锁的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待队列中的后继结点，这个与Condition有关，稍后会分析</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否为共享模式</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取前驱结点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包含了需要 同步的线程本身 以及 线程的状态，如是否被阻塞，是否等待唤醒，是否已经被取消等。每个 Node 结点内部关联其前继结点 prev 和后继结点 next，这样可以方便线程释放锁后快速唤醒下一个在等待的线程。</p><p>SHARED 和 EXCLUSIVE 常量分别代表<strong>共享模式和独占模式</strong>，</p><ul><li>共享模式是一个锁允许多条线程同时操作，如信号量 Semaphore</li><li>独占模式则是同一个时间段只能有一个线程对共享资源进行操作，多余的请求线程需要排队等待，如 ReentranLock。</li></ul><p>变量 waitStatus 则表示当前被封装成 Node 结点的等待状态，共有 4 种取值 CANCELLED、SIGNAL、CONDITION、PROPAGATE。</p><ul><li><code>CANCELLED</code>：值为 1，在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该 Node 的结点，其结点的 waitStatus 为 CANCELLED，即结束状态，进入该状态后的结点将不会再变化。</li><li><code>SIGNAL</code>：值为-1，被标识为该等待唤醒状态的后继结点，当其前继结点的线程释放了同步锁或被取消，将会通知该后继结点的线程执行。说白了，就是处于唤醒状态，只要前继结点释放锁，就会通知标识为 SIGNAL 状态的后继结点的线程执行。</li><li><code>CONDITION</code>：值为-2，与 Condition 相关，该标识的结点处于等待队列中，结点的线程等待在 Condition 上，当其他线程调用了 Condition 的 signal()方法后，CONDITION 状态的结点将从等待队列转移到同步队列中，等待获取同步锁。</li><li><code>PROPAGATE</code>：值为-3，与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态。</li><li><code>0状态</code>：值为 0，代表初始化状态。</li></ul><h2 id="基于-ReetrantLock-分析-AQS-独占模式实现过程"><a href="#基于-ReetrantLock-分析-AQS-独占模式实现过程" class="headerlink" title="基于 ReetrantLock 分析 AQS 独占模式实现过程"></a>基于 ReetrantLock 分析 AQS 独占模式实现过程</h2><p>ReentrantLock 内部存在 3 个实现类，分别是 <code>Sync</code>、 <code>NonfairSync</code>、 <code>FairSync</code>，其中 <code>Sync</code> 继承自 AQS 实现了解锁 <code>tryRelease()</code> 方法，而 <code>NonfairSync</code>(非公平锁)、 <code>FairSync</code>(公平锁)则继承自 Sync，实现了获取锁的 <code>tryAcquire()</code> 方法，ReentrantLock 的所有方法调用都通过间接调用 AQS 和 Sync 类及其子类来完成的。</p><h3 id="ReetrantLock-中非公平锁"><a href="#ReetrantLock-中非公平锁" class="headerlink" title="ReetrantLock 中非公平锁"></a>ReetrantLock 中非公平锁</h3><p>非公平锁的创建如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认构造，创建非公平锁NonfairSync</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据传入参数创建锁类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加锁操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面说过 sync 是个抽象类，存在两个不同的实现子类，这里从非公平锁入手，看看其实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非公平锁实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//执行CAS操作，获取同步状态</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">       <span class="comment">//成功则将独占锁线程设置为当前线程</span></span><br><span class="line">          setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//否则再次请求同步状态</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，通过 CAS 机制保证并发的情况下只有一个线程可以成功将 state 设置为 1，获取到锁；</p><p>此时，其它线程在执行 compareAndSetState 时，因为 state 此时不是 0，所以会失败并返回 false，执行 <code>acquire(1)</code>;</p><p>再次请求同步：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//再次尝试获取同步状态</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里传入参数 arg 是 state 的值，因为要获取锁，所以这里一般传递参数为 1，进入方法后首先会执行 <code>tryAcquire(1)</code> 方法，在前面分析过该方法在 AQS 中并没有具体实现，而是交由子类实现，因此该方法是由 ReetrantLock 类内部类实现的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NonfairSync类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94ReetrantLock_2020-03-17-17-41-52.png" alt="JAVA并发——ReetrantLock_2020-03-17-17-41-52.png"></p><p>假设有三个线程：线程 1 已经获得到了锁，线程 2 正在同步队列中排队，此时线程 3 执行 lock 方法尝试获取锁的时，线程 1 正好释放了锁，将 state 更新为 0，那么线程 3 就可能在线程 2 还没有被唤醒之前去获取到这个锁。</p><p>如果此时还没有获取到锁（nonfairTryAcquire 返回 false），那么接下来会把该线程封装成 node 去同步队列里排队，代码层面上执行的是 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</p><p>ReetrantLock 为独占锁，所以传入的参数为 Node.EXCLUSIVE</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将请求同步状态失败的线程封装成结点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line"></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">//如果是第一个结点加入肯定为空，跳过。</span></span><br><span class="line">    <span class="comment">//如果非第一个结点则直接执行CAS入队操作，尝试在尾部快速添加</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">//使用CAS执行尾部结点替换，尝试在尾部快速添加</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果第一次加入或者CAS操作没有成功执行enq入队操作</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自旋"><a href="#自旋" class="headerlink" title="自旋"></a>自旋</h3><p>同步队列中的结点会进入一个自旋过程，自旋的意思就是原地转圈圈：即结点都在观察时机准备获取同步状态,自旋过程是在 acquireQueued(addWaiter(Node.EXCLUSIVE), arg))方法中执行的，先看前半部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//自旋，死循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取前结点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            当且仅当p为头结点才尝试获取同步状态,FIFO</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">//此时当前node前驱节点为head且已经tryAcquire获取到了锁，正在执行了它的相关信息</span></span><br><span class="line">                <span class="comment">//已经没有任何用处了，所以现在需要考虑将它GC掉</span></span><br><span class="line">                <span class="comment">//将node设置为头结点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">//清空原来头结点的引用便于GC</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果前驱结点不是head，判断是否挂起线程</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            <span class="comment">//最终都没能获取同步状态，结束该线程的请求</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置为头结点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        head = node;</span><br><span class="line">        <span class="comment">//清空结点数据以便于GC</span></span><br><span class="line">        node.thread = <span class="keyword">null</span>;</span><br><span class="line">        node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然如果前驱结点不是 head 而它又没有获取到锁，那么执行如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果前驱结点不是head，判断是否挂起线程</span></span><br><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;parkAndCheckInterrupt())</span><br><span class="line"></span><br><span class="line">      interrupted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前结点的等待状态</span></span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">        <span class="comment">//如果为等待唤醒（SIGNAL）状态则返回true</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//如果ws&gt;0 则说明是结束状态，</span></span><br><span class="line">        <span class="comment">//遍历前驱结点直到找到没有结束状态的结点</span></span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果ws小于0又不是SIGNAL状态，</span></span><br><span class="line">            <span class="comment">//则将其设置为SIGNAL状态，代表该结点的线程正在等待唤醒。</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将当前线程挂起,线程会阻塞住</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//获取线程中断状态,interrupted()是判断当前中断状态，</span></span><br><span class="line">        <span class="comment">//并非中断线程，因此可能true也可能false,并返回</span></span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常我们在设计队列时，我们需要考虑如何最大化的减少后续排队节点对于 CPU 的消耗，而在 AQS 中，只要当前节点的前驱节点不是头结点，再把当前节点加到队列后就会执行 LockSupport.park(this);将当前线程挂起，这样可以最大程度减少 CPU 消耗。</p><p>AQS 通过最简单的 CAS 和 LockSupport 的 park，设计出了高效的队列模型和机制：</p><ol><li><p>AQS 结构其实是在第二个线程获取锁的时候再初始化的，就是 lazy-Init 的思想，最大程度减少不必要的代码执行的开销</p></li><li><p>为了最大程度上提升效率，尽量避免线程间的通讯，采用了双向链表的 Node 结构去存储线程</p></li><li><p>为了最大程度上避免 CPU 上下文切换执行的消耗，在设计排队线程时，只有头结点的下一个的线程在一直重复执行获取锁，队列后面的线程会通过 LockSupport 进行休眠。</p></li></ol><p>非公平锁的释放：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReentrantLock类的unlock</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AQS类的release()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//尝试释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//唤醒后继结点的线程</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ReentrantLock类中的内部类Sync实现的tryRelease(int releases)</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">      <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">      <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">//判断状态是否为0，如果是则说明已释放同步状态</span></span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">          free = <span class="keyword">true</span>;</span><br><span class="line">          <span class="comment">//设置Owner为null</span></span><br><span class="line">          setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//设置更新同步状态</span></span><br><span class="line">      setState(c);</span><br><span class="line">      <span class="keyword">return</span> free;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>一句话总结：释放锁首先就是把 volatile 类型的变量 state 减 1。state 从 1 变成 0.</p><p>unparkSuccessor(h)的作用的唤醒后续的节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里，node是head节点。</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)<span class="comment">//置零当前线程所在的结点状态，允许失败。</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Node s = node.next;<span class="comment">//找到下一个需要唤醒的结点s</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;<span class="comment">//如果为空或已取消</span></span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)<span class="comment">//从这里可以看出，&lt;=0的结点，都是还有效的结点。</span></span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);<span class="comment">//唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码执行操作来看，这里主要作用是用 unpark()唤醒同步队列中最前边未放弃线程(也就是状态为 CANCELLED 的线程结点 s)。</p><h2 id="ReetrantLock-中的公平锁"><a href="#ReetrantLock-中的公平锁" class="headerlink" title="ReetrantLock 中的公平锁"></a>ReetrantLock 中的公平锁</h2><p>下面比较一下公平锁和非公平锁 lock 方法：</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94ReetrantLock_2020-03-17-18-06-01.png" alt="JAVA并发——ReetrantLock_2020-03-17-18-06-01.png"></p><p>再比较一下公平锁和非公平锁 lock 方法：tryAcquire 方法：</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94ReetrantLock_2020-03-17-18-07-03.png" alt="JAVA并发——ReetrantLock_2020-03-17-18-07-03.png"></p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94ReetrantLock_2020-03-17-18-07-15.png" alt="JAVA并发——ReetrantLock_2020-03-17-18-07-15.png"></p><p>唯一的差别就是 hasQueuedPredecessors()判断同步队列是否存在结点，这就是非公平锁与公平锁最大的区别，即公平锁在线程请求到来时先会判断同步队列是否存在结点，如果存在先执行同步队列中的结点线程，当前线程将封装成 node 加入同步队列等待。</p><p>而非公平锁呢，当线程请求到来时，不管同步队列是否存在线程结点，直接上去尝试获取同步状态，获取成功直接访问共享资源。</p><p>请注意在绝大多数情况下，非公平锁才是我们理想的选择，毕竟从效率上来说非公平锁总是胜于公平锁。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>重入锁 ReentrantLock，是一个基于 AQS 并发框架的并发控制类，其内部实现了 3 个类，分别是 Sync、NoFairSync 以及 FairSync 类，其中 Sync 继承自 AQS，实现了释放锁的模板方法 tryRelease(int)，而 NoFairSync 和 FairSync 都继承自 Sync，实现各种获取锁的方法 tryAcquire(int)。</p><p>ReentrantLock 的所有方法实现几乎都间接调用了这 3 个类，因此当我们在使用 ReentrantLock 时，大部分使用都是在间接调用 AQS 同步器中的方法。</p><p>AQS 在设计时将性能优化到了极致，具体体现在同步队列的 park 和 unpark，初始化 AQS 时的懒加载，以及线程之间通过 Node 这样的数据结构从而避免线程间通讯造成的额外开销，这种由释放锁的线程主动唤醒后续线程的方式也是我们再实际过程中可以借鉴的。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java并发 线程安全 ReetrantLock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA并发——synchronized</title>
      <link href="/2020/03/16/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94synchronized/"/>
      <url>/2020/03/16/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94synchronized/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>synchronized 是 Java 中的一个关键字，它是一个重量级锁，用于保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块，同时也可以保证可见性，即一个线程的变化可以被其他线程所见。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>synchronized 关键字最主要有以下 3 种应用方式，下面分别介绍</p><h2 id="修饰示例方法"><a href="#修饰示例方法" class="headerlink" title="修饰示例方法"></a>修饰示例方法</h2><p>修饰实例方法即为为当前实例加锁。当一个线程正在访问一个对象的 synchronized 实例方法时，其他线程不能访问该对象的其他 synchronized 方法，因为一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他 synchronized 实例方法。</p><p>但是其他线程还是可以访问该实例对象的其他非 synchronized 方法。</p><h2 id="修饰静态方法"><a href="#修饰静态方法" class="headerlink" title="修饰静态方法"></a>修饰静态方法</h2><p>需要注意的是如果一个线程 A 调用一个实例对象的非 static synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的 class 对象，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。</p><h2 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h2><p>如 Synchronized（obj） 这里的 obj 可以为类中的一个属性、也可以是当前的对象，它的同步效果和修饰普通方法一样；Synchronized 方法 （obj.class）静态代码块它的同步效果和修饰静态方法类似。</p><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>被 synchronized 修饰的类或对象的所有操作都是原子的，因为在执行操作之前必须先获得类或对象的锁，直到执行完才能释放，这中间的过程无法被中断（除了已经废弃的 stop()方法），确保了同一时刻只有一个线程操作类和对象。</p><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>synchronized 对一个类或对象加锁时，一个线程如果要访问该类或对象必须先获得它的锁，而这个锁的状态对于其他任何线程都是可见的，并且在释放锁之前会将对变量的修改刷新到主存当中，保证资源变量的可见性。</p><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>synchronized 保证了每个时刻都只有一个线程访问同步代码块，也就确定了线程执行同步代码块是分先后顺序的，保证了有序性。</p><h2 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h2><p>synchronized 和 ReentrantLock 都是可重入锁。当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁。通俗一点讲就是说一个线程拥有了锁仍然还可以重复申请锁。</p><h1 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h1><h2 id="java-对象头"><a href="#java-对象头" class="headerlink" title="java 对象头"></a>java 对象头</h2><p>在 JVM 中，对象是分成三部分存在的：对象头、实例数据、对其填充。</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94synchronized_2020-03-16-21-22-59.png" alt="JAVA并发——synchronized_2020-03-16-21-22-59.png"></p><p>实例数据和对其填充与 synchronized 无关。</p><p>对象头是我们需要关注的重点，它是 synchronized 实现锁的基础，因为 synchronized 申请锁、上锁、释放锁都与对象头有关。</p><p>对象头主要结构是由 <code>Mark Word</code> 和 <code>Class Metadata Address</code>组成，其中 <code>Mark Word</code> 存储对象的 <code>hashCode</code>、锁信息或分代年龄或 GC 标志等信息, <code>Class Metadata Address</code> 是类型指针指向对象的类元数据，JVM 通过该指针确定该对象是哪个类的实例。</p><h2 id="锁状态"><a href="#锁状态" class="headerlink" title="锁状态"></a>锁状态</h2><p>JDK6 之前只有两个状态：无锁、有锁（重量级锁），而在 JDK6 之后对 synchronized 进行了优化，新增了两种状态，总共就是四个状态：<strong>无锁状态、偏向锁、轻量级锁、重量级锁。</strong></p><p>锁的类型和状态在对象头 <code>Mark Word</code> 中都有记录，在申请锁、锁升级等过程中 JVM 都需要读取对象的 <code>Mark Word</code> 数据。</p><h2 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h2><p>每一个锁都对应一个 monitor 对象，在 HotSpot 虚拟机中它是由 ObjectMonitor 实现的（C++实现）。</p><h3 id="ObjectMonitor-结构"><a href="#ObjectMonitor-结构" class="headerlink" title="ObjectMonitor 结构"></a>ObjectMonitor 结构</h3><p>每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如 monitor 可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = NULL;</span><br><span class="line">    _count        = <span class="number">0</span>;  <span class="comment">//锁计数器</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = NULL;</span><br><span class="line">    _owner        = NULL;</span><br><span class="line">    _WaitSet      = NULL; <span class="comment">//处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = NULL ;</span><br><span class="line">    _succ         = NULL ;</span><br><span class="line">    _cxq          = NULL ;</span><br><span class="line">    FreeNext      = NULL ;</span><br><span class="line">    _EntryList    = NULL ; <span class="comment">//处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里有几个比较重要的字段:</p><ol><li><p>_owner 指向持有 ObjectMonitor 对象的线程地址。</p></li><li><p>_WaitSet 存放调用 wait 方法，而进入等待状态的线程的队列。</p></li><li><p>_EntryList 这里是等待锁 block 状态的线程的队列。</p></li><li><p>_recursions 锁的重入次数。</p></li><li><p>_count 线程获取锁的次数。</p></li></ol><p>对象监视器会设置几种状态用来区分请求的线程：</p><ul><li>Contention List：所有请求锁的线程将被首先放置到该竞争队列</li><li>Entry List：Contention List 中那些有资格成为候选人的线程被移到 Entry List</li><li>Wait Set：那些调用 wait 方法被阻塞的线程被放置到 Wait Set</li><li>OnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为 OnDeck</li><li>Owner：获得锁的线程称为 Owner</li><li>!Owner：释放锁的线程</li></ul><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94synchronized_2020-03-16-22-00-59.png" alt="JAVA并发——synchronized_2020-03-16-22-00-59.png"></p><h3 id="上锁"><a href="#上锁" class="headerlink" title="上锁"></a>上锁</h3><ol><li>线程获取资源对象的锁，判断_owner 是否为空。这里操作是通过 CAS 操作：比较和交换（Conmpare And Swap），比较新值和旧值的不同，替换，这里会发生 ABA 问题，接下来文章会详细说明。</li><li>如果 _owner 为 null ，直接把其赋值，指向自己， _owner = self ,同时把重入次数 _recursions = 1， 获取锁成功。</li><li>如果 _self == cur 和当前线程一致，说明是重入了， _recursions++ 即可</li><li>线程进入对象资源，处理。 同时等待当前线程的释放信号，期间一致持有对象资源的锁。</li></ol><h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><ol><li><p>通过 ObjectMonitor::exit 退出</p></li><li><p>把线程插入到_EntryList 中 _recursions–</p></li><li><p>再次从 _EntryList 中取出线程</p></li><li><p>调用 unpark 退出</p></li></ol><h1 id="JVM-对-synchronized-的优化"><a href="#JVM-对-synchronized-的优化" class="headerlink" title="JVM 对 synchronized 的优化"></a>JVM 对 synchronized 的优化</h1><p>从最近几个 jdk 版本中可以看出，Java 的开发团队一直在对 synchronized 优化，其中最大的一次优化就是在 jdk6 的时候，新增了两个锁状态，通过锁消除、锁粗化、自旋锁等方法使用各种场景，给 synchronized 性能带来了很大的提升。</p><h2 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h2><p>上面讲到锁有四种状态，并且会因实际情况进行膨胀升级，其膨胀方向是：无锁——&gt;偏向锁——&gt;轻量级锁——&gt;重量级锁，并且膨胀方向不可逆。</p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>一句话总结它的作用：减少统一线程获取锁的代价。在大多数情况下，锁不存在多线程竞争，总是由同一线程多次获得，那么此时就是偏向锁。</p><p>核心思想：</p><p>如果一个线程获得了锁，那么锁就进入偏向模式，此时 Mark Word 的结构也就变为偏向锁结构，当该线程再次请求锁时，无需再做任何同步操作，即获取锁的过程只需要检查 Mark Word 的锁标记位为偏向锁以及当前线程 ID 等于 Mark Word 的 ThreadID 即可，这样就省去了大量有关锁申请的操作。</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>轻量级锁是由偏向锁升级而来，当存在第二个线程申请同一个锁对象时，偏向锁就会立即升级为轻量级锁。注意这里的第二个线程只是申请锁，不存在两个线程同时竞争锁，可以是一前一后地交替执行同步块。</p><h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>重量级锁是由轻量级锁升级而来，当同一时间有多个线程竞争锁时，锁就会被升级成重量级锁，此时其申请锁带来的开销也就变大。</p><h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>消除锁是虚拟机另外一种锁的优化，这种优化更彻底，在 JIT 编译时，对运行上下文进行扫描，去除不可能存在竞争的锁。</p><h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>锁粗化是虚拟机对另一种极端情况的优化处理，通过扩大锁的范围，避免反复加锁和释放锁。</p><h2 id="自旋锁与自适应自旋锁"><a href="#自旋锁与自适应自旋锁" class="headerlink" title="自旋锁与自适应自旋锁"></a>自旋锁与自适应自旋锁</h2><p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。</p><p>自旋锁：许多情况下，共享数据的锁定状态持续时间较短，切换线程不值得，通过让线程执行循环等待锁的释放，不让出 CPU。如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式。但是它也存在缺点：如果锁被其他线程长时间占用，一直不释放 CPU，会带来许多的性能开销。</p><p>自适应自旋锁：这种相当于是对上面自旋锁优化方式的进一步优化，它的自旋的次数不再固定，其自旋的次数由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定，这就解决了自旋锁带来的缺点。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>synchronized 本身并不是锁，只是一个 JVM 定义的关键字。</p><p>被 synchronized 修饰的对象都有一个对应的监视器对象，多个线程同时访问对象的一系列加锁、释放锁的操作，都是通过对监视器对象的变量进行操作实现的。</p><p>synchronized 经过优化，有一个从无锁到重量级的膨胀过程，效率更高。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java并发 线程安全 synchronized </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA并发——锁</title>
      <link href="/2020/03/16/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E9%94%81/"/>
      <url>/2020/03/16/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是锁？"><a href="#什么是锁？" class="headerlink" title="什么是锁？"></a>什么是锁？</h1><p>锁是在执行多线程时用于强行限制资源访问的同步机制，即用于在并发控制中保证对互斥要求的满足。</p><h1 id="java-锁分类"><a href="#java-锁分类" class="headerlink" title="java 锁分类"></a>java 锁分类</h1><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E9%94%81_2020-03-16-14-08-58.png" alt="JAVA并发——锁_2020-03-16-14-08-58.png"></p><ul><li>从线程是否需要对资源加锁可以分为 <code>悲观锁</code> 和 <code>乐观锁</code></li><li>从资源已被锁定，线程是否阻塞可以分为 <code>自旋锁</code></li><li>从多个线程并发访问资源，也就是 Synchronized 可以分为 <code>无锁</code>、<code>偏向锁</code>、 <code>轻量级锁</code> 和 <code>重量级锁</code></li><li>从锁的公平性进行区分，可以分为 <code>公平锁</code> 和 <code>非公平锁</code></li><li>从根据锁是否重复获取可以分为 <code>可重入锁</code> 和 <code>不可重入锁</code></li><li>从那个多个线程能否获取同一把锁分为 <code>共享锁</code> 和 <code>排他锁</code></li></ul><h1 id="线程是否需要对资源加锁"><a href="#线程是否需要对资源加锁" class="headerlink" title="线程是否需要对资源加锁"></a>线程是否需要对资源加锁</h1><p>Java 按照是否对资源加锁分为 <code>乐观锁</code> 和 <code>悲观锁</code>，乐观锁和悲观锁并不是一种真实存在的锁，而是一种设计思想，乐观锁和悲观锁对于理解 Java 多线程和数据库来说至关重要，下面就来探讨一下这两种实现方式的区别和优缺点。</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p><code>悲观锁</code> 是一种悲观思想，它总认为最坏的情况可能会出现，它认为数据很可能会被其他人所修改，所以悲观锁在持有数据的时候总会把 <code>资源</code> 或者 <code>数据</code> 锁住，这样其他线程想要请求这个资源的时候就会阻塞，直到等到悲观锁把资源释放为止。传统的关系型数据库里边就用到了很多这种锁机制，<strong>比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</strong> 悲观锁的实现往往依靠数据库本身的锁功能实现。</p><p>Java 中的 <code>Synchronized</code> 和 <code>ReentrantLock</code> 等独占锁(排他锁)也是一种悲观锁思想的实现，因为 Synchronzied 和 ReetrantLock 不管是否持有资源，它都会尝试去加锁，生怕自己心爱的宝贝被别人拿走。</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁的思想与悲观锁的思想相反，它总认为资源和数据不会被别人所修改，所以读取不会上锁，但是乐观锁在进行写入操作的时候会判断当前数据是否被修改过(具体如何判断我们下面再说)。乐观锁的实现方案一般来说有两种： <code>版本号机制</code> 和 <code>CAS实现</code> 。乐观锁多适用于多度的应用类型，这样可以提高吞吐量。</p><p>在 Java 中 <code>java.util.concurrent.atomic</code> 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。</p><h2 id="两种锁的使用场景"><a href="#两种锁的使用场景" class="headerlink" title="两种锁的使用场景"></a>两种锁的使用场景</h2><p>悲观锁不仅会对写操作加锁还会对读操作加锁，一个典型的悲观锁调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student where name=<span class="string">"cxuan"</span> <span class="keyword">for</span> update</span><br></pre></td></tr></table></figure><p>这条 sql 语句从 Student 表中选取 name = “cxuan” 的记录并对其加锁，那么其他写操作再这个事务提交之前都不会对这条数据进行操作，起到了独占和排他的作用。</p><p>悲观锁因为对读写都加锁，所以它的性能比较低，对于现在互联网提倡的三高(高性能、高可用、高并发)来说，悲观锁的实现用的越来越少了，但是一般多读的情况下还是需要使用悲观锁的，因为虽然加锁的性能比较低，但是也阻止了像乐观锁一样，遇到写不一致的情况下一直重试的时间。</p><p>相对而言，乐观锁用于读多写少的情况，即很少发生冲突的场景，这样可以省去锁的开销，增加系统的吞吐量。<br>乐观锁的适用场景有很多，典型的比如说成本系统，柜员要对一笔金额做修改，为了保证数据的准确性和实效性，使用悲观锁锁住某个数据后，再遇到其他需要修改数据的操作，那么此操作就无法完成金额的修改，对产品来说是灾难性的一刻，使用乐观锁的版本号机制能够解决这个问题，我们下面说。<br>乐观锁的</p><h2 id="乐观锁的实现方式"><a href="#乐观锁的实现方式" class="headerlink" title="乐观锁的实现方式"></a>乐观锁的实现方式</h2><h3 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h3><p>版本号机制是在数据表中加上一个 version 字段来实现的，表示数据被修改的次数，当执行写操作并且写入成功后，version = version + 1，当线程 A 要更新数据时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。</p><h3 id="CAS-算法"><a href="#CAS-算法" class="headerlink" title="CAS 算法"></a>CAS 算法</h3><p>CAS 即 <code>compare and swap</code>（比较与交换），是一种有名的无锁算法。即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization)</p><p>java 的 cas 利用的的是 unsafe 这个类提供的 cas 操作。</p><h4 id="CAS-的骚操作"><a href="#CAS-的骚操作" class="headerlink" title="CAS 的骚操作"></a>CAS 的骚操作</h4><p>CAS 中涉及三个要素：</p><ul><li>需要读写的内存值 V</li><li>进行比较的值 A</li><li>拟写入的新值 B</li></ul><p>当一个线程从内存中读取的值为 V,将当前值 A 与 V 比较，如果相等，则将 B 写入内存；如果不相等，则代表中间由线程修改过这个值，这样我们就要去重复一开始的操作。</p><h3 id="java8-对-CAS-的优化"><a href="#java8-对-CAS-的优化" class="headerlink" title="java8 对 CAS 的优化"></a>java8 对 CAS 的优化</h3><p>由于采用这种 CAS 机制是没有对方法进行加锁的，所以，所有的线程都可以进入 increment() 这个方法，假如进入这个方法的线程太多，就会出现一个问题：V 的值老是被修改了，所以线程要一值重复操作。</p><p>而这就会导致一个问题：由于线程太密集了，太多人想要修改 i 的值了，进而大部分人都会修改不成功，白白着在那里循环消耗资源。</p><p>为了解决这个问题，Java8 引入了一个 cell[] 数组，它的工作机制是这样的：假如有 5 个线程要对 i 进行自增操作，由于 5 个线程的话，不是很多，起冲突的几率较小，那就让他们按照以往正常的那样，采用 CAS 来自增吧。<br>但是，如果有 100 个线程要对 i 进行自增操作的话，这个时候，冲突就会大大增加，系统就会把这些线程分配到不同的 cell 数组元素去，假如 cell[10] 有 10 个元素吧，且元素的初始化值为 0，那么系统就会把 100 个线程分成 10 组，每一组对 cell 数组其中的一个元素做自增操作，这样到最后，cell 数组 10 个元素的值都为 10，系统在把这 10 个元素的值进行汇总，进而得到 100，二这，就等价于 100 个线程对 i 进行了 100 次自增操作。</p><h2 id="乐观锁的缺点"><a href="#乐观锁的缺点" class="headerlink" title="乐观锁的缺点"></a>乐观锁的缺点</h2><h3 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h3><p>ABA 问题说的是，如果一个变量第一次读取的值是 A，准备好需要对 A 进行写操作的时候，发现值还是 A，那么这种情况下，能认为 A 的值没有被改变过吗？可以是由 A -&gt; B -&gt; A 的这种情况，但是 AtomicInteger 却不会这么认为，它只相信它看到的，它看到的是什么就是什么。</p><p>JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><p>也可以采用 CAS 的一个变种 DCAS 来解决这个问题。 DCAS，是对于每一个 V 增加一个引用的表示修改次数的标记符。对于每个 V，如果引用修改了一次，这个计数器就加 1。然后再这个变量需要 update 的时候，就同时检查变量的值和计数器的值。</p><h3 id="循环开销大"><a href="#循环开销大" class="headerlink" title="循环开销大"></a>循环开销大</h3><p>我们知道乐观锁在进行写操作的时候会判断是否能够写入成功，如果写入不成功将触发等待 -&gt; 重试机制，这种情况是一个自旋锁，简单来说就是适用于短期内获取不到，进行等待重试的锁，它不适用于长期获取不到锁的情况，另外，自旋循环对于性能开销比较大。</p><h2 id="CAS-与-synchronized-的使用情景"><a href="#CAS-与-synchronized-的使用情景" class="headerlink" title="CAS 与 synchronized 的使用情景"></a>CAS 与 synchronized 的使用情景</h2><p>简单的来说 CAS 适用于写比较少的情况下（多读场景，冲突一般较少），synchronized 适用于写比较多的情况下（多写场景，冲突一般较多）</p><ul><li>对于资源竞争较少（线程冲突较轻）的情况，使用 Synchronized 同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗 cpu 资源；而 CAS 基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li><li>对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。</li></ul><h1 id="资源已被锁定，线程是否阻塞"><a href="#资源已被锁定，线程是否阻塞" class="headerlink" title="资源已被锁定，线程是否阻塞"></a>资源已被锁定，线程是否阻塞</h1><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁的定义：当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别人获取(占用)，那么此线程就无法获取到这把锁，该线程将会等待，间隔一段时间后会再次尝试获取。这种采用循环加锁 -&gt; 等待的机制被称为 <code>自旋锁(spinlock)</code>。</p><h2 id="自旋锁的原理"><a href="#自旋锁的原理" class="headerlink" title="自旋锁的原理"></a>自旋锁的原理</h2><p>如果持有锁的线程能在短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞状态，它们只需要等一等(自旋)，等到持有锁的线程释放锁之后即可获取，这样就避免了用户进程和内核切换的消耗。</p><h2 id="自旋锁的缺点"><a href="#自旋锁的缺点" class="headerlink" title="自旋锁的缺点"></a>自旋锁的缺点</h2><p>如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX</p><p>同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 cpu 的线程又不能获取到 cpu，造成 cpu 的浪费。</p><h2 id="适应性自旋锁"><a href="#适应性自旋锁" class="headerlink" title="适应性自旋锁"></a>适应性自旋锁</h2><p>解决上面这种情况一个很好的方式是给自旋锁设定一个自旋时间，等时间一到立即释放自旋锁。但是如何去选择自旋时间呢？</p><p>如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！</p><p>JDK 在 1.6 引入了适应性自旋锁，适应性自旋锁意味着自旋时间不是固定的了，而是由前一次在同一个锁上的自旋时间以及锁拥有的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间。</p><h1 id="多个线程并发访问资源"><a href="#多个线程并发访问资源" class="headerlink" title="多个线程并发访问资源"></a>多个线程并发访问资源</h1><h2 id="锁状态的分类"><a href="#锁状态的分类" class="headerlink" title="锁状态的分类"></a>锁状态的分类</h2><p>Java 语言专门针对 synchronized 关键字设置了四种状态，它们分别是：<code>无锁</code>、<code>偏向锁</code>、<code>轻量级锁</code>和<code>重量级锁</code>，这里只介绍这四种锁，具体关于 synchronized 的详细请见 <a href="JAVA并发——synchronized">synchronized 原理</a></p><h2 id="java-对象头"><a href="#java-对象头" class="headerlink" title="java 对象头"></a>java 对象头</h2><p>我们以 Hotspot 虚拟机为例，Hopspot 对象头主要包括两部分数据：<code>Mark Word（标记字段）</code> 和 <code>class Pointer（类型指针）。</code></p><p>Mark Word：默认存储对象的 <code>HashCode</code>，<code>分代年龄</code>和<code>锁标志位信息</code>。这些信息都是与对象自身定义无关的数据，所以 Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间 Mark Word 里存储的数据会随着锁标志位的变化而变化。</p><p>class Point：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><h2 id="锁的分类与解释"><a href="#锁的分类与解释" class="headerlink" title="锁的分类与解释"></a>锁的分类与解释</h2><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E9%94%81_2020-03-16-15-16-08.png" alt="JAVA并发——锁_2020-03-16-15-16-08.png"></p><h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><p>无锁即没有对资源进行锁定，所有的线程都可以对同一个资源进行访问，但是只有一个线程能够成功修改资源。</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E9%94%81_2020-03-16-15-17-04.png" alt="JAVA并发——锁_2020-03-16-15-17-04.png"></p><p>无锁的特点就是在循环内进行修改操作，线程会不断的尝试修改共享资源，直到能够成功修改资源并退出，在此过程中没有出现冲突的发生，这很像我们在之前文章中介绍的 CAS 实现，CAS 的原理和应用就是无锁的实现。</p><p>无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>大多数情况下，锁不仅不存在多线程竞争，还存在锁由同一线程多次获得的情况，偏向锁就是在这种情况下出现的，它的出现是为了解决只有在一个线程执行同步时提高性能。</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E9%94%81_2020-03-16-15-17-21.png" alt="JAVA并发——锁_2020-03-16-15-17-21.png"></p><p>可以从对象头的分配中看到，偏向锁要比无锁多了线程 ID 和 epoch，下面我们就来描述一下偏向锁的获取过程</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E9%94%81_2020-03-16-15-17-56.png" alt="JAVA并发——锁_2020-03-16-15-17-56.png"></p><ol><li>首先线程访问同步代码块，会通过检查对象头 Mark Word 的锁标志位判断目前锁的状态，如果是 01，说明就是无锁或者偏向锁，然后再根据是否偏向锁 的标示判断是无锁还是偏向锁，如果是无锁情况下，执行下一步。</li><li>线程使用 CAS 操作来尝试对对象加锁，如果使用 CAS 替换 ThreadID 成功，就说明是第一次上锁，那么当前线程就会获得对象的偏向锁，此时会在对象头的 Mark Word 中记录当前线程 ID 和获取锁的时间 epoch 等信息，然后执行同步代码块。</li><li>等到下一次线程在进入和退出同步代码块时就不需要进行 CAS 操作进行加锁和解锁，只需要简单判断一下对象头的 Mark Word 中是否存储着指向当前线程的线程 ID，判断的标志当然是根据锁的标志位来判断的。</li></ol><p>全局安全点（Safe Point）：全局安全点的理解会涉及到 C 语言底层的一些知识，这里简单理解 SafePoint 是 Java 代码中的一个线程可能暂停执行的位置。</p><p>偏向锁的对象头中有一个被称为 epoch 的值，它作为偏差有效性的时间戳。</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>轻量级锁是指当前锁是偏向锁的时候，资源被另外的线程所访问，那么偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能，下面是详细的获取过程。</p><ol><li>紧接着上一步，如果 CAS 操作替换 ThreadID 没有获取成功，执行下一步</li><li>如果使用 CAS 操作替换 ThreadID 失败（这时候就切换到另外一个线程的角度）说明该资源已被同步访问过，这时候就会执行锁的撤销操作，撤销偏向锁，然后等原持有偏向锁的线程到达全局安全点（SafePoint）时，会暂停原持有偏向锁的线程，然后会检查原持有偏向锁的状态，如果已经退出同步，就会唤醒持有偏向锁的线程，执行下一步</li><li>检查对象头中的 Mark Word 记录的是否是当前线程 ID，如果是，执行同步代码，如果不是，执行偏向锁获取流程 的第 2 步。</li></ol><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E9%94%81_2020-03-16-15-31-18.png" alt="JAVA并发——锁_2020-03-16-15-31-18.png"></p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E9%94%81_2020-03-16-15-24-31.png" alt="JAVA并发——锁_2020-03-16-15-24-31.png"></p><h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止 CPU 空转。</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E9%94%81_2020-03-16-15-30-55.png" alt="JAVA并发——锁_2020-03-16-15-30-55.png"></p><h1 id="锁的公平性和非公平性"><a href="#锁的公平性和非公平性" class="headerlink" title="锁的公平性和非公平性"></a>锁的公平性和非公平性</h1><ul><li>公平锁：表示线程获取锁的顺序是按照线程加锁的顺序来分配的，即先来先得的 FIFO 先进先出顺序。</li><li>非公平锁：就是一种获取锁的抢占机制，是随机获得锁的，和公平锁不一样的就是先来的不一定先得到锁，这个方式可能造成某些线程一直拿不到锁，结果也就是不公平的了。</li></ul><h2 id="锁公平性的实现"><a href="#锁公平性的实现" class="headerlink" title="锁公平性的实现"></a>锁公平性的实现</h2><p>在 Java 中，我们一般通过 ReetrantLock 来实现锁的公平性，关于 ReetrantLock 的详细解读请见 <a href="JAVA并发——ReetrantLock">ReetrantLock 原理</a></p><h2 id="锁的公平性"><a href="#锁的公平性" class="headerlink" title="锁的公平性"></a>锁的公平性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFairLock</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fairLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()  + <span class="string">"正在持有锁"</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()  + <span class="string">"释放了锁"</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyFairLock myFairLock = <span class="keyword">new</span> MyFairLock();</span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"启动"</span>);</span><br><span class="line">            myFairLock.fairLock();</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread[] thread = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">            thread[i] = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">            thread[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们创建了一个 ReetrantLock，并给构造函数传了一个 true，我们可以查看 ReetrantLock 的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">  sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 JavaDoc 的注释可知，如果是 true 的话，那么就会创建一个 ReentrantLock 的公平锁，然后并创建一个 FairSync ，FairSync 其实是一个 Sync 的内部类，它的主要作用是同步对象以获取公平锁。</p><p>而 Sync 是 ReentrantLock 中的内部类，Sync 继承 AbstractQueuedSynchronizer 类，AbstractQueuedSynchronizer 就是我们常说的 AQS ，它是 JUC（java.util.concurrent） 中最重要的一个类，通过它来实现独占锁和共享锁。</p><p>也就是说，我们把 fair 参数设置为 true 之后，就可以实现一个公平锁了，是这样吗？我们回到示例代码，我们可以执行一下这段代码，它的输出是顺序获取的（碍于篇幅的原因，这里就暂不贴出了）,也就是说我们创建了一个公平锁</p><h2 id="锁的非公平性"><a href="#锁的非公平性" class="headerlink" title="锁的非公平性"></a>锁的非公平性</h2><p>与公平性相对的就是非公平性，我们通过设置 fair 参数为 true，便实现了一个公平锁，与之相对的，我们把 fair 参数设置为 false，是不是就是非公平锁了？用事实证明一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>其他代码不变，我们执行一下看看输出（部分输出）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">1</span>启动</span><br><span class="line">Thread-<span class="number">4</span>启动</span><br><span class="line">Thread-<span class="number">1</span>正在持有锁</span><br><span class="line">Thread-<span class="number">1</span>释放了锁</span><br><span class="line">Thread-<span class="number">5</span>启动</span><br><span class="line">Thread-<span class="number">6</span>启动</span><br><span class="line">Thread-<span class="number">3</span>启动</span><br><span class="line">Thread-<span class="number">7</span>启动</span><br><span class="line">Thread-<span class="number">2</span>启动</span><br></pre></td></tr></table></figure><p>可以看到，线程的启动并没有按顺序获取，可以看出非公平锁对锁的获取是乱序的，即有一个抢占锁的过程。也就是说，我们把 fair 参数设置为 false 便实现了一个非公平锁。</p><h1 id="根据锁是否可重入进行区分"><a href="#根据锁是否可重入进行区分" class="headerlink" title="根据锁是否可重入进行区分"></a>根据锁是否可重入进行区分</h1><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>可重入锁又称为递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者 class），不会因为之前已经获取过还没释放而阻塞。Java 中 ReentrantLock 和 synchronized 都是可重入锁，可重入锁的一个优点是在一定程度上可以避免死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"doSomething..."</span>);</span><br><span class="line">  doSomethingElse();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomethingElse</span><span class="params">()</span></span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"doSomethingElse..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这段代码中，我们对 doSomething() 和 doSomethingElse() 分别使用了 synchronized 进行锁定，doSomething() 方法中调用了 doSomethingElse() 方法，因为 synchronized 是可重入锁，所以同一个线程在调用 doSomething() 方法时，也能够进入 doSomethingElse() 方法中。</p><h2 id="不可重入锁"><a href="#不可重入锁" class="headerlink" title="不可重入锁"></a>不可重入锁</h2><p>如果 synchronized 是不可重入锁的话，那么在调用 doSomethingElse() 方法的时候，必须把 doSomething() 的锁丢掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</p><p>也就是说，不可重入锁会造成死锁</p><h1 id="多个线程能够共享同一把锁"><a href="#多个线程能够共享同一把锁" class="headerlink" title="多个线程能够共享同一把锁"></a>多个线程能够共享同一把锁</h1><h2 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h2><p>独占锁又叫做排他锁，是指锁在同一时刻只能被一个线程拥有，其他线程想要访问资源，就会被阻塞。JDK 中 synchronized 和 JUC 中 Lock 的实现类就是互斥锁。</p><h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><p>共享锁指的是锁能够被多个线程所拥有，如果某个线程对资源加上共享锁后，则其他线程只能对资源再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p><p>我们看到 ReentrantReadWriteLock 有两把锁：ReadLock 和 WriteLock，也就是一个读锁一个写锁，合在一起叫做读写锁。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java并发 线程安全 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA并发——并发容器</title>
      <link href="/2020/03/14/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
      <url>/2020/03/14/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是并发容器？"><a href="#什么是并发容器？" class="headerlink" title="什么是并发容器？"></a>什么是并发容器？</h1><p>JDK5 中添加了新的 concurrent 包，相对同步容器而言，并发容器通过一些机制改进了并发性能。</p><p>因为同步容器将所有对容器状态的访问都串行化了，这样保证了线程的安全性，所以这种方法的代价就是严重降低了并发性，当多个线程竞争容器时，吞吐量严重降低。</p><p>因此 Java5.0 开始针对多线程并发访问设计，提供了并发性能较好的并发容器，引入了 java.util.concurrent 包。与 Vector 和 Hashtable、Collections.synchronizedXxx()同步容器等相比，java.util.concurrent 中引入的并发容器主要解决了两个问题：</p><p>1.根据具体场景进行设计，尽量避免 synchronized，提供并发性。</p><p>2.定义了一些并发安全的复合操作，并且保证并发环境下的迭代操作不会出错。</p><p>java.util.concurrent 中容器在迭代时，可以不封装在 synchronized 中，可以保证不抛异常，但是未必每次看到的都是”最新的、当前的”数据。</p><h1 id="关于一些并发容器的介绍？"><a href="#关于一些并发容器的介绍？" class="headerlink" title="关于一些并发容器的介绍？"></a>关于一些并发容器的介绍？</h1><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>代替同步的 Map（Collections.synchronized（new HashMap()）），众所周知，HashMap 是根据散列值分段存储的，同步 Map 在同步的时候锁住了所有的段，而 ConcurrentHashMap 加锁的时候根据散列值锁住了散列值锁对应的那段，因此提高了并发性能。ConcurrentHashMap 也增加了对常用复合操作的支持，比如”若没有则添加”：putIfAbsent()，替换：replace()。这 2 个操作都是原子操作。</p><p>当然 ConcurrentHashMap 在 JDK8 以后不在使用分段储存，而是使用类似乐观锁的方式（<code>CAS + synchronized</code>）来达到多线程安全的目的。具体详情请见<a href="JAVA容器——ConcurrentHashMap">ConcurrentHashMap</a></p><h2 id="CopyOnWriteArrayList-和-CopyOnWriteArraySet"><a href="#CopyOnWriteArrayList-和-CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArrayList 和 CopyOnWriteArraySet"></a>CopyOnWriteArrayList 和 CopyOnWriteArraySet</h2><p>分别代替 List 和 Set，主要是在遍历操作为主的情况下来代替同步的 List 和同步的 Set，这也就是上面所述的思路：迭代过程要保证不出错，除了加锁，另外一种方法就是”克隆”容器对象。</p><h2 id="ConcurrentLinkedQuerue"><a href="#ConcurrentLinkedQuerue" class="headerlink" title="ConcurrentLinkedQuerue"></a>ConcurrentLinkedQuerue</h2><p>是一个先进先出的队列。它是非阻塞队列。</p><h2 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h2><p>可以在高效并发中替代 SoredMap（例如用 Collections.synchronzedMap 包装的 TreeMap）。</p><h2 id="ConcurrentSkipListSet"><a href="#ConcurrentSkipListSet" class="headerlink" title="ConcurrentSkipListSet"></a>ConcurrentSkipListSet</h2><p>可以在高效并发中替代 SoredSet（例如用 Collections.synchronzedSet 包装的 TreeMap）。</p><h1 id="CopyOnWrite"><a href="#CopyOnWrite" class="headerlink" title="CopyOnWrite"></a>CopyOnWrite</h1><h2 id="什么是-CopyOnWrite-容器？"><a href="#什么是-CopyOnWrite-容器？" class="headerlink" title="什么是 CopyOnWrite 容器？"></a>什么是 CopyOnWrite 容器？</h2><p>Copy-On-Write 简称 COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容 Copy 出去形成一个新的内容然后再改，这是一种延时懒惰策略。从 JDK1.5 开始 Java 并发包里提供了两个使用 CopyOnWrite 机制实现的并发容器,它们是 CopyOnWriteArrayList 和 CopyOnWriteArraySet。CopyOnWrite 容器非常有用，可以在非常多的并发场景中使用到。</p><p>CopyOnWrite 容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行 Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对 CopyOnWrite 容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以 CopyOnWrite 容器也是一种读写分离的思想，读和写不同的容器。</p><h1 id="CopyOnWriteArrayList-的实现原理"><a href="#CopyOnWriteArrayList-的实现原理" class="headerlink" title="CopyOnWriteArrayList 的实现原理"></a>CopyOnWriteArrayList 的实现原理</h1><p>在使用 CopyOnWriteArrayList 之前，我们先阅读其源码了解下它是如何实现的。以下代码是向 CopyOnWriteArrayList 中 add 方法的实现（向 CopyOnWriteArrayList 里添加元素），可以发现在添加的时候是需要加锁的，否则多线程写的时候会 Copy 出 N 个副本出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>读的时候不需要加锁，如果读的时候有多个线程正在向 CopyOnWriteArrayList 添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的 CopyOnWriteArrayList。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CopyOnWrite-容器的应用场景？"><a href="#CopyOnWrite-容器的应用场景？" class="headerlink" title="CopyOnWrite 容器的应用场景？"></a>CopyOnWrite 容器的应用场景？</h2><p>CopyOnWrite 并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景</p><p>使用 CopyOnWriteMap 需要注意两件事情：</p><ol><li><p>减少扩容开销。根据实际需要，初始化 CopyOnWriteMap 的大小，避免写时 CopyOnWriteMap 扩容的开销。</p></li><li><p>使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。如使用上面代码里的 addBlackList 方法。</p></li></ol><h2 id="CopyOnWrite-容器存在的问题？"><a href="#CopyOnWrite-容器存在的问题？" class="headerlink" title="CopyOnWrite 容器存在的问题？"></a>CopyOnWrite 容器存在的问题？</h2><h3 id="内存占用问题"><a href="#内存占用问题" class="headerlink" title="内存占用问题"></a>内存占用问题</h3><p>因为 CopyOnWrite 的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说 200M 左右，那么再写入 100M 数据进去，内存就会占用 300M，那么这个时候很有可能造成频繁的 Yong GC 和 Full GC。之前我们系统中使用了一个服务由于每晚使用 CopyOnWrite 机制更新大对象，造成了每晚 15 秒的 Full GC，应用响应时间也随之变长。针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是 10 进制的数字，可以考虑把它压缩成 36 进制或 64 进制。或者不使用 CopyOnWrite 容器，而使用其他的并发容器，如 ConcurrentHashMap。</p><h3 id="数据一致性问题"><a href="#数据一致性问题" class="headerlink" title="数据一致性问题"></a>数据一致性问题</h3><p>CopyOnWrite 容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用 CopyOnWrite 容器。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java并发 线程安全 并发容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA并发——同步容器</title>
      <link href="/2020/03/14/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8/"/>
      <url>/2020/03/14/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么会出现同步容器？"><a href="#为什么会出现同步容器？" class="headerlink" title="为什么会出现同步容器？"></a>为什么会出现同步容器？</h1><p>像 ArrayList、LinkedList、HashMap 这些容器都是非线程安全的。</p><p>如果有多个线程并发地访问这些容器时，就会出现问题。</p><p>因此，在编写程序时，必须要求程序员手动地在任何访问到这些容器的地方进行同步处理，这样导致在使用这些容器的时候非常地不方便。</p><p>所以，Java 提供了同步容器供用户使用。</p><h1 id="同步容器分为以下几类"><a href="#同步容器分为以下几类" class="headerlink" title="同步容器分为以下几类"></a>同步容器分为以下几类</h1><ul><li>ArrayList -&gt; Vector,Stack</li><li>HashMap -&gt; HashTable</li><li>Collections.synchronizedXXX(List、Set、Map)</li></ul><h1 id="同步容器的缺陷"><a href="#同步容器的缺陷" class="headerlink" title="同步容器的缺陷"></a>同步容器的缺陷</h1><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>我们先通过一个例子看一下 Vector 和 ArrayList 在插入数据时性能上的差异：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)</span><br><span class="line">            list.add(i);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"ArrayList进行100000次插入操作耗时："</span>+(end-start)+<span class="string">"ms"</span>);</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)</span><br><span class="line">            vector.add(i);</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"Vector进行100000次插入操作耗时："</span>+(end-start)+<span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码在我机器上跑出来的结果是：</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8_2020-03-14-21-06-02.png" alt="JAVA并发——同步容器_2020-03-14-21-06-02.png"></p><p>进行同样多的插入操作，Vector 的耗时是 ArrayList 的两倍。</p><p>这只是其中的一方面性能问题上的反映。</p><p>另外，由于 Vector 中的 add 方法和 get 方法都进行了同步，因此，在有多个线程进行访问时，如果多个线程都只是进行读取操作，那么每个时刻就只能有一个线程进行读取，其他线程便只能等待，这些线程必须竞争同一把锁。</p><p>因此为了解决同步容器的性能问题，在 Java 1.5 中提供了并发容器，位于 java.util.concurrent 目录下，并发容器的相关知识将在下一篇文章中讲述。</p><h2 id="ConcurrentModificationException-异常"><a href="#ConcurrentModificationException-异常" class="headerlink" title="ConcurrentModificationException 异常"></a>ConcurrentModificationException 异常</h2><p>也有有人认为 Vector 中的方法都进行了同步处理，那么一定就是线程安全的，事实上这可不一定。看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">                vector.add(i);</span><br><span class="line">            Thread thread1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vector.size();i++)</span><br><span class="line">                        vector.remove(i);</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            Thread thread2 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vector.size();i++)</span><br><span class="line">                        vector.get(i);</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            thread1.start();</span><br><span class="line">            thread2.start();</span><br><span class="line">            <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">10</span>)   &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我机器上运行的结果：</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8_2020-03-14-21-08-19.png" alt="JAVA并发——同步容器_2020-03-14-21-08-19.png"></p><p>正如大家所看到的，这段代码报错了：数组下标越界。</p><h3 id="单线程环境下的解决方法"><a href="#单线程环境下的解决方法" class="headerlink" title="单线程环境下的解决方法"></a>单线程环境下的解决方法</h3><p>既然知道原因了，那么如何解决呢？</p><p>其实很简单，细心的朋友可能发现在 Itr 类中也给出了一个 remove()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet == -<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">       checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    AbstractList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; cursor)</span><br><span class="line">        cursor--;</span><br><span class="line">    lastRet = -<span class="number">1</span>;</span><br><span class="line">    expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，删除元素实际上调用的就是 list.remove()方法，但是它多了一个操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expectedModCount = modCount;</span><br></pre></td></tr></table></figure><p>因此，在迭代器中如果要删除元素的话，需要调用 Itr 类的 remove 方法。</p><p>将上述代码改为下面这样就不会报错了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            Integer integer = iterator.next();</span><br><span class="line">            <span class="keyword">if</span>(integer==<span class="number">2</span>)</span><br><span class="line">                iterator.remove();   <span class="comment">//注意这个地方</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程环境下的解决方法"><a href="#多线程环境下的解决方法" class="headerlink" title="多线程环境下的解决方法"></a>多线程环境下的解决方法</h3><p>上面的解决办法在单线程环境下适用，但是在多线程并不适用，因为 Iterator.remove()并不是安全的，想要达到线程安全的效果，需要在使用的时候加上同步锁。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由上文可知，同步容器存在性能问题，又难做到完全的线程安全。这个时候我们就需要使用并发容器，详情请看<a href="JAVA并发——并发容器">下一章</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java并发 线程安全 同步容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA并发——不安全类和写法</title>
      <link href="/2020/03/14/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E4%B8%8D%E5%AE%89%E5%85%A8%E7%B1%BB%E5%92%8C%E5%86%99%E6%B3%95/"/>
      <url>/2020/03/14/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E4%B8%8D%E5%AE%89%E5%85%A8%E7%B1%BB%E5%92%8C%E5%86%99%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="常见的不安全类有哪些？"><a href="#常见的不安全类有哪些？" class="headerlink" title="常见的不安全类有哪些？"></a>常见的不安全类有哪些？</h1><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E4%B8%8D%E5%AE%89%E5%85%A8%E7%B1%BB%E5%92%8C%E5%86%99%E6%B3%95_2020-03-14-20-29-50.png" alt="JAVA并发——不安全类和写法_2020-03-14-20-29-50.png"></p><h1 id="StringBuilder–StringBuffer"><a href="#StringBuilder–StringBuffer" class="headerlink" title="StringBuilder–StringBuffer"></a>StringBuilder–StringBuffer</h1><h2 id="StringBuilder-demo"><a href="#StringBuilder-demo" class="headerlink" title="StringBuilder-demo"></a>StringBuilder-demo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">//同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stringBuilder.append(<span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//定义信号量</span></span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="comment">//定义计数器闭锁</span></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>,e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>,stringBuilder.length());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我测试的时候输出为，4985（因为线程不安全，所以每次的输出可能是不同的），如果 StringBuilder 类为线程安全的话，输出应该为 5000</p><h2 id="StringBuffer-demo"><a href="#StringBuffer-demo" class="headerlink" title="StringBuffer-demo"></a>StringBuffer-demo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">//同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stringBuffer.append(<span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//定义信号量</span></span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="comment">//定义计数器闭锁</span></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>,e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>,stringBuffer.length());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为 5000，且多次测试结果均为 5000，证明 StringBuffer 类是线程安全的，通过看 StringBuffer 的实现可发现，其所有的实现都是加了 synchronized 关键字的，虽然可以保证线程安全但是性能是有损耗的，这也证明了 StringBuilder 的存在价值，如果定义 StringBuilder 为局部变量时是没有线程安全问题的，这就用到了上篇博客我们讲的堆栈封闭原理</p><h1 id="simpleDateFormat–jodatime"><a href="#simpleDateFormat–jodatime" class="headerlink" title="simpleDateFormat–jodatime"></a>simpleDateFormat–jodatime</h1><h2 id="simpleDateFormat-demo"><a href="#simpleDateFormat-demo" class="headerlink" title="simpleDateFormat-demo"></a>simpleDateFormat-demo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateFormatExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">//同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            simpleDateFormat.parse(<span class="string">"20180208"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            log.error(<span class="string">"parse exception"</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//定义信号量</span></span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="comment">//定义计数器闭锁</span></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>,e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E4%B8%8D%E5%AE%89%E5%85%A8%E7%B1%BB%E5%92%8C%E5%86%99%E6%B3%95_2020-03-14-20-34-55.png" alt="JAVA并发——不安全类和写法_2020-03-14-20-34-55.png"></p><p>因为 simpleDateFormat 为线程不安全的类，所以在多线程访问的时候出现了异常。</p><h2 id="simpleDateFormat-demo2"><a href="#simpleDateFormat-demo2" class="headerlink" title="simpleDateFormat-demo2"></a>simpleDateFormat-demo2</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateFormatExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">//同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//用堆栈封闭的方式</span></span><br><span class="line">            SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd"</span>);</span><br><span class="line">            simpleDateFormat.parse(<span class="string">"20180208"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            log.error(<span class="string">"parse exception"</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//定义信号量</span></span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="comment">//定义计数器闭锁</span></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>,e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此 demo 为 demo1 的改进版，将 SimpleDateFormat 声明为局部变量，运用了堆栈封闭的方式保证了线程安全，运行此 demo 是没有异常抛出的。</p><h2 id="jodatime-demo"><a href="#jodatime-demo" class="headerlink" title="jodatime-demo"></a>jodatime-demo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.joda.time.DateTime;</span><br><span class="line"><span class="keyword">import</span> org.joda.time.format.DateTimeFormat;</span><br><span class="line"><span class="keyword">import</span> org.joda.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateFormatExample3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">//同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern(<span class="string">"yyyyMMdd"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;,&#123;&#125;"</span>,i,DateTime.parse(<span class="string">"20180208"</span>, dateTimeFormatter).toDate());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//定义信号量</span></span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="comment">//定义计数器闭锁</span></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>,e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此 demo 引用了 joda.time 包，保证了线程安全，在实际的开发中，我们更推荐做日期转换的时候使用此包，这种处理方法不仅能保证线程安全</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们做 ArrayList，HashMap，HashSet 的实例演示，它们都是线程不安全的，还好我们一般都将它们定义为局部变量（堆栈封闭），如果我们将它们定义为成员变量或 static 修饰的变量，在多个线程同时访问的时候就很容易出问题。</p><p>典型的线程不安全的写法是：先检查，再执行。</p><p>if（condition（a））{handle（a）；} 就算 a 是一个线程安全的类所对应的对象，对 a 的处理 handle（a）也是原子性的，但由于这两步之间的不是原子性的也会引发线程安全问题，如 A、B 两个线程都通过了 a 的判断条件，A 线程执行 handle（a）之后，a 已经不符合 condition（a）的判断条件了，可是此时 B 线程仍然要执行 handle（a），这就引发了线程安全问题。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java并发 线程安全 不安全类和写法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA并发——线程封闭</title>
      <link href="/2020/03/14/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD/"/>
      <url>/2020/03/14/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是线程封闭？"><a href="#什么是线程封闭？" class="headerlink" title="什么是线程封闭？"></a>什么是线程封闭？</h1><p>实现好的并发是一件困难的事情，所以很多时候我们都想躲避并发。避免并发最简单的方法就是线程封闭。</p><p>就是把对象封装到一个线程里，只有这一个线程能看到此对象。那么这个对象就算不是线程安全的也不会出现任何安全问题。</p><h1 id="实现线程封闭的方法？"><a href="#实现线程封闭的方法？" class="headerlink" title="实现线程封闭的方法？"></a>实现线程封闭的方法？</h1><h2 id="ad-hoc-线程封闭"><a href="#ad-hoc-线程封闭" class="headerlink" title="ad-hoc 线程封闭"></a>ad-hoc 线程封闭</h2><p>这是完全靠实现者控制的线程封闭，他的线程封闭完全靠实现者实现。也是最糟糕的一种线程封闭。所以我们直接把他忽略掉吧。</p><h2 id="栈封闭"><a href="#栈封闭" class="headerlink" title="栈封闭"></a>栈封闭</h2><p>什么是栈封闭呢？简单的说就是局部变量。多个线程访问一个方法，此方法中的局部变量都会被拷贝一分儿到线程栈中。所以局部变量是不被多个线程所共享的，也就不会出现并发问题。所以能用局部变量就别用全局的变量，全局变量容易引起并发问题。</p><h2 id="ThreadLocal-封闭"><a href="#ThreadLocal-封闭" class="headerlink" title="ThreadLocal 封闭"></a>ThreadLocal 封闭</h2><p>ThreadLocal 翻译成中文比较准确的叫法应该是：线程局部变量。</p><p>其实 ThreadLocal 内部维护了一个 Map，Map 的 key 是每个线程的名称，而 Map 的值就是我们要封闭的对象。每个线程中的对象都对应着 Map 中一个值，也就是 ThreadLocal 利用 Map 实现了对象的线程封闭。</p><p>比如说 DAO 的数据库连接，我们知道 DAO 是单例的，那么他的属性 Connection 就不是一个线程安全的变量。而我们每个线程都需要使用他，并且各自使用各自的。这种情况，ThreadLocal 就比较好的解决了这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ConnectionUtil</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Connection&gt; conn = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection con = conn.get();</span><br><span class="line">        <span class="keyword">if</span> (con == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">                con = DriverManager.getConnection(<span class="string">"url"</span>, <span class="string">"userName"</span>, <span class="string">"password"</span>);</span><br><span class="line">                conn.set(con);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> con;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子，都是用同一个连接，但是每个连接都是新的，是同一个连接的副本。</p><p>那么实现机制是如何的呢？</p><p>从本质来讲，就是每个线程都维护了一个 map，而这个 map 的 key 就是 threadLocal，而值就是我们 set 的那个值，每次线程在 get 的时候，都从自己的变量中取值，既然从自己的变量中取值，那肯定就不存在线程安全问题，总体来讲，ThreadLocal 这个变量的状态根本没有发生变化，他仅仅是充当一个 key 的角色，另外提供给每一个线程一个初始值。如果允许的话，我们自己就能实现一个这样的功能，只不过恰好 JDK 就已经帮我们做了这个事情。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java并发 线程安全 线程封闭 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA并发——不可变对象</title>
      <link href="/2020/03/13/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/03/13/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="不可变对象需要满足的条件"><a href="#不可变对象需要满足的条件" class="headerlink" title="不可变对象需要满足的条件"></a>不可变对象需要满足的条件</h1><ul><li>对象创建以后其状态就不可修改</li><li>对象所有域都是 final 类型</li><li>对象都是正确创建的（安全发布）</li></ul><h1 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h1><ul><li>修饰类：不能被继承，final 类中的变量可以根据需要设置为 final，final 类中的方法隐式的被设置为 final 方法。</li><li>修饰方法：不能被继承类修改，一个类的 private 方法会被隐式的指定为 final 方法。</li><li>修饰变量：<ul><li>基本数据类型变量：初始化之后，值不会改变。</li><li>引用数据类型变量：初始化之后，不能指向另外的引用。</li></ul></li></ul><h1 id="Collections-unmodifiableXXX"><a href="#Collections-unmodifiableXXX" class="headerlink" title="Collections.unmodifiableXXX"></a>Collections.unmodifiableXXX</h1><p>被这个类方法修饰的 Collection、List、Set、Map…为不可变对象。</p><h1 id="Guava-InmutableXXX"><a href="#Guava-InmutableXXX" class="headerlink" title="Guava:InmutableXXX"></a>Guava:InmutableXXX</h1><p>初始化方法包含的 Collection、List、Set、Map…为不可变对象。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java并发 线程安全 不可变对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA并发——安全发布对象</title>
      <link href="/2020/03/13/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/03/13/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="对象发布和溢出"><a href="#对象发布和溢出" class="headerlink" title="对象发布和溢出"></a>对象发布和溢出</h1><ul><li>对象发布：使对象能够被当前范围之外的代码所使用。</li><li>对象溢出：一种错误的发布，使对象还未构造完成就被其他线程看见。</li></ul><h2 id="对象溢出的方式"><a href="#对象溢出的方式" class="headerlink" title="对象溢出的方式"></a>对象溢出的方式</h2><h3 id="非静态私有方法"><a href="#非静态私有方法" class="headerlink" title="非静态私有方法"></a>非静态私有方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lass UnsafeStates &#123;</span><br><span class="line">    <span class="keyword">private</span> String[] states = <span class="keyword">new</span> String[]&#123;<span class="string">"AK"</span>, <span class="string">"AL"</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> String[] getStates() &#123;</span><br><span class="line">        <span class="keyword">return</span> states;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 states 的发布就有问题，我们可以通过调用 <code>getStates()</code> 方法获取 states 数组，修改数组的值。此时别的线程在调用这个数组，会发现数组的值已经发生了改变。</p><h3 id="通过静态变量引用逸出"><a href="#通过静态变量引用逸出" class="headerlink" title="通过静态变量引用逸出"></a>通过静态变量引用逸出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Secret&gt; knownSecrets;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    knowsSecrets = <span class="keyword">new</span> HashSet&lt;Secret&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 initialize 方法，发布了 knowSecrets 对象。当你向 knowSecrets 中添加一个 Secret 时，会同时将 Secret 对象发布出去，原因是可以通过遍历 knowSecrets 获取到 Secret 对象的引用，然后进行修改。</p><h3 id="this-逸出"><a href="#this-逸出" class="headerlink" title="this 逸出"></a>this 逸出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisEscape</span> </span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="title">ThisEscape</span><span class="params">(EventSource source)</span> </span>&#123;</span><br><span class="line">    　　　　source.registerListener(<span class="keyword">new</span> EventListener() &#123;</span><br><span class="line">        　　　　　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span> </span>&#123;</span><br><span class="line">            　　　　　　　　doSomething(e);</span><br><span class="line">        　　　　　　&#125;</span><br><span class="line">    　　　　&#125;);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们实例化 ThisEscape 对象时，会调用 source 的 registerListener 方法时，便启动了一个线程，而且这个线程持有了 ThisEscape 对象（调用了对象的 doSomething 方法），但此时 ThisEscape 对象却没有实例化完成（还没有返回一个引用）</p><h2 id="安全发布对象的四种方式"><a href="#安全发布对象的四种方式" class="headerlink" title="安全发布对象的四种方式"></a>安全发布对象的四种方式</h2><ol><li>在静态初始化函数中初始化一个对象引用</li><li>将对象的应用保存到 volatile 类型的域或者 AtomicReferance 对象中</li><li>将对象的引用保存到某个正确构造对象的 final 类型域中</li><li>将对象的引用保存到一个由锁保护的域中。</li></ol><h3 id="懒汉式单例"><a href="#懒汉式单例" class="headerlink" title="懒汉式单例"></a>懒汉式单例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉模式 -》 双重同步锁单例模式</span></span><br><span class="line"><span class="comment"> * 单例实例在第一次使用时进行创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample4</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、memory = allocate() 分配对象的内存空间</span></span><br><span class="line">    <span class="comment">// 2、ctorInstance() 初始化对象</span></span><br><span class="line">    <span class="comment">// 3、instance = memory 设置instance指向刚分配的内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// JVM和cpu优化，发生了指令重排（多线程 ）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、memory = allocate() 分配对象的内存空间</span></span><br><span class="line">    <span class="comment">// 3、instance = memory 设置instance指向刚分配的内存</span></span><br><span class="line">    <span class="comment">// 2、ctorInstance() 初始化对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象 volatile + 双重检测机制 -&gt; 禁止指令重排</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">volatile</span>  <span class="keyword">static</span> SingletonExample4 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 双重检测机制        // B</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonExample4<span class="class">.<span class="keyword">class</span>) </span>&#123; <span class="comment">// 同步锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonExample4(); <span class="comment">// A - 3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="饿汉模式单例"><a href="#饿汉模式单例" class="headerlink" title="饿汉模式单例"></a>饿汉模式单例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉模式</span></span><br><span class="line"><span class="comment"> * 单例实例在类装载时进行创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample2 instance = <span class="keyword">new</span> SingletonExample2();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="饿汉模式单例静态块初始化"><a href="#饿汉模式单例静态块初始化" class="headerlink" title="饿汉模式单例静态块初始化"></a>饿汉模式单例静态块初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉模式</span></span><br><span class="line"><span class="comment"> * 单例实例在类装载时进行创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample6</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample6</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample6 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> SingletonExample6();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample6 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(getInstance().hashCode());</span><br><span class="line">        System.out.println(getInstance().hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举模式"><a href="#枚举模式" class="headerlink" title="枚举模式"></a>枚举模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举模式：最安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="meta">@Recommend</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample7</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample7</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample7 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> SingletonExample7 singleton;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// JVM保证这个方法绝对只调用一次</span></span><br><span class="line">        Singleton() &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> SingletonExample7();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SingletonExample7 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java并发 线程安全 安全发布对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA并发——线程安全</title>
      <link href="/2020/03/13/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
      <url>/2020/03/13/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是进程？"><a href="#什么是进程？" class="headerlink" title="什么是进程？"></a>什么是进程？</h1><p>先看一张图</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8_2020-03-13-18-16-29.png" alt="JAVA并发——线程安全_2020-03-13-18-16-29.png"></p><p>我们看到的这些单独运行的程序就是一个独立的进程，进程之间是相互独立存在的。</p><p>我们上面图中的 QQ、酷狗播放器、电脑管家等等都是独立的进程。</p><h1 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h1><p>上面简单的说了一下什么是进程，进程想要执行任务需要依赖线程，换句话说就是进程中的最小执行单位就是线程，并且一个进程中至少有一个线程。</p><h1 id="什么是多线程？"><a href="#什么是多线程？" class="headerlink" title="什么是多线程？"></a>什么是多线程？</h1><p>提到多线程这里要说两个概念，就是串行和并行，搞清楚这个我们才能更好的理解多线程。</p><p>所谓串行其实是相对于单条线程来执行多个任务来说的，我们就拿下载文件来举个例子，我们下载多个文件，在串行中它是按照一定的顺序去进行下载的，也就是说必须等下载完 A 之后，才能开始下载 B，它们在时间上是不可能发生重叠的。</p><p>并行：下载多个文件，开启多条线程，多个文件同时进行下载，这里是严格意义上的在同一时刻发生的，并行在时间上是重叠的。</p><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>当多个线程同时访问某个类时，不管运行时环境采用何种调用方式，或者这些进程如何交替执行，并且在主调代码中不需要额外的同步和协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。</p><h1 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h1><ol><li>原子性：提供了互斥访问，同一时刻只能有一个线程对他进行操作。</li><li>可见性：一个线程对主内存的修改可以及时的被其他线程观察到。</li><li>有序性：一个线程观察其他线程的指令执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序。</li></ol><h1 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h1><h2 id="什么是原子操作？"><a href="#什么是原子操作？" class="headerlink" title="什么是原子操作？"></a>什么是原子操作？</h2><p>原子是世界上的最小单位，具有不可分割性。比如 a=0；（a 非 long 和 double 类型）这个操作是不可分割的，那么我们说这个操作时原子操作。再比如：a++；这个操作实际是 a = a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。</p><h2 id="如何保证原子性？"><a href="#如何保证原子性？" class="headerlink" title="如何保证原子性？"></a>如何保证原子性？</h2><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><h4 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h4><p>比如：AtomicInteger、AtomicLong、AtomicReference 等。</p><h4 id="Atomicxxx-底层工作原理"><a href="#Atomicxxx-底层工作原理" class="headerlink" title="Atomicxxx 底层工作原理"></a>Atomicxxx 底层工作原理</h4><p>借助于 Unsafe.compareAndSwapInt: CAS 实现</p><p>每次执行计算之前都会拿当前工作内存中的值和主内存的值比较，如果不相同就会从新从主内存中获取最新值赋值给当前对象，直到相同执行对应操作。</p><h4 id="AtomicLong-和-AtomicAddr"><a href="#AtomicLong-和-AtomicAddr" class="headerlink" title="AtomicLong 和 AtomicAddr"></a>AtomicLong 和 AtomicAddr</h4><p>AtomicLong 的原理是依靠底层的 cas 来保障原子性的更新数据，在要添加或者减少的时候，会使用死循环不断地 cas 到特定的值，从而达到更新数据的目的。在竞争不激烈时修改成功的概率很高，否则修改失败的概率就很高，在大量修改失败的情况下，这些原子操作就会进行大量的失败重尝试，性能就会受到影响</p><p>LongAdder 在 AtomicLong 的基础上将单点的更新压力分散到各个节点，在低并发的时候通过对 base 的直接更新可以很好的保障和 AtomicLong 的性能基本保持一致，而在高并发的时候通过分散提高了性能。<br>缺点是 LongAdder 在统计的时候如果有并发更新，可能导致统计的数据有误差。<br>实际使用中在处理高并发计数时，推荐使用 LongAddr，但如果遇到类似于序列号生成这种需要全局唯一的数据情况就需要使用 AtomicLong.</p><h4 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h4><p>AtomicReference 和 AtomicInteger 非常类似，不同之处就在于 AtomicInteger 是对整数的封装，而 AtomicReference 则对应普通的对象引用。也就是它可以保证你在修改对象引用时的线程安全性。在介绍 AtomicReference 的同时，我希望同时提出一个有关原子操作的逻辑上的不足。</p><h4 id="原子类的不足"><a href="#原子类的不足" class="headerlink" title="原子类的不足"></a>原子类的不足</h4><p>我们知道原子操作都是基于 cas 来保障原子性，但同时在 cas 中又会存在 ABA 问题，当一个线程对一个对象的值进行 cas 操作时，另外一个线程对值进行了两次修改，值最后改为旧值，此时就无法判断对象是否会被修改。</p><p>当然因为值未发生变化，多数情况也不会出现问题，但如果我们要记录的是对象的状态，比如被修改的次数，此时原子操作就会出问题。</p><p>为了解决 ABA 问题，伟大的 java 为我们提供了 AtomicMarkableReference 和 AtomicStampedReference 类，为我们解决了问题。</p><p>AtomicStampedReference 是利用版本戳的形式记录了每次改变以后的版本号，这样的话就不会存在 ABA 问题了。</p><h3 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h3><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8_2020-03-13-17-10-32.png" alt="JAVA并发——线程安全_2020-03-13-17-10-32.png"></p><h1 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h1><h2 id="什么是可见性"><a href="#什么是可见性" class="headerlink" title="什么是可见性?"></a>什么是可见性?</h2><p>可见性是指，当多个线程并发访问共享变量时，一个线程对共享变量的修改，其它线程能够立即看到。可见性问题是好多人忽略或者理解错误的一点。</p><p>CPU 从主内存中读数据的效率相对来说不高，现在主流的计算机中，都有几级缓存。每个线程读取共享变量时，都会将该变量加载进其对应 CPU 的高速缓存里，修改该变量后，CPU 会立即更新该缓存，但并不一定会立即将其写回主内存（实际上写回主内存的时间不可预期）。此时其它线程（尤其是不在同一个 CPU 上执行的线程）访问该变量时，从主内存中读到的就是旧的数据，而非第一个线程更新后的数据。</p><h2 id="怎么保证可见性？"><a href="#怎么保证可见性？" class="headerlink" title="怎么保证可见性？"></a>怎么保证可见性？</h2><h3 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h3><p>java 使用 volatile 关键字来保证可见性，通过加入内存屏障和禁止重排序优化来实现。</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8_2020-03-13-18-43-51.png" alt="JAVA并发——线程安全_2020-03-13-18-43-51.png"></p><h3 id="volatie-关键字能否保证原子性？"><a href="#volatie-关键字能否保证原子性？" class="headerlink" title="volatie 关键字能否保证原子性？"></a>volatie 关键字能否保证原子性？</h3><p>这时我们要注意的是，volatile 不能保证原子性，例如自增操作。我们知道一个变量在修改 volatile 变量时，会让缓存行无效，其他的线程会读到最新的值。但在自增操作中，线程 1 对变量进行读取操作之后，被阻塞了的话，并没有对 inc 值进行修改。然后虽然 volatile 能保证线程 2 对变量 inc 的值读取是从内存中读取的，但是线程 1 没有进行修改，所以线程 2 根本就不会看到修改的值。</p><h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>内存屏障（memory barrier） 是一个 CPU 指令。基本上，它是这样一条指令：</p><ol><li>确保一些特定操作执行的顺序；</li><li>影响一些数据的可见性(可能是某些指令执行后的结果)。</li></ol><p>编译器和 CPU 可以在保证输出结果一样的情况下对指令重排序，使性能得到优化。插入一个内存屏障， 相当于告诉 CPU 和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。内存屏障另一个作用是强制更新一次不同 CPU 的缓存。例如，一个写屏障会 把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个 cpu 核心或者哪颗 CPU 执行的。</p><h1 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h1><h2 id="什么是有序性？"><a href="#什么是有序性？" class="headerlink" title="什么是有序性？"></a>什么是有序性？</h2><p>处理器为了提高程序整体的执行效率，可能会对代码进行优化，其中的一项优化方式就是调整代码顺序，按照更高效的顺序执行代码。</p><p>讲到这里，有人要着急了——什么，CPU 不按照我的代码顺序执行代码，那怎么保证得到我们想要的效果呢？实际上，大家大可放心，CPU 虽然并不保证完全按照代码顺序执行，但它会保证程序最终的执行结果和代码顺序执行时的结果一致。</p><h2 id="如何保证有序性？"><a href="#如何保证有序性？" class="headerlink" title="如何保证有序性？"></a>如何保证有序性？</h2><p>Java 中可通过 volatile 在一定程序上保证顺序性，另外还可以通过 synchronized 和锁来保证顺序性。</p><p>synchronized 和锁保证顺序性的原理和保证原子性一样，都是通过保证同一时间只会有一个线程执行目标代码段来实现的。</p><p>除了从应用层面保证目标代码段执行的顺序性外，JVM 还通过被称为 happens-before 原则隐式地保证顺序性。</p><h1 id="happens-before-原则（先行发生原则）"><a href="#happens-before-原则（先行发生原则）" class="headerlink" title="happens-before 原则（先行发生原则）"></a>happens-before 原则（先行发生原则）</h1><ul><li>传递规则：如果操作 1 在操作 2 前面，而操作 2 在操作 3 前面，则操作 1 肯定会在操作 3 前发生。该规则说明了 happens-before 原则具有传递性</li><li>锁定规则：一个 unlock 操作肯定会在后面对同一个锁的 lock 操作前发生。这个很好理解，锁只有被释放了才会被再次获取</li><li>volatile 变量规则：对一个被 volatile 修饰的写操作先发生于后面对该变量的读操作</li><li>程序次序规则：一个线程内，按照代码顺序执行</li><li>线程启动规则：Thread 对象的 start()方法先发生于此线程的其它动作</li><li>线程终结原则：线程的终止检测后发生于线程中其它的所有操作</li><li>线程中断规则： 对线程 interrupt()方法的调用先发生于对该中断异常的获取</li><li>对象终结规则：一个对象构造先于它的 finalize 发生</li></ul><h1 id="还有什么别的方法保证线程安全？"><a href="#还有什么别的方法保证线程安全？" class="headerlink" title="还有什么别的方法保证线程安全？"></a>还有什么别的方法保证线程安全？</h1><p>有。尽可能避免引起非线程安全的条件——共享变量。如果能从设计上避免共享变量的使用，即可避免非线程安全的发生，也就无须通过锁或者 synchronized 以及 volatile 解决原子性、可见性和顺序性的问题。</p><h1 id="synchronized-即可修饰非静态方式，也可修饰静态方法，还可修饰代码块，有何区别？"><a href="#synchronized-即可修饰非静态方式，也可修饰静态方法，还可修饰代码块，有何区别？" class="headerlink" title="synchronized 即可修饰非静态方式，也可修饰静态方法，还可修饰代码块，有何区别？"></a>synchronized 即可修饰非静态方式，也可修饰静态方法，还可修饰代码块，有何区别？</h1><p>synchronized 修饰非静态同步方法时，锁住的是当前实例；synchronized 修饰静态同步方法时，锁住的是该类的 Class 对象；synchronized 修饰静态代码块时，锁住的是 synchronized 关键字后面括号内的对象。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java并发 线程安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA并发——并发模拟</title>
      <link href="/2020/03/13/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E6%A8%A1%E6%8B%9F/"/>
      <url>/2020/03/13/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="并发模拟工具"><a href="#并发模拟工具" class="headerlink" title="并发模拟工具"></a>并发模拟工具</h1><ol><li><p>Postman : Http 请求模拟工具</p></li><li><p>Apache Bench(AB) : Apache 附带的工具,测试网站性能</p></li><li><p>Jmeter : Apache 组织开发的压力测试工具</p></li></ol><h1 id="并发模拟代码"><a href="#并发模拟代码" class="headerlink" title="并发模拟代码"></a>并发模拟代码</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E6%A8%A1%E6%8B%9F_2020-03-13-16-01-29.png" alt="JAVA并发——并发模拟_2020-03-13-16-01-29.png"></p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>CountDownLatch 是一个同步工具类，用来协调多个线程之间的同步，或者说起到线程之间的通信（而不是用作互斥的作用）。</p><p>CountDownLatch 能够使一个线程在等待另外一些线程完成各自工作之后，再继续执行。使用一个计数器进行实现。计数器初始值为线程的数量。当每一个线程完成自己任务后，计数器的值就会减一。当计数器的值为 0 时，表示所有的线程都已经完成了任务，然后在 CountDownLatch 上等待的线程就可以恢复执行任务。CountDownLatch 的详细使用后续我们在深入讲解。</p><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E6%A8%A1%E6%8B%9F_2020-03-13-16-07-10.png" alt="JAVA并发——并发模拟_2020-03-13-16-07-10.png"></p><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>Semaphore 是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore 可以用来构建一些对象池，资源池之类的，比如数据库连接池，我们也可以创建计数为 1 的 Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。</p><h2 id="并发代码"><a href="#并发代码" class="headerlink" title="并发代码"></a>并发代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> modules;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//信号量，此处用于控制并发的线程数</span></span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="comment">//闭锁，可实现计数器递减</span></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//执行此方法用于获取执行许可，当总计未释放的许可数不超过200时，</span></span><br><span class="line">                <span class="comment">//允许通行，否则线程阻塞等待，直到获取到许可。</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    <span class="comment">//释放许可</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">//log.error("exception", e);</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//闭锁减一</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();<span class="comment">//线程阻塞，直到闭锁值为0时，阻塞才释放，继续往下执行</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"count:&#123;&#125;"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果安装以上代码执行，并不一定是线程安全的，原因是 count++操作在并发环境下不能保证数据一致性问题，这就涉及到线程安全的问题，请看<a href="JAVA并发——线程安全">下一章</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java并发 基础 并发模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA并发——基础</title>
      <link href="/2020/03/11/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/03/11/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>同时拥有两个或者多个线程，如果程序在单核处理器上运行，多个线程将交替地换入或者换出内存，这些线程是同时“存在”的，每个线程都处于执行过程中的某个状态，高速切换感觉同时执行。如果运行多核处理器上，此时，程序中的每个线程将分配到一个处理器核上，因此可以真正的同时运行。</p><h1 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h1><p>高并发（High Cuncurrency）是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并发处理很多请求。</p><h1 id="我们在讨论并发时主要考虑以下几点"><a href="#我们在讨论并发时主要考虑以下几点" class="headerlink" title="我们在讨论并发时主要考虑以下几点"></a>我们在讨论并发时主要考虑以下几点</h1><ol><li>多线程操作相同的资源</li><li>保证线程安全</li><li>合理分配和使用资源</li></ol><h1 id="我们在讨论高并发时主要考虑以下几点"><a href="#我们在讨论高并发时主要考虑以下几点" class="headerlink" title="我们在讨论高并发时主要考虑以下几点"></a>我们在讨论高并发时主要考虑以下几点</h1><ol><li>服务器能同时处理很多个请求</li><li>提高程序性能</li></ol><h1 id="请介绍下计算机系统层面上的并发"><a href="#请介绍下计算机系统层面上的并发" class="headerlink" title="请介绍下计算机系统层面上的并发?"></a>请介绍下计算机系统层面上的并发?</h1><h2 id="CPU-cache"><a href="#CPU-cache" class="headerlink" title="CPU cache"></a>CPU cache</h2><p>我们知道我们的 java 代码可以运行在不同的系统上的，同时我们也知道真正处理任务的操作是通过计算机系统完成的并发其实就是让计算机在同一时刻，能够运行更多的任务。</p><p>看起来很简单，实际上绝大多数的计算都不仅是 CPU 一个人的事，而是需要很多计算机系统部件共同参与。但是我们知道，计算机系统中运行速度最快就是 CPU，其他部件例如：内存、磁盘、网络等等都是及其缓慢的，同时这些操作在目前的计算机体系中是很难消除的，因为我们不可能仅仅靠寄存器就完成所有的计算任务。</p><p>面对高速 CPU 和低速存储之间的鸿沟，如果想要实现高效数据通讯，一个良好的解决方案就是在它们之间添加一个 cache 层，这个 cache 层的速度和整体的速度关系如下：</p><blockquote><p>CPU –&gt; cache –&gt; 存储</p></blockquote><p>这是计算机和软件领域通用的一个问题解决方案：增加中间层。没有什么问题是一个中间层解决不了的，如果有，那就两层。在运算的时候，CPU 将需要使用到的数据复制到 Cache 中，以后每次获取数据都从较为快速的 cache 中获取，加快访问速度。</p><h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2><p>所谓理想很丰面，现实很骨感。这种计算体系有一个重要的问题需要解决，那就是：缓存一致性（cache coherence）问题。在现代的计算机系统中，主要都是多核系统为主。在这些计算机系统中，每一个 CPU 都拥有自己独立的高速缓存，但是因为主存只有一个，因此它们之间只能共享，这种系统也称为：共享内存多核系统（Shared-Memory multiprocessors System），如下图所示：</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80_2020-03-11-20-08-57.png" alt="JAVA并发——基础_2020-03-11-20-08-57.png"></p><h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>因此，当多个处理器同时需要访问同一个内存区域的数据时，首先回去访问 CPU 的 cache 区域中的数据，但是 cache 中的数据也是从共享内存中获取的，此时如果别的 CPU 修改了 cache 中的数据，那么就造成了数据不一致的问题了。因此，如果发生了这种「数据竞态」的问题，到底该以哪个数据为准呢？此时，我们需要一个一致性协议来保证。各个 CPU 在操作的时候都需要遵守缓存一致性协议来进行操作，这类型的协议有很多，例如：MSI、MESI、MOSI、Synapse、Firefly 以及 Dragon Protocol 等等。所以，通常情况下，共享内存多核系统的架构如下所示：</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80_2020-03-11-20-12-11.png" alt="JAVA并发——基础_2020-03-11-20-12-11.png"></p><h2 id="指令集重排"><a href="#指令集重排" class="headerlink" title="指令集重排"></a>指令集重排</h2><p>为了能够充分利用多核 CPU 的处理性能，处理在实际执行机器指令时并不一定会按照程序设定的指令顺序执行，可能存在代码乱序执行（Out-Of-Order Execution）优化。注意，这里虽然乱序执行了，但是系统会保证执行的结果逻辑上的正确的，从宏观上看就好像是顺序执行一样。举个例子，比如我们有如下代码：</p><blockquote><p>int a = value1;</p></blockquote><blockquote><p>int b = value2;</p></blockquote><p>这两句话实际的执行顺序可能是先赋值 a 然后赋值 b，但是也可能反过来，反正这两句话执行完毕之后 a 和 b 的值都被赋值上了就可以，这里对外表现为顺序串行执行，这其实就是 as-serial 协议保证的。</p><p>为什么需要这样？一方面这两句话本身并没有什么逻辑上的依赖性，完全可以并行执行；另一方面，如果我们傻傻地按照顺序执行的话，在执行第一句话的时候，我们可能需要从主存中读取 value1 的值，这种操作对于 CPU 来讲是及其缓慢的操作，如果我们顺序执行的话，那么就只能等待 value1 值读取成功之后才能继续执行下面的指令，这样就造成了 CPU 的空等待，白白浪费了资源。</p><h1 id="java-内存模型"><a href="#java-内存模型" class="headerlink" title="java 内存模型"></a>java 内存模型</h1><p>上面我们介绍了计算机层面如何进行并行计算的，也探讨了共享内存多核系统的<br>内存模型。我们 java 的目标：一次编写，到处运行。所以我们需要在 JVM 层面将各系统的差异屏蔽掉，这就需要我们有一套 java 自己的内存模型。然后在不同的硬件平台和操作系统上分别利用本地接口来实现。这里的思想其实和增加 cache 是一样的，通过增加中间层来解决系统差异带来的协作问题。</p><p>Java 在 1.5 版本中引入了 JSR 133 标准，在 JSR 133 标准中，定义了如下的 Java 并发内存模型：</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80_2020-03-11-20-36-45.png" alt="JAVA并发——基础_2020-03-11-20-36-45.png"></p><p>在 JVM 中，并发的最小单位是 Thread，在不考虑 JVM 线程实现细节上，可以简单认为一个 Thread 对应一个内核线程，这样就可以进而认为 Thread 对应一个 CPU 核心。</p><h2 id="工作内存"><a href="#工作内存" class="headerlink" title="工作内存"></a>工作内存</h2><p>这里需要注意的是，工作内存和 Java 内存区域中的堆、栈或者方法区（java 和 native）等并不是一个层面上的东西，它们之间也没有直接的对应关系。如果说主内存存放的是 java 堆中的一些实例对象，那么工作内存应该位于 Java 虚拟机栈。但实际上为了获得更好的运行速度，jvm 和硬件系统可能会让工作内存储存于高速缓存和寄存器中。</p><h2 id="模拟场景"><a href="#模拟场景" class="headerlink" title="模拟场景"></a>模拟场景</h2><p>比如多个线程同时修改一个变量：线程 A 先从主内存中获取共享变量（a=2），然后在自己本地内存中计算（a+2），然后写入到主内存。<br>但此时 B 也从主内存获取（a=2），在本地内存改变（a+2）.写入到主内存。<br>在计算过程中两个线程间的数据是不可见的，此时就会出现结果不正确情况。</p><h2 id="同步操作与规则"><a href="#同步操作与规则" class="headerlink" title="同步操作与规则"></a>同步操作与规则</h2><p>从上面的模拟中我们知道线程间通信可能会出现数据一致性问题，从上面的图中，可以看出每个线程的工作内存和主存之间的一致性保证是通过 save 和 load 等等一系列的操作完成的。</p><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80_2020-03-11-20-44-01.png" alt="JAVA并发——基础_2020-03-11-20-44-01.png"></p><p>由上面的交互关系可知，关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java 内存模型定义了以下八种操作来完成：</p><p>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。</p><p>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</p><p>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的 load 动作使用</p><p>load（载入）：作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。</p><p>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</p><p>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</p><p>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的 write 的操作。</p><p>write（写入）：作用于主内存的变量，它把 store 操作从工作内存中一个变量的值传送到主内存的变量中。</p><h1 id="并发的优势和风险"><a href="#并发的优势和风险" class="headerlink" title="并发的优势和风险"></a>并发的优势和风险</h1><ul><li>优势<ul><li>速度：同时处理多个请求，响应更快。复杂的请求可以分为多个进程同时执行。</li><li>设计：程序设计在某些情况下更简单，也可以有更多的选择。</li><li>资源利用：CPU 能够在等待 IO 的时候做一些其他的事情。</li></ul></li><li>劣势<ul><li>安全性：多个线程共享数据时可能产生于期望不同的结果。</li><li>活跃性：某个操作无法继续进行下去时，就会发生活跃性问题，如死锁、饥饿等。</li><li>性能：线程过多，CPU 频繁切换，调度时间增多，同步机制消耗更多内存。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java并发 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA并发——课程导学</title>
      <link href="/2020/03/11/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E8%AF%BE%E7%A8%8B%E5%AF%BC%E5%AD%A6/"/>
      <url>/2020/03/11/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E8%AF%BE%E7%A8%8B%E5%AF%BC%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Java 是最先支持多线程的开发的语言之一，Java 从一开始就支持了多线程能力。因此 Java 开发者经常遇到多线程和并发问题，这就需要我们对于这方面的知识有一个很好的掌握。但我们又该怎样去学习并发编程哪？</p><h1 id="学习导向"><a href="#学习导向" class="headerlink" title="学习导向"></a>学习导向</h1><h2 id="基础知识讲解与核心知识储备"><a href="#基础知识讲解与核心知识储备" class="headerlink" title="基础知识讲解与核心知识储备"></a>基础知识讲解与核心知识储备</h2><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E8%AF%BE%E7%A8%8B%E5%AF%BC%E5%AD%A6_2020-03-11-19-32-55.png" alt="JAVA并发——课程导学_2020-03-11-19-32-55.png"></p><h2 id="多线程并发与线程安全"><a href="#多线程并发与线程安全" class="headerlink" title="多线程并发与线程安全"></a>多线程并发与线程安全</h2><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E8%AF%BE%E7%A8%8B%E5%AF%BC%E5%AD%A6_2020-03-11-19-33-40.png" alt="JAVA并发——课程导学_2020-03-11-19-33-40.png"></p><h2 id="高并发处理思路与手段"><a href="#高并发处理思路与手段" class="headerlink" title="高并发处理思路与手段"></a>高并发处理思路与手段</h2><p><img src="/images/JAVA%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E8%AF%BE%E7%A8%8B%E5%AF%BC%E5%AD%A6_2020-03-11-19-34-15.png" alt="JAVA并发——课程导学_2020-03-11-19-34-15.png"></p>]]></content>
      
      
      <categories>
          
          <category> JAVA并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java并发 基础 课程导学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA容器——ConcurrentHashMap</title>
      <link href="/2020/03/04/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ConcurrentHashMap/"/>
      <url>/2020/03/04/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ConcurrentHashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="我们已经知道了-HashMap-是不安全的，对于高并发我们常会选择用-ConcuerrentHashMap-为什么？"><a href="#我们已经知道了-HashMap-是不安全的，对于高并发我们常会选择用-ConcuerrentHashMap-为什么？" class="headerlink" title="我们已经知道了 HashMap 是不安全的，对于高并发我们常会选择用 ConcuerrentHashMap,为什么？"></a>我们已经知道了 HashMap 是不安全的，对于高并发我们常会选择用 ConcuerrentHashMap,为什么？</h1><p><code>HashMap</code> 在多线程环境下存在线程安全问题，一般在多线程的场景，我都会使用好几种不同的方式去代替：</p><ul><li>使用 <code>Collections.synchronizedMap(Map)</code> 创建线程安全的 <code>map</code> 集合；</li><li><code>Hashtable</code></li><li><code>ConcurrentHashMap</code></li></ul><p>但是仔细研究过源码的同学都知道，前两者保证线程安全的操作 <code>synchronized</code> 修饰方法，锁住整个 <code>hash</code> 表，效率低下。</p><p><code>ConcurrentHashMap</code> 对锁的粒度和锁的方式进行了优化，<code>jdk1.7</code> 采用了分段锁，而 <code>jdk1.8</code> 采用了 <code>CAS + synchronized</code> 的方式。保证了并发效率及安全性，具体见下文。</p><h1 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h1><p>ConcurrentHashMap 使用的是分段锁技术,将 ConcurrentHashMap 容器的数据分段存储,每一段数据分配一个 Segment,当线程占用一个 Segment 时,其他线程可以访问其他段的数据。</p><h2 id="请讲一下-JDK1-7-ConcurrentHashMap-数据结构"><a href="#请讲一下-JDK1-7-ConcurrentHashMap-数据结构" class="headerlink" title="请讲一下 JDK1.7 ConcurrentHashMap 数据结构"></a>请讲一下 JDK1.7 ConcurrentHashMap 数据结构</h2><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>是由 Segment 数组、HashEntry 组成，和 HashMap 一样，仍然是 <strong>数组加链表</strong>。</p><ul><li>Segment : 可重入锁,继承 <code>ReentrantLock</code>S 也称之为桶</li><li>HashEntry : 主要存储键值对 可以叫节点</li></ul><p>CurrentHashMap 包含一个 <code>Segment</code>数组，每个 <code>Segment</code> 包含一个<code>HashEntry</code> 数组并且守护它，当修改 <code>HashEntry</code> 数组数据时，需要先获取它对应的 <code>Segment</code> 锁；而 <code>HashEntry</code> 数组采用开链法处理冲突，所以它的每个 <code>HashEntry</code> 元素又是链表结构的元素。</p><h4 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h4><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ConcurrentHashMap_2020-03-04-17-11-30.png" alt="JAVA容器——ConcurrentHashMap_2020-03-04-17-11-30.png"></p><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ConcurrentHashMap_2020-03-04-17-23-51.png" alt="JAVA容器——ConcurrentHashMap_2020-03-04-17-23-51.png"></p><h2 id="请讲一下-JDK1-7-ConcurrentHashMap-操作方法和原理"><a href="#请讲一下-JDK1-7-ConcurrentHashMap-操作方法和原理" class="headerlink" title="请讲一下 JDK1.7 ConcurrentHashMap 操作方法和原理"></a>请讲一下 JDK1.7 ConcurrentHashMap 操作方法和原理</h2><h4 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>ConcurrentHashMap 继承自 AbstractMap 类，实现了 ConcurrentMap 和 Serializable 接口。</p><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><ul><li>默认初始化大小值 16</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br></pre></td></tr></table></figure><ul><li>默认负载因子大小 0.75</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure><ul><li>默认分段数量（最大并发线程数）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br></pre></td></tr></table></figure><ul><li>最大容量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure><ul><li>每个 segment 分段中表的最小容量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SEGMENT_TABLE_CAPACITY = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><ul><li>最大分段数量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SEGMENTS = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;</span><br></pre></td></tr></table></figure><ul><li>containsValue 方法不锁表的情况下尝试的次数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h4 id="segment"><a href="#segment" class="headerlink" title="segment"></a>segment</h4><h5 id="成员变量及构造函数"><a href="#成员变量及构造函数" class="headerlink" title="成员变量及构造函数"></a>成员变量及构造函数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自旋等待尝试加锁次数，单核为1，多核为64，Runtime.getRuntime().availableProcessors()方法获取CPU核心数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SCAN_RETRIES =</span><br><span class="line">            Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span> ? <span class="number">64</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表，即HashEntry数组（每个segment中都有一个table）</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//segment中元素个数</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改次数</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扩容阀值</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//负载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 构造函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Segment(<span class="keyword">float</span> lf, <span class="keyword">int</span> threshold, HashEntry&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">            <span class="keyword">this</span>.loadFactor = lf;</span><br><span class="line">            <span class="keyword">this</span>.threshold = threshold;</span><br><span class="line">            <span class="keyword">this</span>.table = tab;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h5><p>先尝试获取锁，如果加锁失败，则 scanAndLock 自旋等待（和上面的 put 方法相似）。</p><p>获取锁之后，(tab.length - 1) &amp; hash 计算删除节点在 table 中的下标。如果 table 中该位置的链表 <code>HashEntry</code> 不为空,循环判断链表中节点是否存在：</p><ul><li>存在，则替换 value 值，返回 OldValue。</li><li>如果不存在，新建节点，放在 frist 节点前。节点超出最大负载则 rehash。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 尝试进行加锁，如果加锁失败，则执行scanAndLockForPut方法，尝试加锁一定次数之后调用线程自中断方法（自旋等待）。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">                scanAndLockForPut(key, hash, value);</span><br><span class="line">            V oldValue;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">                <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">                HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;  <span class="comment">//for循环查找key是否存在，如果找到了，替换value值，返回oldValue</span></span><br><span class="line">                    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        K k;</span><br><span class="line">                        <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                            (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                            oldValue = e.value;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                                e.value = value;</span><br><span class="line">                                ++modCount;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        e = e.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;  <span class="comment">//如果没找到，新建HashEntry节点，放到first节点前面</span></span><br><span class="line">                        <span class="keyword">if</span> (node != <span class="keyword">null</span>)   <span class="comment">//scanAndLockForPut自旋等待时如果已经新建了节点，设置next值即可，setNext方法实现了延迟写。</span></span><br><span class="line">                            node.setNext(first);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                        <span class="keyword">int</span> c = count + <span class="number">1</span>;  <span class="comment">//元素个数加1，如果超过了阀值，则进行rehash，进行扩容</span></span><br><span class="line">                        <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                            rehash(node);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            setEntryAt(tab, index, node);   <span class="comment">//把新建节点放在链表的头位置</span></span><br><span class="line">                        ++modCount;</span><br><span class="line">                        count = c;</span><br><span class="line">                        oldValue = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();   <span class="comment">//最后释放锁</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h5 id="scanAndLockForPut-方法"><a href="#scanAndLockForPut-方法" class="headerlink" title="scanAndLockForPut 方法"></a>scanAndLockForPut 方法</h5><p>自旋锁，尝试加锁一定次数仍然失败进行线程自中断。</p><p>该方法先计算 hash 值在 table 中的位置，循环该位置上的链表查找 key 值。</p><p>如果不存在则新建节点，之后尝试加锁 MAX_SCAN_RETRIES 次，如果一直失败则挂起当前线程。</p><p>期间如果链表头被修改，则重新开始该过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">            HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">            HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> retries = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (!tryLock()) &#123;    <span class="comment">//获取锁失败时进入循环</span></span><br><span class="line">                HashEntry&lt;K,V&gt; f;</span><br><span class="line">                <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;  <span class="comment">//循环链表，找到key值或者不存在新建节点</span></span><br><span class="line">                    <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                            node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        retries = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))     <span class="comment">//如果找到了key值，</span></span><br><span class="line">                        retries = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        e = e.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                * 找到key值或者key值不存在新建节点之后，尝试加锁一定次数进入等待状态</span></span><br><span class="line"><span class="comment">                * 尝试次数，单核为1，多核为64</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">                    lock();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123; <span class="comment">//如果尝试加锁过程中发现链表头变化了，重置retries为-1，重新开始</span></span><br><span class="line">                    e = first = f;</span><br><span class="line">                    retries = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h5 id="rehash-方法"><a href="#rehash-方法" class="headerlink" title="rehash 方法"></a>rehash 方法</h5><p>对当前 <code>table</code> 进行扩容操作，大小变为原来的 2 倍，其中的元素会被重新分配位置，<code>oldTable[idx]</code> 上的链表上的元素可能会重新 <code>hash</code> 到 <code>newTable[idx]</code> 和 <code>newTbale[idx+n]</code> 的链表上,<code>n</code> 为 <code>oldTable</code> 的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>; <span class="comment">//newTable的大小为oldTable的2被</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">        (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">    <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">int</span> idx = e.hash &amp; sizeMask;    <span class="comment">//计算节点在newTable中的位置idx</span></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">//如果链表只有一个节点，直接放到newTable的idx上</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                * 与重新计算每个节点在newTable中的位置并依次进行头插法插入链表头相比，这里进行了优化</span></span><br><span class="line"><span class="comment">                * 1.计算链表中每个节点在newTable中的位置，但是并不立即插入链表头</span></span><br><span class="line"><span class="comment">                * 2.记住最后一个与它的上一个节点在新表中位置不同的节点lastRun，即链表中此节点之后的节点在newTable中的位置都相同</span></span><br><span class="line"><span class="comment">                * 3.把lastRun放到newTable中，它之后的节点会带过来</span></span><br><span class="line"><span class="comment">                * 4.计算lastRun之前的节点在newTable中的位置并依次进行头插法插入newTable中。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                     last != <span class="keyword">null</span>;</span><br><span class="line">                     last = last.next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// Clone remaining nodes</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                    <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// 把新节点放入newTable中</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove 方法"></a>remove 方法</h5><p>先尝试获取锁，如果加锁失败，则 scanAndLock 自旋等待（和上面的 put 方法相似）。</p><p>获取锁之后，(tab.length - 1) &amp; hash 计算删除节点在 table 中的下标，如果 table 中该位置的链表不为空，循环判断链表中节点是否和删除节点相等（value 为 null 时，key 相等即可，否则 key 和 value 均需相等）。</p><p>如果删除节点存在，设置 pre 节点的 next 指针指向 next 节点即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">remove</span><span class="params">(Object key, <span class="keyword">int</span> hash, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryLock())     <span class="comment">//尝试加锁</span></span><br><span class="line">        scanAndLock(key, hash);     <span class="comment">//加锁失败，则自旋等待</span></span><br><span class="line">    V oldValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;    <span class="comment">//计算hash值在table中的下标</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = entryAt(tab, index);</span><br><span class="line">        HashEntry&lt;K,V&gt; pred = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                V v = e.value;</span><br><span class="line">                <span class="keyword">if</span> (value == <span class="keyword">null</span> || value == v || value.equals(v)) &#123;   <span class="comment">//key相等时，value为null或者value也相等即为删除节点</span></span><br><span class="line">                    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                        setEntryAt(tab, index, next);   <span class="comment">//如果删除节点是头节点，设置头节点为next节点</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        pred.setNext(next);     <span class="comment">//否则设置上一个节点的next指针指向next节点</span></span><br><span class="line">                    ++modCount;     <span class="comment">//修改次数加1</span></span><br><span class="line">                    --count;        <span class="comment">//节点数量减1</span></span><br><span class="line">                    oldValue = v;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pred = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();   <span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hash-方法"><a href="#hash-方法" class="headerlink" title="hash 方法"></a>hash 方法</h4><p>用 key.hashCode()与 key.hashCode()向右位移 16 位值异或。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hashSeed;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="number">0</span> != h) &amp;&amp; (k <span class="keyword">instanceof</span> String)) &#123;</span><br><span class="line">            <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">        h += (h &lt;&lt;  <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line">        h += (h &lt;&lt;   <span class="number">3</span>);</span><br><span class="line">        h ^= (h &gt;&gt;&gt;  <span class="number">6</span>);</span><br><span class="line">        h += (h &lt;&lt;   <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</span><br><span class="line">        <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="定位-segment"><a href="#定位-segment" class="headerlink" title="定位 segment"></a>定位 segment</h4><p>ConcurrentHashMap 使用分段锁 Segment 来保护不同段的数据，那么在插入和获取元素的时候，必须先通过散列算法定位到 Segment。</p><p>首先对 key 的 hashCode 进行 hash 操作</p><p>运用散列算法定位 segment 的位置</p><ul><li><code>segmentMask</code>：段掩码，假如 segments 数组长度为 16，则段掩码为 16-1=15；segments 长度为 32，段掩码为 32-1=31。这样得到的所有 bit 位都为 1，可以更好地保证散列的均匀性</li><li><code>segmentShift</code>：2 的 sshift 次方等于 ssize，segmentShift=32-sshift。若 segments 长度为 16，segmentShift=32-4=28;若 segments 长度为 32，segmentShift=32-5=27。而计算得出的 hash 值最大为 32 位，无符号右移 segmentShift，则意味着只保留高几位（其余位是没用的），然后与段掩码 segmentMask 位运算来定位 Segment。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Segment&lt;K,V&gt; <span class="title">segmentFor</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="put-方法（ConcurrentHashMap）"><a href="#put-方法（ConcurrentHashMap）" class="headerlink" title="put 方法（ConcurrentHashMap）"></a>put 方法（ConcurrentHashMap）</h4><p>先计算 key 值在哪个 segment 中，然后调用 segment 的 put 方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        Segment&lt;K,V&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;      <span class="comment">//计算key落在哪个segment中</span></span><br><span class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject</span><br><span class="line">             (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>)</span><br><span class="line">            s = ensureSegment(j);                           <span class="comment">//如果segment不存在则初始化</span></span><br><span class="line">        <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);              <span class="comment">//调用segment的put方法</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="get-方法（ConcurrentHashMap）"><a href="#get-方法（ConcurrentHashMap）" class="headerlink" title="get 方法（ConcurrentHashMap）"></a>get 方法（ConcurrentHashMap）</h4><p>先计算 key 落在哪个 segment 中</p><p>如果 segment 不为 null 并且 table 不为 null，tab.length - 1) &amp; h 计算在 table 中的下标</p><p>循环链表的节点进行比较，如果 key 相等或者 hash 和 equals 方法相等，则返回 value 值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                     (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">                 e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))   <span class="comment">//如果key相等，或者重载的hash方法和equals方法相等</span></span><br><span class="line">                    <span class="keyword">return</span> e.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="remove-方法（ConcurrentHashMap）"><a href="#remove-方法（ConcurrentHashMap）" class="headerlink" title="remove 方法（ConcurrentHashMap）"></a>remove 方法（ConcurrentHashMap）</h4><p>remove 方法有两个，一个参数只有 key，一个参数是 key 和 value，所以 segment 的 remove 方法中 value 为 null 时，key 相等即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);                       <span class="comment">//计算hash值</span></span><br><span class="line">        Segment&lt;K,V&gt; s = segmentForHash(hash);      <span class="comment">//计算hash值落在哪个segment中</span></span><br><span class="line">        <span class="keyword">return</span> s == <span class="keyword">null</span> ? <span class="keyword">null</span> : s.remove(key, hash, <span class="keyword">null</span>);    <span class="comment">//调用segment的remove方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified key is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        Segment&lt;K,V&gt; s;</span><br><span class="line">        <span class="keyword">return</span> value != <span class="keyword">null</span> &amp;&amp; (s = segmentForHash(hash)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            s.remove(key, hash, value) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="你有没有发现-1-7-虽然可以支持每个-Segment-并发访问，但是还是存在一些问题？"><a href="#你有没有发现-1-7-虽然可以支持每个-Segment-并发访问，但是还是存在一些问题？" class="headerlink" title="你有没有发现 1.7 虽然可以支持每个 Segment 并发访问，但是还是存在一些问题？"></a>你有没有发现 1.7 虽然可以支持每个 Segment 并发访问，但是还是存在一些问题？</h2><p>是的，因为基本上还是数组加链表的方式，我们去查询的时候，还得遍历链表，会导致效率很低，这个跟 jdk1.7 的 HashMap 是存在的一样问题，所以他在 jdk1.8 完全优化了。</p><h1 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h1><p>jdk1.8 中 ConcurrentHashMap 有了很大的变化，不再是 segment 结构，而是使用类似乐观锁的方式（<code>CAS + synchronized</code>）来达到多线程安全的目的。</p><h2 id="请讲一下-JDK1-8-ConcurrentHashMap-数据结构"><a href="#请讲一下-JDK1-8-ConcurrentHashMap-数据结构" class="headerlink" title="请讲一下 JDK1.8 ConcurrentHashMap 数据结构"></a>请讲一下 JDK1.8 ConcurrentHashMap 数据结构</h2><p>把之前的 HashEntry 改成了 Node，但是作用不变，把值和 next 采用了 volatile 去修饰，保证了可见性，并且也引入了红黑树，在链表大于一定值的时候会转换（默认是 8）</p><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ConcurrentHashMap_2020-03-06-19-21-16.png" alt="JAVA容器——ConcurrentHashMap_2020-03-06-19-21-16.png"></p><h2 id="请讲一下-JDK1-8-ConcurrentHashMap-的属性、内部类"><a href="#请讲一下-JDK1-8-ConcurrentHashMap-的属性、内部类" class="headerlink" title="请讲一下 JDK1.8 ConcurrentHashMap 的属性、内部类"></a>请讲一下 JDK1.8 ConcurrentHashMap 的属性、内部类</h2><h4 id="类定义-1"><a href="#类定义-1" class="headerlink" title="类定义"></a>类定义</h4><p>ConcurrentHashMap 继承了 AbstractMap，实现了 ConcurrentMap 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><h4 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h4><ul><li>最大容量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure><ul><li>默认初始化的容量 16，容量必须是 2 的倍数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br></pre></td></tr></table></figure><ul><li>数组的最大容量，toArray 和相关方法会用到</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure><ul><li>默认分段数量（不再使用，兼容老版本）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br></pre></td></tr></table></figure><ul><li>默认负载因子</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure><ul><li>链表转换为树的阈值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br></pre></td></tr></table></figure><ul><li>树转化为链表的阈值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><ul><li>树结构的最小容量（当 table 中的其中一个链表长度达到 8 并且 table 中的节点总数达到 64 时，会把该链表转化为树结构，而如果 table 中的节点数量小于 64，不会进行树结构的转化，而是对 table 进行扩容以降低该链表的长度。）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure><ul><li>扩容时每个核心转移的间隔数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br></pre></td></tr></table></figure><ul><li>节点的 hash 值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// 表示该节点正在处理中</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// 表示该节点是树的根节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// 暂时保留</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// 正常节点的hash值可用的位数</span></span><br></pre></td></tr></table></figure><ul><li>CPU 的核心数量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br></pre></td></tr></table></figure><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul><li>table 表，volatile 修饰（一个线程修改该属性时，会立即写入到主存中，即对其他线程立即可见），transient 修饰符（序列化时忽略该属性，即该属性只存在内存中，而不会持久化到磁盘里）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><ul><li>newTable，进行扩容时会新建该表，其他线程发现该表不为空，说明已经有线程在进行扩容操作，就会帮助把 oldTable 中的数据扩容操作到此新表中，一起完成扩容操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br></pre></td></tr></table></figure><ul><li>baseCount 用于计算 size 的其中一个属性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br></pre></td></tr></table></figure><ul><li><p>控制 table 初始化和扩容的属性</p><ul><li>0 ，初始化值</li><li>-1，表示正在初始化</li><li>-N，表示 N-1 个线程正在一起进行扩容操作</li><li>N ，table 为 null 时，该值表示初始化的大小，table 不为 null，该值表示下一次扩容的大小</li></ul></li><li><p>扩容时下一个 table 下标</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br></pre></td></tr></table></figure><ul><li>扩容和 CounterCells 时的锁标识</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> KeySetView&lt;K,V&gt; keySet;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> ValuesView&lt;K,V&gt; values;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> EntrySetView&lt;K,V&gt; entrySet;</span><br></pre></td></tr></table></figure><h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><h5 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h5><p>Node 类实现了 Map.Entry 接口，主要存放 key-value 对，并且具有 next 域</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V val;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a>TreeNode</h5><p>树节点，继承于承载数据的 Node 类。而红黑树的操作是针对 TreeBin 类的，从该类的注释也可以看出，也就是 TreeBin 会将 TreeNode 进行再一次封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * Nodes <span class="keyword">for</span> use in TreeBins</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="TreeBin"><a href="#TreeBin" class="headerlink" title="TreeBin"></a>TreeBin</h5><p>这个类并不负责包装用户的 key、value 信息，而是包装的很多 TreeNode 节点。实际的 ConcurrentHashMap“数组”中，存放的是 TreeBin 对象，而不是 TreeNode 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; root;</span><br><span class="line">        <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">        <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line">        <span class="comment">// values for lockState</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ForwardingNode"><a href="#ForwardingNode" class="headerlink" title="ForwardingNode"></a>ForwardingNode</h5><p>在扩容时才会出现的特殊节点，其 key,value,hash 全部为 null。并拥有 nextTable 指针引用新的 table 数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line">   .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="你在上面提到-CAS-CAS-是什么"><a href="#你在上面提到-CAS-CAS-是什么" class="headerlink" title="你在上面提到 CAS,CAS 是什么?"></a>你在上面提到 CAS,CAS 是什么?</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>CAS 是乐观锁的一种实现方式，是一种轻量级锁，JUC 中很多工具类的实现就是基于 CAS 的。</p><h4 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h4><p>CAS 操作的流程如下图所示，线程在读取数据时不进行加锁，在准备写回数据时，比较原值是否修改，若未被其他线程修改则写回，若已被修改，则重新执行读取流程。</p><p>这是一种乐观策略，认为并发操作并不总会发生。</p><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ConcurrentHashMap_2020-03-06-18-50-14.png" alt="JAVA容器——ConcurrentHashMap_2020-03-06-18-50-14.png"></p><h4 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h4><p>一个线程把值改回了 B，又来了一个线程把值又改回了 A，对于这个时候判断的线程，就发现他的值还是 A，所以他就不知道这个值到底有没有被人改过，其实很多场景如果只追求最后结果正确，这是没关系的。</p><p>但是实际过程中还是需要记录修改过程的，比如资金修改什么的，你每次修改的都应该有记录，方便回溯。</p><p>CAS 无法判断 ABA 问题，这个时候我们可以用版本号、时间戳等来保证记录更新。</p><h4 id="关键操作"><a href="#关键操作" class="headerlink" title="关键操作"></a>关键操作</h4><h5 id="tabAt"><a href="#tabAt" class="headerlink" title="tabAt"></a>tabAt</h5><p>该方法用来获取 table 数组中索引为 i 的 Node 元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="casTabAt"><a href="#casTabAt" class="headerlink" title="casTabAt"></a>casTabAt</h5><p>利用 CAS 操作设置 table 数组中索引为 i 的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="setTabAt"><a href="#setTabAt" class="headerlink" title="setTabAt"></a>setTabAt</h5><p>该方法用来设置 table 数组中索引为 i 的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CAS-性能很高，但是我知道-synchronized-性能可不咋地，为啥-jdk1-8-升级之后反而多了-synchronized？"><a href="#CAS-性能很高，但是我知道-synchronized-性能可不咋地，为啥-jdk1-8-升级之后反而多了-synchronized？" class="headerlink" title="CAS 性能很高，但是我知道 synchronized 性能可不咋地，为啥 jdk1.8 升级之后反而多了 synchronized？"></a>CAS 性能很高，但是我知道 synchronized 性能可不咋地，为啥 jdk1.8 升级之后反而多了 synchronized？</h2><p>synchronized 之前一直都是重量级的锁，但是后来 java 官方是对他进行过升级的，他现在采用的是锁升级的方式去做的。</p><p>针对 synchronized 获取锁的方式，JVM 使用了锁升级的优化方式，就是先使用偏向锁优先同一线程然后再次获取锁，如果失败，就升级为 CAS 轻量级锁，如果失败就会短暂自旋，防止线程被系统挂起。最后如果以上都失败就升级为重量级锁。</p><h2 id="请你讲一下-JDK1-8-ConcurrentHashMap-的操作方法"><a href="#请你讲一下-JDK1-8-ConcurrentHashMap-的操作方法" class="headerlink" title="请你讲一下 JDK1.8 ConcurrentHashMap 的操作方法"></a>请你讲一下 JDK1.8 ConcurrentHashMap 的操作方法</h2><h4 id="构造器方法"><a href="#构造器方法" class="headerlink" title="构造器方法"></a>构造器方法</h4><p>ConcurrentHashMap 一共给我们提供了 5 中构造器方法，具体使用请看注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 构造一个空的map，即table数组还未初始化，初始化放在第一次插入数据时，默认大小为16</span></span><br><span class="line">ConcurrentHashMap()</span><br><span class="line"><span class="comment">// 2. 给定map的大小</span></span><br><span class="line">ConcurrentHashMap(<span class="keyword">int</span> initialCapacity)</span><br><span class="line"><span class="comment">// 3. 给定一个map</span></span><br><span class="line">ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)</span><br><span class="line"><span class="comment">// 4. 给定map的大小以及加载因子</span></span><br><span class="line">ConcurrentHashMap(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span><br><span class="line"><span class="comment">// 5. 给定map大小，加载因子以及并发度（预计同时操作数据的线程）</span></span><br><span class="line">ConcurrentHashMap(<span class="keyword">int</span> initialCapacity,<span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span><br></pre></td></tr></table></figure><p>我们来看看第 2 种构造器，传入指定大小时的情况，该构造器源码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line"><span class="comment">//1. 小于0直接抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"><span class="comment">//2. 判断是否超过了允许的最大值，超过了话则取最大值，否则再对该值进一步处理</span></span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line"><span class="comment">//3. 赋值给sizeCtl</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的逻辑请看注释，很容易理解，如果 <code>initialCapacity</code> 小于 0 就直接抛出异常，如果指定值大于了所允许的最大值的话就取最大值，否则，在对指定值做进一步处理。最后将 <code>cap</code> 赋值给 <code>sizeCtl</code></p><p>关于 <code>sizeCtl</code> 的说明请看上面的说明，当调用构造器方法之后，<strong><code>sizeCtl</code> 的大小应该就代表了 ConcurrentHashMap 的大小，即 table 数组长度。</strong></p><p>调用构造器方法的时候并未构造出 table 数组（可以理解为 ConcurrentHashMap 的数据容器），只是算出 table 数组的长度，当第一次向 ConcurrentHashMap 插入数据的时候才真正的完成初始化创建 table 数组的工作</p><h4 id="tableSizeFor"><a href="#tableSizeFor" class="headerlink" title="tableSizeFor"></a>tableSizeFor</h4><p>通过注释就很清楚了，该方法会将调用构造器方法时指定的大小转换成一个 2 的幂次方数，也就是说 ConcurrentHashMap 的大小一定是 2 的幂次方，比如，当指定大小为 18 时，为了满足 2 的幂次方特性，实际上 concurrentHashMapd 的大小为 2 的 5 次方（32）。</p><h4 id="initTable"><a href="#initTable" class="headerlink" title="initTable"></a>initTable</h4><p>ConcurrentHashMap 的初始化操作，保证只有一个线程正在进行初始化操作。</p><p>正在进行初始化的线程会调用 U.compareAndSwapInt 方法将 sizeCtl 改为-1 即正在初始化的状态。</p><p>有可能存在一个情况是多个线程同时走到这个方法中，为了保证能够正确初始化，在第 1 步中会先通过 if 进行判断，若当前已经有一个线程正在初始化即 sizeCtl 值变为-1，这个时候其他线程在 If 判断为 true 从而调用 Thread.yield()让出 CPU 时间片。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 1. 保证只有一个线程正在进行初始化操作</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 2. 得出数组的大小</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="comment">// 3. 这里才真正的初始化数组</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line"><span class="comment">// 4. 计算数组中可用的大小：实际大小n*0.75（加载因子）</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><ol><li><p><code>spread()</code> 重哈希</p><p>我们知道对于一个 <code>hash</code> 表来说，<code>hash</code> 值分散的不够均匀的话会大大增加哈希冲突的概率，从而影响到 <code>hash</code> 表的性能。因此通过 <code>spread</code> 方法进行了一次重 <code>hash</code> 从而大大减小哈希冲突的可能性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>初始化 <code>table</code></p><p>紧接着到第 2 步，会判断当前 <code>table</code> 数组是否初始化了，没有的话就调用 <code>initTable</code> 进行初始化，该方法在上面已经讲过了。</p></li><li><p>能否直接将新值插入到 table 数组中</p><p>通过 <code>(n - 1) &amp; hash</code> 确定数组中索引 <code>i</code> 的位置，</p><p>通过 <code>tabAt()</code> 方法（该方法在上面已经说明了，有疑问可以回过头去看看）获取该位置上的元素</p><p>如果当前 <code>Node f</code> 为 <code>null</code> 的话，就可以直接用 casTabAt 方法将新值插入即可。</p></li><li><p>当前是否正在扩容</p><p>如果当前节点不为 <code>null</code>，且该节点为特殊节点（<code>forwardingNode</code>）的话，就说明当前 <code>concurrentHashMap</code> 正在进行扩容操作，关于扩容操作，下面会作为一个具体的方法进行讲解。</p><p>那么怎样确定当前的这个 <code>Node</code> 是不是特殊的节点了？是通过判断该节点的 <code>hash</code> 值是不是等于<code>-1（MOVED</code>,代码为<code>(fh = f.hash) == MOVED</code>，对 <code>MOVED</code> 的解释在源码上也写的很清楚了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// hash for forwarding nodes</span></span><br></pre></td></tr></table></figure></li><li><p>当 <code>table[i]</code> 为链表的头结点，在链表中插入新值</p><p>在 <code>table[i]</code> 不为 <code>null</code> 并且不为 <code>forwardingNode</code> 时，并且当前 <code>Node f</code> 的 <code>hash</code> 值大于 <code>0（fh &gt;= 0）</code>的话说明当前节点 <code>f</code> 为当前桶的所有的节点组成的链表的头结点。</p><p>那么接下来，要想向 <code>ConcurrentHashMap</code> 插入新值的话就是向这个链表插入新值。通过 <code>synchronized (f)</code> 的方式进行加锁以实现线程安全性。</p><p>如果直到找到了链表的末尾都没有找到的话，就直接将待插入的键值对追加到链表的末尾即可。</p></li><li><p>当 table[i]为红黑树的根节点，在红黑树中插入新值</p><p>一旦出现拉链过长，甚至在极端情况下，查找一个节点会出现时间复杂度为 <code>O(n)</code> 的情况，则会严重影响 <code>ConcurrentHashMap</code> 的性能，于是，在 <code>JDK1.8</code> 版本中，对数据结构做了进一步的优化，引入了红黑树。</p><p>而当链表长度太长（默认超过 8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高 <code>ConcurrentHashMap</code> 的性能，其中会用到红黑树的插入、删除、查找等算法。</p><p>首先在 <code>if</code> 中通过 <code>f instanceof TreeBin</code> 判断当前 <code>table[i]</code> 是否是树节点，这下也正好验证了我们在最上面介绍时说的 <code>TreeBin</code> 会对 <code>TreeNode</code> 做进一步封装，对红黑树进行操作的时候针对的是 <code>TreeBin</code> 而不是 <code>TreeNode</code>。</p></li><li><p>根据当前节点个数进行调整</p><p>如果当前链表节点个数大于等于 <code>8（TREEIFY_THRESHOLD）</code>的时候，就会调用 <code>treeifyBin</code> 方法将 <code>tabel[i]</code>（第 i 个散列桶）拉链转换成红黑树。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"><span class="comment">//1. 计算key的hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line"><span class="comment">//2. 如果当前table还没有初始化先调用initTable方法将tab进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line"><span class="comment">//3. tab中索引为i的位置的元素为null，则直接使用CAS将值插入即可</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//4. 当前正在扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line"><span class="comment">//5. 当前为链表，在链表中插入新的键值对</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">// 6.当前为红黑树，将新的键值对插入到红黑树中</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 7.插入完键值对后再根据实际大小看是否需要转换成红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//8.对当前容量大小进行检查，如果超过了临界值（实际大小*加载因子）就需要扩容</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>看完了 put 方法再来看 get 方法就很容易了，用逆向思维去看就好，这样存的话我反过来这么取就好了</p><ol><li>首先先看当前的 hash 桶数组节点即 table[i]是否为查找的节点</li><li>若是则直接返回。若不是，则继续再看当前是不是树节点？</li><li>通过看节点的 hash 值是否为小于 0，如果小于 0 则为树节点。</li><li>如果是树节点在红黑树中查找节点；</li><li>如果不是树节点，那就只剩下为链表的形式的一种可能性了，就向后遍历查找节点，若查找到则返回节点的 value 即可，若没有找到就返回 null。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line"><span class="comment">// 1. 重hash</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2. table[i]桶节点的key与查找的key相同，则直接返回</span></span><br><span class="line"><span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 3. 当前节点hash小于0说明为树节点，在红黑树中查找即可</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//4. 从链表中查找，查找到则返回该节点的value，否则就返回null即可</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h4><p>当 <code>ConcurrentHashMap</code> 容量不足的时候，需要对 <code>table</code> 进行扩容。这个方法的基本思想跟 <code>HashMap</code> 是很像的，但是由于它是支持并发扩容的，所以要复杂的多。原因是它支持多线程进行扩容操作，而并没有加锁。我想这样做的目的不仅仅是为了满足 <code>concurrent</code> 的要求，而是希望利用并发处理去减少扩容带来的时间影响。</p><p><strong>第一部分</strong>是构建一个 <code>nextTable</code>,它的容量是原来的两倍，这个操作是单线程完成的。新建 <code>table</code> 数组的代码为: <code>Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1]</code> , 在原容量大小的基础上右移一位。</p><p><strong>第二部分</strong>就是将原来 <code>table</code> 中的元素复制到 <code>nextTable</code> 中，主要是遍历复制的过程。 根据运算得到当前遍历的数组的位置 <code>i</code>，然后利用 <code>tabAt</code> 方法获得 <code>i</code> 位置的元素再进行判断：</p><ol><li>如果这个位置为空，就在原 <code>table</code> 中的 <code>i</code> 位置放入 <code>forwardNode</code> 节点，这个也是触发并发扩容的关键点；</li><li>如果这个位置是 <code>Node</code> 节点<code>（fh&gt;=0）</code>，如果它是一个链表的头节点，就构造一个反序链表，把他们分别放在 <code>nextTable</code> 的 <code>i</code> 和 <code>i+n</code> 的位置上</li><li>如果这个位置是 <code>TreeBin</code> 节点<code>（fh&lt;0）</code>，也做一个反序处理，并且判断是否需要 <code>untreefi</code>，把处理的结果分别放在 <code>nextTable</code> 的 <code>i</code> 和 <code>i+n</code> 的位置上</li><li>遍历过所有的节点以后就完成了复制工作，这时让 <code>nextTable</code> 作为新的 <code>table</code>，并且更新 <code>sizeCtl</code> 为新容量的 <code>0.75</code> 倍 ，完成扩容。设置为新容量的 <code>0.75</code> 倍代码为 <code>sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1)</code>，仔细体会下是不是很巧妙，<code>n&lt;&lt;1</code> 相当于 <code>n</code> 左移一位表示 n 的两倍即 <code>2n</code>,<code>n&gt;&gt;&gt;1</code>，<code>n</code> 右移相当于 <code>n</code> 除以 <code>2</code> 即 <code>0.5n</code>,然后两者相减为 <code>2n-0.5n=1.5n</code>,是不是刚好等于新容量的 <code>0.75</code> 倍即 <code>2n*0.75=1.5n</code>。最后用一个示意图来进行总结（图片摘自网络）：</li></ol><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ConcurrentHashMap_2020-03-06-19-58-06.png" alt="JAVA容器——ConcurrentHashMap_2020-03-06-19-58-06.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>JDK6,7 中的 ConcurrentHashmap 主要使用 Segment 来实现减小锁粒度，分割成若干个 Segment，在 put 的时候需要锁住 Segment，get 时候不加锁，使用 volatile 来保证可见性，当要统计全局时（比如 size），首先会尝试多次计算 modcount 来确定，这几次尝试中，是否有其他线程进行了修改操作，如果没有，则直接返回 size。如果有，则需要依次锁住所有的 Segment 来计算。</p><p>1.8 之前 put 定位节点时要先定位到具体的 segment，然后再在 segment 中定位到具体的桶。而在 1.8 的时候摒弃了 segment 臃肿的设计，直接针对的是 Node[] tale 数组中的每一个桶，进一步减小了锁粒度。并且防止拉链过长导致性能下降，当链表长度大于 8 的时候采用红黑树的设计。</p><p>主要设计上的变化有以下几点:</p><ol><li>不采用 segment 而采用 node，锁住 node 来实现减小锁粒度。</li><li>设计了 MOVED 状态 当 resize 的中过程中 线程 2 还在 put 数据，线程 2 会帮助 resize。</li><li>使用 3 个 CAS 操作来确保 node 的一些操作的原子性，这种方式代替了锁。</li><li>sizeCtl 的不同值来代表不同含义，起到了控制的作用。</li><li>采用 synchronized 而不是 ReentrantLock</li></ol>]]></content>
      
      
      <categories>
          
          <category> JAVA容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java容器 ConcurrentHashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA容器——HashMap</title>
      <link href="/2020/02/25/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94HashMap/"/>
      <url>/2020/02/25/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94HashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="您能给我说说-HashMap-吗？"><a href="#您能给我说说-HashMap-吗？" class="headerlink" title="您能给我说说 HashMap 吗？"></a>您能给我说说 HashMap 吗？</h1><ol><li>HashMap 是基于 Map 接口实现的一种键-值对&lt;key,value&gt;的存储结构，允许 null 值，同时非有序，非同步(即线程不安全)。</li><li>HashMap 的底层实现是数组 + 链表 + 红黑树（JDK1.8 增加了红黑树部分。</li><li>它存储和查找数据时，是根据键 key 的 hashCode 的值计算出具体的存储位置。</li><li>HashMap 增删改查等常规操作都有不错的执行效率，是 ArrayList 和 LinkedList 等数据结构的一种折中实现。</li></ol><h1 id="HashMap-的一些组成部分"><a href="#HashMap-的一些组成部分" class="headerlink" title="HashMap 的一些组成部分"></a>HashMap 的一些组成部分</h1><p>HashMap 的底层实现是数组 + 链表 + 红黑树（JDK1.8 增加了红黑树部分。</p><h2 id="核心组成部分"><a href="#核心组成部分" class="headerlink" title="核心组成部分"></a>核心组成部分</h2><ol><li><p><code>int size;</code> 用于记录 HashMap 实际存储元素的个数；</p></li><li><p><code>float loadFactor;</code> 负载因子（默认是 0.75，此属性后面详细解释）。</p></li><li><p><code>int threshold;</code> 下一次扩容时的阈值，达到阈值便会触发扩容机制 resize（阈值 threshold = 容器容量 capacity * 负载因子 load factor）。也就是说，在容器定义好容量之后，负载因子越大，所能容纳的键值对元素个数就越多。</p></li><li><p><code>Node&lt;K,V&gt;[] table;</code> 底层数组，充当哈希表的作用，用于存储对应 hash 位置的元素 Node&lt;K,V&gt;，此数组长度总是 2 的 N 次幂。（具体原因后面详细解释）</p></li></ol><h2 id="哈希表存储的核心元素"><a href="#哈希表存储的核心元素" class="headerlink" title="哈希表存储的核心元素"></a>哈希表存储的核心元素</h2><ol><li><p><code>final int hash;</code> 元素的哈希值，决定元素存储在 Node&lt;K,V&gt;[] table;哈希表中的位置。由 final 修饰可知，当 hash 的值确定后，就不能再修改。</p></li><li><p><code>final K key;</code> 键，由 final 修饰可知，当 key 的值确定后，就不能再修改。</p></li><li><p><code>V value;</code> 值</p></li><li><p><code>Node&lt;K,V&gt; next;</code> 记录下一个元素结点(单链表结构，用于解决 hash 冲突)</p></li></ol><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94HashMap_2020-02-28-18-54-23.png" alt="JAVA容器——HashMap_2020-02-28-18-54-23.png"></p><h1 id="您能说说-HashMap-常用操作的底层实现原理吗？如存储-put-K-key-V-value-，查找-get-Object-key-，删除-remove-Object-key-，修改-replace-K-key-V-value-等操作。"><a href="#您能说说-HashMap-常用操作的底层实现原理吗？如存储-put-K-key-V-value-，查找-get-Object-key-，删除-remove-Object-key-，修改-replace-K-key-V-value-等操作。" class="headerlink" title="您能说说 HashMap 常用操作的底层实现原理吗？如存储 put(K key, V value)，查找 get(Object key)，删除 remove(Object key)，修改 replace(K key, V value)等操作。"></a>您能说说 HashMap 常用操作的底层实现原理吗？如存储 put(K key, V value)，查找 get(Object key)，删除 remove(Object key)，修改 replace(K key, V value)等操作。</h1><h2 id="put-添加"><a href="#put-添加" class="headerlink" title="put 添加"></a>put 添加</h2><ol><li><p>判断哈希表 <code>Node&lt;K,V&gt;[] table</code> 是否为空或者 <code>null</code>，是则执行 <code>resize()</code>方法进行扩容（初始化）。</p></li><li><p>根据插入的键值 <code>key</code> 的 <code>hash</code> 值（key 的 hashCode 值与 16 的位运算），通过<code>(n - 1) &amp; hash</code> 当前元素的 <code>hash</code> 值 <code>&amp; hash</code> 表长度 - 1（实际就是 <code>hash</code> 值 <code>% hash</code> 表长度） 计算出存储位置 <code>table[i]</code>。如果存储位置没有元素存放，则将新增结点存储在此位置 <code>table[i]</code>。</p></li><li><p>如果存储位置已经有键值对元素存在，则判断该位置元素的 <code>hash</code> 值和 <code>key</code> 值是否和当前操作元素一致，一致则证明是修改 <code>value</code> 操作，覆盖 <code>value</code> 即可。</p></li><li><p>当前存储位置即有元素，又不和当前操作元素一致，则证明此位置 <code>table[i]</code>已经发生了 <code>hash</code> 冲突，则通过判断头结点是否是 <code>treeNode</code>，如果是 <code>treeNode</code> 则证明此位置的结构是红黑树，已红黑树的方式新增结点。</p><ul><li>如果不是红黑树，则证明是单链表，将新增结点插入至链表的最后位置，随后判断当前链表长度是否 大于等于 8，是则将当前存储位置的链表转化为红黑树。遍历过程中如果发现 <code>key</code> 已经存在，则直接覆盖 <code>value</code>。</li><li>插入成功后，判断当前存储键值对的数量 大于 阈值 <code>threshold</code> 是则扩容。</li></ul></li></ol><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加key-value键值对</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果原本存在此key，则返回旧的value值，如果是新增的key-</span></span><br><span class="line"><span class="comment"> *         value，则返回nulll</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实际调用putVal方法进行添加 key-value 键值对操作</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key 键 的 hashCode 通过 “扰动函数” 生成对应的 hash值</span></span><br><span class="line"><span class="comment"> * 经过此操作后，使每一个key对应的hash值生成的更均匀，</span></span><br><span class="line"><span class="comment"> * 减少元素之间的碰撞几率（后面详细说明）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加key-value键值对的实际调用方法（重点）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash key 键的hash值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent 此值如果是true, 则如果此key已存在value，则不执</span></span><br><span class="line"><span class="comment"> * 行修改操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict 此值如果是false，哈希表是在初始化模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回原本的旧值, 如果是新增，则返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于记录当前的hash表</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="comment">// 用于记录当前的链表结点</span></span><br><span class="line">    Node&lt;K,V&gt; p;</span><br><span class="line">    <span class="comment">// n用于记录hash表的长度，i用于记录当前操作索引index</span></span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 当前hash表为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 初始化hash表，并把初始化后的hash表长度值赋值给n</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 1）通过 (n - 1) &amp; hash 当前元素的hash值 &amp; hash表长度 - 1</span></span><br><span class="line">    <span class="comment">// 2）确定当前元素的存储位置，此运算等价于 当前元素的hash值 % hash表的长度</span></span><br><span class="line">    <span class="comment">// 3）计算出的存储位置没有元素存在</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 4) 则新建一个Node结点，在该位置存储此元素</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 当前存储位置已经有元素存在了(不考虑是修改的情况的话，就代表发生hash冲突了)</span></span><br><span class="line">        <span class="comment">// 用于存放新增结点</span></span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="comment">// 用于临时存在某个key值</span></span><br><span class="line">        K k;</span><br><span class="line">        <span class="comment">// 1)如果当前位置已存在元素的hash值和新增元素的hash值相等</span></span><br><span class="line">        <span class="comment">// 2)并且key也相等，则证明是同一个key元素，想执行修改value操作</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;<span class="comment">// 将当前结点引用赋值给e</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 如果当前结点是树结点</span></span><br><span class="line">            <span class="comment">// 则证明当前位置的链表已变成红黑树结构，则已红黑树结点结构新增元素</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">// 排除上述情况，则证明已发生hash冲突，并hash冲突位置现时的结构是单链表结构</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//遍历单链表，将新元素结点放置此链表的最后一位</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 将新元素结点放在此链表的最后一位</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 新增结点后，当前结点数量是否大于等于 阈值 8</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">// 大于等于8则将链表转换成红黑树</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果链表中已经存在对应的key，则覆盖value</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// 已存在对应key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>) <span class="comment">//如果允许修改，则修改value为新值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 当前存储键值对的数量 大于 阈值 是则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">       <span class="comment">// 重置hash大小，将旧hash表的数据逐一复制到新的hash表中（后面详细讲解）</span></span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="comment">// 返回null，则证明是新增操作，而不是修改操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取值-get"><a href="#取值-get" class="headerlink" title="取值 get"></a>取值 get</h2><ol><li><p>先调用 <code>hash(key)</code>方法计算出 <code>key</code> 的 <code>hash</code>值。</p></li><li><p>根据查找的键值<code>key</code>的<code>hash</code>值，通过<code>(n - 1) &amp; hash</code>当前元素的<code>hash</code>值 <code>&amp; hash</code>表长度 <code>- 1</code>（实际就是 <code>hash</code>值 <code>% hash</code>表长度） 计算出存储位置<code>table[i]</code>，判断存储位置是否有元素存在 。</p><ul><li>如果存储位置有元素存放，则首先比较头结点元素，如果头结点的<code>key</code>的<code>hash</code>值 和 要获取的<code>key</code>的<code>hash</code>值相等，并且 头结点的<code>key</code>本身 和要获取的 <code>key</code> 相等，则返回该位置的头结点。</li><li>如果存储位置没有元素存放，则返回<code>null</code>。</li></ul></li><li><p>如果存储位置有元素存放，但是头结点元素不是要查找的元素，则需要遍历该位置进行查找。</p></li><li><p>先判断头结点是否是<code>treeNode</code>，如果是<code>treeNode</code>则证明此位置的结构是红黑树，以红色树的方式遍历查找该结点，没有则返回<code>null</code>。</p></li><li><p>如果不是红黑树，则证明是单链表。遍历单链表，逐一比较链表结点，链表结点的<code>key</code>的<code>hash</code>值 和 要获取的<code>key</code>的<code>hash</code>值相等，并且 链表结点的<code>key</code>本身 和要获取的 <code>key</code> 相等，则返回该结点，遍历结束仍未找到对应<code>key</code>的结点，则返回<code>null</code>。</p></li></ol><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定 key 所映射的 value 值</span></span><br><span class="line"><span class="comment"> * 或者 返回 null 如果容器里不存在对应的key</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 更确切地讲，如果此映射包含一个满足 (key==null ? k==null :key.equals(k))</span></span><br><span class="line"><span class="comment"> * 的从 k 键到 v 值的映射关系，</span></span><br><span class="line"><span class="comment"> * 则此方法返回 v；否则返回 null。（最多只能有一个这样的映射关系。）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回 null 值并不一定 表明该映射不包含该键的映射关系；</span></span><br><span class="line"><span class="comment"> * 也可能该映射将该键显示地映射为 null。可使用containsKey操作来区分这两种情况。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 1.先调用 hash(key)方法计算出 key 的 hash值</span></span><br><span class="line">    <span class="comment">// 2.随后调用getNode方法获取对应key所映射的value值</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取哈希表结点的方法实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash key 键的hash值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回对应的结点，如果结点不存在，则返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于记录当前的hash表</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="comment">// first用于记录对应hash位置的第一个结点，e充当工作结点的作用</span></span><br><span class="line">    Node&lt;K,V&gt; first, e;</span><br><span class="line">    <span class="comment">// n用于记录hash表的长度</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">// 用于临时存放Key</span></span><br><span class="line">    K k;</span><br><span class="line">    <span class="comment">// 通过 (n - 1) &amp; hash 当前元素的hash值 &amp; hash表长度 - 1</span></span><br><span class="line">    <span class="comment">// 判断当前元素的存储位置是否有元素存在</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;<span class="comment">//元素存在的情况</span></span><br><span class="line">       <span class="comment">// 如果头结点的key的hash值 和 要获取的key的hash值相等</span></span><br><span class="line">       <span class="comment">// 并且 头结点的key本身 和要获取的 key 相等</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node 总是检查头结点</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 返回该位置的头结点</span></span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;<span class="comment">// 头结点不相等</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 如果当前结点是树结点</span></span><br><span class="line">                <span class="comment">// 则证明当前位置的链表已变成红黑树结构</span></span><br><span class="line">                <span class="comment">// 通过红黑树结点的方式获取对应key结点</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;<span class="comment">// 当前位置不是红黑树，则证明是单链表</span></span><br><span class="line">                <span class="comment">// 遍历单链表，逐一比较链表结点</span></span><br><span class="line">                <span class="comment">// 链表结点的key的hash值 和 要获取的key的hash值相等</span></span><br><span class="line">                <span class="comment">// 并且 链表结点的key本身 和要获取的 key 相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 找到对应的结点则返回</span></span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过上述查找均无找到，则返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除-remove"><a href="#删除-remove" class="headerlink" title="删除 remove"></a>删除 remove</h2><ol><li><p>先调用 <code>hash(key)</code>方法计算出 <code>key</code> 的 <code>hash</code>值。</p></li><li><p>根据查找的键值<code>key</code>的<code>hash</code>值，通过<code>(n - 1) &amp; hash</code>当前元素的<code>hash</code>值 <code>&amp; hash</code>表长度 - 1（实际就是 <code>hash</code>值 <code>% hash</code>表长度） 计算出存储位置<code>table[i]</code>，判断存储位置是否有元素存在 。</p><ul><li>如果存储位置有元素存放，则首先比较头结点元素，如果头结点的 key 的 hash 值 和 要获取的 key 的 hash 值相等，并且 头结点的 key 本身 和要获取的 key 相等，则该位置的头结点即为要删除的结点，记录此结点至变量 node 中。</li><li>如果存储位置没有元素存放，则没有找到对应要删除的结点，则返回 null。</li></ul></li><li><p>如果存储位置有元素存放，但是头结点元素不是要删除的元素，则需要遍历该位置进行查找。<br>4, 先判断头结点是否是<code>treeNode</code>，如果是<code>treeNode</code>则证明此位置的结构是红黑树，以红色树的方式遍历查找并删除该结点，没有则返回<code>null</code>。</p></li><li><p>如果不是红黑树，则证明是单链表。遍历单链表，逐一比较链表结点，链表结点的<code>key</code>的<code>hash</code>值 和 要获取的<code>key</code>的<code>hash</code>值相等，并且 链表结点的<code>key</code>本身 和要获取的<code>key</code>相等，则此为要删除的结点，记录此结点至变量 <code>node</code> 中，遍历结束仍未找到对应<code>key</code>的结点，则返回<code>null</code>。</p></li><li><p>如果找到要删除的结点 <code>node</code>，则判断是否需要比较 <code>value</code> 也是否一致，如果 <code>value</code> 值一致或者不需要比较 <code>value</code> 值，则执行删除结点操作，删除操作根据不同的情况与结构进行不同的处理。</p><ul><li>如果当前结点是树结点，则证明当前位置的链表已变成红黑树结构，通过红黑树结点的方式删除对应结点。</li><li>如果不是红黑树，则证明是单链表。如果要删除的是头结点，则当前存储位置 <code>table[i]</code> 的头结点指向删除结点的下一个结点。</li><li>如果要删除的结点不是头结点，则将要删除的结点的后继结点 <code>node.next</code> 赋值给要删除结点的前驱结点的 <code>next</code> 域，即 <code>p.next = node.next;</code>。</li></ul></li><li><p><code>HashMap</code> 当前存储键值对的数量 <code>- 1</code>，并返回删除结点。</p></li></ol><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从此映射中移除指定键的映射关系（如果存在）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  key 其映射关系要从映射中移除的键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 与 key 关联的旧值；如果 key 没有任何映射关系，则返回 null。</span></span><br><span class="line"><span class="comment"> *        （返回 null 还可能表示该映射之前将 null 与 key 关联。）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 1.先调用 hash(key)方法计算出 key 的 hash值</span></span><br><span class="line">    <span class="comment">// 2.随后调用removeNode方法删除对应key所映射的结点</span></span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除哈希表结点的方法实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 键的hash值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 用于比较的value值，当matchValue 是 true时才有效, 否则忽略</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> matchValue 如果是 true 只有当value相等时才会移除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> movable 如果是 false当执行移除操作时，不删除其他结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回删除结点node，不存在则返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于记录当前的hash表</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="comment">// 用于记录当前的链表结点</span></span><br><span class="line">    Node&lt;K,V&gt; p;</span><br><span class="line">    <span class="comment">// n用于记录hash表的长度，index用于记录当前操作索引index</span></span><br><span class="line">    <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">// 通过 (n - 1) &amp; hash 当前元素的hash值 &amp; hash表长度 - 1</span></span><br><span class="line">    <span class="comment">// 判断当前元素的存储位置是否有元素存在</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;<span class="comment">// 元素存在的情况</span></span><br><span class="line">        <span class="comment">// node 用于记录找到的结点，e为工作结点</span></span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e;</span><br><span class="line">        K k; V v;</span><br><span class="line">       <span class="comment">// 如果头结点的key的hash值 和 要获取的key的hash值相等</span></span><br><span class="line">       <span class="comment">// 并且 头结点的key本身 和要获取的 key 相等</span></span><br><span class="line">       <span class="comment">// 则证明此头结点就是要删除的结点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 记录要删除的结点的引用地址至node中</span></span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;<span class="comment">// 头结点不相等</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)<span class="comment">// 如果当前结点是树结点</span></span><br><span class="line">                <span class="comment">// 则证明当前位置的链表已变成红黑树结构</span></span><br><span class="line">                <span class="comment">// 通过红黑树结点的方式获取对应key结点</span></span><br><span class="line">                <span class="comment">// 记录要删除的结点的引用地址至node中</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">// 当前位置不是红黑树，则证明是单链表</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">// 遍历单链表，逐一比较链表结点</span></span><br><span class="line">                    <span class="comment">// 链表结点的key的hash值 和 要获取的key的hash值相等</span></span><br><span class="line">                    <span class="comment">// 并且 链表结点的key本身 和要获取的 key 相等</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        <span class="comment">// 找到则记录要删除的结点的引用地址至node中，中断遍历</span></span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果找到要删除的结点，则判断是否需要比较value也是否一致</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">// value值一致或者不需要比较value值，则执行删除结点操作</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 如果当前结点是树结点</span></span><br><span class="line">                <span class="comment">// 则证明当前位置的链表已变成红黑树结构</span></span><br><span class="line">                <span class="comment">// 通过红黑树结点的方式删除对应结点</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p) <span class="comment">// node 和 p相等，则证明删除的是头结点</span></span><br><span class="line">                <span class="comment">// 当前存储位置的头结点指向删除结点的下一个结点</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 删除的不是头结点</span></span><br><span class="line">                <span class="comment">// p是删除结点node的前驱结点，p的next改为记录要删除结点node的后继结点</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">           <span class="comment">// 当前存储键值对的数量 - 1</span></span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="comment">// 返回删除结点</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不存在要删除的结点，则返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="替换-replace"><a href="#替换-replace" class="headerlink" title="替换 replace"></a>替换 replace</h2><ol><li><p>先调用 <code>hash(key)</code>方法计算出 <code>key</code> 的 <code>hash</code>值</p></li><li><p>随后调用<code>getNode</code>方法获取对应<code>key</code>所映射的<code>value</code>值 。</p></li><li><p>记录元素旧值，将新值赋值给元素，返回元素旧值，如果没有找到元素，则返回<code>null</code>。</p></li></ol><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 替换指定 key 所映射的 value 值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 对应要替换value值元素的key键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要替换对应元素的新value值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回原本的旧值，如果没有找到key对应的元素，则返回null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8 JDK1.8新增方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 1.先调用 hash(key)方法计算出 key 的 hash值</span></span><br><span class="line">    <span class="comment">// 2.随后调用getNode方法获取对应key所映射的value值</span></span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span>) &#123;<span class="comment">// 如果找到对应的元素</span></span><br><span class="line">        <span class="comment">// 元素旧值</span></span><br><span class="line">        V oldValue = e.value;</span><br><span class="line">        <span class="comment">// 将新值赋值给元素</span></span><br><span class="line">        e.value = value;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="comment">// 返回元素旧值</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有找到元素，则返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="hash-冲突（或者叫-hash-碰撞）是什么？为什么会出现这种现象，如何解决-hash-冲突？"><a href="#hash-冲突（或者叫-hash-碰撞）是什么？为什么会出现这种现象，如何解决-hash-冲突？" class="headerlink" title="hash 冲突（或者叫 hash 碰撞）是什么？为什么会出现这种现象，如何解决 hash 冲突？"></a>hash 冲突（或者叫 hash 碰撞）是什么？为什么会出现这种现象，如何解决 hash 冲突？</h1><h2 id="hash-冲突"><a href="#hash-冲突" class="headerlink" title="hash 冲突"></a>hash 冲突</h2><p>当我们调用<code>put(K key, V value)</code>操作添加<code>key-value</code>键值对，这个<code>key-value</code>键值对存放在的位置是通过扰动函数<code>(key == null)? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>计算键 <code>key</code> 的 <code>hash</code> 值。随后将 这个 <code>hash</code> 值 <code>%</code>模上 哈希表 <code>Node&lt;K,V&gt;[] table</code> 的长度 得到具体的存放位置。所以 <code>put(K key, V value)</code>多个元素，是有可能计算出相同的存放位置。此现象就是 <code>hash</code> 冲突或者叫 <code>hash</code> 碰撞。</p><h2 id="hash-冲突的避免"><a href="#hash-冲突的避免" class="headerlink" title="hash 冲突的避免"></a>hash 冲突的避免</h2><p>既然会发生<code>hash</code>冲突，我们就应该想办法避免此现象的发生，解决这个问题最关键就是如果生成元素的<code>hash</code>值。<code>Java</code>是使用“扰动函数”生成元素的<code>hash</code>值。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDK 7 的 hash方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">     h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">     <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDK 8 的 hash方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>Java7 做了 4 次 16 位右位移异或混合，Java 8 中这步已经简化了，只做一次 16 位右位移异或混合，而不是四次，但原理是不变的。例子如下：</p><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94HashMap_2020-02-28-19-50-28.png" alt="JAVA容器——HashMap_2020-02-28-19-50-28.png"></p><p>右位移 16 位，正好是 32bit 的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来</p><h2 id="hash-冲突解决："><a href="#hash-冲突解决：" class="headerlink" title="hash 冲突解决："></a>hash 冲突解决：</h2><p>解决<code>hash</code>冲突的方法有很多，常见的有：开发定址法，再散列法，链地址法，公共溢出区法。<code>HashMap</code>是使用链地址法解决<code>hash</code>冲突的，当有冲突元素放进来时，会将此元素插入至此位置链表的最后一位，形成单链表。但是由于是单链表的缘故，每当通过<code>hash % length</code>找到该位置的元素时，均需要从头遍历链表，通过逐一比较<code>hash</code>值，找到对应元素。如果此位置元素过多，造成链表过长，遍历时间会大大增加，最坏情况下的时间复杂度为<code>O(N)</code>，造成查找效率过低。所以当存在位置的链表长度 大于等于 <code>8</code> 时，<code>HashMap</code>会将链表 转变为 红黑树，红黑树最坏情况下的时间复杂度为<code>O(logn)</code>。以此提高查找效率。</p><h1 id="HashMap-的容量为什么一定要是-2-的-n-次方？"><a href="#HashMap-的容量为什么一定要是-2-的-n-次方？" class="headerlink" title="HashMap 的容量为什么一定要是 2 的 n 次方？"></a>HashMap 的容量为什么一定要是 2 的 n 次方？</h1><h2 id="运算效率高"><a href="#运算效率高" class="headerlink" title="运算效率高"></a>运算效率高</h2><p>因为调用 <code>put(K key, V value)</code> 操作添加<code>key-value</code>键值对时，具体确定此元素的位置是通过 <code>hash</code>值 <code>%</code> 模上 哈希表<code>Node&lt;K,V&gt;[] table</code>的长度 <code>hash % length</code> 计算的。但是”模”运算的消耗相对较大，通过位运算<code>h &amp; (length-1)</code>也可以得到取模后的存放位置，而位运算的运行效率高，但只有 length 的长度是 2 的 n 次方时，<code>h &amp; (length-1)</code> 才等价于 <code>h % length</code>。</p><h2 id="分布均匀"><a href="#分布均匀" class="headerlink" title="分布均匀"></a>分布均匀</h2><p>而且当数组长度为 2 的 n 次幂的时候，不同的<code>key</code>算出的<code>index</code>相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。</p><h1 id="HashMap-的负载因子是什么，有什么作用？"><a href="#HashMap-的负载因子是什么，有什么作用？" class="headerlink" title="HashMap 的负载因子是什么，有什么作用？"></a>HashMap 的负载因子是什么，有什么作用？</h1><p>负载因子表示哈希表空间的使用程度</p><ul><li>当负载因子越大，则<code>HashMap</code>的装载程度就越高。也就是能容纳更多的元素，元素多了，发生<code>hash</code>碰撞的几率就会加大，从而链表就会拉长，此时的查询效率就会降低。</li><li>当负载因子越小，则链表中的数据量就越稀疏，此时会对空间造成浪费，但是此时查询效率高。</li></ul><h1 id="扩容？它是怎么扩容的呢？"><a href="#扩容？它是怎么扩容的呢？" class="headerlink" title="扩容？它是怎么扩容的呢？"></a>扩容？它是怎么扩容的呢？</h1><p>当 <code>put</code> 时，如果发现目前的 <code>bucket</code> 占用程度已经超过了 <code>Load Factor</code> 所希望的比例，那么就会发生 <code>resize</code>。在 <code>resize</code> 的过程，简单的说就是把 <code>bucket</code> 扩充为 2 倍，之后重新计算 <code>index</code>，把节点再放到新的 <code>bucket</code> 中。</p><p>当超过限制的时候会<code>resize</code>，然而又因为我们使用的是 2 次幂的扩展(指长度扩为原来 2 倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动 2 次幂的位置。</p><p>怎么理解呢？例如我们从 16 扩展为 32 时，具体的变化如下所示：</p><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94HashMap_2020-02-28-20-03-28.png" alt="JAVA容器——HashMap_2020-02-28-20-03-28.png"></p><p>因此元素在重新计算 <code>hash</code> 之后，因为 n 变为 2 倍，那么 <code>n-1</code> 的 mask 范围在高位多 1bit(红色)，因此新的 index 就会发生这样的变化：</p><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94HashMap_2020-02-28-20-04-09.png" alt="JAVA容器——HashMap_2020-02-28-20-04-09.png"></p><p>因此，我们在扩充 <code>HashMap</code> 的时候，不需要重新计算 <code>hash</code>，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就好了，是 0 的话索引没变，是 1 的话索引变成“原索引+oldCap”。</p><p>这个设计确实非常的巧妙，既省去了重新计算 <code>hash</code> 值的时间，而且同时，由于新增的 1bit 是 0 还是 1 可以认为是随机的，因此 <code>resize</code> 的过程，均匀的把之前的冲突的节点分散到新的 <code>bucket</code> 了。</p><h1 id="拉链法插入链表-为啥-java7-之前用头插法，java8-之后改成尾插了呢？"><a href="#拉链法插入链表-为啥-java7-之前用头插法，java8-之后改成尾插了呢？" class="headerlink" title="拉链法插入链表 为啥 java7 之前用头插法，java8 之后改成尾插了呢？"></a>拉链法插入链表 为啥 java7 之前用头插法，java8 之后改成尾插了呢？</h1><p>使用头插会改变链表的上的顺序，但是如果使用尾插，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了。</p><ul><li>Java7 在多线程操作 HashMap 时可能引起死循环，原因是扩容转移后前后链表顺序倒置，在转移过程中修改了原来链表中节点的引用关系。</li><li>Java8 在同样的前提下并不会引起死循环，原因是扩容转移后前后链表顺序不变，保持之前节点的引用关系。</li></ul><h1 id="您能说说-HashMap-和-HashTable-的区别吗？"><a href="#您能说说-HashMap-和-HashTable-的区别吗？" class="headerlink" title="您能说说 HashMap 和 HashTable 的区别吗？"></a>您能说说 HashMap 和 HashTable 的区别吗？</h1><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>Hashtable 继承了 Dictionary 类，而 HashMap 继承的是 AbstractMap 类。</p><h2 id="容器整体结构"><a href="#容器整体结构" class="headerlink" title="容器整体结构"></a>容器整体结构</h2><ul><li><code>HashMap</code>的<code>key</code>和<code>value</code>都允许为<code>null</code>，<code>HashMap</code>遇到<code>key</code>为<code>null</code>的时候，调用<code>putForNullKey</code>方法进行处理，而对<code>value</code>没有处理。</li><li><code>Hashtable</code> 的 <code>key</code> 和 <code>value</code> 都不允许为 <code>null</code>。<code>Hashtable</code> 遇到 <code>null</code>，直接返回 <code>NullPointerException</code>。</li></ul><h2 id="初始化容量和扩容机制"><a href="#初始化容量和扩容机制" class="headerlink" title="初始化容量和扩容机制"></a>初始化容量和扩容机制</h2><ul><li><code>HashMap</code>默认初始化容量为 16，并且容器容量一定是 2 的 n 次方，扩容时，是以原容量 2 倍 的方式 进行扩容。</li><li><code>Hashtable</code>默认初始化容量为 11，扩容时，是以原容量 2 倍 再加 1 的方式进行扩容。即<code>int newCapacity = (oldCapacity &lt;&lt; 1) + 1</code>;。</li></ul><h2 id="迭代方式不同"><a href="#迭代方式不同" class="headerlink" title="迭代方式不同"></a>迭代方式不同</h2><p>HashMap 中的 Iterator 迭代器是 fail-fast 的，而 Hashtable 的 Enumerator 不是 fail-fast 的。</p><h2 id="线程安全（最重要）"><a href="#线程安全（最重要）" class="headerlink" title="线程安全（最重要）"></a>线程安全（最重要）</h2><ul><li><code>HashMap</code> 不是线程安全，如果想线程安全，可以通过调用<code>synchronizedMap(Map&lt;K,V&gt; m)</code>使其线程安全。但是使用时的运行效率会下降，所以建议使用<code>ConcurrentHashMap</code>容器以此达到线程安全。</li><li><code>Hashtable</code>则是线程安全的，每个操作方法前都有<code>synchronized</code>修饰使其同步，但运行效率也不高，所以还是建议使用<code>ConcurrentHashMap</code>容器以此达到线程安全。</li></ul><p>因此，<code>Hashtable</code>是一个遗留容器，如果我们不需要线程同步，则建议使用<code>HashMap</code>，如果需要线程同步，则建议使用<code>ConcurrentHashMap</code>。</p><h1 id="谈谈-HashMap-线程不安全的体现"><a href="#谈谈-HashMap-线程不安全的体现" class="headerlink" title="谈谈 HashMap 线程不安全的体现"></a>谈谈 HashMap 线程不安全的体现</h1><p>那么，为什么说 HashMap 是线程不安全的呢？它在多线程环境下，会发生什么情况呢？</p><h2 id="resize-死循环-JDK7"><a href="#resize-死循环-JDK7" class="headerlink" title="resize 死循环(JDK7)"></a>resize 死循环(JDK7)</h2><p>我们都知道 HashMap 初始容量大小为 16,一般来说，当有数据要插入时，都会检查容量有没有超过设定的 thredhold，如果超过，需要增大 Hash 表的尺寸，但是这样一来，整个 Hash 表里的元素都需要被重算一遍。这叫 rehash，这个成本相当的大。<br>对索引数组中的元素遍历</p><p>对链表上的每一个节点遍历：用 next 取得要转移那个元素的下一个，将 e 转移到新 Hash 表的头部，使用头插法插入节点。</p><p>循环 2，直到链表节点全部转移</p><p>循环 1，直到所有索引数组全部转移</p><p>经过这几步，我们会发现转移的时候是逆序的。假如转移前链表顺序是 1-&gt;2-&gt;3，那么转移后就会变成 3-&gt;2-&gt;1。这时候就有点头绪了，死锁问题不就是因为 1-&gt;2 的同时 2-&gt;1 造成的吗？所以，HashMap 的死锁问题就出在这个 transfer()函数上。</p><h2 id="fail-fast"><a href="#fail-fast" class="headerlink" title="fail-fast"></a>fail-fast</h2><p>如果在使用迭代器的过程中有其他线程修改了 map，那么将抛出 ConcurrentModificationException，这就是所谓 fail-fast 策略。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java容器 HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA容器——LinkedList</title>
      <link href="/2020/02/25/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94LinkedList/"/>
      <url>/2020/02/25/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94LinkedList/</url>
      
        <content type="html"><![CDATA[<h1 id="请简单介绍一下您所了解的-LinkedList，它可以用来做什么，怎么使用？"><a href="#请简单介绍一下您所了解的-LinkedList，它可以用来做什么，怎么使用？" class="headerlink" title="请简单介绍一下您所了解的 LinkedList，它可以用来做什么，怎么使用？"></a>请简单介绍一下您所了解的 LinkedList，它可以用来做什么，怎么使用？</h1><ol><li>LinkedList 底层是双向链表，同时实现了<code>List</code>接口和<code>Deque</code>接口，所以它既可以看作是一个顺序容器，也可以看作是一个队列(Queue)，同时也可以看作是一个栈(Stack)，但如果想使用栈或队列等数据结构的话，推荐使用 ArrayDeque，它作为栈或队列会比 LinkedList 有更好的使用性能。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个LinkedList，链表的每个节点的内存空间都是实时分配的，所以无须事先指定容器大小</span></span><br><span class="line">LinkedList&lt;String&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line"><span class="comment">// 往容器里面添加元素</span></span><br><span class="line">linkedList.add(<span class="string">"张三"</span>);</span><br><span class="line">linkedList.add(<span class="string">"李四"</span>);</span><br><span class="line"><span class="comment">// 在张三与李四之间插入一个王五</span></span><br><span class="line">linkedList.add(<span class="number">1</span>, <span class="string">"王五"</span>);</span><br><span class="line"><span class="comment">// 在头部插入一个小三</span></span><br><span class="line">linkedList.addFirst(<span class="string">"小三"</span>);</span><br><span class="line"><span class="comment">// 获取index下标为2的元素 王五</span></span><br><span class="line">String element = linkedList.get(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 修改index下标为2的元素 王五 为小四</span></span><br><span class="line">linkedList.set(<span class="number">2</span>, <span class="string">"小四"</span>);</span><br><span class="line"><span class="comment">// 删除index下标为1的元素 张三</span></span><br><span class="line">String removeElement = linkedList.remove(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 删除第一个元素</span></span><br><span class="line">String removeFirstElement = linkedList.removeFirst();</span><br><span class="line"><span class="comment">// 删除最后一个元素</span></span><br><span class="line">String removeLastElement = linkedList.removeLast();</span><br></pre></td></tr></table></figure><ol start="2"><li>LinkedList 底层实现是双向链表，核心组成元素有：<code>int size = 0</code>用于记录链表长度；<code>Node&lt;E&gt; first</code>;用于记录头（第一个）结点（储存的是头结点的引用）；<code>Node&lt;E&gt; last</code>;用于记录尾（最后一个）结点（储存的是尾结点的引用）。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 记录链表长度</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to first node. 指向第一个结点</span></span><br><span class="line"><span class="comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">     *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to last node. 指向最后一个结点</span></span><br><span class="line"><span class="comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">     *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>双向链表的核心组成元素还有一个最重要的<code>Node&lt;E&gt;</code>，<code>Node&lt;E&gt;</code>包含：<code>E item</code>; 用于存储元素数据，<code>Node&lt;E&gt; next</code>; 指向当前元素的后继结点，<code>Node&lt;E&gt; prev</code>; 指向当前元素的前驱结点。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义LinkedList底层的结点实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item; <span class="comment">// 存储元素数据</span></span><br><span class="line">    Node&lt;E&gt; next;<span class="comment">// 指向当前元素的后继结点</span></span><br><span class="line">    Node&lt;E&gt; prev;<span class="comment">// 指向当前元素的前驱结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Node结点构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;<span class="comment">// 存储的元素</span></span><br><span class="line">        <span class="keyword">this</span>.next = next;<span class="comment">// 后继结点</span></span><br><span class="line">        <span class="keyword">this</span>.prev = prev;<span class="comment">// 前驱结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>双向链表底层视图：</li></ul><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94LinkedList_2020-02-25-16-22-31.png" alt="JAVA容器——LinkedList_2020-02-25-16-22-31.png"></p><h1 id="请分别分析一下它是如何获取元素，修改元素，新增元素与删除元素，并分析这些操作对应的时间复杂度。"><a href="#请分别分析一下它是如何获取元素，修改元素，新增元素与删除元素，并分析这些操作对应的时间复杂度。" class="headerlink" title="请分别分析一下它是如何获取元素，修改元素，新增元素与删除元素，并分析这些操作对应的时间复杂度。"></a>请分别分析一下它是如何获取元素，修改元素，新增元素与删除元素，并分析这些操作对应的时间复杂度。</h1><h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><p>LinkedList 提供了三种获取元素的方法，分别是：</p><ol><li><p>获取第一个元素 getFirst()，获取第一个元素，直接返回 Node<E> first 指向的结点即可，所以时间复杂度为 O(1)。</p></li><li><p>获取最后一个元素 getLast()，获取最后一个元素，直接返回 Node<E> last 指向的结点即可，所以时间复杂度也为 O(1)。</p></li><li><p>获取指定索引 index 位置的元素 <code>get(int index)</code>，由于 <code>Node&lt;E&gt;</code>结点在内存中存储的空间不是连续存储的，所以查找某一位置的结点，只能通过遍历链表的方式查找结点，因此 LinkedList 会先通过判断 <code>index &lt; (size &gt;&gt; 1)</code>，<code>size&gt;&gt;1</code> 即为 <code>size/2</code> 当前链表长度的一半，判断 index 的位置是在链表的前半部分还是后半部分。决定是从头部遍历查找数据还是从尾部遍历查找数据。最坏情况下，获取中间元素，则需要遍历 n/2 次才能获取到对应元素，所以此方法的时间复杂度为 O(n)。</p></li></ol><p>综上所述，LinkedList 获取元素的时间复杂度为 O(n)。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回列表中指定位置的元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定index位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回指定位置的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查index下标是否合法[0,size)</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// 遍历列表获取对应index位置的元素</span></span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查下标是否合法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isElementIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定位置的结点元素（重点）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="comment">// 判断index位置是在链表的前半部分还是后半部分</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// 从头结点开始，从前往后遍历找到对应位置的结点元素</span></span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从尾结点开始，从后往前遍历找到对应位置的结点元素</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h2><p>LinkedList 提供了一种修改元素数据的方法 set(int index, E element)，修改元素数据的步骤是：1.检查 index 索引是否合法[0,size)。2.折半查询获取对应索引元素。3.将新元素赋值，返回旧元素。由获取元素的分析可知，折半查询的时间复杂度为 O(n)，故修改元素数据的时间复杂度为 O(n)。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改指定位置结点的存储数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 修改的存储数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回未修改前的存储数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查index下标是否合法[0,size)</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// 折半查询获取对应索引元素</span></span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    <span class="comment">// 将新元素赋值，返回旧元素</span></span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="新增元素"><a href="#新增元素" class="headerlink" title="新增元素"></a>新增元素</h2><p>LinkedList 提供了四种新增元素的方法，分别是：</p><ol><li><p>将指定元素插入到链表的第一个位置中 addFirst(E e)，只需将头结点 first 指向新元素结点，将原第一结点的前驱指针指向新元素结点即可。不需要移动原数据存储位置，只需交换一下相关结点的指针域信息即可。所以时间复杂度为 O(1)。</p></li><li><p>将指定元素插入到链表的最后一个位置中 addLast(E e)，只需将尾结点 last 指向新元素结点，将原最后一个结点的后继指针指向新元素结点即可。不需要移动原数据存储位置，只需交换一下相关结点的指针域信息即可。所以时间复杂度也为 O(1)。</p></li><li><p>添加元素方法 add(E e) 等价于 addLast(E e)。</p></li><li><p>将指定元素插入到链表的指定位置 index 中 add(int index, E element)，需要先根据位置 index 调用 node(index)遍历链表获取该位置的原结点，然后将新结点插入至原该位置结点的前面，不需要移动原数据存储位置，只需交换一下相关结点的指针域信息即可。所以时间复杂度也为 O(1)。</p></li></ol><p>综上所述，LinkedList 新增元素的时间复杂度为 O(1)，单纯论插入新元素，操作是非常高效的，特别是插入至头部或插入到尾部。但如果是通过索引 index 的方式插入，插入的位置越靠近链表中间所费时间越长，因为需要对链表进行遍历查找。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定元素插入到链表的第一个位置中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要插入的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将元素e作为第一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取原头结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">// 初始化新元素结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    <span class="comment">// 头指针指向新元素结点</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="comment">// 如果是第一个元素（链表为空）</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 将尾指针也指向新元素结点</span></span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 链表不会空</span></span><br><span class="line">        <span class="comment">// 原头结点的前驱指针指向新结点</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    <span class="comment">// 记录链表长度的size + 1</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定元素插入到链表的最后一个位置中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;此方法等同与add(E e)方法 &#123;<span class="doctag">@link</span> #add&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要插入的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定元素插入到链表的最后一个位置中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;此方法等同与addLast(E e)方法  &#123;<span class="doctag">@link</span> #addLast&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要插入的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将元素e作为最后一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取原尾结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 初始化新元素结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 位指针指向新元素结点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">// 如果是第一个元素（链表为空）</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 将头指针也指向新元素结点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 链表不会空</span></span><br><span class="line">        <span class="comment">// 原尾结点的后继指针指向新结点</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    <span class="comment">// 记录链表长度的size + 1</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定元素插入到链表的指定位置index中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 元素要插入的位置index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 要插入的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查插入位置是否合法[0,size]</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="comment">// 如果插入的位置和当前链表长度相等，则直接将元素插入至链表的尾部</span></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        <span class="comment">// 将元素插入至链表的尾部</span></span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//将元素插入至指定位置,node(index)先获取占有该index位置的原结点</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查位置是否合法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查位置是否合法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//合法位置为[0,size]</span></span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将新元素e插入至旧元素succ前面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="comment">// 记录旧元素结点succ的前驱指针</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="comment">// 初始化新元素结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    <span class="comment">// 旧元素结点的前驱指针指向新元素结点(即新元素结点放至在旧元素结点的前面，取代了原本旧元素的位置)</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="comment">// 如果旧元素结点的前驱指针为空，则证明旧元素结点是头结点，</span></span><br><span class="line">    <span class="comment">// 将新元素结点插入至旧元素结点前面，所以现时新的头结点是新元素结点</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//不是插入至头部</span></span><br><span class="line">        <span class="comment">// 旧元素的前驱结点的后继指针指向新元素结点</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    <span class="comment">// 记录链表长度的size + 1</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>LinkedList 提供了四种删除元素的方法，分别是：</p><ol><li><p>删除链表中的第一个元素<code>removeFirst()</code>，只需将头结点<code>first</code>指向删除元素结点的后继结点并将其前驱结点指针信息<code>prev</code>清空即可。不需要移动原数据存储位置，只需操作相关结点的指针域信息即可。所以时间复杂度为 O(1)。</p></li><li><p>删除链表中的最后一个元素<code>removeLast()</code>，只需将尾结点<code>last</code>指向删除元素结点的前驱结点并将其后继结点指针信息<code>next</code>清空即可。不需要移动原数据存储位置，只需操作相关结点的指针域信息即可，所以时间复杂度也为 O(1)。</p></li><li><p>将指定位置 index 的元素删除<code>remove(int index)</code>，需要先根据位置 index 调用<code>node(index)</code>遍历链表获取该位置的原结点，然后将删除元素结点的前驱结点的 next 后继结点指针域指向删除元素结点的后继结点<code>node.prev.next = node.next</code>，删除元素结点的后继结点的 prev 前驱结点指针域指向删除元素结点的前驱结点即可<code>node.next.prev = node.prev</code>（此处可能有些绕，不太理解的同学自行学习一下双向链表的数据结构吧），不需要移动原数据存储位置，只需交换一下相关结点的指针域信息即可。所以时间复杂度也为 O(1)。</p></li><li><p>删除传入的 Object o 指定对象，比较对象是否一致通过<code>o.equals</code>方法比较<code>remove(Object o)</code>，和 3.的思路基本差不多，关键是比较对象是通过<code>o.equals</code>方法，记住这点即可。</p></li></ol><p>综上所述，LinkedList 删除元素的时间复杂度为 O(1)，单纯论删除元素，操作是非常高效的，特别是删除第一个结点或删除最后一个结点。但如果是通过索引 index 的方式或者 object 对象的方式删除，则需要对链表进行遍历查找对应 index 索引的对象或者利用 equals 方法判断对象。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除链表中的第一个元素并返回</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 链表中的第一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据头结点获取第一个元素结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>) <span class="comment">// 没有元素结点则抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除第一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="comment">// 记录要移除元素结点的数据域</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="comment">// 记录要移除元素结点的后继结点指针</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    <span class="comment">// 清空要删除结点的数据域和next指针域信息，以帮助垃圾回收</span></span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    <span class="comment">// 头结点指向要移除元素结点的后继结点</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="comment">// 如果要移除元素结点的后继结点为空，则证明链表只有一个元素</span></span><br><span class="line">    <span class="comment">// 所以需要将尾结点的指针信息也要清空</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 将新的第一个结点的前驱结点指针信息清空</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 记录链表长度的size - 1</span></span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 返回移除元素结点的数据域</span></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除链表中的最后一个元素并返回</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 链表中的最后一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据尾结点获取最后一个元素结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)<span class="comment">// 没有元素结点则抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除最后一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">    <span class="comment">// 记录要移除元素结点的数据域</span></span><br><span class="line">    <span class="keyword">final</span> E element = l.item;</span><br><span class="line">    <span class="comment">// 记录要移除元素结点的前驱结点指针</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    <span class="comment">// 清空要删除结点的数据域和prev指针域信息，以帮助垃圾回收</span></span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    <span class="comment">// 头结点指向要移除元素结点的前驱结点</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="comment">// 如果要移除元素结点的前驱结点为空，则证明链表只有一个元素</span></span><br><span class="line">    <span class="comment">// 所以需要将头结点的指针信息也要清空</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 将新的最后一个结点的后继结点指针信息清空</span></span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 记录链表长度的size - 1</span></span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 返回移除元素结点的数据域</span></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定位置index的元素删除</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 要删除的位置index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 要删除位置的原元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查index下标是否合法[0,size)</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// 根据index进行遍历链表获取要删除的结点，再调用unlink方法进行删除</span></span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除传入的Object o指定对象，比较对象是否一致通过o.equals方法比较</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 要删除的Object o指定对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 是否存在要删除对象o</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果删除对象为null，则遍历链表查找node.item数据域为null的结点并移除</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从头开始遍历链表，并通过equals方法逐一比较node.item是否相等</span></span><br><span class="line">        <span class="comment">// 相等则对象一致，删除此对象。</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除指定结点x</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="comment">// 记录要移除元素结点的数据域</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="comment">// 记录要移除元素结点的后继结点指针</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="comment">// 记录要移除元素结点的前驱结点指针</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果要移除元素结点的前驱结点为空，则证明要删除结点为第一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 头结点指向要删除元素结点的后继结点</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 要删除元素结点的前驱结点的后继指针指向要删除元素结点的后继结点</span></span><br><span class="line">        prev.next = next;</span><br><span class="line">        <span class="comment">// 清空要删除结点的前驱结点指针信息，以帮助GC</span></span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果要移除元素结点的后继结点为空，则证明要删除结点为最后一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 尾结点指向要删除元素结点的前驱结点</span></span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 要删除元素结点的后继结点的前驱指针指向要删除元素结点的前驱结点</span></span><br><span class="line">        next.prev = prev;</span><br><span class="line">        <span class="comment">// 清空要删除结点的后继结点指针信息，以帮助GC</span></span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空要删除元素的数据域，以帮助GC</span></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 记录链表长度的size - 1</span></span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 返回移除元素结点的数据域</span></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="那您可以比较一下-ArrayList-和-LinkedList-吗"><a href="#那您可以比较一下-ArrayList-和-LinkedList-吗" class="headerlink" title="那您可以比较一下 ArrayList 和 LinkedList 吗?"></a>那您可以比较一下 ArrayList 和 LinkedList 吗?</h1><h2 id="更占内存"><a href="#更占内存" class="headerlink" title="更占内存"></a>更占内存</h2><p>LinkedList 内部存储的是 Node<E>，不仅要维护数据域，还要维护 prev 和 next，如果 LinkedList 中的结点特别多，则 LinkedList 比 ArrayList 更占内存。</p><h2 id="插入删除效率高"><a href="#插入删除效率高" class="headerlink" title="插入删除效率高"></a>插入删除效率高</h2><p>LinkedList 在做插入和删除操作时，插入或删除头部或尾部时是高效的，操作越靠近中间位置的元素时，需要遍历查找，速度相对慢一些，如果在数据量较大时，每次插入或删除时遍历查找比较费时。所以 LinkedList 插入与删除，慢在遍历查找，快在只需要更改相关结点的引用地址。ArrayList 在做插入和删除操作时，插入或删除尾部时也一样是高效的，操作其他位置，则需要批量移动元素，所以 ArrayList 插入与删除，快在遍历查找，慢在需要批量移动元素。</p><h2 id="循环遍历效率低"><a href="#循环遍历效率低" class="headerlink" title="循环遍历效率低"></a>循环遍历效率低</h2><ul><li>由于 ArrayList 实现了 RandomAccess 随机访问接口，所以使用 for(int i = 0; i &lt; size; i++)遍历会比使用 Iterator 迭代器来遍历快：</li><li>而由于 LinkedList 未实现 RandomAccess 接口，所以推荐使用 Iterator 迭代器来遍历数据。</li><li>因此，如果我们需要频繁在列表的中部改变插入或删除元素时，建议使用 LinkedList，否则，建议使用 ArrayList，因为 ArrayList 遍历查找元素较快，并且只需存储元素的数据域，不需要额外记录其他数据的位置信息，可以节省内存空间。</li></ul><h1 id="LinkedList-是线程安全的吗？"><a href="#LinkedList-是线程安全的吗？" class="headerlink" title="LinkedList 是线程安全的吗？"></a>LinkedList 是线程安全的吗？</h1><p>LinkedList 不是线程安全的，如果多个线程同时对同一个 LinkedList 更改数据的话，会导致数据不一致或者数据污染。如果出现线程不安全的操作时，LinkedList 会尽可能的抛出<code>ConcurrentModificationException</code>防止数据异常，当我们在对一个 LinkedList 进行遍历时，在遍历期间，我们是不能对 LinkedList 进行添加，删除等更改数据结构的操作的，否则也会抛出<code>ConcurrentModificationException</code>异常，此为 fail-fast（快速失败）机制。从源码上分析，我们在 add,remove 等更改 LinkedList 数据时，都会导致 modCount 的改变，当<code>expectedModCount != modCount</code>时，则抛出<code>ConcurrentModificationException</code>。如果想要线程安全，可以考虑调用<code>Collections.synchronizedCollection(Collection&lt;T&gt; c)</code>方法。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>参考资料</p>]]></content>
      
      
      <categories>
          
          <category> JAVA容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java容器 LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA容器——ArrayList</title>
      <link href="/2020/02/24/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ArrayList/"/>
      <url>/2020/02/24/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ArrayList/</url>
      
        <content type="html"><![CDATA[<h1 id="ArrayList-有用过吗？它是一个什么东西？可以用来干嘛？"><a href="#ArrayList-有用过吗？它是一个什么东西？可以用来干嘛？" class="headerlink" title="ArrayList 有用过吗？它是一个什么东西？可以用来干嘛？"></a>ArrayList 有用过吗？它是一个什么东西？可以用来干嘛？</h1><h2 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h2><p>ArrayList 就是数组列表，主要用来装载数据，当我们装载的是基本类型的数据 int，long，boolean，short，byte…的时候我们只能存储他们对应的包装类，它的主要底层实现是数组 Object[] elementData。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>ArrayList 底层是用数组实现的存储。</li><li>初始化容量为 10，扩容为 1.5 倍。</li><li>查询效率高，增删效率低，线程不安全。使用频率很高。</li></ul><h1 id="为啥线程不安全还使用他呢？"><a href="#为啥线程不安全还使用他呢？" class="headerlink" title="为啥线程不安全还使用他呢？"></a>为啥线程不安全还使用他呢？</h1><h2 id="用于查询较多"><a href="#用于查询较多" class="headerlink" title="用于查询较多"></a>用于查询较多</h2><p>因为我们正常使用的场景中，都是用来查询，不会涉及太频繁的增删，如果涉及频繁的增删，可以使用 LinkedList，如果你需要线程安全就使用 Vector，这就是三者的区别了，实际开发过程中还是 ArrayList 使用最多的。</p><h2 id="综合考虑安全和性能"><a href="#综合考虑安全和性能" class="headerlink" title="综合考虑安全和性能"></a>综合考虑安全和性能</h2><p>不存在一个集合工具是查询效率又高，增删效率也高的，还线程安全的，至于为啥大家看代码就知道了，因为数据结构的特性就是优劣共存的，想找个平衡点很难，牺牲了性能，那就安全，牺牲了安全那就快速。</p><h1 id="您说它的底层实现是数组，但是数组的大小是定长的，如果我们不断的往里面添加数据的话，不会有问题吗？"><a href="#您说它的底层实现是数组，但是数组的大小是定长的，如果我们不断的往里面添加数据的话，不会有问题吗？" class="headerlink" title="您说它的底层实现是数组，但是数组的大小是定长的，如果我们不断的往里面添加数据的话，不会有问题吗？"></a>您说它的底层实现是数组，但是数组的大小是定长的，如果我们不断的往里面添加数据的话，不会有问题吗？</h1><p>ArrayList 可以通过构造方法在初始化的时候指定底层数组的大小；</p><p>通过无参构造方法的方式 <code>ArrayList()</code> 初始化，则赋值底层数 <code>Object[] elementData</code> 为一个默认空数组 <code>Object[]DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}</code> 所以数组容量为 <code>0</code>，只有真正对数据进行添加 <code>add</code> 时，才分配默认 <code>DEFAULT_CAPACITY = 10</code> 的初始容量。</p><p>容量超过 <code>10</code> 时，会创建一个容量 <code>1.5</code> 倍的空数组，将原有数据拷贝过去。</p><h1 id="能具体说下-1-7-和-1-8-版本初始化的时候的区别么？"><a href="#能具体说下-1-7-和-1-8-版本初始化的时候的区别么？" class="headerlink" title="能具体说下 1.7 和 1.8 版本初始化的时候的区别么？"></a>能具体说下 1.7 和 1.8 版本初始化的时候的区别么？</h1><p>1.7 开始变化有点大，一个是初始化的时候，1.7 以前会调用 <code>this(10)</code> 才是真正的容量为 10，1.7 即本身以后是默认走了空数组，只有第一次 <code>add</code> 的时候容量会变成 10。</p><h1 id="我记得你说到了，他增删很慢，你能说一下-ArrayList-在增删的时候是怎么做的么？主要说一下他为啥慢。"><a href="#我记得你说到了，他增删很慢，你能说一下-ArrayList-在增删的时候是怎么做的么？主要说一下他为啥慢。" class="headerlink" title="我记得你说到了，他增删很慢，你能说一下 ArrayList 在增删的时候是怎么做的么？主要说一下他为啥慢。"></a>我记得你说到了，他增删很慢，你能说一下 ArrayList 在增删的时候是怎么做的么？主要说一下他为啥慢。</h1><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>他有指定 index 新增，也有直接新增的，在这之前他会有一步校验长度的判断 ensureCapacityInternal，就是说如果长度不够，是需要扩容的。</p><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ArrayList_2020-02-24-15-55-53.png" alt="JAVA容器——ArrayList_2020-02-24-15-55-53.png"></p><p>在扩容的时候，老版本的 jdk 和 8 以后的版本是有区别的，8 之后的效率更高了，采用了位运算，右移一位，其实就是除以 2 这个操作。</p><p>1.7 的时候 3/2+1 ，1.8 直接就是 3/2。</p><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ArrayList_2020-02-24-15-56-30.png" alt="JAVA容器——ArrayList_2020-02-24-15-56-30.png"></p><h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><p>指定位置新增的时候，在校验之后的操作很简单，就是数组的 copy，大家可以看下代码。</p><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ArrayList_2020-02-24-16-04-27.png" alt="JAVA容器——ArrayList_2020-02-24-16-04-27.png"></p><p>不知道大家看懂 arraycopy 的代码没有，我画个图解释下，你可能就明白一点：</p><p>比如有下面这样一个数组我需要在 index 5 的位置去新增一个元素 A</p><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ArrayList_2020-02-24-16-04-56.png" alt="JAVA容器——ArrayList_2020-02-24-16-04-56.png"></p><p>那从代码里面我们可以看到，他复制了一个数组，是从 index 5 的位置开始的，然后把它放在了 index 5+1 的位置</p><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ArrayList_2020-02-24-16-05-25.png" alt="JAVA容器——ArrayList_2020-02-24-16-05-25.png"></p><p>给我们要新增的元素腾出了位置，然后在 index 的位置放入元素 A 就完成了新增的操作了</p><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94ArrayList_2020-02-24-16-05-52.png" alt="JAVA容器——ArrayList_2020-02-24-16-05-52.png"></p><p>至于为啥说他效率低，我想我不说你也应该知道了，我这只是在一个这么小的 List 里面操作，要是我去一个几百几千几万大小的 List 新增一个元素，那就需要后面所有的元素都复制，然后如果再涉及到扩容啥的就更慢了不是嘛。</p><h1 id="ArrayList-插入删除一定慢么？"><a href="#ArrayList-插入删除一定慢么？" class="headerlink" title="ArrayList 插入删除一定慢么？"></a>ArrayList 插入删除一定慢么？</h1><p>取决于你删除的元素离数组末端有多远，ArrayList 拿来作为堆栈来用还是挺合适的，push 和 pop 操作完全不涉及数据移动操作。</p><h1 id="那他的删除是怎么实现的那？"><a href="#那他的删除是怎么实现的那？" class="headerlink" title="那他的删除是怎么实现的那？"></a>那他的删除是怎么实现的那？</h1><p>删除其实跟新增是一样的，不过叫是叫删除，但是在代码里面我们发现，他还是在 copy 一个数组。</p><h1 id="ArrayList-的遍历和-LinkedList-遍历性能比较如何？"><a href="#ArrayList-的遍历和-LinkedList-遍历性能比较如何？" class="headerlink" title="ArrayList 的遍历和 LinkedList 遍历性能比较如何？"></a>ArrayList 的遍历和 LinkedList 遍历性能比较如何？</h1><p>论遍历 ArrayList 要比 LinkedList 快得多，ArrayList 遍历最大的优势在于内存的连续性，CPU 的内部缓存结构会缓存连续的内存片段，可以大幅降低读取内存的性能开销。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ArrayList 就是动态数组，用 MSDN 中的说法，就是 Array 的复杂版本，它提供了动态的增加和减少元素，实现了 ICollection 和 IList 接口，灵活的设置数组的大小等好处。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java容器 ArrayList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA容器——概述</title>
      <link href="/2020/02/24/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/02/24/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>Java 的容器是前人为我们设计好的一套存储对象和数据的一套轮子，通过使用 Java 中写好的容器 API 我们可以很方便的存储、操作我们的数据。</p><h1 id="容器的分类"><a href="#容器的分类" class="headerlink" title="容器的分类"></a>容器的分类</h1><p>容器主要包括 Collection 和 Map 两种：</p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>主要是单个元素的集合，由 List、Queue、Set 三个接口区分不同的集合特征，然后由下面的具体的类来实现对应的功能。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>有一组键值对的存储形式来保存，可以用键对象来查找值。</p><h2 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h2><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0_2020-02-24-14-44-33.png" alt="JAVA容器——概述_2020-02-24-14-44-33.png"></p><p><img src="/images/JAVA%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0_2020-02-24-14-45-06.png" alt="JAVA容器——概述_2020-02-24-14-45-06.png"></p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>List 的特点就是所有的元素是可以重复的。</p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><ul><li>底层由 Object 数组实现。</li><li>默认长度为 10，每次扩容 1.5 倍，也可以自定义初始长度。</li><li>元素存放数据为遍历顺序。</li><li>访问与查找速度快，删除与插入速度慢。</li><li>toArray：把 LinkedList 转化为 Array</li></ul><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>底层由链表（双向链表）实现。</li><li>在列表中插入和删除速度快，但是查找需要遍历整个链表。</li><li>可以通过它实现队列和栈。</li><li>动态改变大小（链表特性）</li></ul><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li>getFirst 和 element 都返回列表的头，但是不删除它，如果列表为空，抛出异常</li><li>peek 实现的功能一样，但是列表为空时返回 null</li><li>removeFirst 和 remove 都是删除并返回列表的头，如果列表为空抛出异常</li><li>pool 实现的功能一样，但是列表为空时返回 null</li></ul><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><ul><li>底层由数组实现</li><li>synchronized 进行同步，线程安全</li><li>插入、删除、访问速度慢</li></ul><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p>队列是一个满足“先进先出”的数据结构。<br>LinkedList 提供了方法支持队列操作，并且实现了 Queue 接口，所以 LinkedList 是队列的一种实现，可以通过 LinkedList 向上转型为 Queue</p><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><ul><li>offer:讲一个元素插入对尾</li><li>peek:不移除的情况下将元素插入队尾，队列为空返回 null</li><li>element:不移除的情况下将元素插入队尾，队列为空报错</li><li>poll:移除并返回队头，队列为空返回 null</li><li>remove:不移除的情况下将元素插入队尾，队列为空报错</li></ul><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ol><li><p>FIFO 队列</p><p>Queue<Integer> q=new LinkedList<Integer>();</p></li><li><p>优先队列</p><p>Queue<Integer> q=new PriorityQueue<Integer>();</p><p>默认升序，底层为堆，初始容量 11</p><p>Queue<Student> q=new PriorityQueue<Student>((e1,e2)-&gt;(e1.id-e2.id));</p><p>传入对象时需要指定比较器；</p></li><li><p>BlockingQueue</p><p>阻塞队列，在 java.util.concurrent 包下，在线程安全中介绍。</p></li></ol><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>不可重复</p><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li>基于哈希表实现，支持快速查找，但不支持有序性操作。</li><li>通过 HashMap 实现。</li></ul><h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><pre><code>public boolean add(E e)public boolean contains(Object o)public boolean remove(Object o)</code></pre><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><ul><li><p>基于红黑树实现，支持有序性操作，查找效率 O(logN)。</p></li><li><p>通过 NavigableMap 实现</p><p>private transient NavigableMap&lt;E,Object&gt; m;</p></li><li><p>数据类型为对象数据时须指定比较方法。</p><p>public TreeSet(Comparator&lt;? super E&gt; comparator)</p></li></ul><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。</p><h1 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h1><h2 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h2><ul><li>Map 是使用键值对存储的一种结构，所以在处理列如单词统计等方面是杀手锏</li><li>Map 的键值对都可以为 null</li><li>Map 可以多维扩展。例如一个人拥有多个宠物，你可以这样定义：Map&lt; Person, List&lt; pet&gt;&gt;</li></ul><h2 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h2><ul><li>Object put(Object key, Object value):放进一个键值对，返回值是被替换的值</li><li>Object remove(Object key)</li><li>void putAll(Map mapping)</li><li>void clear()</li><li>boolean containsKey(Object key)是否包含某个键</li><li>boolean containsValue(Object value)是否包含某个值</li></ul><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><ul><li><p>public Set keySet()：返回这个 Map 的所有键的集合，因为 Map 中键是唯一的，所以返回使用一个 set</p></li><li><p>public Collection values()：返回这个 Map 的所有值的集合，因为值可能重复，所以返回一个 Collection</p></li><li><p>public Set entrySet()：返回一个实现 Map.Entry 接口对象集合，使用这个方法可以遍历每一条记录。</p><p>for(Map.Entry&lt;String, String&gt; file : films.entrySet()){<br>String title = file.getKey();<br>String videoUrl = file.getValue();<br>}</p></li></ul><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>基于红黑树实现。</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ul><li>基于哈希表实现。</li><li>由数组和链表，红黑树共同完成：</li><li>键可以是 null，而且键值不可以重复，如果重复了以后就会对第一个进行键值进行覆盖。</li><li>初始容量为 16，最大容量 1073741824</li><li>默认负载因子 0.75,扩容 2 倍。</li><li>链表转红黑树的阈值 8，红黑树转链表的阈值 6</li></ul><h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><ul><li>和 HashMap 类似，但它是线程安全的</li><li>它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</li><li>HashMap 的默认初始容量为 16，Hashtable 为 11。</li><li>HashMap 的扩容为原来的 2 倍，Hashtable 的扩容为原来的 2 倍加 1。</li></ul><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</p><h1 id="线程安全的容器"><a href="#线程安全的容器" class="headerlink" title="线程安全的容器"></a>线程安全的容器</h1><h2 id="同步容器类（使用了-synchronized）"><a href="#同步容器类（使用了-synchronized）" class="headerlink" title="同步容器类（使用了 synchronized）"></a>同步容器类（使用了 synchronized）</h2><p>Vector、Stack、HashTable</p><p>缺点：</p><p>通过同步方法将访问操作串行化，导致并发环境下效率低下</p><p>复合操作（迭代、条件运算如没有则添加等）非线程安全，需要客户端代码来实现加锁。</p><h2 id="并发容器："><a href="#并发容器：" class="headerlink" title="并发容器："></a>并发容器：</h2><h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p><p>写操作需要加锁，防止并发写入时导致写入数据丢失。</p><p>写操作结束之后需要把原始数组指向新的复制数组。</p><p>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；<br>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。<br>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景</p><h4 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h4><p>CopyOnWriteArraySet 基于 CopyOnWriteArrayList 实现，其唯一的不同是在 add 时调用的是 CopyOnWriteArrayList 的 addIfAbsent 方法，其遍历当前 Object 数组，如 Object 数组中已有了当前元素，则直接返回，如果没有则放入 Object 数组的尾部，并返回。</p><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。<br>默认的并发级别为 16，也就是说默认创建 16 个 Segment。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>Java 容器深入剖析</p>]]></content>
      
      
      <categories>
          
          <category> JAVA容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java容器 概述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（九）——搜素</title>
      <link href="/2020/02/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A0/"/>
      <url>/2020/02/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h1><h2 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h2><p>顺序查找对序列本身没有要求（比如不需要是已经排序好的），也不仅限于数字、字符，也可以用于前缀，对象信息的关键信息的匹配（比如查找指定 id 的相应信息）。</p><p>衡量查找性能的一个指标是————ASL(Average Search Length)，ASL=Pi 乘 Ci，Pi 是查找第 i 个元素的概率，Ci 是找到第 i 个已经比较过次数。</p><p>哨兵方式的顺序查找相比较基础的顺序查找在循环的比较部分减少了一般。</p><h2 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 顺序查找</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequentialSearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SequentialSearch</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 哨兵方式顺序查找</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Search2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Search2</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(key == array[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = array[<span class="number">0</span>];</span><br><span class="line">        array[<span class="number">0</span>] = key;</span><br><span class="line">        <span class="keyword">int</span> index = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(array[index] != key) &#123;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        array[<span class="number">0</span>] = temp;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="设计理念-1"><a href="#设计理念-1" class="headerlink" title="设计理念"></a>设计理念</h2><p>如果是顺序查找，7 个数最多可能会比较 7 次，但用二分查找，最多只要 3 次就能 OK。</p><p>时间复杂度是 O（logn）(底数为 2)。</p><p>二分查找的优化————插值查找</p><p>如果数据范围是 1<del>100000,让你找 10,那么就不一定要从中间找起了。可以三分之一，四分之一处查找，比如 1</del>10，待查为 3，那可以从前面三分之一为划分点。对于要查找的位置有个精确的计算公式 P=low+（key-a[low])/(a[high]-a[low])*(high-low)</p><h2 id="java-实现-1"><a href="#java-实现-1" class="headerlink" title="java 实现"></a>java 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 二分查找递归与非递归的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchRecursion</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  searchRecursion(target, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; array[mid]) &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">searchRecursion</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(array[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &lt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> searchRecursion(target, mid + <span class="number">1</span>, end);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> searchRecursion(target, start, mid -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 二分插入排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryInsertSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryInsertSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = array.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = array[i];</span><br><span class="line">            <span class="keyword">int</span> insertIndex = binarySearch(i - <span class="number">1</span>, temp);</span><br><span class="line">            <span class="keyword">if</span>(insertIndex != i) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; insertIndex; j--) &#123;</span><br><span class="line">                    array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                array[insertIndex] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.println(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> end, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">            mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid] &gt; target) &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果相等，也插入到后面</span></span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="杨氏矩阵的的查找"><a href="#杨氏矩阵的的查找" class="headerlink" title="杨氏矩阵的的查找"></a>杨氏矩阵的的查找</h1><h2 id="设计理念-2"><a href="#设计理念-2" class="headerlink" title="设计理念"></a>设计理念</h2><p>杨氏矩阵就是行列递增的矩阵。</p><p>杨氏矩阵的操作</p><p>插入。插入一个数，需要移动其他元素<br>删除。给定 x,y 坐标，删除那个数，伴随其他元素移动，怎样移动操作最少？<br>查找 t 是否存在于矩阵中。这也是这篇博客里所要关注的。<br>返回第 k 大的数。涉及到堆查找，后续博客再细说。<br>关于查找 t 是否存在于矩阵，书中给了几种实现的方法：</p><p>递归实现和非递归实现</p><p>优化：<br>每次不都从每行的第一个数开始查找，左右上下进行比较然后查找。<br>分治法。杨氏矩阵行列是递增的，那么对角线也是递增的，可以利用对角线划分的区域来缩小要查找数的范围。（实现略）<br>定位查找法。先定位到第一行最右的数，然后只需要往下走，往左走两种操作即可，相比方法 2 省掉了往右走。</p><h2 id="java-实现-2"><a href="#java-实现-2" class="headerlink" title="java 实现"></a>java 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YoungSearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">YoungSearch</span><span class="params">(<span class="keyword">int</span>[][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recursionSearch</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == array.length || y == array[<span class="number">0</span>].length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; array[x][y]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target == array[x][y]) &#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"x: %d, y: %d"</span>, x, y));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> recursionSearch(x + <span class="number">1</span>, y, target) || recursionSearch(x, y + <span class="number">1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array[<span class="number">0</span>].length &amp;&amp; target &gt;= array[i][j]; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(target == array[i][j]) &#123;</span><br><span class="line">                    System.out.println(String.format(<span class="string">"x: %d y: %d"</span>, i, j));</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.简单优化（向左/右/下走）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search2</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> width = array[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> height = array.length;</span><br><span class="line">        <span class="keyword">if</span>(target &gt;= array[<span class="number">0</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; width &amp;&amp; target &gt;= array[<span class="number">0</span>][i]; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(target == array[<span class="number">0</span>][i]) &#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">"x: %d, y: %d"</span>, <span class="number">0</span>, i));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; width - <span class="number">1</span>) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环向下查找</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; height; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(target == array[j][i]) &#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">"x: %d, y: %d"</span>, j, i));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; array[j][i]) &#123;</span><br><span class="line">                <span class="keyword">for</span>(; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(target == array[j][i]) &#123;</span><br><span class="line">                        System.out.println(String.format(<span class="string">"x: %d, y: %d"</span>, j, i));</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &gt; array[j][i]) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &gt; array[j][i]) &#123;</span><br><span class="line">                <span class="keyword">for</span>(; i &lt; width; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(target == array[j][i])&#123;</span><br><span class="line">                        System.out.println(String.format(<span class="string">"x: %d, y: %d"</span>, j, i));</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; array[j][i]) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; width - <span class="number">1</span>) &#123;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.进一步优化（从第一行最右边的数开始，只需要向下和向左两个操作）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search3</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = array[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = array[i][j];</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(target == temp) &#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">"x: %d, y: %d"</span>, i, j));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">0</span> &amp;&amp; target &lt; temp)&#123;</span><br><span class="line">                temp = array[i][--j];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i &lt; array.length - <span class="number">1</span> &amp;&amp; target &gt; temp) &#123;</span><br><span class="line">                temp = array[++i][j];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h1><h2 id="设计理念-3"><a href="#设计理念-3" class="headerlink" title="设计理念"></a>设计理念</h2><p>对于待查找的数据列表来说，如果元素变动很少，那么可以先进行排序再查找。但如果这个数据经常需要添加元素，那么每次查找前都需要排序，这并不是一个好的选择。</p><p>就有了分块查找，这个概念再学数据库的时候听过。分块查找里有索引表和分块这两个概念。索引表就是帮助分块查找的一个分块依据，就是一个数组，用来存储每块最大的存储值（范围上限）；分块就是通过索引表把数据分为几块。</p><p>原理</p><p>当需要增加一个元素的时候，先根据索引表，获取这个元素应该在那一块，然后直接把元素加入到相应的块里，而块内的元素直接不需要有序。</p><p>从上面可知，分块查找只需要索引表有序，每一个块里的元素可以是无序的，但第 i 块的每个元素一定比第 i-1 块的每一个元素大（小）。当索引表很大的时候，可以对索引表进行二分查找，锁定块的位置，然后对块内的元素进行顺序查找。总性能不如二分查找，但强过顺序查找，更好的是不需要数列完全有序。<br>举个例子，比如索引表为【10，20，30】,分块一【2，1，4，2】分块二【19，15，18，】分块三【22，27，23】，现在要增加 22 这个数，直接根据索引表把 22 放到分块三最后就行了【22,27,23,22】。</p><p>可以看出，分块查找同时有顺序查找和二分查找的有点————不需要有序、速度快。</p><p>应用场景<br>视频网站对用户观看行为记录，每个用户分别观看了一个视频多久，如果对每条这样的记录都放到一个表里，那太多了，可以根据具体业务做分表，一天一个表，表名如 t_user_watch_xxx_20180806，存储查询的时候就可以根据时间去做一个表的分块，在查询详细的记录。</p><h2 id="java-实现-3"><a href="#java-实现-3" class="headerlink" title="java 实现"></a>java 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分块查找</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockSearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] index;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlockSearch</span><span class="params">(<span class="keyword">int</span>[] index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index.length; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = binarySearch(value);</span><br><span class="line">        list.get(i).add(value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = binarySearch(data);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; list.get(i).size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(data == list.get(i).get(j)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; l = list.get(i);</span><br><span class="line">            System.out.println(<span class="string">"ArrayList: "</span> + i +  <span class="string">":"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; l.size(); j++) &#123;</span><br><span class="line">                System.out.println(l.get(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = index.length - <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">int</span> mid = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">            mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target == index[mid]) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; index[mid]) &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（八）——排序算法</title>
      <link href="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="常见的排序算法总结"><a href="#常见的排序算法总结" class="headerlink" title="常见的排序算法总结"></a>常见的排序算法总结</h1><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95_2020-02-20-16-44-05.png" alt="数据结构与算法（八）——排序算法_2020-02-20-16-44-05.png"></p><h1 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h1><p>因为待排序的记录序列中可能存在两个或两个以上的关键字相等的记录， 排序结果可能会存在不唯一的情况。所以就有稳定与不稳定的定义。</p><p>假设 ki=kj( 1 =&lt; i &lt;= n,1 =&lt; j &lt;= n, i != j)，且在排序前的序列中 ri 领先于 rj。如果排序后 ri 仍领先于 rj，则称所用的排序方法是稳定的；反之，若可能使得排序后的序列中 rj 领先于 ri，则称所用的排序方法是不稳定的。只要有一组关键字发生类似情况，就可认为此排序方法是不稳定的。</p><h1 id="内排序和外排序"><a href="#内排序和外排序" class="headerlink" title="内排序和外排序"></a>内排序和外排序</h1><p>根据在排序过程中待排序记录是否全部放在内存中，排序分为内排序和外排序。</p><ul><li>内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。</li><li>外排序是由于排序的记录个数太多，不能同时放置在内存中，整个排序过程需要在内外存之间多次交换数据才能进行。</li></ul><p>内排序，排序算法的性能主要有 3 个影响因素：</p><ul><li>时间性能<br>排序算法的时间开销是衡量其好坏的最重要的标志。<br>在内排序中，主要进行两种操作：比较和移动。<br>高效率的内排序算法应该具有尽可能少的关键字比较次数和尽可能少的记录移动次数。</li><li>辅助空间<br>评估算法的另一个主要标准是执行算法所需要的辅助存储空间。<br>辅助存储空间是除了存放待排序所占用的存储空间外，执行算法所需要的其他存储空间。</li><li>算法的复杂性<br>指算法本身的复杂性，过于复杂的算法也会影响排序的性能。</li></ul><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p><strong>两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。</strong></p><h2 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h2><ul><li>最好：仅需要 n - 1 次比较，时间复杂度为 O(n)；</li><li>最坏：需要 n(n - 1)/2 次比较和交换；</li><li>平均：复杂度为 O(n2)。</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 最简单交换排序，非冒泡排序,比较的不是相邻关键字，但便于理解</span></span><br><span class="line">   <span class="comment">// 比较次数n(n + 1)/2，交换次数会很多，仔细分析下，会把小的数字放到最后去，而冒泡则不会，原因就是比较的是相邻关键字</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">simpleSwapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array.length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = array.length; i &lt; size; ++i) &#123;</span><br><span class="line">           <span class="comment">//for (int j = 0; j &lt; size; j++) &#123; //这种效率更低 n^2</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; size; ++j) &#123;</span><br><span class="line">               <span class="keyword">if</span> (array[j] &lt; array[i]) &#123;</span><br><span class="line">                   CommonUtil.swap(array, i, j);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 正宗的冒泡排序，从最底下开始冒泡，两两比较,每次都将小的往上冒一点</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array.length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, size = array.length; i &lt; size; ++i) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = size - <span class="number">1</span>; j &gt;= i; --j) &#123;</span><br><span class="line">               <span class="keyword">if</span> (array[j] &lt; array[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                   CommonUtil.swap(array, j, j - <span class="number">1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//CommonUtil.printArray(array);</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 冒泡排序优化，如果经过一轮发现已经是有序的，就不再进行排序</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSortBetter</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array.length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, size = array.length; i &lt; size &amp;&amp; flag; ++i) &#123;</span><br><span class="line">           flag = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = size - <span class="number">1</span>; j &gt;= i; --j) &#123;<span class="comment">//经过一轮循环，发现两两已经是有序的了，就置为false</span></span><br><span class="line">               <span class="keyword">if</span> (array[j] &lt; array[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                   CommonUtil.swap(array, j, j - <span class="number">1</span>);</span><br><span class="line">                   flag = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//CommonUtil.printArray(array);</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h1><h2 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h2><p>每一次遍历时选取关键字最小的记录作为有序序列的第 i 个记录。</p><h2 id="算法复杂度分析-1"><a href="#算法复杂度分析-1" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h2><ul><li>最好最差的情况，都要进行 n(n-1)/2 次比较；在最好的情况下，不需要进行交换，在最坏的情况下，进行 n-1 次交换。</li><li>平均：复杂度为 O(n2)。</li></ul><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleSelectionSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">simpleSelectionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array.length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = array.length; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; size; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &lt; array[minIndex]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">                CommonUtil.swap(array, i, minIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><h2 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h2><p>将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录递增 1 的有序表。插入排序是进行值移动，而非值交换。所以在量较小的情况下插入排序性能要优于冒泡和简单选择排序。</p><h2 id="算法复杂度分析-2"><a href="#算法复杂度分析-2" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h2><ul><li>最好，只需进行比较 n - 1 次，无需进行移动；</li><li>最坏的情况下，比较(n + 2)(n - 1)/2 次，交换(n + 4)(n - 1)/2 次。</li><li>平均：复杂度 O(n2)</li></ul><h2 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StraightInsertionSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//for循环</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">straightInsertionSort2</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array.length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j, temp, size = array.length; i &lt; size; ++i) &#123;</span><br><span class="line">            temp = array[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; temp; --j) &#123;</span><br><span class="line">                array[j + <span class="number">1</span>] = array[j];<span class="comment">//移动而非交换</span></span><br><span class="line">            &#125;</span><br><span class="line">            array[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a>二分插入排序</h1><h2 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h2><p>二分（折半）插入排序是一种在直接插入排序算法上进行小改动的排序算法。其与直接排序算法最大的区别在于查找插入位置时使用的是二分查找的方式，在速度上有一定提升。</p><h2 id="算法复杂度分析-3"><a href="#算法复杂度分析-3" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h2><p>插入每个记录需要 O(log i)比较，最多移动 i+1 次，最少 2 次。</p><ul><li>最佳： O(n log n)，</li><li>最差：O(n^2)</li><li>平均: O(n^2)。</li><li></li></ul><p>总排序码比较次数比直接插入排序的最差情况好得多，但比最好情况要差，所元素初始序列已经按排序码接近有序时，直接插入排序比二分插入排序比较次数少</p><h2 id="java-实现-1"><a href="#java-实现-1" class="headerlink" title="java 实现"></a>java 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryInsertionSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binaryInsertionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array.length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp, left, right, middle;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, size = array.length; i &lt; size; i++) &#123;</span><br><span class="line">            temp = array[i];</span><br><span class="line">            left = <span class="number">0</span>;</span><br><span class="line">            right = i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//寻找合适的位置</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">                middle = (left + right) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (array[middle] &gt; temp) &#123;</span><br><span class="line">                    right = middle - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = middle + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= left; j--) &#123;</span><br><span class="line">                array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            array[left] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="基本思想-4"><a href="#基本思想-4" class="headerlink" title="基本思想"></a>基本思想</h2><ol><li><p>对一个未排序序列，假设从该序列中的元素中取一个基准值 pivotkey，将小于 pivotkey 放左边，大于 pivotkey 放右边；</p></li><li><p>接着以该 k 为中间，左右两边的分割作为新的序列，重新进行 1 操作。 快排因为用到了递归操作，所以在简单排序中性能不如直接插入排序， 而在大量数据排序时，递归产生的性能影响对于算法的整体性能优势可以忽略。</p></li></ol><h2 id="算法复杂度分析-4"><a href="#算法复杂度分析-4" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h2><ul><li>最坏：待排序为正序或逆序，这样每次分割后的子序列一个之比上一次序列少一个元素，一个为空。如 1 2 3 4 5 pivotkey=1;分割后一个序列为 2 3 4 5 一个为空，最终 O(n^2)</li><li>最好：每一次分割都能平分，很均匀 O(nlogn)</li><li>平均：O(n*logn) 数学归纳法</li></ul><h2 id="java-实现-2"><a href="#java-实现-2" class="headerlink" title="java 实现"></a>java 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuickSortWhile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_LIMIT = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array.length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        quick_sort_recursive(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick_sort_recursive</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= MAX_LIMIT) &#123;</span><br><span class="line">            <span class="comment">// 到达一定程度的小数组时使用插入排序</span></span><br><span class="line">            insertSort(arr, start, end);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123; <span class="comment">//尾递归优化</span></span><br><span class="line">            <span class="keyword">int</span> pivot = partition(arr, start, end);</span><br><span class="line"></span><br><span class="line">            quick_sort_recursive(arr, start, pivot - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            start = pivot + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       分区操作：将arr[end]作为中轴，比它小的放在前面，比它大的放在后面</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivotKey = arr[end];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = start, right = end - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (arr[left] &lt;= pivotKey &amp;&amp; left &lt; right) left++;</span><br><span class="line">            <span class="keyword">while</span> (arr[right] &gt;= pivotKey &amp;&amp; left &lt; right) right--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                CommonUtil.swap(arr, left, right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr[left] &gt;= pivotKey) &#123;</span><br><span class="line">            CommonUtil.swap(arr, left, end);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入排序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>, j, temp; i &lt;= end; ++i) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            j = i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= start &amp;&amp; arr[j] &gt; temp) &#123;</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li></ul><h2 id="基本思想-5"><a href="#基本思想-5" class="headerlink" title="基本思想"></a>基本思想</h2><p>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。</p><p>假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为 O(n2)的排序（冒泡排序或插入排序），可能会进行 n 次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。</p><p>一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用 i += step_size 而不是 i++ ）。</p><p>例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为 5 开始进行排序，我们可以通过将这列表放在有 5 列的表中来更好地描述算法，这样他们就应该看起来是这样：</p><p>13 14 94 33 82<br>25 59 94 65 23<br>45 27 73 25 39<br>10</p><p>然后我们对每列进行排序：</p><pre><code>10 14 73 25 2313 27 94 33 3925 59 94 65 8245</code></pre><p>将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时 10 已经移至正确位置了，然后再以 3 为步长进行排序：</p><pre><code>10 14 7325 23 1327 94 3339 25 5994 65 8245</code></pre><p>排序之后变为：</p><pre><code>10 14 1325 23 3327 25 5939 65 7345 94 8294</code></pre><p>最后以 1 步长进行排序（此时就是简单的插入排序了）。</p><h2 id="步长选择及复杂度"><a href="#步长选择及复杂度" class="headerlink" title="步长选择及复杂度"></a>步长选择及复杂度</h2><p>步长的选择是希尔排序的重要部分。只要最终步长为 1 任何步长序列都可以工作。<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95_2020-02-23-23-05-25.png" alt="数据结构与算法（八）——排序算法_2020-02-23-23-05-25.png"></p><ul><li><p>最优时间复杂度<br>O(n)</p></li><li><p>不稳定</p></li></ul><h2 id="java-实现-3"><a href="#java-实现-3" class="headerlink" title="java 实现"></a>java 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellsort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = a.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> d=n/<span class="number">2</span>;d&gt;<span class="number">0</span>;d/=<span class="number">2</span>) &#123;<span class="comment">/* 希尔增量序列 */</span></span><br><span class="line">            <span class="comment">/* 插入排序 */</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> p=d;p&lt;n;p++) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[p];</span><br><span class="line">                <span class="keyword">for</span>(j=p;j&gt;=d &amp;&amp; a[j-<span class="number">1</span>] &gt; temp;j=j-d)</span><br><span class="line">                    a[j] = a[j-d];</span><br><span class="line">                a[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><pre><code>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</code></pre><h2 id="基本思想-6"><a href="#基本思想-6" class="headerlink" title="基本思想"></a>基本思想</h2><p>归并过程</p><pre><code>比较a[i]和b[j]的大小，若a[i]≤b[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素b[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。</code></pre><p>原理</p><p>第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</p><pre><code>第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置重复步骤3直到某一指针超出序列尾将另一序列剩下的所有元素直接复制到合并序列尾</code></pre><h2 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h2><p>上述我们讲了归并排序的原理，将两个有序数组进行归并排序，但现实中可能不会给我们从上面的演算我们就直到，归并排序的前提是需要两个已经排好顺序的数组，那往往不会有两个已经排好顺序的数组给我们的呀<strong>(一般是杂乱无章的一个数组)</strong>，那这个算法是不是很鸡肋的呢？？</p><p>其实并不是的，首先假设题目给出的数组是这样子的：int[] arr = {2, 7, 8, 1, 4, 9};<br>当我们要做归并的时候就以 arr[3]也就元素为 1 的那个地方分开。是然后用一个指针 L 指向 arr[0]，一个指针 M 指向 arr[3]，用一个指针 R 指向 arr<a href="数组最后一位">5</a>。有了指针的帮助，我们就可以将这个数组切割成是两个有序的数组了（操作的方式就可以和上面一样了）<br>可是上面说了，一般给出的是杂乱无章的一个数组，现在还是达不到要求。比如给出的是这样一个数组：int[] arrays = {9, 2, 5, 1, 3, 2, 9, 5, 2, 1, 8};<br>此时，我们就得用到分治的思想了：</p><p>那么我们也可以这样想将 int[] arr = {2, 7, 8, 1, 4, 9};数组分隔成一份一份的，arr[0]它是一个有序的”数组”,arr[1]它也是一个有序的”数组”,利用指针(L,M,R)又可以像操作两个数组一样进行排序。最终合成{2,7}…….再不断拆分合并，最后又回到了我们的 arr = {1,2,4,7,8,9}，因此归并排序是可以排序杂乱无章的数组的</p><p>这就是我们的分治法—&gt;将一个大问题分成很多个小问题进行解决，最后重新组合起来</p><h2 id="算法复杂度分析-5"><a href="#算法复杂度分析-5" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h2><p>归并排序的时间复杂度为 O(nlogn)</p><h2 id="java-实现-4"><a href="#java-实现-4" class="headerlink" title="java 实现"></a>java 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arrays = &#123;<span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    mergeSort(arrays, <span class="number">0</span>, arrays.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"公众号：Java3y"</span> + arrays);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arrays</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> L      指向数组第一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> R      指向数组最后一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arrays, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果只有一个元素，那就不用排序了</span></span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取中间的数，进行拆分</span></span><br><span class="line">        <span class="keyword">int</span> M = (L + R) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左边的数不断进行拆分</span></span><br><span class="line">        mergeSort(arrays, L, M);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右边的数不断进行拆分</span></span><br><span class="line">        mergeSort(arrays, M + <span class="number">1</span>, R);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//合并</span></span><br><span class="line">        merge(arrays, L, M + <span class="number">1</span>, R);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arrays</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> L      指向数组第一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> M      指向数组分隔的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> R      指向数组最后的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arrays, <span class="keyword">int</span> L, <span class="keyword">int</span> M, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左边的数组的大小</span></span><br><span class="line">    <span class="keyword">int</span>[] leftArray = <span class="keyword">new</span> <span class="keyword">int</span>[M - L];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//右边的数组大小</span></span><br><span class="line">    <span class="keyword">int</span>[] rightArray = <span class="keyword">new</span> <span class="keyword">int</span>[R - M + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//往这两个数组填充数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt; M; i++) &#123;</span><br><span class="line">        leftArray[i - L] = arrays[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = M; i &lt;= R; i++) &#123;</span><br><span class="line">        rightArray[i - M] = arrays[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// arrays数组的第一个元素</span></span><br><span class="line">    <span class="keyword">int</span>  k = L;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//比较这两个数组的值，哪个小，就往数组上放</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; leftArray.length &amp;&amp; j &lt; rightArray.length) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//谁比较小，谁将元素放入大数组中,移动指针，继续比较下一个</span></span><br><span class="line">        <span class="keyword">if</span> (leftArray[i] &lt; rightArray[j]) &#123;</span><br><span class="line">            arrays[k] = leftArray[i];</span><br><span class="line"></span><br><span class="line">            i++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arrays[k] = rightArray[j];</span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果左边的数组还没比较完，右边的数都已经完了，那么将左边的数抄到大数组中(剩下的都是大数字)</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; leftArray.length) &#123;</span><br><span class="line">        arrays[k] = leftArray[i];</span><br><span class="line"></span><br><span class="line">        i++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果右边的数组还没比较完，左边的数都已经完了，那么将右边的数抄到大数组中(剩下的都是大数字)</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; rightArray.length) &#123;</span><br><span class="line">        arrays[k] = rightArray[j];</span><br><span class="line"></span><br><span class="line">        k++;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结及参考资料"><a href="#总结及参考资料" class="headerlink" title="总结及参考资料"></a>总结及参考资料</h1><p>除了以上常见的排序算法，还有堆排序、桶排序、基数排序、计数排序等。<br>常见的排序算法</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（七）——堆、哈希表、图</title>
      <link href="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E5%A0%86%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E3%80%81%E5%9B%BE/"/>
      <url>/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E5%A0%86%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E3%80%81%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h1><ul><li>堆(也被称为优先队列(队列+排序规则)，图一最大堆，图二最小堆)</li><li>堆是一种特殊的基于树的满足某些特性的数据结构，整个堆中的所有父子节点的键值都会满足相同的排序条件。堆更准确地可以分为最大堆与最小堆，在最大堆中，父节点的键值永远大于或者等于子节点的值，并且整个堆中的最大值存储于根节点；而最小堆中，父节点的键值永远小于或者等于其子节点的键值，并且整个堆中的最小值存储于根节点。</li></ul><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度:"></a>时间复杂度:</h1><ul><li>访问最大值 / 最小值: O(1)</li><li>插入: O(log(n))</li><li>移除最大值 / 最小值: O(log(n))</li></ul><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E5%A0%86%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E3%80%81%E5%9B%BE_2020-02-20-16-33-06.png" alt="数据结构与算法（七）——堆、哈希表、图_2020-02-20-16-33-06.png"></p><h1 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h1><ul><li>哈希能够将任意长度的数据映射到固定长度的数据。哈希函数返回的即是哈希值，如果两个不同的键得到相同的哈希值，即将这种现象称为碰撞。</li><li>Hash Map: Hash Map 是一种能够建立起键与值之间关系的数据结构，Hash Map 能够使用哈希函数将键转化为桶或者槽中的下标，从而优化对于目标值的搜索速度。</li></ul><p>碰撞解决</p><ul><li>链地址法（Separate Chaining）: 链地址法中，每个桶是相互独立的，包含了一系列索引的列表。搜索操作的时间复杂度即是搜索桶的时间（固定时间）与遍历列表的时间之和。</li><li>开地址法（Open Addressing）: 在开地址法中，当插入新值时，会判断该值对应的哈希桶是否存在，如果存在则根据某种算法依次选择下一个可能的位置，直到找到一个尚未被占用的地址。所谓开地址法也是指某个元素的位置并不永远由其哈希值决定。</li></ul><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E5%A0%86%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E3%80%81%E5%9B%BE_2020-02-20-16-35-27.png" alt="数据结构与算法（七）——堆、哈希表、图_2020-02-20-16-35-27.png"></p><h1 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h1><ul><li>图是一种数据元素间为多对多关系的数据结构，加上一组基本操作构成的抽象数据类型。<ul><li>无向图（Undirected Graph）: 无向图具有对称的邻接矩阵，因此如果存在某条从节点 u 到节点 v 的边，反之从 v 到 u 的边也存在。</li><li>有向图（Directed Graph）: 有向图的邻接矩阵是非对称的，即如果存在从 u 到 v 的边并不意味着一定存在从 v 到 u 的边。</li></ul></li></ul><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E5%A0%86%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E3%80%81%E5%9B%BE_2020-02-20-16-37-36.png" alt="数据结构与算法（七）——堆、哈希表、图_2020-02-20-16-37-36.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 堆、哈希表、图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（六）——树</title>
      <link href="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91/"/>
      <url>/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="树的介绍"><a href="#树的介绍" class="headerlink" title="树的介绍"></a>树的介绍</h1><p>首先它是一种非线性的数据结构，将它命名为“树”是因为它看起来像一颗倒挂的树，根朝上，页朝下。</p><p>当然计算机的树模型，是由现实中的树抽象来的，它指的是 N 个有父子关系的节点的有限集合。对于这个有限的节点集合而言，它满足如下条件：</p><ul><li>当 N=0 时，改节点集合为空，这课树也被称为空树</li><li>在任意的非空树中，有且仅有一个根(root)节点</li><li>当 N&gt;1 时，除根节点以外的其余节点可分为 M 个互为相交的有限集合 T1,T2,…,Tm，其中的每个集合本身又是一棵树，并称其为根的子树（subtree）。</li></ul><h1 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h1><ul><li>节点：树的最基本组成单元，通常包括一个数据元素及若干指针用于指向其他节点。</li><li>节点的度：节点拥有的子树的个数被称为节点的度（degree）</li><li>树的度：树中所有节点的度的最大值就是该树的度</li><li>叶子节点：度为 0 的节点被称为叶子节点或终端节点</li><li>分支节点：度不为 0 的节点被称为分支节点或非终端节点</li><li>子节点,父节点，兄弟节点：节点的子树的根被称为该节点的子节点，而该节点称为子节点的父节点(parent).具有相同父节点的子节点之间互称为兄弟节点。</li><li>节点的层次(level):节点的层次从根开始算起，根的层次值为 1，其余节点的层次值为父节点层次值加 l。</li><li>树的深度(depth):树中节点的最大层次值称为树的深度或高度。</li><li>有序树与无序树:如果将树中节点的各棵子树看成从左到右是有序的(即不能互换),则称该树为有序树,否则称为无序树。</li><li>祖先节点(ancestor)：从根到该节点所经分支上的所有节点</li><li>后代节点(descendant):以某节点为根的子树中任一节点都称为该节点的后代节点。</li><li>森林(forest):森林是两颗或两颗以上互不相交的树的集合，删去一棵树的根，就得到一个森林。</li></ul><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉树指的是每个节点最多只能有两个子树的有序树。通常左边的子树被称作“左子树”(left subtree)，右边的子树被称为“右子树”(right subtree).由此可见，二叉树依然是树，它是一种特殊的树。</p><h2 id="树与二叉树的区别"><a href="#树与二叉树的区别" class="headerlink" title="树与二叉树的区别"></a>树与二叉树的区别</h2><ul><li>树中节点的最大度数没有限制，而二叉树节点的最大度数为 2，也就是说，二叉树是节点的最大度数为 2 的树。</li><li>无序树的节点无左右之分，而二叉树的节点有左，右之分，也就是说，二叉树是有序树。</li></ul><h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><p>一棵深度为 k 的二叉树，如果它包含了 2^k-1 个节点，就把这棵二叉树称为满二叉树。满二叉树的特点是。每一层上的节点数都是最大节点数，即各层节点数分别为 1,2,4,8, 16,…,满二叉树下图所示：<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91_2020-02-20-14-59-36.png" alt="数据结构与算法（六）——树_2020-02-20-14-59-36.png"></p><h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>如果一颗二叉树除最后一层外，其余层的所有节点都是满的，并且最后一层或者是满的，或者仅在右边缺少若干连续的节点，则此二叉树就是完全二叉树。</p><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>哈夫曼树又被称为最优二叉树，是一种带权路径最短的二叉树。哈夫曼树是二叉树的一种应用，在信息检索中很常用.</p><p>对于哈夫曼树，有一个很重要的定理:对于具有对 n 个叶子节点的哈夫曼树，一共需要 2 乘以 n-1 个节点。因为对于二叉树来说，有三种类型节点，即度数为 2 的节点、度数为 1 的节点和度数为 0 的叶子节点，而哈夫曼树的非叶子节点都是由两个节点合并产生的，所以不会出现度 数为 1 的节点。而生成的非叶子节点的个数为叶子节点个数-1 因此 n 个叶子节点的哈夫曼树，一共需要 Z 乘以 n-1 个节点。</p><h2 id="二叉树的特点"><a href="#二叉树的特点" class="headerlink" title="二叉树的特点"></a>二叉树的特点</h2><ul><li>二叉树第 i 层上的节点数据至多为 2 的 i-1 次方</li><li>深度为 k 的二叉树至多有 2 的 k 次方-1 个节点.满二叉树的每层节点的数量依次为 1, 2, 4,8,…,因此深度为 k 的满二叉树包含的节点数为公比为 2 的等比数列的前 k 项总和，即 2 的 k 次方一 1。</li><li>在任何一棵二叉树中，如果其叶子节点的数量为 n0,度为 2 的子节点数量为 n2，则 n0=n2 + 1。这是因为:如果为任意叶子节点增加一个子节点，则原有叶子节点变成非叶子节点，新增节点变成叶子节点，上述等式不变;如果为任意叶子节点增加两个子节点，则原有叶子节点变成度为 2 的非叶子 lto 点，新增的两个节点变成叶子节点，上述等式依然不变。</li><li>具有 n 个节点的完全二叉树的深度为 log2(n+1)</li></ul><h2 id="二叉树的储存"><a href="#二叉树的储存" class="headerlink" title="二叉树的储存"></a>二叉树的储存</h2><ul><li>顺序存储:采用数组来记录二叉树的所有节点。（可能会造成空间浪费）</li><li>二叉链表存储:每个节点保留一个 left,right 域，分别指向其左、右子节点。</li><li>三叉链表存储:每个节点保留一个 left, right,parent 域，分别指向其左、右子节点和父节点。</li></ul><h2 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h2><p>遍历二叉树指的是按某种规律依次访问二叉树的每个节点，对二叉树的遍历过程就是将非线性结构的二叉树的节点排列成线性序列的过程。<br>如果采用顺序结构来保存二叉树，程序遍历二叉树非常容易，无须进行任何思考，直接遍历底层数组即可。如果采用链表来保存二叉树的节点，则有以下两种遍历方式。</p><ul><li>深度优先遍历：这种遍历算法将先访问到树中最深层次的节点<ul><li>先序遍历</li><li>中序遍历</li><li>后序遍历</li></ul></li><li>广度优先遍历：这种遍历算法将逐层访问每层的节点，先访问根（第一层）节点，然后访问第二层的节点…..一次类推。因此，广度优先遍历方法又被称为按层遍历。</li></ul><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>先序遍历指先处理根节点，其处理顺序如下：</p><ol><li>访问根节点</li><li>递归遍历左子树</li><li>递归遍历右子树</li></ol><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>中序遍历指其次处理根节点.其处理顺序如下。</p><ol><li>递归遍历左子树</li><li>访问根节点</li><li>递归遍历右子树</li></ol><h4 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h4><p>后序遍历指最后处理根节点，其处理顺序如下。</p><ol><li>递归遍历左子树</li><li>递归遍历右子树</li><li>访问根节点</li></ol><h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><p>广度优先遍历又称为按层遍历，整个遍历算法是先遍历几叉树的第一层(根节点)，再遍历根节点的两个子’节点(第二层)……依此类推，逐层遍历二叉树的所有节点。</p><p>为了实现广度优先遍历，可以借助于具有 FIFO 特征的队列来实现。如下所示。</p><ul><li>建一个队列(先进先出)，把树的根节点压入队列。</li><li>从队列中弹出一个节点(第一个弹出的就是根节点)，然后把改节点的左，右节点压入队列，如果没有子节点，则说明已经达到叶子节点了。</li><li>用循环重复执行 2 步，知道队列为空。当队列为空时，说明所有的叶子节点(深度最深的层)都已经经过了队列，也就完成了遍历。</li></ul><h4 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h4><p>用栈储存二叉树，栈代替我们完成了递归。</p><h4 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h4><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91_2020-02-20-15-45-37.png" alt="数据结构与算法（六）——树_2020-02-20-15-45-37.png"></p><p>前序遍历：1 2 4 5 7 8 3 6</p><p>中序遍历：4 2 7 5 8 1 3 6</p><p>后序遍历：4 7 8 5 2 6 3 1</p><p>层次遍历：1 2 3 4 5 6 7 8</p><h2 id="二叉树的初始化"><a href="#二叉树的初始化" class="headerlink" title="二叉树的初始化"></a>二叉树的初始化</h2><h4 id="链式储存"><a href="#链式储存" class="headerlink" title="链式储存"></a>链式储存</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by engineer on 2017/10/23.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 二叉树结点定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据域</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="comment">// 左子树</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode&lt;T&gt; leftChild;</span><br><span class="line">    <span class="comment">// 右子树</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode&lt;T&gt; rightChild;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, data, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(TreeNode&lt;T&gt; leftChild, T data, TreeNode&lt;T&gt; rightChild)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.leftChild = leftChild;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.rightChild = rightChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode&lt;T&gt; <span class="title">getLeftChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> leftChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode&lt;T&gt; <span class="title">getRightChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rightChild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建二叉树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 树根</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">TreeNode <span class="title">CreateTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeNode&lt;String&gt; nodeH = <span class="keyword">new</span> TreeNode&lt;&gt;(<span class="string">"H"</span>);</span><br><span class="line">        TreeNode&lt;String&gt; nodeG = <span class="keyword">new</span> TreeNode&lt;&gt;(<span class="string">"G"</span>);</span><br><span class="line"></span><br><span class="line">        TreeNode&lt;String&gt; nodeF = <span class="keyword">new</span> TreeNode&lt;&gt;(nodeH, <span class="string">"F"</span>, <span class="keyword">null</span>);</span><br><span class="line">        TreeNode&lt;String&gt; nodeE = <span class="keyword">new</span> TreeNode&lt;&gt;(nodeG, <span class="string">"E"</span>, <span class="keyword">null</span>);</span><br><span class="line">        TreeNode&lt;String&gt; nodeD = <span class="keyword">new</span> TreeNode&lt;&gt;(<span class="string">"D"</span>);</span><br><span class="line"></span><br><span class="line">        TreeNode&lt;String&gt; nodeC = <span class="keyword">new</span> TreeNode&lt;&gt;(<span class="keyword">null</span>, <span class="string">"C"</span>, nodeF);</span><br><span class="line">        TreeNode&lt;String&gt; nodeB = <span class="keyword">new</span> TreeNode&lt;&gt;(nodeD, <span class="string">"B"</span>, nodeE);</span><br><span class="line">        TreeNode&lt;String&gt; nodeA = <span class="keyword">new</span> TreeNode&lt;&gt;(nodeB, <span class="string">"A"</span>, nodeC);</span><br><span class="line">        <span class="keyword">return</span> nodeA;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问每个结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">visitNode</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        System.out.print(node.getData().toString());</span><br><span class="line">        System.out.print(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序遍历-递归实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preTraversal</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            visitNode(node);</span><br><span class="line">            preTraversal(node.getLeftChild());</span><br><span class="line">            preTraversal(node.getRightChild());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序遍历-递归实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            traversal(node.getLeftChild());</span><br><span class="line">            visitNode(node);</span><br><span class="line">            traversal(node.getRightChild());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后序遍历-递归实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postTraversal</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            postTraversal(node.getLeftChild());</span><br><span class="line">            postTraversal(node.getRightChild());</span><br><span class="line">            visitNode(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="排序二叉树"><a href="#排序二叉树" class="headerlink" title="排序二叉树"></a>排序二叉树</h2><p>排序二叉树是一种特殊结构的二叉树，通过它可以非常方便地对树中的所有节点进行排序和检索</p><p>排序二叉树要么是一颗空二叉树，要么是具有下列性质的二叉树</p><ul><li>若它的左子树不空，则左子树上所有的节点的值均小于它的根节点的值</li><li>若它的右子树不空，则右子树上所有的节点均大于它的根节点的值</li><li>它的左右子树分别为排序二叉树。</li></ul><p>下图显示了一棵排序二叉树. 对于排序二叉树，若按中序遍历就可以得到由小到大的有序序列。中序遍历得:<br>{2,3,4,8,9,9,10,13,15,18)<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91_2020-02-20-15-57-44.png" alt="数据结构与算法（六）——树_2020-02-20-15-57-44.png"></p><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>排序二叉树虽然可以快速检索，但在最坏的情况下，如果插入的节点集本身就是有序的，要么是由小到大排列，要么是由大到小排列，那么最后得到的排序二义树将变成链表:在这种情况下，排序二叉树就变成了普通链表，其检索效率就会很低。<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91_2020-02-20-16-07-33.png" alt="数据结构与算法（六）——树_2020-02-20-16-07-33.png"></p><p>为了改变排序二叉树存在的不足，对二叉树进行改进————红黑树，他将这种排序二叉树称为“对称二叉 B 树”。</p><p>红黑树的应用非常广泛，常见的函数库，如 C++中的 map，multimap,以及 Java 中的 TreeMap，TreeSet， Java8 中的 HashMap 的实现也采用了红黑树。</p><p>红黑树从本质上来说就是一颗二叉查找树，但是在二叉树的基础上增加了着色相关的性质，使得红黑树可以保证相对平衡，从而保证红黑树的增删改查的时间复杂度最坏也能达到 O(log N)。</p><p>红黑树是一个更高效的检索二叉树，因此常常用来实现关联数组。典型的，JDK 提供的集合类 TreeMap 本身就是一颗红黑树的实现。 红黑树在原有的排序二叉树上增加如下几个要求：</p><ul><li>性质 l:每个节点要么是红色，要么是黑色。</li><li>性质 2:根节点永远是黑色的。</li><li>除质 3:所有的叶子节点都是空节点(即 null)，并且是黑色的。</li><li>性质 4:每个红色节点的两个子节点都是黑色的。(从每个叶子到根的路径上不会有两个连续的红色节点。)</li><li>性质 5:从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。</li></ul><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91_2020-02-20-16-09-08.png" alt="数据结构与算法（六）——树_2020-02-20-16-09-08.png"></p><p>上图是一棵典型的红黑树，红黑树的 5 条特性确保了从根到叶子的最长的可能路径不多于最短的可能路径的两倍长，使得整棵树大致上是平衡的。树上的增删改查操作的最坏情况时间都与树的高度成正比，所以红黑树在最坏情况下也是高效的。</p><p>在红黑树中一般用黑的 NIL 节点表示叶节点，不包含值，只是标志该分支结束，有时候绘图中会直接省略。</p><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>当在含 n 个关键字的红黑树上进行 insert 和 delete 操作时，修改后的树可能不满足上面给出的 5 个红黑树的基本特性，所以需要改变树中的某些节点的颜色以及指针结构。 这些指针结构的修改是通过旋转完成的，旋转分为左旋和右旋:</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91_2020-02-20-16-16-55.png" alt="数据结构与算法（六）——树_2020-02-20-16-16-55.png"></p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p>疯狂 java 笔记之树和二叉树</p><p>图解红黑树</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（五）——队列</title>
      <link href="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/"/>
      <url>/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="队列介绍"><a href="#队列介绍" class="headerlink" title="队列介绍"></a>队列介绍</h1><p>队列是数据结构中比较重要的一种类型，它支持 FIFO，尾部添加、头部删除（先进队列的元素先出队列），跟我们生活中的排队类似。</p><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><ul><li>索引: O(n)</li><li>搜索: O(n)</li><li>插入: O(1)</li><li>移除: O(1)</li></ul><h1 id="队列类型"><a href="#队列类型" class="headerlink" title="队列类型"></a>队列类型</h1><h2 id="单队列"><a href="#单队列" class="headerlink" title="单队列"></a>单队列</h2><p>单队列就是常见的队列, 每次添加元素时，都是添加到队尾：<br>以数组实现的队列为例，初始时队列长度固定为 4，font 和 rear 均为 0：<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%98%9F%E5%88%97_2020-02-20-13-45-34.png" alt="数据结构与算法（五）——队列_2020-02-20-13-45-34.png"><br>每添加一个元素，rear 后移一位。当添加四个元素后， rear 到了索引为 4 的位置：<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%98%9F%E5%88%97_2020-02-20-13-46-12.png" alt="数据结构与算法（五）——队列_2020-02-20-13-46-12.png"><br>这时 a1,a2 出队，front 后移动到 2：<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%98%9F%E5%88%97_2020-02-20-13-46-40.png" alt="数据结构与算法（五）——队列_2020-02-20-13-46-40.png"><br>这时想要再添加两个元素，但 rear 后移两位后就会越界：<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%98%9F%E5%88%97_2020-02-20-13-47-26.png" alt="数据结构与算法（五）——队列_2020-02-20-13-47-26.png"><br>明明有三个空位，却只能再放入一个！这就是单队列的“假溢出”情况。<br>针对这种情况，解决办法就是后面满了，就再从头开始，也就是头尾相接的循环。这就是 “循环队列” 的概念。</p><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>循环队列中，<br>rear = (rear - size) % size</p><p>接着上面的例子，当 rear 大于 队列长度时，rear = ( 5 - 5) % 5 = 0 :<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%98%9F%E5%88%97_2020-02-20-13-52-12.png" alt="数据结构与算法（五）——队列_2020-02-20-13-52-12.png"><br>这样继续添加时，还可以添加几个元素：<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%98%9F%E5%88%97_2020-02-20-13-52-37.png" alt="数据结构与算法（五）——队列_2020-02-20-13-52-37.png"><br>那如何判断队列是否装满元素了呢，单使用 front == rear 无法判断究竟是空的还是满了。</p><p>两种方法：</p><ul><li>加个标志 flag ,初始为 false，添加满了置为 true；</li><li>不以 front = rear 为放满标志，改为 (rear - front) % size = 1。</li></ul><p>法 2 的公式放满元素时空余了一个位置，这个公式是什么意思呢？<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%98%9F%E5%88%97_2020-02-20-13-53-37.png" alt="数据结构与算法（五）——队列_2020-02-20-13-53-37.png"><br>接着上面的情况，当 rear 从后面添加元素跑到前面 0 时，再添加一个元素 a6，rear 后移一位到 1，这时 front = 2, (1 - 2) % 5 = 1, 满足放满条件。</p><p>因此，当 rear &gt; font 时，队列中元素个数 = rear - font;</p><p>当 rear &lt; font 时，队列中元素分为两部分： size - font 和 rear ,也就是 rear + size - font。以上述图片为例，队列中元素个数 = 1 + 5 - 2 = 4.</p><h1 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 1.单向队列（Queue）：只能在一端插入数据，另一端删除数据。</span></span><br><span class="line"><span class="comment">     * 2.双向队列（Deque）：每一端都可以进行插入数据和删除数据操作。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  与栈不同的是，队列中的数据不总是从数组的0下标开始的</span></span><br><span class="line"><span class="comment">     *  选择的做法是移动队头和队尾的指针。</span></span><br><span class="line"><span class="comment">     *  为了避免队列不满却不能插入新的数据，我们可以让队尾指针绕回到数组开始的位置，这也称为“循环队列”。</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="comment">// 单向循环队列，顺序存储结构实现</span></span><br><span class="line">    <span class="keyword">private</span> Object[] objQueue;</span><br><span class="line">    <span class="comment">//队列大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="comment">//顶部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top;</span><br><span class="line">    <span class="comment">//底部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bottom;</span><br><span class="line">    <span class="comment">//实际元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> item;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        maxSize = size;</span><br><span class="line">        objQueue = <span class="keyword">new</span> Object[maxSize];</span><br><span class="line">        top = <span class="number">0</span>;</span><br><span class="line">        bottom = -<span class="number">1</span>;</span><br><span class="line">        item = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入队</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(item == maxSize)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(obj+<span class="string">" add error, queue is full"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环队列，首尾结合，下标控制队首和队尾位置</span></span><br><span class="line">        <span class="keyword">if</span>(bottom == maxSize-<span class="number">1</span>)&#123;</span><br><span class="line">            bottom = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        objQueue[++bottom] = obj;</span><br><span class="line">        item++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出对</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(item == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"queue is null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Object obj = objQueue[top];</span><br><span class="line">        <span class="comment">//声明原顶栈可以回收空间(GC)</span></span><br><span class="line">        objQueue[top] = <span class="keyword">null</span>;</span><br><span class="line">        top++;</span><br><span class="line">        <span class="comment">//重置下标</span></span><br><span class="line">        <span class="keyword">if</span>(top == maxSize)&#123;</span><br><span class="line">            top = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        item--;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//链式存储结构实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeQueue</span>&lt;<span class="title">Object</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> NodeQueue next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NodeQueue</span><span class="params">(Object data, NodeQueue next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队列头 出</span></span><br><span class="line">    <span class="keyword">private</span> NodeQueue queueTop;</span><br><span class="line">    <span class="comment">//队列尾 进</span></span><br><span class="line">    <span class="keyword">private</span> NodeQueue queueBottom;</span><br><span class="line">    <span class="comment">//队列大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queueTop = <span class="keyword">null</span>;</span><br><span class="line">        queueBottom = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入队</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNodeQueue</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            queueTop = <span class="keyword">new</span> NodeQueue(obj,<span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//指向同一存储地址</span></span><br><span class="line">            queueBottom = queueTop;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            NodeQueue&lt;Object&gt; nodeQueue = <span class="keyword">new</span> NodeQueue(obj,<span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//让尾节点的next指向新增的节点</span></span><br><span class="line">            queueBottom.next = nodeQueue;</span><br><span class="line">            <span class="comment">//以新节点作为尾节点</span></span><br><span class="line">            queueBottom = nodeQueue;</span><br><span class="line">        &#125;</span><br><span class="line">        size ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出队</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">removeNodeQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"queue is null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        NodeQueue nodeQueue = queueTop;</span><br><span class="line">        queueTop = queueTop.next;</span><br><span class="line">        <span class="comment">//声明原队列头next可以回收空间(GC)</span></span><br><span class="line">        nodeQueue.next = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> nodeQueue.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"&#123; "</span>);</span><br><span class="line">        <span class="keyword">for</span>(NodeQueue nodeQueue = queueTop ; nodeQueue != <span class="keyword">null</span> ; nodeQueue = nodeQueue.next)&#123;</span><br><span class="line">            sb.append(nodeQueue.data.toString()+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString()+<span class="string">"&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue queue = <span class="keyword">new</span> Queue();</span><br><span class="line">        queue.addNodeQueue(<span class="string">"123"</span>);</span><br><span class="line">        queue.addNodeQueue(<span class="string">"abc"</span>);</span><br><span class="line">        queue.addNodeQueue(<span class="string">"ddd"</span>);</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">        queue.removeNodeQueue();</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">        queue.removeNodeQueue();</span><br><span class="line">        queue.removeNodeQueue();</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="队列应用"><a href="#队列应用" class="headerlink" title="队列应用"></a>队列应用</h1><ol><li>模拟现实世界中的队列，如售票柜台的队列以及其他先到先服务的场景。</li><li>计算客户在呼叫中心等待的时间。</li><li>异步数据的传输（文件输入输出、管道、嵌套字）。</li><li>操作系统中的优先级任务执行。</li><li>短信群体发送 应用的发布订阅模式</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（四）——栈</title>
      <link href="/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88/"/>
      <url>/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="栈介绍"><a href="#栈介绍" class="headerlink" title="栈介绍"></a>栈介绍</h1><ul><li>栈（stack）又称为堆栈或堆叠，栈作为一种数据结构，它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶</li><li>java 中 Stack 是 Vector 的一个子类，只定义了默认构造函数，用来创建一个空栈。</li><li>栈是元素的集合，其包含了两个基本操作：push 操作可以用于将元素压入栈，pop 操作可以将栈顶元素移除。</li><li>栈是一种特殊的线性表，其入栈和出栈只允许在一端进行。</li><li>遵循后入先出（LIFO）原则。</li></ul><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>数据结构中，栈是一种线性数据结构，遵从 LIFO（后进先出）的操作顺序，所有操作都是在顶部进行。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88_2020-02-17-17-16-10.png" alt="数据结构与算法（四）——栈_2020-02-17-17-16-10.png"></p><p>有点像羽毛球桶。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88_2020-02-17-17-17-12.png" alt="数据结构与算法（四）——栈_2020-02-17-17-17-12.png"></p><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><ul><li>索引: O(n)</li><li>搜索: O(n)</li><li>插入: O(1)</li><li>移除: O(1)</li></ul><h1 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h1><h2 id="数组实现-Stack-本是用数组实现的"><a href="#数组实现-Stack-本是用数组实现的" class="headerlink" title="数组实现( Stack 本是用数组实现的)"></a>数组实现( Stack 本是用数组实现的)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="comment">//小贴士：通常可以利用栈实现字符串逆序，还可以利用栈判断分隔符是否匹配，如&lt;a[b&#123;c&#125;]&gt;，可以正进反出，栈为空则成功。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**基于数组实现的顺序栈，连续存储的线性实现，需要初始化容量**/</span></span><br><span class="line">    <span class="comment">//固定数据类型</span></span><br><span class="line">    <span class="comment">//private int[] array;</span></span><br><span class="line">    <span class="comment">//动态数据类型</span></span><br><span class="line">    <span class="keyword">private</span> Object[] objArray;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(maxSize &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            objArray = <span class="keyword">new</span> Object[maxSize];</span><br><span class="line">            <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">            top = -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"初始化大小错误：maxSize="</span> + maxSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入栈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">objPush</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="comment">//扩容</span></span><br><span class="line">        grow();</span><br><span class="line">        <span class="comment">//++在前表示先运算再赋值，优先级高，在后表示先赋值再运算，优先级低</span></span><br><span class="line">        objArray[++top] = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出栈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">objPop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object obj = peekTop();</span><br><span class="line">        <span class="comment">//声明原顶栈可以回收空间(GC)</span></span><br><span class="line">        objArray[top--] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看栈顶</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">peekTop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(top != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> objArray[top];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"stack is null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态扩容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// &lt;&lt; 左移运算符，1表示乘以2的1次方</span></span><br><span class="line">        <span class="keyword">if</span>(top == maxSize-<span class="number">1</span>)&#123;</span><br><span class="line">            maxSize = maxSize&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            objArray = Arrays.copyOf(objArray,maxSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**基于链式存储，不连续存储的非线性实现**/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">Object</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object data, Node next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node nodeTop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nodePush</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="comment">//栈顶指向新元素，新元素的next指向原栈顶元素</span></span><br><span class="line">        nodeTop = <span class="keyword">new</span> Node(obj,nodeTop);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">nodePop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node old = nodeTop;</span><br><span class="line">        <span class="comment">//声明原顶栈可以回收空间(GC)</span></span><br><span class="line">        old.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//栈顶指向下一个元素</span></span><br><span class="line">        nodeTop = nodeTop.next;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> old.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"[ "</span>);</span><br><span class="line">        <span class="keyword">for</span>(Node&lt;Object&gt; node = nodeTop; node != <span class="keyword">null</span>; node = node.next)&#123;</span><br><span class="line">            sb.append(node.data.toString() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString()+<span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Stack stack = new Stack(1);</span></span><br><span class="line"><span class="comment">//        stack.objPush("abc");</span></span><br><span class="line"><span class="comment">//        stack.objPush(123);</span></span><br><span class="line"><span class="comment">//        stack.objPush("de");</span></span><br><span class="line"><span class="comment">//        stack.objPush("cd");</span></span><br><span class="line"><span class="comment">//        stack.objPush("er");</span></span><br><span class="line"><span class="comment">//        stack.objPush("hello");</span></span><br><span class="line"><span class="comment">//        stack.objPush(666);</span></span><br><span class="line"><span class="comment">//        stack.objPush(545);</span></span><br><span class="line"><span class="comment">//        stack.objPush("word");</span></span><br><span class="line"><span class="comment">//        while (stack.top != -1)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(stack.objPop());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println(stack.peekTop());</span></span><br><span class="line">        Stack stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        stack.nodePush(<span class="string">"111"</span>);</span><br><span class="line">        stack.nodePush(<span class="string">"222"</span>);</span><br><span class="line">        stack.nodePush(<span class="string">"aaa"</span>);</span><br><span class="line">        stack.nodePush(<span class="string">"bbb"</span>);</span><br><span class="line">        System.out.println(stack);</span><br><span class="line">        <span class="keyword">while</span> (stack.size &gt; <span class="number">1</span>)</span><br><span class="line">        System.out.println(stack.nodePop());</span><br><span class="line">        System.out.println(stack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * description:LinkedList 模拟 Stack</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * author: shixinzhang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * data: 10/23/2016</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListStack</span> <span class="keyword">extends</span> <span class="title">LinkedList</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedListStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.push(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">调用：</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPush</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    LinkedListStack stack = <span class="keyword">new</span> LinkedListStack();</span><br><span class="line">    System.out.println(<span class="string">"栈是否为空: "</span> + stack.isEmpty());</span><br><span class="line"></span><br><span class="line">    stack.push(<span class="string">"shixin"</span>);</span><br><span class="line">    stack.push(<span class="string">"好帅"</span>);</span><br><span class="line">    stack.push(<span class="string">"技巧一流"</span>);</span><br><span class="line">    stack.push(<span class="string">"haha"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"栈中元素: "</span> + stack);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"获取顶端元素 peek :"</span> + stack.peek());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"顶端元素出栈 pop :"</span> + stack.pop());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"出栈后栈内元素:"</span> + stack);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"search(好帅) 的位置:"</span> + stack.search(<span class="string">"好帅"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h1><ul><li>符号匹配</li><li>中缀表达式转换为后缀表达式</li><li>计算后缀表达式</li><li>实现函数的嵌套调用</li><li>HTML 和 XML 文件中的标签匹配</li><li>网浏览器中已访问页面的历史记录</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（三）——链表</title>
      <link href="/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="链表介绍"><a href="#链表介绍" class="headerlink" title="链表介绍"></a>链表介绍</h1><p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，是一种物理存储单元上非连续、非顺序的存储结构。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括存储数据元素的数据域和存储下一个结点地址的指针域两个部分。 相比于线性表顺序结构，操作复杂。数据元素的逻辑顺序也是通过链表中的指针链接次序实现的。</p><h1 id="物理储存"><a href="#物理储存" class="headerlink" title="物理储存"></a>物理储存</h1><p>链表的分布式没有顺序的，非连续的，也就是随心所欲，想在哪在哪，那怎么找到下一个的，就是靠指针连接的。以单向链表为例，如下图：<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8_2020-02-14-16-43-24.png" alt="数据结构与算法（三）——链表_2020-02-14-16-43-24.png"></p><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><ul><li>索引: O(n)</li><li>搜索: O(n)</li><li>插入: O(1)</li><li>移除: O(1)</li></ul><h1 id="链表的分类"><a href="#链表的分类" class="headerlink" title="链表的分类"></a>链表的分类</h1><ul><li>单向链表<br>链表中的节点仅指向下一个节点，并且最后一个节点指向空。<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8_2020-02-14-16-46-29.png" alt="数据结构与算法（三）——链表_2020-02-14-16-46-29.png"></li><li>双向链表<br>其中每个节点具有两个指针 p、n，使得 p 指向先前节点并且 n 指向下一个节点；最后一个节点的 n 指针指向 null。<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8_2020-02-14-16-47-56.png" alt="数据结构与算法（三）——链表_2020-02-14-16-47-56.png"></li><li>循环链表<br>每个节点指向下一个节点并且最后一个节点指向第一个节点的链表。<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8_2020-02-14-16-49-21.png" alt="数据结构与算法（三）——链表_2020-02-14-16-49-21.png"></li></ul><h1 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h1><h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLink</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Node head = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Object data;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Node next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        Node addNode = <span class="keyword">new</span> Node(data); <span class="comment">//实例化一个节点</span></span><br><span class="line">        <span class="comment">//判断是不是第一个节点,如果是的话，我就把这个加入到头节点,因为是头节点所有就没有前驱节点了</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = addNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果不是第一个节点 得找到当前链表的最后一个节点 把要加入的节点的当做最后一个节点的后继节点</span></span><br><span class="line">            Node temp = head; <span class="comment">//定义一个临时节点 把头节点赋值给他 然后一直找，直到找到最后一个节点</span></span><br><span class="line">            <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到当前链表最后一个节点，然后把要加入的这个节点当做尾节点的后继</span></span><br><span class="line">            temp.next = addNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == head) &#123;</span><br><span class="line">            System.out.println(<span class="string">"链表的长度为0"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 说明不是只有一个元素</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Node temp = head;</span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(temp.data);</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取链表的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先需要判断指定位置是否正确</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertNode</span><span class="params">(<span class="keyword">int</span> index, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">1</span> || index &gt; length() + <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"下标校验不通过。"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//临时节点，从头节点开始</span></span><br><span class="line">        Node temp = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录遍历的当前位置</span></span><br><span class="line">        <span class="keyword">int</span> currentPos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化要插入的节点</span></span><br><span class="line">        Node insertNode = <span class="keyword">new</span> Node(value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//找到上一个节点的位置了</span></span><br><span class="line">            <span class="keyword">if</span> ((index - <span class="number">1</span>) == currentPos) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//temp表示的是上一个节点</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//将原本由上一个节点的指向交由插入的节点来指向</span></span><br><span class="line">                insertNode.next = temp.next;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//将上一个节点的指针域指向要插入的节点</span></span><br><span class="line">                temp.next = insertNode;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            currentPos++;</span><br><span class="line">            temp = temp.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定位置的节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//首先需要判断指定位置是否正确，</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">1</span> || index &gt; length() + <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"下标校验不通过。"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//临时节点，从头节点开始</span></span><br><span class="line">        Node temp = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录遍历的当前位置</span></span><br><span class="line">        <span class="keyword">int</span> currentPos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//先找到要删除节点 上一个节点的位置</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index - <span class="number">1</span> == currentPos) &#123;</span><br><span class="line">                <span class="comment">//temp 表示要删除的节点</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//temp.next表示的是想要删除的节点</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//将想要删除的节点存储一下</span></span><br><span class="line">                Node deleteNode = temp.next;</span><br><span class="line">                <span class="comment">//把想要删除的下一个节点由上一个节点交互</span></span><br><span class="line">                temp.next = deleteNode.next;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            currentPos++;</span><br><span class="line">            temp = temp.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getOne</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">//首先需要判断指定位置是否正确，</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">1</span> || index &gt; length()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"下标校验不通过"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//临时节点</span></span><br><span class="line">        Node temp = head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录遍历的当前位置</span></span><br><span class="line">        <span class="keyword">int</span> currentPos = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index==currentPos)&#123;</span><br><span class="line">                <span class="keyword">return</span> temp.data;</span><br><span class="line">            &#125;</span><br><span class="line">            currentPos++;</span><br><span class="line">            temp=temp.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyLink myLink = <span class="keyword">new</span> MyLink();</span><br><span class="line">        myLink.addNode(<span class="string">"1"</span>);</span><br><span class="line">        myLink.addNode(<span class="string">"aaaa"</span>);</span><br><span class="line">        myLink.traverse();</span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">        myLink.delete(<span class="number">1</span>);</span><br><span class="line">        myLink.addNode(<span class="string">"333"</span>);</span><br><span class="line">        myLink.traverse();</span><br><span class="line">        System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">        Object one = myLink.getOne(<span class="number">1</span>);</span><br><span class="line">        System.out.println(one);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 链表通常由一连串节点组成，每个节点包含任意的实例数据（data fields）和一或两个用来指向上一个/或下一个节点的位置的链接（"links"）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node head; <span class="comment">//链表头</span></span><br><span class="line">    <span class="keyword">private</span> Node tail; <span class="comment">//链表尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size; <span class="comment">//节点数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双端链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object data;</span><br><span class="line">        <span class="keyword">private</span> Node prev; <span class="comment">//上一个</span></span><br><span class="line">        <span class="keyword">private</span> Node next; <span class="comment">//下一个</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向链表头添加数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addHead</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(object);</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            head = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            head.prev = node;</span><br><span class="line">            node.next = head;</span><br><span class="line">            head = node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//头部指向下一个，prev值为null则说明是链表的头部</span></span><br><span class="line">        <span class="keyword">if</span>(size != <span class="number">0</span>)&#123;</span><br><span class="line">            head.prev = <span class="keyword">null</span>;</span><br><span class="line">            head = head.next;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *向链表尾添加数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTail</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(object);</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            head = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node.prev = tail;</span><br><span class="line">            tail.next = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除尾部</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteTail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//尾部指向上一个，next值为null则说明是链表的尾部</span></span><br><span class="line">        <span class="keyword">if</span>(size != <span class="number">0</span>)&#123;</span><br><span class="line">            tail.next = <span class="keyword">null</span>;</span><br><span class="line">            tail = tail.prev;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node node = head;</span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.print(<span class="string">"["</span>+node.data+<span class="string">"-&gt;"</span>);</span><br><span class="line">            node = node.next;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList linkedList = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        linkedList.addHead(<span class="string">"123"</span>);</span><br><span class="line"><span class="comment">//        linkedList.addHead("abc");</span></span><br><span class="line"><span class="comment">//        linkedList.addHead("%$$");</span></span><br><span class="line"><span class="comment">//        linkedList.addTail("+_+");</span></span><br><span class="line"><span class="comment">//        linkedList.addTail("hello");</span></span><br><span class="line">        linkedList.addTail(<span class="string">"word"</span>);</span><br><span class="line">        linkedList.deleteHead();</span><br><span class="line">        linkedList.deleteTail();</span><br><span class="line">        linkedList.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表的优缺点"><a href="#链表的优缺点" class="headerlink" title="链表的优缺点"></a>链表的优缺点</h1><ul><li>优点：空间没有限制<br>插入删除元素很快</li><li>缺点：存取速度很慢</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法（二）——数组</title>
      <link href="/2020/02/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/"/>
      <url>/2020/02/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数组介绍"><a href="#数组介绍" class="headerlink" title="数组介绍"></a>数组介绍</h1><p>数组——数据结构的鼻祖。数组几乎能表示一切的数据结构。在 Java 中，数组是用来存放同一种数据类型的集合，注意只能存放同一种数据类型(Object 类型数组除外)。</p><h1 id="物理储存"><a href="#物理储存" class="headerlink" title="物理储存"></a>物理储存</h1><p>数组的内存空间都是连续的，如下图：<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84_2020-02-14-16-41-07.png" alt="数据结构与算法（二）——数组_2020-02-14-16-41-07.png"></p><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><ul><li>查找: O(n)</li><li>插入: O(1)</li><li>删除: O(n)</li></ul><h1 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a>数组的声明</h1><ol><li>第一种方式<br>数据类型 [] 数组名称 = new 数据类型[数组长度];</li><li>第二种方式<br>数据类型 [] 数组名称 = {数组元素 1，数组元素 2，……}</li></ol><h1 id="访问数组元素和赋值"><a href="#访问数组元素和赋值" class="headerlink" title="访问数组元素和赋值"></a>访问数组元素和赋值</h1><p>数组是存在下标索引的，通过下标可以获取指定位置的元素，数组小标是从 0 开始的，也就是说下标 0 对应的就是数组中第 1 个元素，可以很方便的对数组中的元素进行存取操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明数组,声明一个长度为3，只能存放int类型的数据</span></span><br><span class="line"><span class="keyword">int</span> [] myArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//给myArray第一个元素赋值1</span></span><br><span class="line">myArray[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//访问myArray的第一个元素</span></span><br><span class="line">System.out.println(myArray[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>上面的 myArray 数组，我们只能赋值三个元素，也就是下标从 0 到 2，如果你访问 myArray[3] ，那么会报数组下标越界异常。</p><h1 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h1><p>数组有个 length 属性，是记录数组的长度的，我们可以利用 length 属性来遍历数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明数组2,声明一个数组元素为 1,2,3的int类型数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> [] myArray2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; myArray2.length ; i++)&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(myArray2[i]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ys.array;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> </span>&#123;</span><br><span class="line">     <span class="comment">//定义一个数组</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> [] intArray;</span><br><span class="line">     <span class="comment">//定义数组的实际有效长度</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> elems;</span><br><span class="line">     <span class="comment">//定义数组的最大长度</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//默认构造一个长度为50的数组</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">MyArray</span><span class="params">()</span></span>&#123;</span><br><span class="line">         elems = <span class="number">0</span>;</span><br><span class="line">         length = <span class="number">50</span>;</span><br><span class="line">         intArray = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//构造函数，初始化一个长度为length 的数组</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">MyArray</span><span class="params">(<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">         elems = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">this</span>.length = length;</span><br><span class="line">         intArray = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//获取数组的有效长度</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> elems;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 遍历显示元素</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; elems ; i++)&#123;</span><br><span class="line">             System.out.print(intArray[i]+<span class="string">" "</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 添加元素</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> value,假设操作人是不会添加重复元素的，如果有重复元素对于后面的操作都会有影响。</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span>添加成功返回true,添加的元素超过范围了返回false</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(elems == length)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             intArray[elems] = value;</span><br><span class="line">             elems++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 根据下标获取元素</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span>查找下标值在数组下标有效范围内，返回下标所表示的元素</span></span><br><span class="line"><span class="comment">      * 查找下标超出数组下标有效值，提示访问下标越界</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;elems)&#123;</span><br><span class="line">             System.out.println(<span class="string">"访问下标越界"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> intArray[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 查找元素</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> searchValue</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span>查找的元素如果存在则返回下标值，如果不存在，返回 -1</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> searchValue)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> i ;</span><br><span class="line">         <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; elems ;i++)&#123;</span><br><span class="line">             <span class="keyword">if</span>(intArray[i] == searchValue)&#123;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(i == elems)&#123;</span><br><span class="line">             <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> i;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 删除元素</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span>如果要删除的值不存在，直接返回 false;否则返回true，删除成功</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> k = find(value);</span><br><span class="line">         <span class="keyword">if</span>(k == -<span class="number">1</span>)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">if</span>(k == elems-<span class="number">1</span>)&#123;</span><br><span class="line">                 elems--;</span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i&lt; elems-<span class="number">1</span> ; i++)&#123;</span><br><span class="line">                     intArray[i] = intArray[i+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                 &#125;</span><br><span class="line">                  elems--;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 修改数据</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> oldValue原值</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> newValue新值</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span>修改成功返回true，修改失败返回false</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> oldValue,<span class="keyword">int</span> newValue)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> i = find(oldValue);</span><br><span class="line">         <span class="keyword">if</span>(i == -<span class="number">1</span>)&#123;</span><br><span class="line">             System.out.println(<span class="string">"需要修改的数据不存在"</span>);</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             intArray[i] = newValue;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="数组的局限性"><a href="#数组的局限性" class="headerlink" title="数组的局限性"></a>数组的局限性</h1><ol><li>插入快：无序数组只需要在数组末尾插入；有序数组需要在指定的位置插入</li><li>查找慢：根据下标取值是很快的，但根据元素查找的话，如果是无序数组，需要一个个遍历，是很慢的。有序数组，根据特定的算法会快一些（各种排序算法）。</li><li>删除慢：根据元素值删除，我们要先找到该元素所处的位置，然后将元素后面的值整体向前面移动一个位置。也需要比较多的时间。</li><li>数组一旦创建后，大小就固定了，不能动态扩展数组的元素个数。如果初始化你给一个很大的数组大小，那会白白浪费内存空间，如果给小了，后面数据个数增加了又添加不进去了。</li><li>需要大块连续的内存块</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构和算法（一）——简介</title>
      <link href="/2020/02/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E7%AE%80%E4%BB%8B/"/>
      <url>/2020/02/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要学习数据结构与算法"><a href="#为什么要学习数据结构与算法" class="headerlink" title="为什么要学习数据结构与算法"></a>为什么要学习数据结构与算法</h1><p>首先，学编程一定要学数据结构与算法，不会数据结构与算法一样可以编程。这矛盾吗？一点都不矛盾。学开车一定要懂发动机吗？但是你懂的发动机无疑能够更懂得汽车，汽车怎么开的更快、功耗降低。。。学习数据结构与算法能够让你了解该用什么数据结构储存数据，这涉及到编程中关键的性能和效率问题。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>数据结构是计算机存储、组织数据的方式，指相互之间存在一种或多种特定关系的数据元素的集合。</p><h2 id="数据结构的基本功能"><a href="#数据结构的基本功能" class="headerlink" title="数据结构的基本功能"></a>数据结构的基本功能</h2><ol><li>如何插入一条新的数据项</li><li>如何寻找某一特定的数据项</li><li>如何删除某一特定的数据项</li><li>如何迭代的访问各个数据项，以便进行显示或其他操作</li></ol><h2 id="常用的数据结构及优缺点"><a href="#常用的数据结构及优缺点" class="headerlink" title="常用的数据结构及优缺点"></a>常用的数据结构及优缺点</h2><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E7%AE%80%E4%BB%8B_2020-02-04-18-49-33.png" alt="数据结构和算法（一）——简介_2020-02-04-18-49-33.png"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E7%AE%80%E4%BB%8B_2020-02-04-18-52-35.png" alt="数据结构和算法（一）——简介_2020-02-04-18-52-35.png"><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E7%AE%80%E4%BB%8B_2020-02-14-16-59-11.png" alt="数据结构和算法（一）——简介_2020-02-14-16-59-11.png"></p><h2 id="数据结构的选择"><a href="#数据结构的选择" class="headerlink" title="数据结构的选择"></a>数据结构的选择</h2><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E7%AE%80%E4%BB%8B_2020-02-14-17-02-10.png" alt="数据结构和算法（一）——简介_2020-02-14-17-02-10.png"></p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>算法简单来说就是解决问题的步骤。</p><p>在 Java 中，算法通常都是由类的方法来实现的。前面的数据结构，比如链表为啥插入、删除快，而查找慢，平衡的二叉树插入、删除、查找都快，这都是实现这些数据结构的算法所造成的。后面我们讲的各种排序实现也是算法范畴的重要领域。</p><h2 id="算法的五个要素"><a href="#算法的五个要素" class="headerlink" title="算法的五个要素"></a>算法的五个要素</h2><ol><li>有穷性：对于任意一组合法输入值，在执行又穷步骤之后一定能结束，即：算法中的每个步骤都能在有限时间内完成。</li><li>确定性：在每种情况下所应执行的操作，在算法中都有确切的规定，使算法的执行者或阅读者都能明确其含义及如何执行。并且在任何条件下，算法都只有一条执行路径。</li><li>可行性：算法中的所有操作都必须足够基本，都可以通过已经实现的基本操作运算有限次实现之。</li><li>有输入：作为算法加工对象的量值，通常体现在算法当中的一组变量。有些输入量需要在算法执行的过程中输入，而有的算法表面上可以没有输入，实际上已被嵌入算法之中。</li><li>有输出：它是一组与“输入”有确定关系的量值，是算法进行信息加工后得到的结果，这种确定关系即为算法功能。</li></ol><h2 id="算法的设计原则"><a href="#算法的设计原则" class="headerlink" title="算法的设计原则"></a>算法的设计原则</h2><ol><li>正确性：首先，算法应当满足以特定的“规则说明”方式给出的需求。其次，对算法是否“正确”的理解可以有以下四个层次：<ul><li>程序语法错误。</li><li>程序对于几组输入数据能够得出满足需要的结果。</li><li>程序对于精心选择的、典型、苛刻切带有刁难性的几组输入数据能够得出满足要求的结果。</li><li>程序对于一切合法的输入数据都能得到满足要求的结果。<br>　　 PS：通常以第 三 层意义的正确性作为衡量一个算法是否合格的标准。</li></ul></li><li>可读性：算法为了人的阅读与交流，其次才是计算机执行。因此算法应该易于人的理解；另一方面，晦涩难懂的程序易于隐藏较多的错误而难以调试。</li><li>健壮性：当输入的数据非法时，算法应当恰当的做出反应或进行相应处理，而不是产生莫名其妙的输出结果。并且，处理出错的方法不应是中断程序执行，而是应当返回一个表示错误或错误性质的值，以便在更高的抽象层次上进行处理。</li><li>高效率与低存储量需求：通常算法效率值得是算法执行时间；存储量是指算法执行过程中所需要的最大存储空间，两者都与问题的规模有关。</li></ol><h2 id="算法复杂度及分析"><a href="#算法复杂度及分析" class="headerlink" title="算法复杂度及分析"></a>算法复杂度及分析</h2><p>如何度量一个算法的执行速度并评价其效率？</p><ol><li>_渐进复杂度_： 在评价算法的运行时间时，我们往往可以忽略其在处理小规模问题时的性能，转而关注其在处理足够大规模问题时的性能，即所谓的渐进复杂度。原因不难理解，小规模的问题所需的处理时间相对更少，不同算法在效率方面的差异并不明显；只有在处理大规模的问题时，这方面的差异才有质的区别。</li><li>_基本操作次数_： 即便是同一算法、同一输入，在不同的硬<br>件平台上、使用不同的操作系统所需要的计算时间都不相同。然而实际上，无论在何种计算环境中，每一次基本操作都可以在常数时间内完成，因此如果根据算法所需执行的基本操作次数来表示，就可以更加客观地反映算法的效率。</li><li>_实测统计_： 而有些算法的时间复杂度极难从理论上作出分析，此时我们可以采用实验的方法，随机选择足够多规模不同的输入，通过实测统计得出运行时间随输入规模而增长的趋势。</li><li>_只关注时间复杂度_： 就渐进复杂度的意义而言，在任何一个算法的任何一次运行过程中，其实际占用的存储空间都不会多于其间执行的基本操作次数。从这个意义上说，时间复杂度本身就是空间复杂度的一个上界。<br><strong>注：当然，空间复杂度本身也有其存在的意义，尤其是在对空间效率非常在乎的应用场合，或者是当问题的输入规模极为庞大时。</strong></li></ol><ul><li>表示算法复杂度的度量记号大 O 级别</li></ul><ol><li>O(1)：最低的复杂度，无论数据量大小，耗时都不变，都可以在一次计算后获得。哈希算法就是典型的 O(1)</li><li>O(n)：线性，n 表示数据的量，当量增大，耗时也增大，常见有遍历算法</li><li>O(n²)：平方，表示耗时是 n 的平方倍，当看到循环嵌循环的时候，基本上这个算法就是平方级的，如：冒泡排序等</li><li>O(log n)：对数，通常 ax=n,那么数 x 叫做以 a 为底 n 的对数,也就是 x=logan，这里是 a 通常是 2，如：数量增大 8 倍，耗时只增加了 3 倍，二分查找就是对数级的算法，每次剔除一半</li><li>O(n log n)：线性对数，就是 n 乘以 log n,按照上面说的数据增大 8 倍，耗时就是 8*3=24 倍，归并排序就是线性对数级的算法</li></ol><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E7%AE%80%E4%BB%8B_2020-02-14-16-09-13.png" alt="数据结构和算法（一）——简介_2020-02-14-16-09-13.png"></p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p>数据结构与算法(java 描述)</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 简介 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPU飙升到100%的原因</title>
      <link href="/2020/01/08/CPU%E9%A3%99%E5%8D%87%E5%88%B0100-%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
      <url>/2020/01/08/CPU%E9%A3%99%E5%8D%87%E5%88%B0100-%E7%9A%84%E5%8E%9F%E5%9B%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是-cpu-使用率？"><a href="#什么是-cpu-使用率？" class="headerlink" title="什么是 cpu 使用率？"></a>什么是 cpu 使用率？</h3><p>CPU％= 1 - idleTime / sysTime * 100<br>idleTime：CPU 空闲的时间<br>sysTime：CPU 处于用户模式和内核模式的时间总和</p><h3 id="与-cpu-有关的是什么？"><a href="#与-cpu-有关的是什么？" class="headerlink" title="与 cpu 有关的是什么？"></a>与 cpu 有关的是什么？</h3><p><strong>计算密集型程序的 CPU 密集程度更高</strong>。<br>那么，JAVA 应用程序中的哪些操作更加 CPU 密集？<br>以下列出了常见的 CPU 密集型操作：</p><ol><li>频繁的 GC; 如果访问量很高，可能会导致频繁的 GC 甚至 FGC。当调用量很大时，内存分配将如此之快以至于 GC 线程将连续执行，这将导致 CPU 飙升。</li><li>序列化和反序列化。稍后将给出一个示例：当程序执行 xml 解析时，调用量会增加，从而导致 CPU 变满。</li><li>序列化和反序列化;</li><li>正则表达式。我遇到了正则表达式使 CPU 充满的情况; 原因可能是 Java 正则表达式使用的引擎实现是 NFA 自动机，它将在字符匹配期间执行回溯。</li><li>线程上下文切换; 有许多已启动的线程，这些线程的状态在 Blocked（锁定等待，IO 等待等）和 Running 之间发生变化。当锁争用激烈时，这种情况很容易发生。</li><li>有些线程正在执行非阻塞操作，例如 while(true)语句。如果在程序中计算需要很长时间，则可以使线程休眠。</li></ol><h3 id="cpu-是否与进程和线程有关？"><a href="#cpu-是否与进程和线程有关？" class="headerlink" title="cpu 是否与进程和线程有关？"></a>cpu 是否与进程和线程有关？</h3><p>线程的等待及阻塞不会使用 CPU 资源，线程的频繁的上下文切换（锁竞争激烈）容易造成 CPU 飙升。</p><h3 id="一问一答"><a href="#一问一答" class="headerlink" title="一问一答"></a>一问一答</h3><ol><li><p>while 的无限循环会导致 CPU 使用率飙升吗？<br>会。<br>首先，无限循环将调用 CPU 寄存器进行计数，此操作将占用 CPU 资源。那么，如果线程始终处于无限循环状态，CPU 是否会切换线程？<br>除非操作系统时间片到期，否则无限循环不会放弃占用的 CPU 资源，并且无限循环将继续向系统请求时间片，直到系统没有空闲时间来执行任何其他操作。<br>stackoverflow 中也提出了这个问题：<a href="https://stackoverflow.com/questions/2846165/why-does-an-infinite-loop-of-the-unintended-kind-increase-the-cpu-use" target="_blank" rel="noopener">为什么无意的无限循环增加了 CPU 的使用？</a></p></li><li><p>频繁的 Young GC 会导致 CPU 占用率飙升吗？<br>会。<br>Young GC 本身就是 JVM 用于垃圾收集的操作，它需要计算内存和调用寄存器。因此，频繁的 Young GC 必须占用 CPU 资源。<br>让我们来看一个现实世界的案例。for 循环从数据库中查询数据集合，然后再次封装新的数据集合。如果内存不足以存储，JVM 将回收不再使用的数据。因此，如果所需的存储空间很大，您可能会收到 CPU 使用率警报。</p></li><li><p>对于 CPU 占用率高的应用程序，线程数是否较大？<br>不是。<br>高 CPU 使用率的关键因素是计算密集型操作。如果一个线程中有大量计算，则 CPU 使用率也可能很高。这也是数据脚本任务需要在大规模集群上运行的原因。</p></li><li><p>如果分时操作系统中 CPU 的值 us 或 sy 值很高，这意味着什么？<br>您可以使用命令查找 CPU 的值 us 和 sy 值 top<br>us：用户空间占用 CPU 的百分比。简单来说，高我们是由程序引起的。通过分析线程堆栈很容易找到有问题的线程。整编：微信公众号，搜云库技术团队，ID：souyunku<br>sy：内核空间占用 CPU 的百分比。当 sy 为高时，如果它是由程序引起的，那么它基本上是由于线程上下文切换。</p></li></ol><h3 id="如何找出-CPU-使用率高的原因"><a href="#如何找出-CPU-使用率高的原因" class="headerlink" title="如何找出 CPU 使用率高的原因"></a>如何找出 CPU 使用率高的原因</h3><p>如果发现应用程序服务器的 CPU 使用率很高，请首先检查线程数，JVM，系统负载等参数，然后使用这些参数来证明问题的原因。其次，使用 jstack 打印堆栈信息并使用工具分析线程使用情况</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzA3MTUzOTcxOQ==&mid=2452969215&idx=1&sn=1dc1a52231895d8cd15f0f33f774a8ef&scene=21#wechat_redirect" target="_blank" rel="noopener">这六种原因，真能让 Java 应用 CPU 使用率飙升至 100% 吗？</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux之shell脚本学习</title>
      <link href="/2019/12/16/linux%E4%B9%8Bshell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/12/16/linux%E4%B9%8Bshell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-shell？"><a href="#什么是-shell？" class="headerlink" title="什么是 shell？"></a>什么是 shell？</h2><p>代理，linux 命令与 linux 内核间的代理； 对一个纯文本的文件进行解析，然后执行这些功能，也可以说 Shell 脚本就是一系列命令的集合。</p><h2 id="shell-能做什么？"><a href="#shell-能做什么？" class="headerlink" title="shell 能做什么？"></a>shell 能做什么？</h2><ul><li>将一些复杂的命令简单化(平时我们提交一次 github 代码可能需要很多步骤，但是可以用 Shell 简化成一步)</li><li>可以写一些脚本自动实现一个工程中自动更换最新的 sdk(库)</li><li>自动打包、编译、发布等功能</li><li>清理磁盘中空文件夹</li><li>总之一切有规律的活脚本都可以尝试一下</li></ul><h2 id="shell-不能做什么？"><a href="#shell-不能做什么？" class="headerlink" title="shell 不能做什么？"></a>shell 不能做什么？</h2><ul><li>需要精密的运算的时候</li><li>需要语言效率很高的时候</li><li>需要一些网络操作的时候</li><li>总之 Shell 就是可以快速开发一个脚本简化开发流程，并不可以用来替代高级语言</li></ul><h2 id="shell-工作原理"><a href="#shell-工作原理" class="headerlink" title="shell 工作原理"></a>shell 工作原理</h2><p>Shell 可以被称作是脚本语言，因为它本身是不需要编译的，而是通过解释器解释之后再编译执行，和传统语言相比多了解释的过程所以效率会略差于传统的直接编译的语言。</p><h2 id="hello-world-脚本"><a href="#hello-world-脚本" class="headerlink" title="hello world 脚本"></a>hello world 脚本</h2><blockquote><p>#!/bin/bash<br>echo “Hello World”</p></blockquote><h2 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h2><blockquote><p>cd 到该目录下<br>chmod +x ./test.sh #给脚本权限<br>./test.sh #执行脚本<br>也可以直接 sh test.sh，无须#!/bin/bash</p></blockquote><p><img src="/images/linux%E4%B9%8Bshell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0_2019-12-19-15-29-37.png" alt="linux之shell脚本学习_2019-12-19-15-29-37.png"></p><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="创建变量"><a href="#创建变量" class="headerlink" title="创建变量"></a>创建变量</h4><blockquote><p>myText=”hello world”<br>muNum=100</p></blockquote><p>“=”前后不能有空格，命名规则就和其它语言一样。</p><h4 id="访问变量"><a href="#访问变量" class="headerlink" title="访问变量"></a>访问变量</h4><blockquote><p>myText=”hello world”<br>muNum=100<br>echo $myText<br>echo muNum</p></blockquote><p>当想要访问变量的时候，需要使用$，否则输出的将是纯文本内容:</p><blockquote><p>root@8f24935911d1:/home/qn/shell# ./hello.sh<br>hello world<br>muNum</p></blockquote><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除 + - * /"></a>加减乘除 + - * /</h4><blockquote><p>#!/bin/bash<br>echo “Hello World !”<br>a=3<br>b=5<br>val=<code>expr $a + $b</code><br>echo “Total value : $val”<br>val=<code>expr $a - $b</code><br>echo “Total value : $val”<br>val=<code>expr $a \* $b</code><br>echo “Total value : $val”<br>val=<code>expr $a / $b</code><br>echo “Total value : $val”</p></blockquote><p>定义变量的时候“=”前后是不能有空格的，但是进行四则运算的时候运算符号前后一定要有空格，乘法的时候需要进行转义</p><blockquote><p>root@8f24935911d1:/home/qn/shell# ./hello.sh<br>Hello World !<br>Total value : 8<br>Total value : -2<br>Total value : 15<br>Total value : 0</p></blockquote><h4 id="其它运算符-、-、-、！、-o、-a"><a href="#其它运算符-、-、-、！、-o、-a" class="headerlink" title="其它运算符 =、==、!=、！、-o、-a"></a>其它运算符 =、==、!=、！、-o、-a</h4><p><img src="/images/linux%E4%B9%8Bshell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0_2019-12-19-15-49-19.png" alt="linux之shell脚本学习_2019-12-19-15-49-19.png"></p><blockquote><p>a=3<br>b=5<br>val=<code>expr $a / $b</code><br>echo “Total value : $val”<br>val=<code>expr $a % $b</code><br>echo “Total value : $val”<br>if [ $a == $b ]<br>then<br>&emsp;&emsp;echo “a is equal to b”<br>fi<br>if [ $a != $b ]<br>then<br>&emsp;&emsp;echo “a is not equal to b”<br>fi</p></blockquote><blockquote><p>root@8f24935911d1:/home/qn/shell# ./hello.sh<br>Total value : 0<br>Total value : 3<br>a is not equal to b</p></blockquote><h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p><img src="/images/linux%E4%B9%8Bshell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0_2019-12-19-15-58-30.png" alt="linux之shell脚本学习_2019-12-19-15-58-30.png"></p><blockquote><p>a=10<br>b=20<br>if [ $a -eq $b ]<br>then<br>&emsp;&emsp;echo “true”<br>else<br>&emsp;&emsp;echo “false”<br>fi<br>if [ $a -ne $b ]<br>then<br>&emsp;&emsp;echo “true”<br>else<br>&emsp;&emsp;echo “false”<br>fi<br>if [ $a -gt $b ]<br>then<br>&emsp;&emsp;echo “true”<br>else<br>&emsp;&emsp;echo “false”<br>fi<br>if [ $a -lt $b ]<br>then<br>&emsp;&emsp;echo “true”<br>else<br>&emsp;&emsp;echo “false”<br>fi<br>if [ $a -ge $b ]<br>then<br>&emsp;&emsp;echo “true”<br>else<br>&emsp;&emsp;echo “false”<br>fi<br>if [ $a -le $b ]<br>then<br>&emsp;&emsp;echo “true”<br>else<br>&emsp;&emsp;echo “false”<br>fi</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux脚本之crontab(定时任务)</title>
      <link href="/2019/12/16/linux%E8%84%9A%E6%9C%AC%E4%B9%8Bcrontab-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/2019/12/16/linux%E8%84%9A%E6%9C%AC%E4%B9%8Bcrontab-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>crontab 命令常见于 Unix 和类 Unix 的操作系统之中，用于设置周期性被执行的指令。</li><li>该命令从标准输入设备读取指令，并将其存放于 crontab 文件中</li><li>crontab 储存的指令被守护进程激活，crond 常常在后台运行，每一分钟检查是否有预定的作业需要执行。这类作业一般称为 cron jobs。</li></ul><h2 id="安装-cron-docker-ubuntu"><a href="#安装-cron-docker-ubuntu" class="headerlink" title="安装 cron(docker ubuntu)"></a>安装 cron(docker ubuntu)</h2><h3 id="确认是否安装"><a href="#确认是否安装" class="headerlink" title="确认是否安装"></a>确认是否安装</h3><p>一般 linux 版本都已经安装了 crontab，我们可以执行 crontab 确认：</p><blockquote><p>-bash: crontab: command not found</p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote><p>apt-get install cron</p></blockquote><p>如果报出这个错误：Unable to locate package，这个错误一般是因为软件源未更新造成的，于是采用命令：sudo apt-get update 来更新软件源</p><h3 id="确认-cron-安装成功"><a href="#确认-cron-安装成功" class="headerlink" title="确认 cron 安装成功"></a>确认 cron 安装成功</h3><blockquote><p>crontab -l</p></blockquote><h3 id="设置定时任务"><a href="#设置定时任务" class="headerlink" title="设置定时任务"></a>设置定时任务</h3><blockquote><p>crontab -e</p></blockquote><p>_/1 _ * * * cd /home/qn/shell&amp;&amp;sh test.sh &gt; time.log</p><h3 id="启动定时任务"><a href="#启动定时任务" class="headerlink" title="启动定时任务"></a>启动定时任务</h3><blockquote><p>service cron start</p></blockquote><h2 id="安装日志服务-rsyslog"><a href="#安装日志服务-rsyslog" class="headerlink" title="安装日志服务 rsyslog"></a>安装日志服务 rsyslog</h2><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><blockquote><p>vi /etc/rsyslog.d/50-default.conf</p></blockquote><p>cron.* /var/log/cron.log #将 cron 前面的注释符去掉</p><h3 id="启动日志服务"><a href="#启动日志服务" class="headerlink" title="启动日志服务"></a>启动日志服务</h3><blockquote><p>service rsyslog start</p></blockquote><h3 id="重启-cron"><a href="#重启-cron" class="headerlink" title="重启 cron"></a>重启 cron</h3><blockquote><p>service cron restart</p></blockquote><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><blockquote><p>tail -f /var/log/cron.log</p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>时程表的格式如下:</p><blockquote><p>f1 f2 f3 f4 f5 program</p></blockquote><p>其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执行的程式。</p>]]></content>
      
      
      <categories>
          
          <category> linux脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 定时任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka的原理解析</title>
      <link href="/2019/12/05/Kafka%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
      <url>/2019/12/05/Kafka%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>Kafka 是最初由 Linkedin 公司开发，是一个分布式、支持分区的（<code>partition</code>）、多副本的（<code>replica</code>），基于<code>zookeeper</code>协调的分布式消息系统，它的最大的特性就是可以实时的处理大量数据。</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>消息队列的性能好坏，其<strong>文件存储机制设计</strong>是衡量一个消息队列服务技术水平和最关键指标之一。下面将从 Kafka 文件存储机制和物理结构角度，分析 Kafka 是如何实现高效文件存储，及实际应用效果。</p><h1 id="kafka-特性"><a href="#kafka-特性" class="headerlink" title="kafka 特性"></a>kafka 特性</h1><h2 id="高吞吐量、低延迟"><a href="#高吞吐量、低延迟" class="headerlink" title="高吞吐量、低延迟"></a>高吞吐量、低延迟</h2><p>kafka 每秒可以处理几十万条消息，它的延迟最低只有几毫秒。（每个 topic 可以分多个 partition, consumer group 多个 consume thread 对 partition 进行消费）</p><h2 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h2><p>kafka 支持热扩展，水平扩展（partition）</p><h2 id="持久性、可靠性"><a href="#持久性、可靠性" class="headerlink" title="持久性、可靠性"></a>持久性、可靠性</h2><p>消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</p><h2 id="容错性"><a href="#容错性" class="headerlink" title="容错性"></a>容错性</h2><p>允许集群中节点失败（若副本数量为 n,则允许 n-1 个节点失败）</p><h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><p>支持数千个客户端同时读写</p><h1 id="kafka-使用场景"><a href="#kafka-使用场景" class="headerlink" title="kafka 使用场景"></a>kafka 使用场景</h1><h2 id="日志收集"><a href="#日志收集" class="headerlink" title="日志收集"></a>日志收集</h2><p>一个公司可以用 Kafka 可以收集各种服务的 log，通过 kafka 以统一接口服务的方式开放给各种 consumer，例如 hadoop、Hbase、Solr 等。</p><h2 id="消息系统"><a href="#消息系统" class="headerlink" title="消息系统"></a>消息系统</h2><p>解耦和生产者和消费者、缓存消息等。</p><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>轨迹，访问量等信息，被各服务推送到 topic，消费者通过订阅这些消息做监控分析。</p><h2 id="运营指标"><a href="#运营指标" class="headerlink" title="运营指标"></a>运营指标</h2><p>Kafka 也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</p><h2 id="流式处理"><a href="#流式处理" class="headerlink" title="流式处理"></a>流式处理</h2><p>比如 spark streaming 和 storm</p><h2 id="事件源"><a href="#事件源" class="headerlink" title="事件源"></a>事件源</h2><p>略</p><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><h2 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h2><p>kafka 集群节点,在集群中每个 broker 都有一个唯一 brokerid，不得重复。</p><h2 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h2><ul><li>在 Kafka 中的每一条消息都有一个 Topic。一般来说在我们应用中产生不同类型的数据，都可以设置不同的主题。</li><li>一个主题一般会有多个消息的订阅者，当生产者发布消息到某个主题时，订阅了这个主题的消费者都可以接收到生产者写入的新消息。</li></ul><h2 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h2><p>kafka 是面对分布式系统的，同时一个 topic 对应 partition，一个 partition 有对个副本,会从所有的副本中选取一个 leader 出来。所有读写操作都是通过 leader 来进行的。一个 partition 是个有序队列。</p><h2 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h2><p>在分区中的每条消息都会按照时间顺序分配到一个单调递增的顺序编号，也就是我们的 Offset。Offset 是一个 Long 型的数字。</p><h2 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h2><p>负责发布消息到 Kafka broker。</p><h2 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h2><p>消息消费者，向 Kafka broker 读取消息的客户端。</p><h2 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h2><p>各个 consumer（consumer 线程）可以组成一个组（Consumer group），partition 中的每个 message 只能被组（Consumer group）中的一个 consumer（consumer 线程）消费。</p><h1 id="Zookeeper-在-kafka-的作用"><a href="#Zookeeper-在-kafka-的作用" class="headerlink" title="Zookeeper 在 kafka 的作用"></a>Zookeeper 在 kafka 的作用</h1><p>kafka 用 zk 做 meta 信息存储，consumer 的消费状态，group 的管理以及 offse t 的值。考虑到 zk 本身的一些因素以及整个架构较大概率存在单点问题，新版本中确实逐渐弱化了 zookeeper 的作用。新的 consumer 使用了 kafka 内部的 group coordination 协议，也减少了对 zookeeper 的依赖</p><h2 id="zookeeper-储存"><a href="#zookeeper-储存" class="headerlink" title="zookeeper 储存"></a>zookeeper 储存</h2><h4 id="储存结构图"><a href="#储存结构图" class="headerlink" title="储存结构图"></a>储存结构图</h4><p><img src="/images/Kafka%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90_2019-12-09-15-48-21.png" alt="Kafka的原理解析_2019-12-09-15-48-21.png"></p><h4 id="broker-注册"><a href="#broker-注册" class="headerlink" title="broker 注册"></a>broker 注册</h4><p>/brokers/ids/[0..n] 向 zookeeper 注册自己的节点信息，是一个临时节点，及 broker.id,当 id&gt;0 才会正常启动；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Schema:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"jmx_port"</span>: jmx端口号,</span><br><span class="line"><span class="string">"timestamp"</span>: kafka broker初始启动时的时间戳,</span><br><span class="line"><span class="string">"host"</span>: 主机名或ip地址,</span><br><span class="line"><span class="string">"version"</span>: 版本编号默认为<span class="number">1</span>,</span><br><span class="line"><span class="string">"port"</span>: kafka broker的服务端端口号,由server.properties中参数port确定</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"jmx_port"</span>: -<span class="number">1</span>,</span><br><span class="line"><span class="string">"timestamp"</span>:<span class="string">"1525741823119"</span></span><br><span class="line"><span class="string">"version"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="string">"host"</span>: <span class="string">"hadoop1"</span>,</span><br><span class="line"><span class="string">"port"</span>: <span class="number">9092</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="topic-注册"><a href="#topic-注册" class="headerlink" title="topic 注册"></a>topic 注册</h4><p>/brokers/topics/[topic] 向 zookeeper 注册 topic 信息，以及 topic 下所有 partition 分配信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Schema:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"jmx_port"</span>: jmx端口号,</span><br><span class="line"><span class="string">"timestamp"</span>: kafka broker初始启动时的时间戳,</span><br><span class="line"><span class="string">"host"</span>: 主机名或ip地址,</span><br><span class="line"><span class="string">"version"</span>: 版本编号默认为<span class="number">1</span>,</span><br><span class="line"><span class="string">"port"</span>: kafka broker的服务端端口号,由server.properties中参数port确定</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"jmx_port"</span>: -<span class="number">1</span>,</span><br><span class="line"><span class="string">"timestamp"</span>:<span class="string">"1525741823119"</span></span><br><span class="line"><span class="string">"version"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="string">"host"</span>: <span class="string">"hadoop1"</span>,</span><br><span class="line"><span class="string">"port"</span>: <span class="number">9092</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="partition-注册"><a href="#partition-注册" class="headerlink" title="partition 注册"></a>partition 注册</h4><p>/brokers/topics/[topic]/partitions/[partitionId]/state 注册 partition 状态信息（副本 leader 所在的 brokerId）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Schema:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"controller_epoch"</span>: 表示kafka集群中的中央控制器选举次数,</span><br><span class="line"><span class="string">"leader"</span>: 表示该partition选举leader的brokerId,</span><br><span class="line"><span class="string">"version"</span>: 版本编号默认为<span class="number">1</span>,</span><br><span class="line"><span class="string">"leader_epoch"</span>: 该partition leader选举次数,</span><br><span class="line"><span class="string">"isr"</span>: [同步副本组brokerId列表]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"controller_epoch"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="string">"leader"</span>: <span class="number">3</span>,</span><br><span class="line"><span class="string">"version"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="string">"leader_epoch"</span>: <span class="number">0</span>,</span><br><span class="line"><span class="string">"isr"</span>: [<span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="控制器选举次数"><a href="#控制器选举次数" class="headerlink" title="控制器选举次数"></a>控制器选举次数</h4><p>/controller_epoch –&gt; int (epoch) 注册 broker leader 选举次数</p><ul><li>broker leader 注册</li></ul><p>/controller -&gt; int (broker id of the controller) 存储 center controller 中央控制器所在 kafka broker 的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Schema:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"version"</span>: 版本编号默认为<span class="number">1</span>,</span><br><span class="line"><span class="string">"brokerid"</span>: kafka集群中broker唯一编号,</span><br><span class="line"><span class="string">"timestamp"</span>: kafka broker中央控制器变更时的时间戳</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"version"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="string">"brokerid"</span>: <span class="number">0</span>,</span><br><span class="line"><span class="string">"timestamp"</span>: <span class="string">"1525741822769"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Consumer-注册信息"><a href="#Consumer-注册信息" class="headerlink" title="Consumer 注册信息"></a>Consumer 注册信息</h4><p>/consumers/[groupId]/ids/[consumerIdString] 每个 Consumer 启动时，都会向 zookeeper 注册自己的信息，是一个临时节点；consumerIdString 产生规则：即表示此 consumer 目前所消费的 topic + partitions 列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Schema:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"version"</span>: 版本编号默认为<span class="number">1</span>,</span><br><span class="line"><span class="string">"subscription"</span>: &#123; <span class="comment">//订阅topic列表</span></span><br><span class="line"><span class="string">"topic名称"</span>: consumer中topic消费者线程数</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"pattern"</span>: <span class="string">"static"</span>,</span><br><span class="line"><span class="string">"timestamp"</span>: <span class="string">"consumer启动时的时间戳"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"version"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="string">"subscription"</span>: &#123;</span><br><span class="line"><span class="string">"topic2"</span>: <span class="number">1</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"pattern"</span>: <span class="string">"white_list"</span>,</span><br><span class="line"><span class="string">"timestamp"</span>: <span class="string">"1525747915336"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Consumer-owner"><a href="#Consumer-owner" class="headerlink" title="Consumer owner"></a>Consumer owner</h4><p>/consumers/[groupId]/owners/[topic]/[partitionId] -&gt; consumerIdString + threadId 索引编号</p><ol><li>首先进行”Consumer Id 注册”;</li><li>然后在”Consumer id 注册”节点下注册一个 watch 用来监听当前 group 中其他 consumer 的”退出”和”加入”;只要此 znode path 下节点列表变更,都会触发此 group 下 consumer 的负载均衡.(比如一个 consumer 失效,那么其他 consumer 接管 partitions).</li><li>在”Broker id 注册”节点下,注册一个 watch 用来监听 broker 的存活情况;如果 broker 列表变更,将会触发所有的 groups 下的 consumer 重新 balance.</li></ol><h4 id="Consumer-offset"><a href="#Consumer-offset" class="headerlink" title="Consumer offset"></a>Consumer offset</h4><p>/consumers/[groupId]/offsets/[topic]/[partitionId] -&gt; long (offset)<br>用来跟踪每个 consumer 目前所消费的 partition 中最大的 offset<br>此 znode 为持久节点,可以看出 offset 跟 group_id 有关,以表明当消费者组(consumer group)中一个消费者失效,<br>重新触发 balance,其他 consumer 可以继续消费</p><h1 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h1><h2 id="消息写入"><a href="#消息写入" class="headerlink" title="消息写入"></a>消息写入</h2><ul><li>序列化 ProducerRecord<br>每个消息是一个 ProducerRecord 对象，必须指定消息所属的 Topic 和消息值 Value，此外还可以指定消息所属的 Partition 以及消息的 Key。</li><li>推送到 partition<br>对于每条待发送的消息而言，如果该消息指定了 key，则 partitioner（分区器）会根据 key 的哈希值来选择目标分区，将具有相同 key 的所有消息都路由到相同的分区中；若该消息未指定 key，则 partitioner 使用轮询的方式确认目标分区</li><li>找到分区副本 leader</li></ul><p>Producers 直接发送消息到 broker 上的 leader partition（分区副本选举）</p><ol><li>producer 先从 zookeeper 的 “/brokers/…/state”节点找到该 partition 的 leader</li><li>producer 将消息发送给该 leader</li><li>leader 将消息写入本地 log</li><li>followers 从 leader pull 消息，写入本地 log 后向 leader 发送 ACK</li><li>leader 收到所有 ISR 中的 replication 的 ACK 后，增加 HW（high watermark，最后 commit 的 offset）并向 producer 发送 ACK</li></ol><h2 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h2><ul><li>批量发送<br>消息写入到目标分区的一块内存缓冲池中。而 producer 的另一个工作线程(I/O 发送线程，也称 Sender 线程)则负责实时地从该缓冲区中提取准备就绪的消息封装进一个批次(batch),统一发送给对应的 broker。</li><li>同步异步发送<br>Kafka producer 发送消息的主方法是 send 方法，producer 在底层完全实现了异步化发送，并且通过 Java 提供的 Future 同时实现了同步发送和异步发送+回调(Callback)(默认异步)两种发送方式。最后 producer 程序结束时需要关闭 producer。</li></ul><h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><ul><li>asks 参数</li></ul><ol><li>acks 设置为 0，表示 producer 不会等待 broker 的响应；所以 producer 无法知道消息是否发送成功，这样有可能会导致数据丢失，但同时，acks 值为 0 会得到最大的系统吞吐量。</li><li>若 acks 设置为 1，表示 producer 会在 leader partition 收到消息时得到 broker 的一个确认，这样会有更好的可靠性，因为客户端会等待直到 broker 确认收到消息。</li><li>若设置为-1，producer 会在所有备份的 partition 收到消息时得到 broker 的确认，这个设置可以得到最高的可靠性保证。</li></ol><ul><li>bootstrap.servers</li></ul><p>broker 列表</p><ul><li>buffer.memory 参数</li></ul><ol><li>指定 producer 端用于缓存消息的缓冲区的大小，单位是字节，默认 32M，采用异步发送消息的架构；</li><li>Java 版 Producer 启动时会首先创建一块内存缓冲区用于保存待发送消息，然后由另一个专属线程负责从缓冲区中读取消息执行真正的发送，这部分内存空间的大小就是由 buffer.memory 参数指定。该参数指定的内存大小几乎可以认为是 producer 程序使用的内存大小，若 producer 程序要给很多分区发送消息，那么就需要仔细设置该参数防止过小的内存缓冲区降低了 producer 程序整体的吞吐量。</li></ol><ul><li>batch.size 参数</li></ul><ol><li>batch.size 是 producer 调优吞吐量与延时性能最重要的参数之一，producer 会将发往同一分区的多条消息封装进一个 batch 中，当 batch 满了或者 batch 没满(linger.ms 参数=0，默认消息立即发送)producer 会发送该 batch。</li><li>Batch 小，吞吐量低，延时低，Batch 大，吞吐量高，延时高</li><li>Batch.size 默认为 16KB。</li></ol><ul><li>request.timeout.ms 参数</li></ul><p>当 producer 发送请求给 broker 后，broker 需要在规定时间范围内将处理结果返回给 producer。超时时间默认 30s</p><h1 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h1><h2 id="订阅-topic"><a href="#订阅-topic" class="headerlink" title="订阅 topic"></a>订阅 topic</h2><p>kafka 以 Consumer Group 的方式去订阅 topic,topic 的每条消息只能发送到订阅它的消费者组(Consumer Group)的其中一个实例上，并且每个消费者至多使用一个消费者组来标示自己。</p><h2 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h2><ul><li>Consumer 端使用 zookeeper 用来注册 consumer 信息,其中包括 consumer 消费的 partition 列表等,同时也用来发现 broker 列表,并和 partition leader 建立 socket 连接,并获取消息。</li><li>订阅 topic 后，当 consumer 调用 poll(拉取模型)时，会自动加入相应的 Consumer Group；只要 consumer 持续 poll，consumer 将持续的从分配给他的 topic partitions 接收消息；</li><li>consumer 会在后台持续向服务发送心跳，如果 consumer 进程崩溃或者在 session.timeout.ms 期间没有发送心跳，这个 consumer 将会被认为已经死掉了，他的分区将会被重新分配。</li></ul><h2 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h2><ul><li>bootstrap.servers</li></ul><p>broker 列表</p><ul><li>enable.auto.commit</li></ul><p>将以配置项 auto.commit.interval.ms 指定的频率自动提交 offset</p><ul><li>auto.commit.interval.ms</li></ul><p>提交 offset 的频率</p><ul><li>group.id</li></ul><p>指定该 consumer 所属的 Consumer Group</p><ul><li>deserializer</li></ul><p>字节转换</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="Consumer-Group-解析"><a href="#Consumer-Group-解析" class="headerlink" title="Consumer Group 解析"></a>Consumer Group 解析</h2><p>什么是 consumer group? 一言以蔽之，consumer group 是 kafka 提供的可扩展且具有容错性的消费者机制。既然是一个组，那么组内必然可以有多个消费者或消费者实例(consumer instance)，它们共享一个公共的 ID，即 group ID。组内的所有消费者协调在一起来消费订阅主题(subscribed topics)的所有分区(partition)。当然，每个分区只能由同一个消费组内的一个 consumer 来消费。</p><h4 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h4><p><img src="/images/Kafka%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90_2019-12-09-17-17-24.png" alt="Kafka的原理解析_2019-12-09-17-17-24.png"></p><h4 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h4><ol><li>唯一标识</li></ol><p>group.id 是一个字符串，唯一标识一个 consumer group</p><ol start="2"><li>限制</li></ol><p>consumer group 下订阅的 topic 下的每个分区只能分配给某个 group 下的一个 consumer(当然该分区还可以被分配给其他 group)，所以如果想同时对一个 topic 做消费的话，启动多个 consumer group 就可以了。</p><ol start="3"><li>水平扩展</li></ol><p>kafka 为了保证吞吐量，只允许同一个 consumer group 下的一个 consumer 线程去访问一个 partition，这样就避免了阻塞（悲观锁）；如果觉得效率不高的时候，可以加 partition 的数量来横向扩展，那么再加新的 consumer thread 去消费；当启动一个 consumer group 去消费一个 topic 的时候，无论 topic 里面有多个少个 partition，无论我们 consumer group 里面配置了多少个 consumer thread，这个 consumer group 下面的所有 consumer thread 一定会消费全部的 partition；即便这个 consumer group 下只有一个 consumer thread，那么这个 consumer thread 也会去消费所有的 partition。</p><ol start="4"><li>最优设计</li></ol><p>consumer group 下的 consumer thread 的数量等于 partition 数量，这样效率是最高的。</p><h4 id="Consumer-Rebalance"><a href="#Consumer-Rebalance" class="headerlink" title="Consumer Rebalance"></a>Consumer Rebalance</h4><ol><li>什么是 rebalance</li></ol><p>rebalance 本质上是一种协议，规定了一个 consumer group 下的所有 consumer 如何达成一致来分配订阅 topic 的每个分区。比如某个 group 下有 20 个 consumer，它订阅了一个具有 100 个分区的 topic。正常情况下，Kafka 平均会为每个 consumer 分配 5 个分区。这个分配的过程就叫 rebalance。</p><ol start="2"><li>rebalance 的触发条件有三种</li></ol><ul><li><p>组成员发生变更(新 consumer 加入组、已有 consumer 主动离开组或已有 consumer 崩溃了——这两者的区别后面会谈到)</p></li><li><p>订阅主题数发生变更——这当然是可能的，如果你使用了正则表达式的方式进行订阅，-那么新建匹配正则表达式的 topic 就会触发 rebalance</p></li><li><p>订阅主题的分区数发生变更</p></li><li><p>Consumer Group 管理</p></li></ul><p>依赖 zookeeper 来实现对于 consumer group 的管理。（具体见 zookeeper 上 cunsumer 的储存）</p><h1 id="offsite-量的维护"><a href="#offsite-量的维护" class="headerlink" title="offsite 量的维护"></a>offsite 量的维护</h1><p>kafka 消息是顺序读取，必须维护上一次读到哪里的 offset 信息。<br>维护 offset 有两套机制，<code>high level API</code> 的 offset 存于 Zookeeper 中；<code>low level API</code> 的 offset 由自己维护。消息生产端不用维护 offset，因为消息 offset 默认是自增的。</p><h2 id="high-level-api"><a href="#high-level-api" class="headerlink" title="high level api"></a>high level api</h2><p>offset 是维护在 Zookeeper 上，先拿 message 处理，再定时自动 commit offsite+1（也可以改成手动）, 并且 kakfa 处理 message 是没有锁操作的。<br>因此如果处理 message 失败，此时还没有 commit offsite+1，当 consumer thread 重启后会重复消费这个 message。<br>但是作为高吞吐量高并发的实时处理系统，at least once 的情况下，至少一次会被处理到，是可以容忍的。</p><h2 id="low-level-api"><a href="#low-level-api" class="headerlink" title="low level api"></a>low level api</h2><p>如果无法容忍，就得使用 low level api 来自己程序维护这个 offsite 信息，那么想什么时候 commit offsite+1 就自己搞定了。<br>lance 到一个 partition 上，一起插进去，offsite 作为自增 id 自己增加就好。</p><h1 id="消费模型"><a href="#消费模型" class="headerlink" title="消费模型"></a>消费模型</h1><p>消息由生产者发送到 Kafka 集群后，会被消费者消费。一般来说我们的消费模型有两种：推送模型（push）、拉取模型（pull）</p><h2 id="推送模型"><a href="#推送模型" class="headerlink" title="推送模型"></a>推送模型</h2><p>基于推送模型的消息系统，由消息代理记录消费状态。消息代理将消息推送到消费者后，标记这条消息为已经被消费，但是这种方式无法很好地保证消费的处理语义。<br>比如当我们已经把消息发送给消费者之后，由于消费进程挂掉或者由于网络原因没有收到这条消息，如果我们在消费代理将其标记为已消费，这个消息就永久丢失了。<br>如果我们利用生产者收到消息后回复这种方法，消息代理需要记录消费状态，这种不可取。<br>如果采用 Push，消息消费的速率就完全由消费代理控制，一旦消费者发生阻塞，就会出现问题。</p><h2 id="拉取模型"><a href="#拉取模型" class="headerlink" title="拉取模型"></a>拉取模型</h2><p>Kafka 采取拉取模型(Poll)，由自己控制消费速度，以及消费的进度，消费者可以按照任意的偏移量进行消费。比如消费者可以消费已经消费过的消息进行重新处理，或者消费最近的消息等等。</p><h1 id="kafka-吞吐量大的原因？"><a href="#kafka-吞吐量大的原因？" class="headerlink" title="kafka 吞吐量大的原因？"></a>kafka 吞吐量大的原因？</h1><ol><li>kafka 针对一个 partition，不是通过对多个 consumer thread 加悲观锁来防止重复消费，而是一个 partition 只能同时被一个 consumer thread 消费，如果消息数量太大觉得效率不高要增大吞吐量，直接横向扩展 partition 数量，同时增加一个 consumer group 下的 consumer thread 数量即可。这样没有锁竞争，充分发挥了横向的扩展性，吞吐量极高。</li><li>kafka 分布式并发的读和写都非常快，写的性能体现在以 o(1)的时间复杂度进行顺序写入。读的性能体现在以 o(1)的时间复杂度进行顺序读取，<br>对 topic 进行 partition 分区，consume group 中的 consume 线程可以以很高能性能进行顺序读。</li><li>大量使用操作系统页缓存，内存操作速度快且命中率高</li><li>Kafka 不直接参与物理 I/O 操作，而是交由最擅长此事的操作系统来完成</li><li>使用以 sendfile 为代表的零拷贝技术加强网络间的数据传输速率</li></ol><h1 id="kafka-消息持久化"><a href="#kafka-消息持久化" class="headerlink" title="kafka 消息持久化"></a>kafka 消息持久化</h1><p>Kafka 由操作系统自行决定什么时候把页缓存中的数据写回磁盘上。Kafka 依赖操作系统的 flush“刷盘”功能实现消息真正写入物理磁盘，而默认的刷盘间隔是 5s，通常情况下，该间隔太短，适当增加例如 2min 可以大程度上提升操作系统物理写入操作的性能。<br>此外，传统持久化方式是优先使用内存，内存不足后再一次性写入磁盘，Kafka 相反，当操作系统决定将页缓存中的数据写入到磁盘上时，会优先写入到磁盘（文件系统的持久化日志），减少了 Kafka 程序对内存的消耗，将内存主要供于页缓存使用<br>此外持久化到磁盘上的好处如下：</p><ol><li>解耦消息发送与消息消费</li><li>实现灵活的消息处理：如重置消费位点等</li></ol><h1 id="消息可靠性和稳定性和容错性"><a href="#消息可靠性和稳定性和容错性" class="headerlink" title="消息可靠性和稳定性和容错性"></a>消息可靠性和稳定性和容错性</h1><h2 id="broker-上的可靠性"><a href="#broker-上的可靠性" class="headerlink" title="broker 上的可靠性"></a>broker 上的可靠性</h2><p>因为消息会持久化到磁盘上，所以如果正常 stop 一个 broker，其上的数据不会丢失；但是如果不正常 stop，可能会使存在页面缓存来不及写入磁盘的消息丢失，这可以通过配置 flush 页面缓存的周期、阈值缓解，但是同样会频繁的写磁盘会影响性能，又是一个选择题，根据实际情况配置。</p><h2 id="消息消费的可靠性"><a href="#消息消费的可靠性" class="headerlink" title="消息消费的可靠性"></a>消息消费的可靠性</h2><ol><li>At most once 消息可能会丢，绝对不会重复传输；</li><li>At least once 消息绝对不会丢，但是可能会重复传输；</li><li>Exactly once 每条信息肯定会被传输一次且仅传输一次，这是用户想要的。</li></ol><p>Kafka 提供的是<code>At least once</code>模型，因为消息的读取进度由 offset 提供，offset 可以由消费者自己维护也可以维护在 zookeeper 里，但是当消息消费后 consumer 挂掉，offset 没有即时写回，就有可能发生重复读的情况，这种情况同样可以通过调整 commit offset 周期、阈值缓解，甚至消费者自己把消费和 commit offset 做成一个事务解决，但是如果你的应用不在乎重复消费，那就干脆不要解决，以换取最大的性能。</p><h2 id="消息生产的可靠性"><a href="#消息生产的可靠性" class="headerlink" title="消息生产的可靠性"></a>消息生产的可靠性</h2><ul><li>acks 设置为 0，表示 producer 不会等待 broker 的响应；所以 producer 无法知道消息是否发送成功，这样有可能会导致数据丢失，但同时，acks 值为 0 会得到最大的系统吞吐量。</li><li>若 acks 设置为 1，表示 producer 会在 leader partition 收到消息时得到 broker 的一个确认，这样会有更好的可靠性，因为客户端会等待直到 broker 确认收到消息。</li><li>若设置为-1，producer 会在所有备份的 partition 收到消息时得到 broker 的确认，这个设置可以得到最高的可靠性保证。</li></ul><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>Kafka 的备份的单元是 partition，也就是每个 partition 都都会有 leader partiton 和 follow partiton。其中 leader partition 是用来进行和 producer 进行写交互，follow 从 leader 副本进行拉数据进行同步，从而保证数据的冗余，防止数据丢失的目的。</p><h1 id="中央控制器的选举"><a href="#中央控制器的选举" class="headerlink" title="中央控制器的选举"></a>中央控制器的选举</h1><p>集群中的 kafka 节点会根据选举机制选出一个 leader，作为 kafka broker controller，又称为控制器；其他节点因为选举失败，会创建一个 watch 对象，时刻盯着 leader，如果 leader 宕机（或者未通过 zookeeper 心跳监测），那么此时所有节点又会再次选举。</p><h1 id="partiton-中文件存储方式"><a href="#partiton-中文件存储方式" class="headerlink" title="partiton 中文件存储方式"></a>partiton 中文件存储方式</h1><p>-每个 partion(目录)相当于一个巨型文件被平均分配到多个大小相等 segment(段)数据文件中。但每个段 segment file 消息数量不一定相等，这种特性方便 old segment file 快速被删除。 -每个 partiton 只需要支持顺序读写就行了，segment 文件生命周期由服务端配置参数决定。这样做的好处就是能快速删除无用文件，有效提高磁盘利用率。</p><h1 id="副本集合（ISR）"><a href="#副本集合（ISR）" class="headerlink" title="副本集合（ISR）"></a>副本集合（ISR）</h1><ul><li>Kafka 动态维护了一个同步状态的副本的集合（a set of in-sync replicas），简称 ISR。</li><li>在这个集合中的节点都是和 leader 保持高度一致的，任何一条消息必须被这个集合中的每个节点读取并追加到日志中了，才回通知外部这个消息已经被提交了。因此这个集合中的任何一个节点随时都可以被选为 leader.ISR 在 ZooKeeper 中维护。</li><li>ISR 中有 f+1 个节点，就可以允许在 f 个节点 down 掉的情况下不会丢失消息并正常提供服。ISR 的成员是动态的，如果一个节点被淘汰了，当它重新达到“同步中”的状态时，他可以重新加入 ISR.这种 leader 的选择方式是非常快速的，适合 kafka 的应用场景。</li></ul><h1 id="分区副本的选举"><a href="#分区副本的选举" class="headerlink" title="分区副本的选举"></a>分区副本的选举</h1><ul><li><code>什么是分区副本</code>？分区（partition）概念见图 3，在 kafka 的集群中，会存在着多个主题 topic，在每一个 topic 中，又被划分为多个 partition，为了防止数据不丢失，每一个 partition 又有多个副本（Replica）</li><li><code>首领副本</code>：也就是 leader 主副本，每个分区都有一个首领副本，为了保证数据一致性，所有的生产者与消费者的请求都会经过该副本来处理。</li><li><code>跟随着副本</code>：除了首领副本外的其他所有副本都是跟随者副本，跟随者副本不处理来自客户端的任何请求，只负责从首领副本同步数据，保证与首领保持一致。如果首领副本发生崩溃，就会从这其中选举出一个 leader。</li><li><code>首选首领副本</code>：创建分区时指定的首选首领。如果不指定，则为分区的第一个副本。</li></ul><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><ul><li><p>每个 log entry 格式为”4 个字节的数字 N 表示消息的长度” + “N 个字节的消息内容”;每个日志都有一个 offset 来唯一的标记一条消息,offset 的值为 8 个字节的数字,表示此消息在此 partition 中所处的起始位置..每个 partition 在物理存储层面,有多个 log file 组成(称为 segment).segment file 的命名为”最小 offset”.kafka.例如”00000000000.kafka”;其中”最小 offset”表示此 segment 中起始消息的 offset.</p></li><li><p>获取消息时,需要指定 offset 和最大 chunk 尺寸,offset 用来表示消息的起始位置,chunk size 用来表示最大获取消息的总长度(间接的表示消息的条数).根据 offset,可以找到此消息所在 segment 文件,然后根据 segment 的最小 offset 取差值,得到它在 file 中的相对位置,直接读取输出即可.</p></li></ul><p><img src="/images/Kafka%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90_2019-12-10-13-45-56.png" alt="Kafka的原理解析_2019-12-10-13-45-56.png"></p>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot实战之kafka</title>
      <link href="/2019/12/05/springboot%E5%AE%9E%E6%88%98%E4%B9%8Bkafka/"/>
      <url>/2019/12/05/springboot%E5%AE%9E%E6%88%98%E4%B9%8Bkafka/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-idea-创建一个-maven-项目"><a href="#使用-idea-创建一个-maven-项目" class="headerlink" title="使用 idea 创建一个 maven 项目"></a>使用 idea 创建一个 maven 项目</h1><h1 id="kafka-安装"><a href="#kafka-安装" class="headerlink" title="kafka 安装"></a>kafka 安装</h1><p>详见<a href="/2019/12/04/docker%E4%BD%BF%E7%94%A8%E4%B9%8BKafka%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/" title="docker使用之Kafka的安装使用">docker使用之Kafka的安装使用</a></p><h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--参数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8089</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">kafka</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">bootstrap-servers</span>: <span class="string">localhost:9092</span></span><br><span class="line">    <span class="attr">producer</span>:<span class="string"></span></span><br><span class="line">      <span class="meta">key-serializer</span>: <span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line">      <span class="meta">value-serializer</span>: <span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line">    <span class="attr">consumer</span>:<span class="string"></span></span><br><span class="line">      <span class="meta">group-id</span>: <span class="string">myGroup</span></span><br><span class="line">      <span class="meta">key-deserializer</span>: <span class="string">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class="line">      <span class="meta">value-deserializer</span>: <span class="string">org.apache.kafka.common.serialization.StringDeserializer</span></span><br></pre></td></tr></table></figure><h2 id="消息体"><a href="#消息体" class="headerlink" title="消息体"></a>消息体</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.kafka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">private</span> Date sendTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getSendTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sendTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSendTime</span><span class="params">(Date sendTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sendTime = sendTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.kafka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.GsonBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.kafka.core.KafkaTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaSender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String,String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Gson gson = <span class="keyword">new</span> GsonBuilder().create();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Message message = <span class="keyword">new</span> Message();</span><br><span class="line">        message.setId(System.currentTimeMillis());</span><br><span class="line">        message.setMsg(UUID.randomUUID().toString());</span><br><span class="line">        message.setSendTime(<span class="keyword">new</span> Date());</span><br><span class="line">        kafkaTemplate.send(<span class="string">"test"</span>, gson.toJson(message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.kafka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line"><span class="keyword">import</span> org.springframework.kafka.annotation.KafkaListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConsumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@KafkaListener</span>(topics = &#123;<span class="string">"test"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(ConsumerRecord&lt;?, ?&gt; record)</span> </span>&#123;</span><br><span class="line">        Optional&lt;?&gt; kafkaMessage = Optional.ofNullable(record.value());</span><br><span class="line">        <span class="keyword">if</span> (kafkaMessage.isPresent()) &#123;</span><br><span class="line">            Object message = kafkaMessage.get();</span><br><span class="line">            System.out.println(<span class="string">"接收信息"</span>+message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.qn.kafka.KafkaSender;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ConfigurableApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">        KafkaSender sender = context.getBean(KafkaSender<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            sender.send();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3_000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>直接运行启动类：<br><img src="/images/springboot%E5%AE%9E%E6%88%98%E4%B9%8Bkafka_2019-12-05-14-54-28.png" alt="springboot实战之kafka_2019-12-05-14-54-28.png"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/c16350e88abe" target="_blank" rel="noopener">Spring Boot 集成 Kafka</a></p>]]></content>
      
      
      <categories>
          
          <category> springBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker使用之Kafka的安装使用</title>
      <link href="/2019/12/04/docker%E4%BD%BF%E7%94%A8%E4%B9%8BKafka%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/12/04/docker%E4%BD%BF%E7%94%A8%E4%B9%8BKafka%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><blockquote><p>docker pull wurstmeister/zookeeper</p></blockquote><blockquote><p>docker pull wurstmeister/kafka</p></blockquote><h3 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h3><blockquote><p>docker run -d –name zookeeper -p 2181 -t wurstmeister/zookeeper</p></blockquote><blockquote><p>docker run -d –name kafka –publish 9092:9092 –link zookeeper –env KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181 –env KAFKA_ADVERTISED_HOST_NAME=127.0.0.1 –env KAFKA_ADVERTISED_PORT=9092 –volume /etc/localtime:/etc/localtime wurstmeister/kafka:latest</p></blockquote><h3 id="查看启动镜像"><a href="#查看启动镜像" class="headerlink" title="查看启动镜像"></a>查看启动镜像</h3><blockquote><p>docker ps</p></blockquote><p><img src="/images/docker%E4%BD%BF%E7%94%A8%E4%B9%8BKafka%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8_2019-12-04-16-04-31.png" alt="docker使用之Kafka的安装使用_2019-12-04-16-04-31.png"></p><h2 id="测试消息发送"><a href="#测试消息发送" class="headerlink" title="测试消息发送"></a>测试消息发送</h2><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><blockquote><p>docker exec -it 83156456fb03 /bin/bash</p></blockquote><h3 id="进入-kafka-默认目录"><a href="#进入-kafka-默认目录" class="headerlink" title="进入 kafka 默认目录"></a>进入 kafka 默认目录</h3><blockquote><p>cd /opt/kafka_2.12-2.3.0/</p></blockquote><h3 id="创建-topic"><a href="#创建-topic" class="headerlink" title="创建 topic"></a>创建 topic</h3><blockquote><p>bin/kafka-topics.sh –create –zookeeper zookeeper:2181 –replication-factor 1 –partitions 1 –topic test</p></blockquote><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><blockquote><p>bin/kafka-console-producer.sh –broker-list localhost:9092 –topic test</p></blockquote><p><img src="/images/docker%E4%BD%BF%E7%94%A8%E4%B9%8BKafka%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8_2019-12-04-16-11-42.png" alt="docker使用之Kafka的安装使用_2019-12-04-16-11-42.png"></p><h3 id="接受消息"><a href="#接受消息" class="headerlink" title="接受消息"></a>接受消息</h3><blockquote><p>bin/kafka-console-consumer.sh –bootstrap-server localhost:9092 –topic test –from-beginning</p></blockquote><p><img src="/images/docker%E4%BD%BF%E7%94%A8%E4%B9%8BKafka%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8_2019-12-04-16-13-40.png" alt="docker使用之Kafka的安装使用_2019-12-04-16-13-40.png"></p><h2 id="java-生产者与消费者"><a href="#java-生产者与消费者" class="headerlink" title="java 生产者与消费者"></a>java 生产者与消费者</h2><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.kafka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.KafkaProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.Producer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafKaProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//broker地址</span></span><br><span class="line">        props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//请求时候需要验证</span></span><br><span class="line">        props.put(<span class="string">"acks"</span>, <span class="string">"all"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//请求失败时候需要重试</span></span><br><span class="line">        props.put(<span class="string">"retries"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//内存缓存区大小</span></span><br><span class="line">        props.put(<span class="string">"buffer.memory"</span>, <span class="number">33554432</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定消息key序列化方式</span></span><br><span class="line">        props.put(<span class="string">"key.serializer"</span>,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定消息本身的序列化方式</span></span><br><span class="line">        props.put(<span class="string">"value.serializer"</span>,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line"></span><br><span class="line">        Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">                <span class="comment">// 生产一条消息的时间有点长</span></span><br><span class="line">                producer.send(<span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"test"</span>, <span class="string">"测试用例"</span>+Integer.toString(i)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Message sent successfully"</span>);</span><br><span class="line">        producer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qn.kafka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecords;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.KafkaConsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafKaConsumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123; <span class="string">"deprecation"</span>, <span class="string">"resource"</span> &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">        props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);   <span class="comment">// "localhost:9092"</span></span><br><span class="line">        <span class="comment">//每个消费者分配独立的组号</span></span><br><span class="line">        props.put(<span class="string">"group.id"</span>, <span class="string">"test1"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果value合法，则自动提交偏移量</span></span><br><span class="line">        props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"true"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置多久一次更新被消费消息的偏移量</span></span><br><span class="line">        props.put(<span class="string">"auto.commit.interval.ms"</span>, <span class="string">"1000"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置会话响应的时间，超过这个时间kafka可以选择放弃消费或者消费下一条消息</span></span><br><span class="line">        props.put(<span class="string">"session.timeout.ms"</span>, <span class="string">"30000"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//props.put("auto.offset.reset", "earliest");</span></span><br><span class="line"></span><br><span class="line">        props.put(<span class="string">"key.deserializer"</span>,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">        props.put(<span class="string">"value.deserializer"</span>,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line"></span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">        System.out.println(<span class="string">"建立消费者"</span>);</span><br><span class="line">        consumer.subscribe(Collections.singletonList(<span class="string">"test"</span>));  <span class="comment">//核心函数1：订阅topic</span></span><br><span class="line">        System.out.println(<span class="string">"订阅成功"</span>);</span><br><span class="line">        <span class="comment">//消费轮询</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                ConsumerRecords&lt;String,String&gt; records = consumer.poll(<span class="number">100000</span>);</span><br><span class="line">                <span class="keyword">for</span>(ConsumerRecord&lt;String,String&gt; record : records) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"取出数据："</span>+ record.value());</span><br><span class="line">                    System.out.printf(<span class="string">"offset = %d ,key = %s, value = %s%n"</span>,record.offset(),record.key(),record.value());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            consumer.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://johng.cn/install-kafka-with-docker/" target="_blank" rel="noopener">使用 docker 安装 kafka</a></p><p><a href="https://blog.51cto.com/59465168/2319494" target="_blank" rel="noopener">Kafka 的使用和错误解决</a></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker kafka安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud实战之Config（4）</title>
      <link href="/2019/12/02/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%884%EF%BC%89/"/>
      <url>/2019/12/02/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%884%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>在<a href="/2019/11/29/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%882%EF%BC%89/" title="springcloud实战之Config（2）">springcloud实战之Config（2）</a> ，我们简单的实现了动态刷新。但如果有大量的微服务，就需要为每个 client 去 refresh,明显是不合理的。而 Spring Cloud Bus 可以完美解决这一问题。</p><h1 id="通过消息总线-Spring-Cloud-Bus-更新客户端配置文件（使用-Kafka）"><a href="#通过消息总线-Spring-Cloud-Bus-更新客户端配置文件（使用-Kafka）" class="headerlink" title="通过消息总线 Spring Cloud Bus 更新客户端配置文件（使用 Kafka）"></a>通过消息总线 Spring Cloud Bus 更新客户端配置文件（使用 Kafka）</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h4 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h4><p>Spring bus 的一个核心思想是通过分布式的启动器对 spring boot 应用进行扩展，也可以用来建立一个多个应用之间的通信频道。目前唯一实现的方式是用 AMQP 消息代理作为通道，同样特性的设置（有些取决于通道的设置）在更多通道的文档中。其实本质是利用了 MQ 的广播机制在分布式的系统中传播消息，目前常用的有 Kafka 和 RabbitMQ。</p><h4 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h4><p><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%884%EF%BC%89_2019-12-04-16-28-26.png" alt="springcloud实战之Config（4）_2019-12-04-16-28-26.png"></p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ul><li>提交代码触发 post 请求给 bus/refresh</li><li>server 端接收到请求并发送给 Spring Cloud Bus</li><li>Spring Cloud bus 接到消息并通知给其它客户端</li><li>其它客户端接收到通知，请求 Server 端获取最新配置</li><li>全部客户端均获取到最新的配置</li></ul><h2 id="安装-kafka"><a href="#安装-kafka" class="headerlink" title="安装 kafka"></a>安装 kafka</h2><p>详见<a href="/2019/12/04/docker%E4%BD%BF%E7%94%A8%E4%B9%8BKafka%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/" title="docker使用之Kafka的安装使用">docker使用之Kafka的安装使用</a></p><h4 id="server-模块整合"><a href="#server-模块整合" class="headerlink" title="server 模块整合"></a>server 模块整合</h4><h5 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8769</span></span><br><span class="line"><span class="comment">#避免配置中心向自己发布服务导致程序报错服务启动不了。</span></span><br><span class="line"><span class="comment">#如果不加项目启动时报错：Cannot execute request on any known server</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://localhost:9999/eureka</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">spring-cloud-config-server</span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">config</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">server</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">git</span>:<span class="string"></span></span><br><span class="line">          <span class="attr">uri</span>: <span class="string">https://github.com/qn101630/qn101630.github.io.git # 配置git仓库的地址</span></span><br><span class="line">          <span class="meta">search-paths</span>: <span class="string">config-repo # git仓库地址下的相对地址，可以配置多个，用,分割。</span></span><br><span class="line">          <span class="attr">username</span>: <span class="string">qn101630                               # git仓库的账号</span></span><br><span class="line">          <span class="attr">password</span>: <span class="string">qn192837QN</span></span><br><span class="line">          <span class="meta">default-label</span>: <span class="string">code</span></span><br><span class="line"><span class="comment">    # bus消息总线</span></span><br><span class="line">    <span class="attr">stream</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">kafka</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">binder</span>:<span class="string"></span></span><br><span class="line">          <span class="attr">brokers</span>: <span class="string">localhost:9092</span></span><br><span class="line">    <span class="attr">bus</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">trace</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">enabled</span>: <span class="string">true</span></span><br><span class="line"><span class="comment">#          skip-ssl-validation: true</span></span><br><span class="line"><span class="comment"># 暴露服务端端口 以便客户端刷新</span></span><br><span class="line"><span class="attr">management</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">endpoints</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">web</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">exposure</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">include</span>: <span class="string">"*"</span></span><br></pre></td></tr></table></figure><h4 id="client-整合"><a href="#client-整合" class="headerlink" title="client 整合"></a>client 整合</h4><p>与 server 整合一致，添加同样的配置与依赖</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ul><li>运行 Eureka、server、client(8771)、client(8772);直接访问<code>http://localhost:8771/testConfig</code>，返回配置信息</li><li>修改配置项，push 到 Git,这时候我们需要在 server 端 post<blockquote><p>curl -X POST <a href="http://localhost:8769/actuator/bus-refresh" target="_blank" rel="noopener">http://localhost:8769/actuator/bus-refresh</a></p></blockquote></li><li>再次访问<code>http://localhost:8771/testConfig</code>，返回修改后的配置</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/qqxx6661/article/details/88701051" target="_blank" rel="noopener">通过消息总线 Spring Cloud Bus 实现配置文件刷新</a></p>]]></content>
      
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> config实战 动态刷新（Bus） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud实战之Config（3）</title>
      <link href="/2019/12/02/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%883%EF%BC%89/"/>
      <url>/2019/12/02/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%883%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>我们在前文中，完成了</p><ul><li>利用<code>springcloud config</code>与<code>git</code>完成了统一的配置，即配置中心</li><li>开启了<code>rehash</code>，完成了初步的动态刷新</li></ul><h1 id="高可用问题及方案"><a href="#高可用问题及方案" class="headerlink" title="高可用问题及方案"></a>高可用问题及方案</h1><h2 id="多个-server"><a href="#多个-server" class="headerlink" title="多个 server"></a>多个 server</h2><p>前文中我们实现<code>client</code>对配置中心配置的读取，是通过直连的方式（写死的 url）,这显然不符合要求，因为我们的配置中心的<code>server</code>需要有多个（高可用）。</p><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>将配置中心<code>server</code>与<code>client</code>作为微服务处理，在<code>Eureka</code>中注册,通过服务化的方式进行访问，同时开启多个指向同一个 git 地址的 server，就可以实现高可用。</p><h2 id="代码改造"><a href="#代码改造" class="headerlink" title="代码改造"></a>代码改造</h2><h4 id="服务端改造"><a href="#服务端改造" class="headerlink" title="服务端改造"></a>服务端改造</h4><h5 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h5><p>添加对 Eureka 的依赖，父 pom 已经添加，此处省略。</p><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://localhost:9999/eureka</span></span><br></pre></td></tr></table></figure><h4 id="客户端改造"><a href="#客户端改造" class="headerlink" title="客户端改造"></a>客户端改造</h4><h5 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h5><p>同上</p><h5 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h5><p>bootstrap.yml</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://localhost:9999/eureka</span></span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ul><li>测试服务化：启动 Eureka、server(8769)、server(8770)、client，访问<code>http://localhost:8771/testConfig</code>，得到配置信息;</li><li>测试高可用：关闭 server(8769),再次访问以上地址，得到配置信息;</li><li>测试动态刷新，修改配置，上传 git,post 请求<code>curl -v -X POST http://localhost:8771/actuator/refresh</code>，再次访问以上地址，得到修改后的配置信息。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://windmt.com/2018/04/19/spring-cloud-8-config-with-eureka/" target="_blank" rel="noopener">配置中心（服务化与高可用）</a></p>]]></content>
      
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> condig实战 服务化与高可用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis中“#”和“$的区别</title>
      <link href="/2019/12/02/Mybatis%E4%B8%AD%E2%80%9C-%E2%80%9D%E5%92%8C%E2%80%9C-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/12/02/Mybatis%E4%B8%AD%E2%80%9C-%E2%80%9D%E5%92%8C%E2%80%9C-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是动态-SQL"><a href="#什么是动态-SQL" class="headerlink" title="什么是动态 SQL"></a>什么是动态 SQL</h1><p>动态 SQL 是 <code>mybatis</code> 的强大特性之一，也是它优于其他 ORM 框架的一个重要原因。<code>mybatis</code> 在对 sql 语句进行预编译之前，会对 sql 进行动态解析，解析为一个 BoundSql 对象，也是在此处对动态 SQL 进行处理的。在动态 SQL 解析阶段， <code>#{ }</code> 和 <code>${ }</code> 会有不同的表现</p><h1 id="讲解下-和-的异同点"><a href="#讲解下-和-的异同点" class="headerlink" title="讲解下#和$的异同点"></a>讲解下#和$的异同点</h1><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>都可以获取对象中的属性值,<code>$[name]</code> 和<code>#[name]</code>相同</p><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><p><code>#</code> 可以防止 sql 注入，先把 sql 中使用#的地方变成?占位，再设置参数值,会把传入的参数使用引号包起来，参数值?: ‘name’，如下：</p><blockquote><p>SELECT * FROM user WHERE name = #{name} AND password = #{password}</p></blockquote><blockquote><p>SELECT * FROM user WHERE name = ? AND password = ?</p></blockquote><p><code>$</code> 在动态解析的时候，会将我们传入的参数当做 String 字符串填充到我们的语句中，进行预编译，此时的<code>SQL</code>语句已经不包含变量了，完全已经是常量数据了。相当于我们普通没有变量的 sql 了。如下：</p><blockquote><p>select * from user where name = “xxx”;</p></blockquote><p>由于预编译的存在，<code>$</code>的使用会导致<strong>sql 注入</strong>，可以拼接 sql，如下：</p><blockquote><p>SELECT * FROM user WHERE name = $[name] AND password  = $[password]</p></blockquote><p>但如果 name = OR 1 = 1 OR，sql 注入就会影响到 sql 语句的原意，如下：</p><blockquote><p>SELECT * FROM user WHERE name = OR 1 = 1 OR AND password =</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>#</code>方式能够很大程度防止 sql 注入，<code>$</code>方式无法防止 Sql 注入。<br><code>$</code>方式一般用于传入数据库对象，例如传入表名.<br>一般能用<code>#</code>的就别用<code>$</code>.</p>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> $和# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud实战之Config（2）</title>
      <link href="/2019/11/29/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%882%EF%BC%89/"/>
      <url>/2019/11/29/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Refresh"><a href="#Refresh" class="headerlink" title="Refresh"></a>Refresh</h1><h2 id="依赖（父-pom-已经添加过）"><a href="#依赖（父-pom-已经添加过）" class="headerlink" title="依赖（父 pom 已经添加过）"></a>依赖（父 pom 已经添加过）</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="对需要刷新的类加上注解-RefreshScope"><a href="#对需要刷新的类加上注解-RefreshScope" class="headerlink" title="对需要刷新的类加上注解@RefreshScope"></a>对需要刷新的类加上注解@RefreshScope</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span> <span class="comment">//不配置这个注解刷新的时候会报错</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个@Value会根据配置的配置中心地址找到git仓库对应的配置和本地服务的配置文件</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;config.hello&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String hello;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"testConfig"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"读取到配置中心："</span> + hello;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="client-端配置，将端口暴露"><a href="#client-端配置，将端口暴露" class="headerlink" title="client 端配置，将端口暴露"></a>client 端配置，将端口暴露</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">endpoints</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">web</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">exposure</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">include</span>: <span class="string">refresh</span></span><br></pre></td></tr></table></figure><h2 id="Server-端配置，将端口暴露"><a href="#Server-端配置，将端口暴露" class="headerlink" title="Server 端配置，将端口暴露"></a>Server 端配置，将端口暴露</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">endpoints</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">web</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">exposure</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">include</span>: <span class="string">"*"</span></span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>启动 server 与 client,修改 git 上的 dev 配置属性，通过 post 请求的方式更新配置文件：<br><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%882%EF%BC%89_2019-12-02-14-18-14.png" alt="springcloud实战之Config（2）_2019-12-02-14-18-14.png"><br><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%882%EF%BC%89_2019-12-02-14-18-50.png" alt="springcloud实战之Config（2）_2019-12-02-14-18-50.png"><br>再次访问 <code>http://localhost:8771/testConfig</code>就可以得到最新的配置结果。</p><h1 id="Webhook"><a href="#Webhook" class="headerlink" title="Webhook"></a>Webhook</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>WebHook 是当某个事件发生时，通过发送 http post 请求的方式来通知信息接收方。Webhook 来监测你在 Github.com 上的各种事件，最常见的莫过于 push 事件。如果你设置了一个监测 push 事件的 Webhook，那么每当你的这个项目有了任何提交，这个 Webhook 都会被触发，这时 Github 就会发送一个 HTTP POST 请求到你配置好的地址。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>如此一来，你就可以通过这种方式去自动完成一些重复性工作，比如，你可以用 Webhook 来自动触发一些持续集成（CI）工具的运作，比如 Travis CI；又或者是通过 Webhook 去部署你的线上服务器。下图就是 github 上面的 webhook 配置。</p><p><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%882%EF%BC%89_2019-12-03-13-59-00.png" alt="springcloud实战之Config（2）_2019-12-03-13-59-00.png"></p><ul><li>Payload URL ：触发后回调的 URL</li><li>Content type ：数据格式，两种一般使用 json</li><li>Secret ：用作给 POST 的 body 加密的字符串。采用 HMAC 算法</li><li>events ：触发的事件列表。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果项目少配置少的情况可以通过/refresh 来手动刷新配置，可以利用 Webhook 的机制每次提交代码发送请求来刷新客户端，当客户端越来越多的时候，需要每个客户端都执行一遍；如果项目比较复杂的情况呢这种肯定是行不通的，Spring Cloud Bus 消息总线可以解决配置修改的真正的动态刷新。详见<a href="/2019/12/02/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%884%EF%BC%89/" title="springcloud实战之Config（4）">springcloud实战之Config（4）</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/qqxx6661/article/details/88604499" target="_blank" rel="noopener">配置中心 Spring Cloud Config 初体验</a></p>]]></content>
      
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> config实战 动态刷新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker简单介绍与安装（win10）</title>
      <link href="/2019/11/28/docker%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85%EF%BC%88win10%EF%BC%89/"/>
      <url>/2019/11/28/docker%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85%EF%BC%88win10%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="环境配置的难题"><a href="#环境配置的难题" class="headerlink" title="环境配置的难题"></a>环境配置的难题</h2><p>软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？</p><p>用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。</p><p>如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说：”它在我的机器可以跑了”（It works on my machine），言下之意就是，其他机器很可能跑不了。</p><p>环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，<strong>安装的时候，把原始环境一模一样地复制过来。</strong></p><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>资源占用多<br>虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。</li><li>冗余步骤多<br>虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。</li><li>启动慢<br>启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。</li></ol><h2 id="Linux-容器"><a href="#Linux-容器" class="headerlink" title="Linux 容器"></a>Linux 容器</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><ol><li>由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。</li><li>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</li><li>容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。</li></ol><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>启动快<br>容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。</li><li>资源占用少<br>容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。</li><li>体积小<br>容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。</li></ol><h2 id="Docker-是什么？"><a href="#Docker-是什么？" class="headerlink" title="Docker 是什么？"></a>Docker 是什么？</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><ol><li>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。</li><li>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</li></ol><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ol><li>提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</li><li>提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</li><li>组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</li></ol><h2 id="Docker-的安装"><a href="#Docker-的安装" class="headerlink" title="Docker 的安装"></a>Docker 的安装</h2><p>详见———&gt; <a href="https://www.runoob.com/docker/windows-docker-install.html" target="_blank" rel="noopener">菜鸟教程 Docker 安装</a></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 介绍 安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eureka与Zookeeper的区别</title>
      <link href="/2019/11/28/Eureka%E4%B8%8EZookeeper%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/11/28/Eureka%E4%B8%8EZookeeper%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="生态"><a href="#生态" class="headerlink" title="生态"></a>生态</h1><p>在微服务的开发过程中，如果使用的是 Dubbo 那就必须使用到 Zookeeper ，在使用 Spring Cloud Eureka 时，自然其功能更强大得多。Spring Cloud Eureka 后来者居上，Dubbo 早在几年前停止了维护，在其停止了维护的几年里正是互联网发展的大好时期，Eureka 借机快速发展，夺得了一大片市场，可以说已经超越了 Dubbo 了，17 年的时候，阿里巴巴又突然宣布重启对 Dubbo 的维护，在其重启的发布会上，其主导维护者也表示，将希望加入 Eureka 的生态…</p><h1 id="CAP-定理"><a href="#CAP-定理" class="headerlink" title="CAP 定理"></a>CAP 定理</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>一个系统不可能同时满足一致性（C）、可用性(A)、分区容错性（P）</p><p><img src="/images/Eureka%E4%B8%8EZookeeper%E7%9A%84%E5%8C%BA%E5%88%AB_2019-11-28-10-31-07.png" alt="Eureka与Zookeeper的区别_2019-11-28-10-31-07.png"></p><h2 id="三个指标"><a href="#三个指标" class="headerlink" title="三个指标"></a>三个指标</h2><ul><li>一致性：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）。</li><li>可用性：在一个分布式系统的集群中一部分节点故障后，该集群是否还能够正常响应客户端的读写请求。（对数据更新具备高可用性）。</li><li>分区容错性：大多数的分布式系统都分布在多个子网络中，而每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。在一个分布式系统中一般分区容错是无法避免的，因此可以认为 CAP 中的 P 总是成立的。CAP 理论告诉我们，在 C 和 A 之间是无法同时做到。</li></ul><h1 id="Zookeeper-保证-CP"><a href="#Zookeeper-保证-CP" class="headerlink" title="Zookeeper 保证 CP"></a>Zookeeper 保证 CP</h1><ul><li>任何时候对 Zookeeper 的访问请求能得到一致的数据结果，同时系统对网络分割具备容错性</li><li>在使用 Zookeeper 获取服务列表时，如果此时的 Zookeeper 集群中的 Leader 宕机了，该集群就要进行 Leader 的选举，又或者 Zookeeper 集群中半数以上服务器节点不可用（例如有三个节点，如果节点一检测到节点三挂了 ，节点二也检测到节点三挂了，那这个节点才算是真的挂了），那么将无法处理该请求。所以说，Zookeeper 不能保证服务可用性。</li></ul><h1 id="Eureka-保证-AP"><a href="#Eureka-保证-AP" class="headerlink" title="Eureka 保证 AP"></a>Eureka 保证 AP</h1><ul><li>各个节点是平等的，几个节点挂掉，其他节点依然可以提供服务，首先报证可用性。</li><li>每个 Eureka Client 本地都有一份它最新获取到的服务注册表的缓存信息，即使所有的 Eureka Server 都挂掉了，依然可以根据本地缓存的服务信息正常工作。</li><li>如果 Eureka 服务节点在短时间里丢失了大量的心跳连接（注：可能发生了网络故障），那么这个 Eureka 节点会进入<strong>自我保护模式</strong>。 此时，这个 Eureka 节点对于新的服务还能提供注册服务，对于”死亡“的仍然保留，以防还有客户端向其发起请求。当网络故障恢复后，这个 Eureka 节点会退出自我保护模式。</li><li>Eureka 不能保证每次获取的服务列表都是最新的</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于服务发现来讲，保证服务的高可用尤为重要，哪怕返回前几分钟的服务信息，也比出现网络故障要好。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://dockone.io/article/78" target="_blank" rel="noopener">为什么不应该使用 Zookeeper 做服务发现</a></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务发现 zookeeper eureka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud实战之Config（1）</title>
      <link href="/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%881%EF%BC%89/"/>
      <url>/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="创建一个远程仓库（本地建立一个配置仓库由-idea-提交给-git"><a href="#创建一个远程仓库（本地建立一个配置仓库由-idea-提交给-git" class="headerlink" title="创建一个远程仓库（本地建立一个配置仓库由 idea 提交给 git)"></a>创建一个远程仓库（本地建立一个配置仓库由 idea 提交给 git)</h1><h2 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h2><p><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%881%EF%BC%89_2019-11-22-21-48-43.png" alt="springcloud实战之Config（1）_2019-11-22-21-48-43.png"></p><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p><a href="https://github.com/qn101630/qn101630.github.io/tree/code/config-repo" target="_blank" rel="noopener">我的配置仓库</a></p><h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><h2 id="创建一个-config-server-组件"><a href="#创建一个-config-server-组件" class="headerlink" title="创建一个 config-server 组件"></a>创建一个 config-server 组件</h2><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8769</span></span><br><span class="line"><span class="comment">#避免配置中心向自己发布服务导致程序报错服务启动不了。</span></span><br><span class="line"><span class="comment">#如果不加项目启动时报错：Cannot execute request on any known server</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">register-with-eureka</span>: <span class="string">false</span></span><br><span class="line">    <span class="meta">fetch-registry</span>: <span class="string">false</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">spring-cloud-config-server</span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">config</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">server</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">git</span>:<span class="string"></span></span><br><span class="line">          <span class="attr">uri</span>: <span class="string">https://github.com/qn101630/qn101630.github.io.git # 配置git仓库的地址，这是我的公开git,可以不用登录密码</span></span><br><span class="line">          <span class="meta">search-paths</span>: <span class="string">config-repo # git仓库地址下的相对地址，可以配置多个，用,分割。</span></span><br><span class="line">          <span class="attr">username</span>: <span class="string">qn101630                               # git仓库的账号</span></span><br><span class="line">          <span class="attr">password</span>: <span class="string">qn192837QN</span></span><br><span class="line">          <span class="meta">default-label</span>: <span class="string">code</span></span><br></pre></td></tr></table></figure><h4 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span> <span class="comment">//启用配置中心服务，作为一个接口对外提供</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigServerApp<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问远程配置"><a href="#访问远程配置" class="headerlink" title="访问远程配置"></a>访问远程配置</h4><p>访问地址：<a href="http://localhost:8769/spring-cloud-config-dev.properties" target="_blank" rel="noopener">http://localhost:8769/spring-cloud-config-dev.properties</a></p><h2 id="创建一个-config-client-组件"><a href="#创建一个-config-client-组件" class="headerlink" title="创建一个 config-client 组件"></a>创建一个 config-client 组件</h2><h4 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>config-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--无法引入：spring-cloud-config-server--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><h5 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8771</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">register-with-eureka</span>: <span class="string">false</span></span><br><span class="line">    <span class="meta">fetch-registry</span>: <span class="string">false</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">spring-cloud-config-client</span></span><br></pre></td></tr></table></figure><h5 id="bootstrap-yml"><a href="#bootstrap-yml" class="headerlink" title="bootstrap.yml"></a>bootstrap.yml</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">config</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">name</span>: <span class="string">spring-cloud-config</span></span><br><span class="line">      <span class="attr">profile</span>: <span class="string">dev</span></span><br><span class="line">      <span class="attr">uri</span>: <span class="string">http://localhost:8769/</span></span><br><span class="line">      <span class="attr">label</span>: <span class="string">code</span></span><br></pre></td></tr></table></figure><h4 id="启动类-1"><a href="#启动类-1" class="headerlink" title="启动类"></a>启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ClientApp<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="业务类"><a href="#业务类" class="headerlink" title="业务类"></a>业务类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个@Value会根据配置的配置中心地址找到git仓库对应的配置和本地服务的配置文件</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;config.hello&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String hello;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"testConfig"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"读取到配置中心："</span> + hello;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最终测试"><a href="#最终测试" class="headerlink" title="最终测试"></a>最终测试</h1><p>启动项目后访问：<a href="http://localhost:8769/hello" target="_blank" rel="noopener">http://localhost:8769/hello</a></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>目前我们的配置信息是由 client 去拉取，但是 git 上的配置发生了改变，client 无法及时的获取更改后的配置，必须重新启动 client 才可以，这显然是不合适的，所以我们还要实现动态获取配置，详情请见<a href="/2019/11/29/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BConfig%EF%BC%882%EF%BC%89/" title="springcloud实战之Config（2）">springcloud实战之Config（2）</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/qqxx6661/article/details/88604499" target="_blank" rel="noopener">配置中心 Spring Cloud Config 初体验</a></p>]]></content>
      
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> config实战 初体验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud解析之Config</title>
      <link href="/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BConfig/"/>
      <url>/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BConfig/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么需要配置中心？"><a href="#为什么需要配置中心？" class="headerlink" title="为什么需要配置中心？"></a>为什么需要配置中心？</h1><p>微服务架构没有配置中心：</p><ul><li>配置文件分散在各个项目里，不方便维护</li><li>配置内容安全与权限，实际开发中，开发人员是不知道线上环境的配置的</li><li>更新配置后，项目需要重启</li></ul><h1 id="描述下配置中心原理"><a href="#描述下配置中心原理" class="headerlink" title="描述下配置中心原理"></a>描述下配置中心原理</h1><p>把原本放在本地文件的配置抽取出来放在中心服务器，本质是配置信息从本地迁移到云端。从而能够提供更好的管理、发布能力。</p><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="/images/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BConfig_2019-11-22-21-30-17.png" alt="springcloud解析之Config_2019-11-22-21-30-17.png"></p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ul><li>Config-Client : 提供了基于 Spring 的客户端</li><li>Config-Server : 负责将远程的配置返回给客户端</li><li>Remote Repository : 远程仓库（svn/git)</li><li>Local Repository : 将远程仓库的配置 clone 到本地的临时目录</li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>提供服务端和客户端支持</li><li>集中管理各环境的配置文件</li><li>配置文件修改之后，可以快速的生效</li><li>可以进行版本管理</li><li>支持大的并发查询</li><li>支持各种语言</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>动态配置能力弱</li><li>调整配置需要重新部署，添加代码比较多</li><li>治理能力弱</li><li>安全审计能力弱</li><li>不算严格企业级</li><li>适用于小型项目</li></ul>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> config 配置中心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud实战之Zuul</title>
      <link href="/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BZuul/"/>
      <url>/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BZuul/</url>
      
        <content type="html"><![CDATA[<h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><p>新建 Zuul 子模块</p><h2 id="Zuul-服务网关体验"><a href="#Zuul-服务网关体验" class="headerlink" title="Zuul 服务网关体验"></a>Zuul 服务网关体验</h2><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">zuul</span></span><br><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8773</span></span><br><span class="line"><span class="comment">#服务中心注册</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">serviceUrl</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://localhost:9999/eureka/</span></span><br><span class="line"><span class="comment">#自定义负载均衡策略</span></span><br><span class="line"><span class="meta">provider-user</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">ribbon</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName</span>: <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br><span class="line"><span class="comment"># 服务网关设置</span></span><br><span class="line"><span class="attr">zuul</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">routes</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">hello</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">path</span>: <span class="string">/producer/**</span></span><br><span class="line">      <span class="attr">serviceId</span>: <span class="string">provider-user</span></span><br></pre></td></tr></table></figure><h4 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//启用服务网关</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ZuulApp<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="熔断器-Filter"><a href="#熔断器-Filter" class="headerlink" title="熔断器 Filter"></a>熔断器 Filter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiFallbackProvider</span> <span class="keyword">implements</span> <span class="title">FallbackProvider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRoute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置熔断的服务名</span></span><br><span class="line">        <span class="comment">//如果是所有服务则设置为*</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"provider-user"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">fallbackResponse</span><span class="params">(String route, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClientHttpResponse() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> HttpStatus <span class="title">getStatusCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> HttpStatus.OK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRawStatusCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getStatusText</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"&#123;code:0,message:service error =_=&#125;"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> InputStream <span class="title">getBody</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ByteArrayInputStream(getStatusText().getBytes()</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> HttpHeaders <span class="title">getHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">                headers.setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line">                <span class="keyword">return</span> headers;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ol><li>启动 Eureka 客户端、三个提供者服务（不同端口）、Zuul 网关模块，访问地址：<a href="http://localhost:8773/producer/user/1" target="_blank" rel="noopener">http://localhost:8773/producer/user/1</a></li><li>访问 15 次，发现请求是随机访问到三个提供者服务（说明自定义的负载均衡策略生效了，zuul 默认的负载均衡策略是轮询）。</li><li>关掉两个提供者服务，再次请求以上地址，发现可能返回服务降级内容（不超过两次）。</li><li>关掉最后一个提供者，再次请求会返回服务降级内容（说明熔断器生效）。</li></ol><p><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8Bzuul%EF%BC%88%E4%BA%8C%EF%BC%89_2019-11-20-15-57-24.png" alt="springcloud实战之zuul（二）_2019-11-20-15-57-24.png"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/qqxx6661/article/details/88767696" target="_blank" rel="noopener">[菜鸟 SpringCloud 实战入门]第九章：服务网关 Zuul 体验</a></p>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zuul实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud解析之Zuul</title>
      <link href="/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BZuul/"/>
      <url>/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BZuul/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-Zuul"><a href="#什么是-Zuul" class="headerlink" title="什么是 Zuul?"></a>什么是 Zuul?</h2><ul><li>服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供 REST API 的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。</li><li>Spring Cloud Netflix 中的 Zuul 就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。</li></ul><h2 id="为什么需要-Zuul"><a href="#为什么需要-Zuul" class="headerlink" title="为什么需要 Zuul?"></a>为什么需要 Zuul?</h2><ul><li>客户端直接与微服务通信：</li></ul><ol><li>客户端会多次请求不同的微服务，增加了客户端的复杂性。</li><li>存在跨域请求，在一定场景下处理相对复杂。</li><li>认证复杂，每个服务都需要独立认证。</li><li>难以重构，随着项目的迭代，可能需要重新划分微服务。</li><li>某些微服务可能使用了防火墙/浏览器不友好的协议，直接访问会有一定困难。</li></ol><ul><li>使用网关优点：</li></ul><ol><li>易于监控。可在微服务网关收集监控数据并将其推送到外部系统进行分析。</li><li>易于认证。可在微服务网关上进行认证。然后再将请求转发到后端的微服务，而无须在每个微服务中进行认证。</li><li>减少了客户端与各个微服务之间的交互次数。</li></ol><ul><li>Zuul 提供了不同类型的 filter 用于处理请求，这些 filter 可以让我们实现以下功能：</li></ul><ol><li>权限控制和安全性：可以识别认证需要的信息和拒绝不满足条件的请求</li><li>监控：监控请求信息</li><li>动态路由：根据需要动态地路由请求到后台的不同集群</li><li>压力测试</li><li>负载均衡</li><li>静态资源处理：直接在 zuul 处理静态资源的响应而不需要转发这些请求到内部集群中</li></ol><h2 id="Zuul-的执行过程"><a href="#Zuul-的执行过程" class="headerlink" title="Zuul 的执行过程"></a>Zuul 的执行过程</h2><p><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BZuul%EF%BC%88%E4%B8%80%EF%BC%89_2019-11-20-13-55-29.png" alt="springcloud实战之Zuul（一）_2019-11-20-13-55-29.png"></p><hr><ul><li>Zuul 内部的处理使用 ZuulServlet 完成，ZuulServlet 继承 HttpServlet，重写了 service 方法，service 方法内部分别是 pre、route、post 和 error 类型的 filter 进行调用。</li><li>filter 的执行顺序：先执行 pre 类型的 filter；如果 pre filter 执行失败那么执行 error 和 post 类型的 filter，pre filter 执行成功的话执行 route 类型的 filter；如果 route filter 执行失败那么执行 error 和 post 类型的 filter，route filter 执行成功的话执行 post filter；如果 post filter 执行失败那么执行 error 类型的 filter，post filter 执行成功的话，结束。上述过程中执行失败指的是 ZuulException 被 catch，如果是其他 Exception 的话，那么执行 error 类型的 filter，然后结束。</li><li>要在 SpringCloud 中使用 Zuul，需要加上<code>@EnableZuulProxy</code>注解。加上这个注解之后 SpringCloud 会构造一些 bean，比如 ZuulHandlerMapping、DiscoveryClientRouteLocator、各种 filter 等。其中<code>DiscoveryClientRouteLocato</code>r 是一个基于服务发现的路由规则生成器，它会基于 zuul 的配置构造路由规则。<code>ZuulHandlerMapping</code>是一个 HandlerMapping 的实现，它跟基于路由规则注册 handler，其中 key 为路由规则对应的路径，handler 都是 ZuulController，ZuulController 内部使用 ZuulServlet 进行请求的处理。</li><li>Zuul 把真正的服务调用放在了 filter 中实现。它提供了<code>SimpleHostRoutingFilter</code>和<code>RibbonRoutingFilter</code>这 2 个 route 类型的 filter 用于执行服务。从名字也可以看出来，SimpleHostRoutingFilter 用于执行基于 host 方式的调用 url 接口，RibbonRoutingFilter 基于服务发现的方式调用服务。<strong>一般我们都建议使用 RibbonRoutingFilter，因为它内部使用 ribbon，更加健壮。</strong></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://fangjian0423.github.io/2017/02/22/springcloud-zuul/" target="_blank" rel="noopener">SpringCloud 网关服务 zuul 介绍</a></p><p><a href="https://www.cnblogs.com/duanxz/p/7527765.html" target="_blank" rel="noopener">服务网关 zuul 之一：入门介绍</a></p>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ribbon服务网关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud实战之Hystrix（2）</title>
      <link href="/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BHystrix%EF%BC%882%EF%BC%89/"/>
      <url>/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BHystrix%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><p>多应用监控</p><h2 id="新建一个子模块-hystrix-dashboard-turbine"><a href="#新建一个子模块-hystrix-dashboard-turbine" class="headerlink" title="新建一个子模块 hystrix-dashboard-turbine"></a>新建一个子模块 hystrix-dashboard-turbine</h2><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hystrix-dashboard-turbine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring boot 1.X：spring-cloud-starter-hystrix-dashboard--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-netflix-turbine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line"><span class="comment">  # 服务端口号</span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8767</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line"><span class="comment">    # 服务名，即serviceId</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">hystrix-dashboard-turbine</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">serviceUrl</span>:<span class="string"></span></span><br><span class="line"><span class="comment">      # 安全认证的服务注册中心地址</span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://localhost:9999/eureka</span></span><br><span class="line"><span class="comment"># 熔断器turbine</span></span><br><span class="line"><span class="attr">turbine</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">aggregator</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">cluster-config</span>: <span class="string">default</span></span><br><span class="line">  <span class="meta">cluster-name-expression</span>: <span class="string">new String("default")</span></span><br><span class="line">  <span class="meta">app-config</span>: <span class="string">consumer-feign, consumer-feign-2</span></span><br></pre></td></tr></table></figure><h4 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableTurbine</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TurbineApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(TurbineApp<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复制一个提供者服务"><a href="#复制一个提供者服务" class="headerlink" title="复制一个提供者服务"></a>复制一个提供者服务</h2><h4 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span><br><span class="line">         xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;springcloud&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.qn&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;provider-user-2&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">7901 #自定义boot项目访问端口</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">provider-user-2</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">instance</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">hostname</span>: <span class="string">localhost</span></span><br><span class="line"><span class="comment">    # 发呆时间，即服务失效时间（缺省为90s）,就是超过15秒没有续约就会从注册表中剔除</span></span><br><span class="line">    <span class="meta">lease-expiration-duration-in-seconds</span>: <span class="string">15</span></span><br><span class="line"><span class="comment">    # 心跳时间，即服务续约间隔时间（缺省为30s）</span></span><br><span class="line">    <span class="meta">lease-renewal-interval-in-seconds</span>: <span class="string">5</span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://localhost:9999/eureka</span></span><br></pre></td></tr></table></figure><h2 id="复制一个-Feign-客户端"><a href="#复制一个-Feign-客户端" class="headerlink" title="复制一个 Feign 客户端"></a>复制一个 Feign 客户端</h2><h4 id="依赖-2"><a href="#依赖-2" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>consumer-feign-2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring boot 1.X：spring-cloud-starter-hystrix--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring boot 1.X：spring-cloud-starter-hystrix-dashboard--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8901</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">consumer-feign-2</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">instance</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">hostname</span>: <span class="string">localhost</span></span><br><span class="line"><span class="comment">    # 发呆时间，即服务失效时间（缺省为90s）,就是超过15秒没有续约就会从注册表中剔除</span></span><br><span class="line">    <span class="meta">lease-expiration-duration-in-seconds</span>: <span class="string">15</span></span><br><span class="line"><span class="comment">    # 心跳时间，即服务续约间隔时间（缺省为30s）</span></span><br><span class="line">    <span class="meta">lease-renewal-interval-in-seconds</span>: <span class="string">5</span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://localhost:9999/eureka</span></span><br><span class="line"><span class="meta">PROVIDER-USER</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">ribbon</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName</span>: <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br><span class="line"><span class="comment"># 在feign使用hystrix</span></span><br><span class="line"><span class="attr">feign</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">hystrix</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">enabled</span>: <span class="string">true</span></span><br><span class="line"><span class="comment"># 熔断器DashBoard: actuator在boot2.0调整后开关web端点的配置，*代表开启所有</span></span><br><span class="line"><span class="attr">management</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">endpoints</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">web</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">exposure</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">include</span>: <span class="string">"*"</span></span><br></pre></td></tr></table></figure><h4 id="Service-接口"><a href="#Service-接口" class="headerlink" title="Service 接口"></a>Service 接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个feign接口，通过@ FeignClient（“服务名”），来指定调用哪个服务</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value =<span class="string">"PROVIDER-USER-2"</span>,fallback = ServiceHystrixImpl<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">getUser2</span><span class="params">(@PathVariable Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>fallback 服务降级</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHystrixImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser2</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">12345l</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="查看监控"><a href="#查看监控" class="headerlink" title="查看监控"></a>查看监控</h1><ol><li>启动 hystrix-dashboard-turbine、俩个 Feign 客户端、两个提供者服务、eureka 客户端。</li><li>访问网址<a href="http://localhost:8767/hystrix" target="_blank" rel="noopener">http://localhost:8767/hystrix</a> ，输入输入： <a href="http://localhost:8767/turbine.stream" target="_blank" rel="noopener">http://localhost:8767/turbine.stream</a> ，然后点击 Monitor Stream ,可以看到出现了监控列表，分别访问<a href="http://localhost:8900/order/1、http://localhost:8901/order/1，显示界面如下：" target="_blank" rel="noopener">http://localhost:8900/order/1、http://localhost:8901/order/1，显示界面如下：</a><br><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BHystrix%EF%BC%88%E4%B8%89%EF%BC%89_2019-11-19-17-19-13.png" alt="springcloud实战之Hystrix（三）_2019-11-19-17-19-13.png"></li></ol>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多应用监控 turbine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud实战之Hystrix（1）</title>
      <link href="/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BHystrix%EF%BC%881%EF%BC%89/"/>
      <url>/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BHystrix%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><p>使用上一章建立的 Feign 客户端</p><h2 id="添加配置文件"><a href="#添加配置文件" class="headerlink" title="添加配置文件"></a>添加配置文件</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">hystrix</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">enabled</span>: <span class="string">true</span></span><br></pre></td></tr></table></figure><h2 id="fallback-类"><a href="#fallback-类" class="headerlink" title="fallback 类"></a>fallback 类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHystrixImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">12345l</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改-Service-接口"><a href="#修改-Service-接口" class="headerlink" title="修改 Service 接口"></a>修改 Service 接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个feign接口，通过@ FeignClient（“服务名”），来指定调用哪个服务，fallback定义服务降级</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value =<span class="string">"PROVIDER-USER"</span>,fallback = ServiceHystrixImpl<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">getUser</span><span class="params">(@PathVariable Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">启动Feign客户端，访问提供者服务，url地址同上，停止服务提供者，再次访问，会返回服务降级内容。</span><br></pre></td></tr></table></figure><h1 id="熔断器监控-Hystrix-Dashboard-单一应用"><a href="#熔断器监控-Hystrix-Dashboard-单一应用" class="headerlink" title="熔断器监控 Hystrix Dashboard(单一应用)"></a>熔断器监控 Hystrix Dashboard(单一应用)</h1><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>consumer-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring boot 1.X：spring-cloud-starter-hystrix--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring boot 1.X：spring-cloud-starter-hystrix-dashboard--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="添加配置文件内容"><a href="#添加配置文件内容" class="headerlink" title="添加配置文件内容"></a>添加配置文件内容</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 熔断器DashBoard: actuator在boot2.0调整后开关web端点的配置，*代表开启所有</span></span><br><span class="line"><span class="attr">management</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">endpoints</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">web</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">exposure</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">include</span>: <span class="string">"*"</span></span><br></pre></td></tr></table></figure><h2 id="启动类添加注解"><a href="#启动类添加注解" class="headerlink" title="启动类添加注解"></a>启动类添加注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//通过注解@EnableEurekaClient 表明自己是一个eurekaclient.</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="comment">//开启Feign的功能</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="comment">//注解开启Hystrix仪表盘</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="comment">//注解开启Hystrix</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerFeignApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConsumerFeignApp<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h1><ol><li>启动 Feign 客户端，访问网址<a href="http://localhost:8900/hystrix/，显示界面如下：" target="_blank" rel="noopener">http://localhost:8900/hystrix/，显示界面如下：</a><br><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BHystrix%EF%BC%88%E4%BA%8C%EF%BC%89_2019-11-19-15-36-15.png" alt="springcloud实战之Hystrix（二）_2019-11-19-15-36-15.png"></li><li>输入<a href="http://localhost:8900/actuator/hystrix.stream,点击monitor,显示界面如下：" target="_blank" rel="noopener">http://localhost:8900/actuator/hystrix.stream,点击monitor,显示界面如下：</a><br><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BHystrix%EF%BC%88%E4%BA%8C%EF%BC%89_2019-11-19-15-39-54.png" alt="springcloud实战之Hystrix（二）_2019-11-19-15-39-54.png"></li><li>只使用 Hystrix Dashboard 的话, 你只能看到单个应用内的服务信息, 这明显不够. 我们需要一个工具能让我们汇总系统内多个服务的数据并显示到 Hystrix Dashboard 上,这个工具就是 Turbine.详见<a href="/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BHystrix%EF%BC%882%EF%BC%89/" title="springcloud实战之Hystrix（2）">springcloud实战之Hystrix（2）</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hystrix实战 单应用监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud解析之Hystrix</title>
      <link href="/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BHystrix/"/>
      <url>/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BHystrix/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么需要熔断器？"><a href="#为什么需要熔断器？" class="headerlink" title="为什么需要熔断器？"></a>为什么需要熔断器？</h1><ul><li>传统分布式系统面临一些性能上的问题，当复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败。这时可能会出现<strong>服务雪崩</strong>。</li><li>对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。</li></ul><h1 id="什么是服务雪崩？"><a href="#什么是服务雪崩？" class="headerlink" title="什么是服务雪崩？"></a>什么是服务雪崩？</h1><p>多个微服务之间调用的时候，假设微服务 A 调用微服务 B 和微服务 C，微服务 B 和微服务 C 又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务 A 的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”。</p><h1 id="什么是熔断器-Hystrix？"><a href="#什么是熔断器-Hystrix？" class="headerlink" title="什么是熔断器 Hystrix？"></a>什么是熔断器 Hystrix？</h1><ul><li>Hystrix 是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix 能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。</li><li>“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。</li></ul><h1 id="Hystrix-能做什么"><a href="#Hystrix-能做什么" class="headerlink" title="Hystrix 能做什么"></a>Hystrix 能做什么</h1><p><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BHystrix%EF%BC%88%E4%B8%80%EF%BC%89_2019-11-19-14-44-07.png" alt="springcloud实战之Hystrix（一）_2019-11-19-14-44-07.png"></p><h2 id="断路器"><a href="#断路器" class="headerlink" title="断路器"></a>断路器</h2><p>当 Hystrix Command 请求后端服务失败数量超过一定比例(默认 50%), 断路器会切换到开路状态(Open). 这时所有请求会直接失败而不会发送到后端服务. 断路器保持在开路状态一段时间后(默认 5 秒), 自动切换到半开路状态(HALF-OPEN). 这时会判断下一次请求的返回情况, 如果请求成功, 断路器切回闭路状态(CLOSED), 否则重新切换到开路状态(OPEN). Hystrix 的断路器就像我们家庭电路中的保险丝, 一旦后端服务不可用, 断路器会直接切断请求链, 避免发送大量无效请求影响系统吞吐量, 并且断路器有自我检测并恢复的能力。</p><h2 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h2><p>对于查询操作, 我们可以实现一个 fallback 方法, 当请求后端服务出现异常的时候, 可以使用 fallback 方法返回的值. fallback 方法的返回值一般是设置的默认值或者来自缓存。</p><h2 id="资源隔离"><a href="#资源隔离" class="headerlink" title="资源隔离"></a>资源隔离</h2><p>在 Hystrix 中, 主要通过线程池来实现资源隔离. 通常在使用的时候我们会根据调用的远程服务划分出多个线程池. 例如调用产品服务的 Command 放入 A 线程池, 调用账户服务的 Command 放入 B 线程池. 这样做的主要优点是运行环境被隔离开了. 这样就算调用服务的代码存在 bug 或者由于其他原因导致自己所在线程池被耗尽时, 不会对系统的其他服务造成影响. 但是带来的代价就是维护多个线程池会对系统带来额外的性能开销. 如果是对性能有严格要求而且确信自己调用服务的客户端代码不会出问题的话, 可以使用 Hystrix 的信号模式(Semaphores)来隔离资源.</p><h2 id="服务监控-hystrixDashboard"><a href="#服务监控-hystrixDashboard" class="headerlink" title="服务监控 hystrixDashboard"></a>服务监控 hystrixDashboard</h2><p>除了隔离依赖服务的调用以外，Hystrix 还提供了准实时的调用监控（Hystrix Dashboard），Hystrix 会持续地记录所有通过 Hystrix 发起的请求的执行信息，并以统计报表和图形的形式展示给用户，包括每秒执行多少请求多少成功，多少失败等。Netflix 通过 hystrix-metrics-event-stream 项目实现了对以上指标的监控。Spring Cloud 也提供了 Hystrix Dashboard 的整合，对监控内容转化成可视化界面。</p>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hystrix 熔断器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud实战之Euraka</title>
      <link href="/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BEuraka/"/>
      <url>/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BEuraka/</url>
      
        <content type="html"><![CDATA[<h1 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h1><ul><li>jdk1.8</li><li>maven 3.6.2</li><li>IntelliJ IDEA</li><li>springCloud Finchley.RELEASE</li><li>springBoot 2.0.3</li></ul><h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><h2 id="project-依赖"><a href="#project-依赖" class="headerlink" title="project 依赖"></a>project 依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--子项目--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>consumer-order<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>provider-user<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>appEureka<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>consumer-order-ribbon<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--参数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--springBoot--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--springCloud版本序列配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Finchley.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Spring Cloud 基础--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Spring Cloud 服务注册组件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--此处的依赖是SpringBoot2.0以后专用的，如果您使用的SpringBoot版本低于2.0请使用spring-cloud-starter-eureka-server--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring boot 2.0.3版本解决方案：spring-cloud-starter-feign--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--Spring Boot 执行器组件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="eureka-客户端依赖、启动类、配置"><a href="#eureka-客户端依赖、启动类、配置" class="headerlink" title="eureka 客户端依赖、启动类、配置"></a>eureka 客户端依赖、启动类、配置</h2><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xmlversion="1.0"encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">projectxmlns="http:</span>//<span class="attr">maven.apache.org</span>/<span class="attr">POM</span>/<span class="attr">4.0.0</span>"</span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>appEureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span><span class="comment">//开启Eurekaserver</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Eureka</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">    SpringApplication.run(Eureka<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 端口号</span></span><br><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">9999</span></span><br><span class="line"><span class="comment"># 服务注册相关配置</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line"><span class="comment">  # 服务实例主机名</span></span><br><span class="line">  <span class="attr">instance</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">hostname</span>: <span class="string">localhost</span></span><br><span class="line"><span class="comment">  # 服务提供者配置</span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line"><span class="comment">    # 不进行注册（当服务注册中心是单点而非高可用时的配置方式）</span></span><br><span class="line">    <span class="attr">registerWithEureka</span>: <span class="string">false</span></span><br><span class="line"><span class="comment">    # 不获取注册信息（当服务注册中心是单点而非高可用时的配置方式）</span></span><br><span class="line">    <span class="attr">fetchRegistry</span>: <span class="string">false</span></span><br><span class="line"><span class="comment">    # 服务注册中心地址</span></span><br><span class="line">    <span class="attr">serviceUrl</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure><h4 id="消费者依赖、启动类、配置、bean、业务类"><a href="#消费者依赖、启动类、配置、bean、业务类" class="headerlink" title="消费者依赖、启动类、配置、bean、业务类"></a>消费者依赖、启动类、配置、bean、业务类</h4><h5 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xmlversion="1.0"encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">projectxmlns="http:</span>//<span class="attr">maven.apache.org</span>/<span class="attr">POM</span>/<span class="attr">4.0.0</span>"</span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>consumer-order<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="启动类-1"><a href="#启动类-1" class="headerlink" title="启动类"></a>启动类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerApp</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">    SpringApplication.run(ConsumerApp<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line"><span class="attr">port</span>:<span class="string">8900</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line"><span class="attr">application</span>:<span class="string"></span></span><br><span class="line"><span class="attr">name</span>:<span class="string">consumer-order</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line"><span class="attr">instance</span>:<span class="string"></span></span><br><span class="line">   <span class="attr">hostname</span>: <span class="string">localhost</span></span><br><span class="line"><span class="comment">   # 发呆时间，即服务失效时间（缺省为90s）,就是超过15秒没有续约就会从注册表中剔除</span></span><br><span class="line">   <span class="meta">lease-expiration-duration-in-seconds</span>: <span class="string">15</span></span><br><span class="line"><span class="comment">   # 心跳时间，即服务续约间隔时间（缺省为30s）</span></span><br><span class="line">   <span class="meta">lease-renewal-interval-in-seconds</span>: <span class="string">5</span></span><br><span class="line"><span class="attr">client</span>:<span class="string"></span></span><br><span class="line"><span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line"><span class="attr">defaultZone</span>:<span class="string">http://localhost:9999/eureka</span></span><br></pre></td></tr></table></figure><h5 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"><span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id=id;</span><br><span class="line"><span class="keyword">this</span>.date=newDate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Longget <span class="title">Id</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id=id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getDate</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(Datedate)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.date=date;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="业务类"><a href="#业务类" class="headerlink" title="业务类"></a>业务类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span></span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> EurekaClient eurekaClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/order/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Userget <span class="title">Order</span><span class="params">(@PathVariableLongid)</span></span>&#123;</span><br><span class="line">InstanceInfo nextServerFromEureka=eurekaClient.getNextServerFromEureka(<span class="string">"PROVIDER-USER"</span>,<span class="keyword">false</span>);</span><br><span class="line">Stringurl=nextServerFromEureka.getHomePageUrl();</span><br><span class="line">Useruser=restTemplate.getForObject(url+<span class="string">"/user/"</span>+id,User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="提供者依赖、配置、启动类、bean、业务类"><a href="#提供者依赖、配置、启动类、bean、业务类" class="headerlink" title="提供者依赖、配置、启动类、bean、业务类"></a>提供者依赖、配置、启动类、bean、业务类</h4><h5 id="依赖-2"><a href="#依赖-2" class="headerlink" title="依赖"></a>依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xmlversion="1.0"encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">projectxmlns="http:</span>//<span class="attr">maven.apache.org</span>/<span class="attr">POM</span>/<span class="attr">4.0.0</span>"</span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>provider-user<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line"><span class="attr">port</span>:<span class="string">7900#自定义boot项目访问端口</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line"><span class="attr">application</span>:<span class="string"></span></span><br><span class="line"><span class="attr">name</span>:<span class="string">provider-user</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line"><span class="attr">instance</span>:<span class="string"></span></span><br><span class="line">   <span class="attr">hostname</span>: <span class="string">localhost</span></span><br><span class="line"><span class="comment">   # 发呆时间，即服务失效时间（缺省为90s）,就是超过15秒没有续约就会从注册表中剔除</span></span><br><span class="line">   <span class="meta">lease-expiration-duration-in-seconds</span>: <span class="string">15</span></span><br><span class="line"><span class="comment">   # 心跳时间，即服务续约间隔时间（缺省为30s）</span></span><br><span class="line">   <span class="meta">lease-renewal-interval-in-seconds</span>: <span class="string">5</span></span><br><span class="line"><span class="attr">client</span>:<span class="string"></span></span><br><span class="line"><span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line"><span class="attr">defaultZone</span>:<span class="string">http://localhost:9999/eureka</span></span><br></pre></td></tr></table></figure><h5 id="启动类-2"><a href="#启动类-2" class="headerlink" title="启动类"></a>启动类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span><span class="comment">//启用eureka客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderApp</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">SpringApplication.run(ProviderApp<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="bean-1"><a href="#bean-1" class="headerlink" title="bean"></a>bean</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"><span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id=id;</span><br><span class="line"><span class="keyword">this</span>.date=newDate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Longget <span class="title">Id</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id=id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getDate</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(Datedate)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.date=date;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="业务类-1"><a href="#业务类-1" class="headerlink" title="业务类"></a>业务类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> EurekaClient eurekaClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">publicUsergetUser(<span class="meta">@PathVariableLongid</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> User(id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ul><li>启动 eureka、消费者、提供者，访问 eureka 客户端<br><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8Beureka%EF%BC%88%E4%BA%8C%EF%BC%89_2019-11-14-10-26-57.png" alt="springcloud实战之eureka（二）_2019-11-14-10-26-57.png"></li><li>消费者通过 eureka 访问提供者<br><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8Beureka%EF%BC%88%E4%BA%8C%EF%BC%89_2019-11-14-10-31-56.png" alt="springcloud实战之eureka（二）_2019-11-14-10-31-56.png"></li></ul>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eureka实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud解析之Eureka</title>
      <link href="/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BEureka/"/>
      <url>/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BEureka/</url>
      
        <content type="html"><![CDATA[<h1 id="Eureka-是什么？"><a href="#Eureka-是什么？" class="headerlink" title="Eureka 是什么？"></a>Eureka 是什么？</h1><ul><li><code>Netflix</code>提供的一种高可用的服务发现解决方案。</li><li>基于 REST 的服务，主要用于定位运行在 AWS 域中的中间层服务，以达到负载均衡和中间层服务故障转移的目的。SpringCloud 将它集成在其子项目<code>spring-cloud-netflix</code>中，实现 SpringCloud 的服务发现功能。</li></ul><h1 id="介绍下-Eureka-的工作原理"><a href="#介绍下-Eureka-的工作原理" class="headerlink" title="介绍下 Eureka 的工作原理"></a>介绍下 Eureka 的工作原理</h1><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ul><li>Eureka 服务器和 Eureka 客户端。Eureka 服务器用作服务注册服务器。</li><li>Eureka 客户端是一个 java 客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。</li></ul><h2 id="Eureka-架构图"><a href="#Eureka-架构图" class="headerlink" title="Eureka 架构图"></a>Eureka 架构图</h2><p><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8Beureka%EF%BC%88%E4%B8%80%EF%BC%89_2019-11-18-13-35-14.png" alt="springcloud实战之eureka（一）_2019-11-18-13-35-14.png"></p><h2 id="心跳监测"><a href="#心跳监测" class="headerlink" title="心跳监测"></a>心跳监测</h2><p>在应用启动后，将会向 Eureka Server 发送心跳,默认周期为 30 秒，如果 Eureka Server 在多个心跳周期内没有接收到某个节点的心跳，Eureka Server 将会从服务注册表中把这个服务节点移除(默认 90 秒)。</p><h2 id="心跳保护"><a href="#心跳保护" class="headerlink" title="心跳保护"></a>心跳保护</h2><p>如果 Eureka 服务节点在短时间里丢失了大量的心跳连接（注：可能发生了网络故障），那么这个 Eureka 节点会进入<strong>自我保护模式</strong>。 此时，这个 Eureka 节点对于新的服务还能提供注册服务，对于”死亡“的仍然保留，以防还有客户端向其发起请求。当网络故障恢复后，这个 Eureka 节点会退出自我保护模式。</p><h2 id="客户端缓存"><a href="#客户端缓存" class="headerlink" title="客户端缓存"></a>客户端缓存</h2><ul><li>Eureka 集群中所有节点都失效，或者发生网络分割故障导致客户端不能访问任何一台 Eureka 服务器；Eureka 服务的消费者仍然可以通过 Eureka 客户端缓存来获取现有的服务注册信息。</li><li>甚至最极端的环境下，所有正常的 Eureka 节点都不对请求产生相应，也没有更好的服务器解决方案来解决这种问题时；得益于 Eureka 的客户端缓存技术，消费者服务仍然可以通过 Eureka 客户端查询与获取注册服务信息，这点很重要。</li></ul><h2 id="服务同步"><a href="#服务同步" class="headerlink" title="服务同步"></a>服务同步</h2><p>如果某台服务器宕机，Eureka 不会有类似于 ZooKeeper 的选举 leader 的过程；客户端请求会自动切换到新的 Eureka 节点；当宕机的服务器重新恢复后，Eureka 会再次将其纳入到服务器集群管理之中；而对于它来说，所有要做的无非是同步一些新的服务注册信息而已。所以，再也不用担心有“掉队”的服务器恢复以后，会从 Eureka 服务器集群中剔除出去的风险了。</p><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><ul><li>服务发现有<strong>客户端发现模式</strong>和<strong>服务端发现模式</strong>两种。区别在于服务发现 Balance 策略是由使用方自己实现还是作为一项服务来供使用方调用。</li><li>服务发现依赖于服务注册表，系统中每个服务实例启动时，会将自己的网络位置信息发送到服务注册表，服务注册表利用<strong>心跳机制</strong>即时更新。实例关闭或者服务注册表检测到实例心跳超时情况下，实例信息就会从服务注册表移出。</li></ul><h2 id="两种服务发现模式"><a href="#两种服务发现模式" class="headerlink" title="两种服务发现模式"></a>两种服务发现模式</h2><ul><li>客户端发现模式是由服务请求方负责发现所有可用实例在网络中的具体位置，并根据具体的 Balance 策略将请求路由到具体的实例处理。</li><li>服务端发现模式则是请求方把请求经由 Load Balancer，Load Balancer 查询服务注册表后根据自己的 Balance 策略将请求路由到目标服务的一台具体实例上进行处理。</li></ul>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eureka 服务发现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud实战之Feign</title>
      <link href="/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BFeign/"/>
      <url>/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BFeign/</url>
      
        <content type="html"><![CDATA[<h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>consumer-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8900</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">consumer-order-ribbon</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">instance</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">hostname</span>: <span class="string">localhost</span></span><br><span class="line"><span class="comment">    # 发呆时间，即服务失效时间（缺省为90s）,就是超过15秒没有续约就会从注册表中剔除</span></span><br><span class="line">    <span class="meta">lease-expiration-duration-in-seconds</span>: <span class="string">15</span></span><br><span class="line"><span class="comment">    # 心跳时间，即服务续约间隔时间（缺省为30s）</span></span><br><span class="line">    <span class="meta">lease-renewal-interval-in-seconds</span>: <span class="string">5</span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://localhost:9999/eureka</span></span><br></pre></td></tr></table></figure><h2 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//通过注解@EnableEurekaClient 表明自己是一个eurekaclient.</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="comment">//开启Feign的功能</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerFeignApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConsumerFeignApp<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务接口"><a href="#服务接口" class="headerlink" title="服务接口"></a>服务接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个feign接口，通过@ FeignClient（“服务名”），来指定调用哪个服务</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value =<span class="string">"provider-user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">getUser</span><span class="params">(@PathVariable Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="业务类（数据类同上省略）"><a href="#业务类（数据类同上省略）" class="headerlink" title="业务类（数据类同上省略）"></a>业务类（数据类同上省略）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/order/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getOrder</span><span class="params">(@PathVariable Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUser(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">启动eureka、同时启动两个提供者、启动Feign客户端，访问地址http://localhost:8900/order/1，可以看到，轮流访问两个提供者服务。说明 Feign 默认是集成了 Ribbon 的轮询方案。</span><br></pre></td></tr></table></figure><h1 id="Feign-如何结合-Ribbon-切换均衡算法"><a href="#Feign-如何结合-Ribbon-切换均衡算法" class="headerlink" title="Feign 如何结合 Ribbon 切换均衡算法"></a>Feign 如何结合 Ribbon 切换均衡算法</h1><p>可以在 application.yml 中指定，如下:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">PROVIDER-USER</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">ribbon</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName</span>: <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br></pre></td></tr></table></figure><h1 id="测试均衡算法"><a href="#测试均衡算法" class="headerlink" title="测试均衡算法"></a>测试均衡算法</h1><p>重启 Feign 客户端，访问上面那个 url，可以发现随机访问负载策略是生效的。</p>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> feign实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud解析之Feign</title>
      <link href="/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BFeign/"/>
      <url>/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BFeign/</url>
      
        <content type="html"><![CDATA[<h1 id="Feign-是什么？"><a href="#Feign-是什么？" class="headerlink" title="Feign 是什么？"></a>Feign 是什么？</h1><ul><li>Feign 是一个声明式 WebService 客户端。</li><li>使用 Feign 能让编写的 WebService 客户端更加简洁。</li><li>它的使用方法式定义一个接口，然后在上面添加注解</li><li>Spring Cloud 对 Feign 进行了封装，使其支持了 Spring MVC 标准注解和 HttpMessageConverters。</li><li>Feign 可以与 Eureka 和 Ribbon 组合使用以支持负载均衡。</li></ul><h1 id="为什么要使用-Feign"><a href="#为什么要使用-Feign" class="headerlink" title="为什么要使用 Feign?"></a>为什么要使用 Feign?</h1><ul><li>Feign 旨在使编写 Java Http 客户端变得更容易。</li><li>让我们的服务接口化，改变前面的 Ribben+RestTemplate 的模板化的调用方式。</li><li>Feign 封装了 Ribbon，可以结合 Ribbon 自定义负载均衡策略</li><li><strong>但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用</strong>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> feign 服务接口化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud实战之Ribbon</title>
      <link href="/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BRibbon/"/>
      <url>/2019/11/22/springcloud%E5%AE%9E%E6%88%98%E4%B9%8BRibbon/</url>
      
        <content type="html"><![CDATA[<h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><p>创建一个消费者</p><h2 id="默认简单轮询负载均衡策略"><a href="#默认简单轮询负载均衡策略" class="headerlink" title="默认简单轮询负载均衡策略"></a>默认简单轮询负载均衡策略</h2><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>consumer-order-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8900</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">consumer-order-ribbon</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://localhost:9999/eureka</span></span><br><span class="line">  <span class="attr">instance</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">prefer-ip-address</span>: <span class="string">true</span></span><br></pre></td></tr></table></figure><h4 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConsumerApp<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 向程序的ioc注入一个bean: restTemplate;</span></span><br><span class="line"><span class="comment">    * 并通过<span class="doctag">@LoadBalanced</span>注解表明这个restRemplate开启负载均衡的功能。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.date = <span class="keyword">new</span> Date();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.date = date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="业务类"><a href="#业务类" class="headerlink" title="业务类"></a>业务类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/order/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getOrder</span><span class="params">(@PathVariable Long id)</span></span>&#123;</span><br><span class="line">        User user = restTemplate.getForObject(<span class="string">"http://PROVIDER-USER/user/"</span>+ id, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><hr><p>启动消费者（ribbon）、提供者（7900，7901）、eureka 客户端，访问如下界面刷新 10 次<br><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8Bribbon%EF%BC%88%E4%BA%8C%EF%BC%89_2019-11-14-17-21-44.png" alt="springcloud实战之ribbon（二）_2019-11-14-17-21-44.png"></p><hr><p>两个提供者服务各被访问 5 次</p><h2 id="自定义负载均衡策略"><a href="#自定义负载均衡策略" class="headerlink" title="自定义负载均衡策略"></a>自定义负载均衡策略</h2><h4 id="负载均衡策略类"><a href="#负载均衡策略类" class="headerlink" title="负载均衡策略类"></a>负载均衡策略类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonConfigration</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置负载均衡策略为 随机，默认是轮训</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">ribbonRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomRule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="负载均衡配置类"><a href="#负载均衡配置类" class="headerlink" title="负载均衡配置类"></a>负载均衡配置类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RibbonClient</span>(name = <span class="string">"PROVIDER-USER"</span>, configuration = RibbonConfigration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Component</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">RibbonConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h1><p>如上，访问 20 次，可以看到负载策略是随机访问的</p><h1 id="配置文件的方式"><a href="#配置文件的方式" class="headerlink" title="配置文件的方式"></a>配置文件的方式</h1><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">PROVIDER-USER</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">ribbon</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName</span>: <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br></pre></td></tr></table></figure><p>此方式配置轮询策略，会优先于第二种配置类的方式。</p>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ribbon实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud解析之Ribbon</title>
      <link href="/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BRibbon/"/>
      <url>/2019/11/22/springcloud%E8%A7%A3%E6%9E%90%E4%B9%8BRibbon/</url>
      
        <content type="html"><![CDATA[<h1 id="Ribbon-是什么？"><a href="#Ribbon-是什么？" class="headerlink" title="Ribbon 是什么？"></a>Ribbon 是什么？</h1><p>springcloud 的客户端负载均衡组件</p><h1 id="什么是负载均衡？"><a href="#什么是负载均衡？" class="headerlink" title="什么是负载均衡？"></a>什么是负载均衡？</h1><p>负载均衡又分为服务端负载均衡和客户端负载均衡。</p><h2 id="服务端负载均衡"><a href="#服务端负载均衡" class="headerlink" title="服务端负载均衡"></a>服务端负载均衡</h2><p>硬件负载均衡和软件负载均衡</p><ul><li>硬件负载均衡主要通过在服务器节点之间按照专门用于负载均衡的设备，比如 F5 等</li><li>软件负载均衡则是通过在服务器上安装一些用于负载均衡功能或模块等软件来完成请求分发工作，比如 Nginx 等</li><li>服务端负载均衡架构图<br><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8Bribbon%EF%BC%88%E4%B8%80%EF%BC%89_2019-11-14-11-01-18.png" alt="springcloud实战之ribbon（一）_2019-11-14-11-01-18.png"></li></ul><h2 id="客户端负载均衡"><a href="#客户端负载均衡" class="headerlink" title="客户端负载均衡"></a>客户端负载均衡</h2><ul><li>客户端负载均衡和服务端负载均衡最大的不同点在于上面所提到<strong>服务清单所存储的位置</strong>。</li><li>在客户端负载均衡中，所有客户端节点都维护着自己要访问的服务端清单，而这些服务端端清单来自于服务注册中心，比如上一章我们介绍的 Eureka 服务端。同服务端负载均衡的架构类似，在客户端负载均衡中也需要心跳去维护服务端清单的健康性，默认会创建针对各个服务治理框架的 Ribbon 自动化整合配置。</li></ul><h1 id="讲解下-Ribbon-的工作原理"><a href="#讲解下-Ribbon-的工作原理" class="headerlink" title="讲解下 Ribbon 的工作原理"></a>讲解下 Ribbon 的工作原理</h1><h2 id="Ribbon-架构图"><a href="#Ribbon-架构图" class="headerlink" title="Ribbon 架构图"></a>Ribbon 架构图</h2><p><img src="/images/springcloud%E5%AE%9E%E6%88%98%E4%B9%8Bribbon%EF%BC%88%E4%B8%80%EF%BC%89_2019-11-18-10-30-38.png" alt="springcloud实战之ribbon（一）_2019-11-18-10-30-38.png"></p><h2 id="Ribbon-实现软负载均衡主要有这三点"><a href="#Ribbon-实现软负载均衡主要有这三点" class="headerlink" title="Ribbon 实现软负载均衡主要有这三点"></a>Ribbon 实现软负载均衡主要有这三点</h2><ol><li>服务发现：就是发现依赖服务的列表，通俗来说就是依据服务的名字把它的所有服务实例找出来</li><li>服务选择规则：依据指定的服务规则，从多个有效服务中选择一个服务发起请求</li><li>服务监听：定时检测服务存活情况，及时高效剔除不可用的服务。</li></ol><h2 id="Ribbon-主要组件"><a href="#Ribbon-主要组件" class="headerlink" title="Ribbon 主要组件"></a>Ribbon 主要组件</h2><p><code>ServerList</code>、<code>IRule</code>、<code>ServerListFilter</code>;<br>首先通过 <code>ServerList</code> 获取所有可用服务列表，再通过 <code>ServerListFilter</code> 过滤掉一部分服务，最后 <code>IRule</code> 从过滤后的服务中选择一个实例进行 <code>http</code> 请求</p><h2 id="Ribbon-负载均衡策略"><a href="#Ribbon-负载均衡策略" class="headerlink" title="Ribbon 负载均衡策略"></a>Ribbon 负载均衡策略</h2><ul><li>简单轮询负载均衡（RoundRobin）</li><li>随机负载均衡 （Random）</li><li>随机选择状态为 UP 的 Server</li><li>加权响应时间负载均衡 （WeightedResponseTime）</li><li>区域感知轮询负载均衡（ZoneAware）</li></ul><h2 id="Ribbon-配置"><a href="#Ribbon-配置" class="headerlink" title="Ribbon 配置"></a>Ribbon 配置</h2><p>连接超时、重试、重试算法</p><h2 id="Ribbon-功能"><a href="#Ribbon-功能" class="headerlink" title="Ribbon 功能"></a>Ribbon 功能</h2><ul><li>易于与服务发现组件（比如 Netflix 的 Eureka）集成</li><li>使用 Archaius 完成运行时配置</li><li>使用 JMX 暴露运维指标，使用 Servo 发布</li><li>多种可插拔的序列化选择</li><li>异步和批处理操作</li><li>自动 SLA 框架</li><li>系统管理/指标控制台</li></ul>]]></content>
      
      
      <categories>
          
          <category> springcloud笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ribbon 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务之初见</title>
      <link href="/2019/11/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%9D%E8%A7%81/"/>
      <url>/2019/11/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E5%88%9D%E8%A7%81/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是微服务架构"><a href="#什么是微服务架构" class="headerlink" title="什么是微服务架构"></a>什么是微服务架构</h1><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%98%AF%E4%BB%80%E4%B9%88_2019-11-20-13-53-42.png" alt="微服务是什么_2019-11-20-13-53-42.png"></p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间相互协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务和服务之间采用轻量级的通信机制相互沟通（通常是基于 HTTP 的 Restful API).每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境、类生产环境等</p><h1 id="单体应用-VS-微服务架构"><a href="#单体应用-VS-微服务架构" class="headerlink" title="单体应用 VS 微服务架构"></a>单体应用 VS 微服务架构</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>提升开发交流，每个服务足够内聚，足够小，代码容易理解；</li><li>服务独立测试、部署、升级、发布；</li><li>按需定制的 DFX，资源利用率，每个服务可以各自进行 x 扩展和 z 扩展，而且，每个服务可以根据自己的需要部署到合适的硬件服务器上；每个服务按</li><li>需要选择 HA 的模式，选择接受服务的实例个数；</li><li>容易扩大开发团队，可以针对每个服务（service）组件开发团队；</li><li>提高容错性（fault isolation），一个服务的内存泄露并不会让整个系统瘫痪；</li><li>新技术的应用，系统不会被长期限制在某个技术栈上；</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>没有银弹，微服务提高了系统的复杂度；</li><li>开发人员要处理分布式系统的复杂性；</li><li>服务之间的分布式通信问题；</li><li>服务的注册与发现问题；</li><li>服务之间的分布式事务问题；</li><li>数据隔离再来的报表处理问题；</li><li>服务之间的分布式一致性问题；</li><li>服务管理的复杂性，服务的编排；</li><li>不同服务实例的管理。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.zhihu.com/question/65502802" target="_blank" rel="noopener">什么是微服务架构？</a></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务介绍 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
